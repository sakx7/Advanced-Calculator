[
  {
    "name": "eval",
    "full_id": "sympy.assumptions.assume.Predicate.eval",
    "type": "method",
    "description": "\n        Evaluate ``self(*args)`` under the given assumptions.\n\n        This uses only direct resolution methods, not logical inference.\n        ",
    "section": "Predicate",
    "url": "https://docs.sympy.org/latest/modules/assumptions/index.html"
  },
  {
    "name": "register",
    "full_id": "sympy.assumptions.assume.Predicate.register",
    "type": "method",
    "description": "\n        Register the signature to the handler.\n        ",
    "section": "Predicate",
    "url": "https://docs.sympy.org/latest/modules/assumptions/index.html"
  },
  {
    "name": "register_many",
    "full_id": "sympy.assumptions.assume.Predicate.register_many",
    "type": "method",
    "description": "\n        Register multiple signatures to same handler.\n        ",
    "section": "Predicate",
    "url": "https://docs.sympy.org/latest/modules/assumptions/index.html"
  },
  {
    "name": "arg",
    "full_id": "sympy.assumptions.assume.AppliedPredicate.arg",
    "type": "property",
    "description": "\n        Return the expression used by this assumption.\n\n        Examples\n        ========\n\n        >>> from sympy import Q, Symbol\n        >>> x = Symbol('x')\n        >>> a = Q.integer(x + 1)\n        >>> a.arg\n        x + 1\n\n        ",
    "section": "Predicate",
    "url": "https://docs.sympy.org/latest/modules/assumptions/index.html"
  },
  {
    "name": "arguments",
    "full_id": "sympy.assumptions.assume.AppliedPredicate.arguments",
    "type": "property",
    "description": "\n        Return the arguments which are applied to the predicate.\n        ",
    "section": "Predicate",
    "url": "https://docs.sympy.org/latest/modules/assumptions/index.html"
  },
  {
    "name": "function",
    "full_id": "sympy.assumptions.assume.AppliedPredicate.function",
    "type": "property",
    "description": "\n        Return the predicate.\n        ",
    "section": "Predicate",
    "url": "https://docs.sympy.org/latest/modules/assumptions/index.html"
  },
  {
    "name": "ask",
    "full_id": "sympy.assumptions.ask.ask",
    "type": "function",
    "description": "\n    Function to evaluate the proposition with assumptions.\n\n    Explanation\n    ===========\n\n    This function evaluates the proposition to ``True`` or ``False`` if\n    the truth value can be determined. If not, it returns ``None``.\n\n    It should be discerned from :func:`~.refine` which, when applied to a\n    proposition, simplifies the argument to symbolic ``Boolean`` instead of\n    Python built-in ``True``, ``False`` or ``None``.\n\n    **Syntax**\n\n        * ask(proposition)\n            Evaluate the *proposition* in global assumption context.\n\n        * ask(proposition, assumptions)\n            Evaluate the *proposition* with respect to *assumptions* in\n            global assumption context.\n\n    Parameters\n    ==========\n\n    proposition : Boolean\n        Proposition which will be evaluated to boolean value. If this is\n        not ``AppliedPredicate``, it will be wrapped by ``Q.is_true``.\n\n    assumptions : Boolean, optional\n        Local assumptions to evaluate the *proposition*.\n\n    context : AssumptionsContext, optional\n        Default assumptions to evaluate the *proposition*. By default,\n        this is ``sympy.assumptions.global_assumptions`` variable.\n\n    Returns\n    =======\n\n    ``True``, ``False``, or ``None``\n\n    Raises\n    ======\n\n    TypeError : *proposition* or *assumptions* is not valid logical expression.\n\n    ValueError : assumptions are inconsistent.\n\n    Examples\n    ========\n\n    >>> from sympy import ask, Q, pi\n    >>> from sympy.abc import x, y\n    >>> ask(Q.rational(pi))\n    False\n    >>> ask(Q.even(x*y), Q.even(x) & Q.integer(y))\n    True\n    >>> ask(Q.prime(4*x), Q.integer(x))\n    False\n\n    If the truth value cannot be determined, ``None`` will be returned.\n\n    >>> print(ask(Q.odd(3*x))) # cannot determine unless we know x\n    None\n\n    ``ValueError`` is raised if assumptions are inconsistent.\n\n    >>> ask(Q.integer(x), Q.even(x) & Q.odd(x))\n    Traceback (most recent call last):\n      ...\n    ValueError: inconsistent assumptions Q.even(x) & Q.odd(x)\n\n    Notes\n    =====\n\n    Relations in assumptions are not implemented (yet), so the following\n    will not give a meaningful result.\n\n    >>> ask(Q.positive(x), x > 0)\n\n    It is however a work in progress.\n\n    See Also\n    ========\n\n    sympy.assumptions.refine.refine : Simplification using assumptions.\n        Proposition is not reduced to ``None`` if the truth value cannot\n        be determined.\n    ",
    "section": "Querying",
    "url": "https://docs.sympy.org/latest/modules/assumptions/index.html"
  },
  {
    "name": "register_handler",
    "full_id": "sympy.assumptions.ask.register_handler",
    "type": "function",
    "description": "\n    Register a handler in the ask system. key must be a string and handler a\n    class inheriting from AskHandler.\n\n    .. deprecated:: 1.8.\n        Use multipledispatch handler instead. See :obj:`~.Predicate`.\n\n    ",
    "section": "Ask",
    "url": "https://docs.sympy.org/latest/modules/assumptions/ask.html"
  },
  {
    "name": "remove_handler",
    "full_id": "sympy.assumptions.ask.remove_handler",
    "type": "function",
    "description": "\n    Removes a handler from the ask system.\n\n    .. deprecated:: 1.8.\n        Use multipledispatch handler instead. See :obj:`~.Predicate`.\n\n    ",
    "section": "Ask",
    "url": "https://docs.sympy.org/latest/modules/assumptions/ask.html"
  },
  {
    "name": "add",
    "full_id": "sympy.assumptions.assume.AssumptionsContext.add",
    "type": "method",
    "description": "Add assumptions.",
    "section": "Assume",
    "url": "https://docs.sympy.org/latest/modules/assumptions/assume.html"
  },
  {
    "name": "assuming",
    "full_id": "sympy.assumptions.assume.assuming",
    "type": "function",
    "description": "\n    Context manager for assumptions.\n\n    Examples\n    ========\n\n    >>> from sympy import assuming, Q, ask\n    >>> from sympy.abc import x, y\n    >>> print(ask(Q.integer(x + y)))\n    None\n    >>> with assuming(Q.integer(x), Q.integer(y)):\n    ...     print(ask(Q.integer(x + y)))\n    True\n    ",
    "section": "Assume",
    "url": "https://docs.sympy.org/latest/modules/assumptions/assume.html"
  },
  {
    "name": "refine",
    "full_id": "sympy.assumptions.refine.refine",
    "type": "function",
    "description": "\n    Simplify an expression using assumptions.\n\n    Explanation\n    ===========\n\n    Unlike :func:`~.simplify` which performs structural simplification\n    without any assumption, this function transforms the expression into\n    the form which is only valid under certain assumptions. Note that\n    ``simplify()`` is generally not done in refining process.\n\n    Refining boolean expression involves reducing it to ``S.true`` or\n    ``S.false``. Unlike :func:`~.ask`, the expression will not be reduced\n    if the truth value cannot be determined.\n\n    Examples\n    ========\n\n    >>> from sympy import refine, sqrt, Q\n    >>> from sympy.abc import x\n    >>> refine(sqrt(x**2), Q.real(x))\n    Abs(x)\n    >>> refine(sqrt(x**2), Q.positive(x))\n    x\n\n    >>> refine(Q.real(x), Q.positive(x))\n    True\n    >>> refine(Q.positive(x), Q.real(x))\n    Q.positive(x)\n\n    See Also\n    ========\n\n    sympy.simplify.simplify.simplify : Structural simplification without assumptions.\n    sympy.assumptions.ask.ask : Query for boolean expressions using assumptions.\n    ",
    "section": "Refine",
    "url": "https://docs.sympy.org/latest/modules/assumptions/refine.html"
  },
  {
    "name": "refine_Pow",
    "full_id": "sympy.assumptions.refine.refine_Pow",
    "type": "function",
    "description": "\n    Handler for instances of Pow.\n\n    Examples\n    ========\n\n    >>> from sympy import Q\n    >>> from sympy.assumptions.refine import refine_Pow\n    >>> from sympy.abc import x,y,z\n    >>> refine_Pow((-1)**x, Q.real(x))\n    >>> refine_Pow((-1)**x, Q.even(x))\n    1\n    >>> refine_Pow((-1)**x, Q.odd(x))\n    -1\n\n    For powers of -1, even parts of the exponent can be simplified:\n\n    >>> refine_Pow((-1)**(x+y), Q.even(x))\n    (-1)**y\n    >>> refine_Pow((-1)**(x+y+z), Q.odd(x) & Q.odd(z))\n    (-1)**y\n    >>> refine_Pow((-1)**(x+y+2), Q.odd(x))\n    (-1)**(y + 1)\n    >>> refine_Pow((-1)**(x+3), True)\n    (-1)**(x + 1)\n\n    ",
    "section": "Refine",
    "url": "https://docs.sympy.org/latest/modules/assumptions/refine.html"
  },
  {
    "name": "refine_abs",
    "full_id": "sympy.assumptions.refine.refine_abs",
    "type": "function",
    "description": "\n    Handler for the absolute value.\n\n    Examples\n    ========\n\n    >>> from sympy import Q, Abs\n    >>> from sympy.assumptions.refine import refine_abs\n    >>> from sympy.abc import x\n    >>> refine_abs(Abs(x), Q.real(x))\n    >>> refine_abs(Abs(x), Q.positive(x))\n    x\n    >>> refine_abs(Abs(x), Q.negative(x))\n    -x\n\n    ",
    "section": "Refine",
    "url": "https://docs.sympy.org/latest/modules/assumptions/refine.html"
  },
  {
    "name": "refine_arg",
    "full_id": "sympy.assumptions.refine.refine_arg",
    "type": "function",
    "description": "\n    Handler for complex argument\n\n    Explanation\n    ===========\n\n    >>> from sympy.assumptions.refine import refine_arg\n    >>> from sympy import Q, arg\n    >>> from sympy.abc import x\n    >>> refine_arg(arg(x), Q.positive(x))\n    0\n    >>> refine_arg(arg(x), Q.negative(x))\n    pi\n    ",
    "section": "Refine",
    "url": "https://docs.sympy.org/latest/modules/assumptions/refine.html"
  },
  {
    "name": "refine_atan2",
    "full_id": "sympy.assumptions.refine.refine_atan2",
    "type": "function",
    "description": "\n    Handler for the atan2 function.\n\n    Examples\n    ========\n\n    >>> from sympy import Q, atan2\n    >>> from sympy.assumptions.refine import refine_atan2\n    >>> from sympy.abc import x, y\n    >>> refine_atan2(atan2(y,x), Q.real(y) & Q.positive(x))\n    atan(y/x)\n    >>> refine_atan2(atan2(y,x), Q.negative(y) & Q.negative(x))\n    atan(y/x) - pi\n    >>> refine_atan2(atan2(y,x), Q.positive(y) & Q.negative(x))\n    atan(y/x) + pi\n    >>> refine_atan2(atan2(y,x), Q.zero(y) & Q.negative(x))\n    pi\n    >>> refine_atan2(atan2(y,x), Q.positive(y) & Q.zero(x))\n    pi/2\n    >>> refine_atan2(atan2(y,x), Q.negative(y) & Q.zero(x))\n    -pi/2\n    >>> refine_atan2(atan2(y,x), Q.zero(y) & Q.zero(x))\n    nan\n    ",
    "section": "Refine",
    "url": "https://docs.sympy.org/latest/modules/assumptions/refine.html"
  },
  {
    "name": "refine_im",
    "full_id": "sympy.assumptions.refine.refine_im",
    "type": "function",
    "description": "\n    Handler for imaginary part.\n\n    Explanation\n    ===========\n\n    >>> from sympy.assumptions.refine import refine_im\n    >>> from sympy import Q, im\n    >>> from sympy.abc import x\n    >>> refine_im(im(x), Q.real(x))\n    0\n    >>> refine_im(im(x), Q.imaginary(x))\n    -I*x\n    ",
    "section": "Refine",
    "url": "https://docs.sympy.org/latest/modules/assumptions/refine.html"
  },
  {
    "name": "refine_matrixelement",
    "full_id": "sympy.assumptions.refine.refine_matrixelement",
    "type": "function",
    "description": "\n    Handler for symmetric part.\n\n    Examples\n    ========\n\n    >>> from sympy.assumptions.refine import refine_matrixelement\n    >>> from sympy import MatrixSymbol, Q\n    >>> X = MatrixSymbol('X', 3, 3)\n    >>> refine_matrixelement(X[0, 1], Q.symmetric(X))\n    X[0, 1]\n    >>> refine_matrixelement(X[1, 0], Q.symmetric(X))\n    X[0, 1]\n    ",
    "section": "Refine",
    "url": "https://docs.sympy.org/latest/modules/assumptions/refine.html"
  },
  {
    "name": "refine_re",
    "full_id": "sympy.assumptions.refine.refine_re",
    "type": "function",
    "description": "\n    Handler for real part.\n\n    Examples\n    ========\n\n    >>> from sympy.assumptions.refine import refine_re\n    >>> from sympy import Q, re\n    >>> from sympy.abc import x\n    >>> refine_re(re(x), Q.real(x))\n    x\n    >>> refine_re(re(x), Q.imaginary(x))\n    0\n    ",
    "section": "Refine",
    "url": "https://docs.sympy.org/latest/modules/assumptions/refine.html"
  },
  {
    "name": "refine_sign",
    "full_id": "sympy.assumptions.refine.refine_sign",
    "type": "function",
    "description": "\n    Handler for sign.\n\n    Examples\n    ========\n\n    >>> from sympy.assumptions.refine import refine_sign\n    >>> from sympy import Symbol, Q, sign, im\n    >>> x = Symbol('x', real = True)\n    >>> expr = sign(x)\n    >>> refine_sign(expr, Q.positive(x) & Q.nonzero(x))\n    1\n    >>> refine_sign(expr, Q.negative(x) & Q.nonzero(x))\n    -1\n    >>> refine_sign(expr, Q.zero(x))\n    0\n    >>> y = Symbol('y', imaginary = True)\n    >>> expr = sign(y)\n    >>> refine_sign(expr, Q.positive(im(y)))\n    I\n    >>> refine_sign(expr, Q.negative(im(y)))\n    -I\n    ",
    "section": "Refine",
    "url": "https://docs.sympy.org/latest/modules/assumptions/refine.html"
  },
  {
    "name": "euler_equations",
    "full_id": "sympy.calculus.euler.euler_equations",
    "type": "function",
    "description": "\n    Find the Euler-Lagrange equations [1]_ for a given Lagrangian.\n\n    Parameters\n    ==========\n\n    L : Expr\n        The Lagrangian that should be a function of the functions listed\n        in the second argument and their derivatives.\n\n        For example, in the case of two functions $f(x,y)$, $g(x,y)$ and\n        two independent variables $x$, $y$ the Lagrangian has the form:\n\n            .. math:: L\\left(f(x,y),g(x,y),\\frac{\\partial f(x,y)}{\\partial x},\n                      \\frac{\\partial f(x,y)}{\\partial y},\n                      \\frac{\\partial g(x,y)}{\\partial x},\n                      \\frac{\\partial g(x,y)}{\\partial y},x,y\\right)\n\n        In many cases it is not necessary to provide anything, except the\n        Lagrangian, it will be auto-detected (and an error raised if this\n        cannot be done).\n\n    funcs : Function or an iterable of Functions\n        The functions that the Lagrangian depends on. The Euler equations\n        are differential equations for each of these functions.\n\n    vars : Symbol or an iterable of Symbols\n        The Symbols that are the independent variables of the functions.\n\n    Returns\n    =======\n\n    eqns : list of Eq\n        The list of differential equations, one for each function.\n\n    Examples\n    ========\n\n    >>> from sympy import euler_equations, Symbol, Function\n    >>> x = Function('x')\n    >>> t = Symbol('t')\n    >>> L = (x(t).diff(t))**2/2 - x(t)**2/2\n    >>> euler_equations(L, x(t), t)\n    [Eq(-x(t) - Derivative(x(t), (t, 2)), 0)]\n    >>> u = Function('u')\n    >>> x = Symbol('x')\n    >>> L = (u(t, x).diff(t))**2/2 - (u(t, x).diff(x))**2/2\n    >>> euler_equations(L, u(t, x), [t, x])\n    [Eq(-Derivative(u(t, x), (t, 2)) + Derivative(u(t, x), (x, 2)), 0)]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Lagrange_equation\n\n    ",
    "section": "Calculus",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "is_decreasing",
    "full_id": "sympy.calculus.singularities.is_decreasing",
    "type": "function",
    "description": "\n    Return whether the function is decreasing in the given interval.\n\n    Parameters\n    ==========\n\n    expression : Expr\n        The target function which is being checked.\n    interval : Set, optional\n        The range of values in which we are testing (defaults to set of\n        all real numbers).\n    symbol : Symbol, optional\n        The symbol present in expression which gets varied over the given range.\n\n    Returns\n    =======\n\n    Boolean\n        True if ``expression`` is decreasing (either strictly decreasing or\n        constant) in the given ``interval``, False otherwise.\n\n    Examples\n    ========\n\n    >>> from sympy import is_decreasing\n    >>> from sympy.abc import x, y\n    >>> from sympy import S, Interval, oo\n    >>> is_decreasing(1/(x**2 - 3*x), Interval.open(S(3)/2, 3))\n    True\n    >>> is_decreasing(1/(x**2 - 3*x), Interval.open(1.5, 3))\n    True\n    >>> is_decreasing(1/(x**2 - 3*x), Interval.Lopen(3, oo))\n    True\n    >>> is_decreasing(1/(x**2 - 3*x), Interval.Ropen(-oo, S(3)/2))\n    False\n    >>> is_decreasing(1/(x**2 - 3*x), Interval.Ropen(-oo, 1.5))\n    False\n    >>> is_decreasing(-x**2, Interval(-oo, 0))\n    False\n    >>> is_decreasing(-x**2 + y, Interval(-oo, 0), x)\n    False\n\n    ",
    "section": "Singularities",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "is_increasing",
    "full_id": "sympy.calculus.singularities.is_increasing",
    "type": "function",
    "description": "\n    Return whether the function is increasing in the given interval.\n\n    Parameters\n    ==========\n\n    expression : Expr\n        The target function which is being checked.\n    interval : Set, optional\n        The range of values in which we are testing (defaults to set of\n        all real numbers).\n    symbol : Symbol, optional\n        The symbol present in expression which gets varied over the given range.\n\n    Returns\n    =======\n\n    Boolean\n        True if ``expression`` is increasing (either strictly increasing or\n        constant) in the given ``interval``, False otherwise.\n\n    Examples\n    ========\n\n    >>> from sympy import is_increasing\n    >>> from sympy.abc import x, y\n    >>> from sympy import S, Interval, oo\n    >>> is_increasing(x**3 - 3*x**2 + 4*x, S.Reals)\n    True\n    >>> is_increasing(-x**2, Interval(-oo, 0))\n    True\n    >>> is_increasing(-x**2, Interval(0, oo))\n    False\n    >>> is_increasing(4*x**3 - 6*x**2 - 72*x + 30, Interval(-2, 3))\n    False\n    >>> is_increasing(x**2 + y, Interval(1, 2), x)\n    True\n\n    ",
    "section": "Singularities",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "is_monotonic",
    "full_id": "sympy.calculus.singularities.is_monotonic",
    "type": "function",
    "description": "\n    Return whether the function is monotonic in the given interval.\n\n    Parameters\n    ==========\n\n    expression : Expr\n        The target function which is being checked.\n    interval : Set, optional\n        The range of values in which we are testing (defaults to set of\n        all real numbers).\n    symbol : Symbol, optional\n        The symbol present in expression which gets varied over the given range.\n\n    Returns\n    =======\n\n    Boolean\n        True if ``expression`` is monotonic in the given ``interval``,\n        False otherwise.\n\n    Raises\n    ======\n\n    NotImplementedError\n        Monotonicity check has not been implemented for the queried function.\n\n    Examples\n    ========\n\n    >>> from sympy import is_monotonic\n    >>> from sympy.abc import x, y\n    >>> from sympy import S, Interval, oo\n    >>> is_monotonic(1/(x**2 - 3*x), Interval.open(S(3)/2, 3))\n    True\n    >>> is_monotonic(1/(x**2 - 3*x), Interval.open(1.5, 3))\n    True\n    >>> is_monotonic(1/(x**2 - 3*x), Interval.Lopen(3, oo))\n    True\n    >>> is_monotonic(x**3 - 3*x**2 + 4*x, S.Reals)\n    True\n    >>> is_monotonic(-x**2, S.Reals)\n    False\n    >>> is_monotonic(x**2 + y + 1, Interval(1, 2), x)\n    True\n\n    ",
    "section": "Singularities",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "is_strictly_decreasing",
    "full_id": "sympy.calculus.singularities.is_strictly_decreasing",
    "type": "function",
    "description": "\n    Return whether the function is strictly decreasing in the given interval.\n\n    Parameters\n    ==========\n\n    expression : Expr\n        The target function which is being checked.\n    interval : Set, optional\n        The range of values in which we are testing (defaults to set of\n        all real numbers).\n    symbol : Symbol, optional\n        The symbol present in expression which gets varied over the given range.\n\n    Returns\n    =======\n\n    Boolean\n        True if ``expression`` is strictly decreasing in the given ``interval``,\n        False otherwise.\n\n    Examples\n    ========\n\n    >>> from sympy import is_strictly_decreasing\n    >>> from sympy.abc import x, y\n    >>> from sympy import S, Interval, oo\n    >>> is_strictly_decreasing(1/(x**2 - 3*x), Interval.Lopen(3, oo))\n    True\n    >>> is_strictly_decreasing(1/(x**2 - 3*x), Interval.Ropen(-oo, S(3)/2))\n    False\n    >>> is_strictly_decreasing(1/(x**2 - 3*x), Interval.Ropen(-oo, 1.5))\n    False\n    >>> is_strictly_decreasing(-x**2, Interval(-oo, 0))\n    False\n    >>> is_strictly_decreasing(-x**2 + y, Interval(-oo, 0), x)\n    False\n\n    ",
    "section": "Singularities",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "is_strictly_increasing",
    "full_id": "sympy.calculus.singularities.is_strictly_increasing",
    "type": "function",
    "description": "\n    Return whether the function is strictly increasing in the given interval.\n\n    Parameters\n    ==========\n\n    expression : Expr\n        The target function which is being checked.\n    interval : Set, optional\n        The range of values in which we are testing (defaults to set of\n        all real numbers).\n    symbol : Symbol, optional\n        The symbol present in expression which gets varied over the given range.\n\n    Returns\n    =======\n\n    Boolean\n        True if ``expression`` is strictly increasing in the given ``interval``,\n        False otherwise.\n\n    Examples\n    ========\n\n    >>> from sympy import is_strictly_increasing\n    >>> from sympy.abc import x, y\n    >>> from sympy import Interval, oo\n    >>> is_strictly_increasing(4*x**3 - 6*x**2 - 72*x + 30, Interval.Ropen(-oo, -2))\n    True\n    >>> is_strictly_increasing(4*x**3 - 6*x**2 - 72*x + 30, Interval.Lopen(3, oo))\n    True\n    >>> is_strictly_increasing(4*x**3 - 6*x**2 - 72*x + 30, Interval.open(-2, 3))\n    False\n    >>> is_strictly_increasing(-x**2, Interval(0, oo))\n    False\n    >>> is_strictly_increasing(-x**2 + y, Interval(-oo, 0), x)\n    False\n\n    ",
    "section": "Singularities",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "monotonicity_helper",
    "full_id": "sympy.calculus.singularities.monotonicity_helper",
    "type": "function",
    "description": "\n    Helper function for functions checking function monotonicity.\n\n    Parameters\n    ==========\n\n    expression : Expr\n        The target function which is being checked\n    predicate : function\n        The property being tested for. The function takes in an integer\n        and returns a boolean. The integer input is the derivative and\n        the boolean result should be true if the property is being held,\n        and false otherwise.\n    interval : Set, optional\n        The range of values in which we are testing, defaults to all reals.\n    symbol : Symbol, optional\n        The symbol present in expression which gets varied over the given range.\n\n    It returns a boolean indicating whether the interval in which\n    the function's derivative satisfies given predicate is a superset\n    of the given interval.\n\n    Returns\n    =======\n\n    Boolean\n        True if ``predicate`` is true for all the derivatives when ``symbol``\n        is varied in ``range``, False otherwise.\n\n    ",
    "section": "Singularities",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "singularities",
    "full_id": "sympy.calculus.singularities.singularities",
    "type": "function",
    "description": "\n    Find singularities of a given function.\n\n    Parameters\n    ==========\n\n    expression : Expr\n        The target function in which singularities need to be found.\n    symbol : Symbol\n        The symbol over the values of which the singularity in\n        expression in being searched for.\n\n    Returns\n    =======\n\n    Set\n        A set of values for ``symbol`` for which ``expression`` has a\n        singularity. An ``EmptySet`` is returned if ``expression`` has no\n        singularities for any given value of ``Symbol``.\n\n    Raises\n    ======\n\n    NotImplementedError\n        Methods for determining the singularities of this function have\n        not been developed.\n\n    Notes\n    =====\n\n    This function does not find non-isolated singularities\n    nor does it find branch points of the expression.\n\n    Currently supported functions are:\n        - univariate continuous (real or complex) functions\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Mathematical_singularity\n\n    Examples\n    ========\n\n    >>> from sympy import singularities, Symbol, log\n    >>> x = Symbol('x', real=True)\n    >>> y = Symbol('y', real=False)\n    >>> singularities(x**2 + x + 1, x)\n    EmptySet\n    >>> singularities(1/(x + 1), x)\n    {-1}\n    >>> singularities(1/(y**2 + 1), y)\n    {-I, I}\n    >>> singularities(1/(y**3 + 1), y)\n    {-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2}\n    >>> singularities(log(x), x)\n    {0}\n\n    ",
    "section": "Singularities",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "apply_finite_diff",
    "full_id": "sympy.calculus.finite_diff.apply_finite_diff",
    "type": "function",
    "description": "\n    Calculates the finite difference approximation of\n    the derivative of requested order at ``x0`` from points\n    provided in ``x_list`` and ``y_list``.\n\n    Parameters\n    ==========\n\n    order: int\n        order of derivative to approximate. 0 corresponds to interpolation.\n    x_list: sequence\n        Sequence of (unique) values for the independent variable.\n    y_list: sequence\n        The function value at corresponding values for the independent\n        variable in x_list.\n    x0: Number or Symbol\n        At what value of the independent variable the derivative should be\n        evaluated. Defaults to 0.\n\n    Returns\n    =======\n\n    sympy.core.add.Add or sympy.core.numbers.Number\n        The finite difference expression approximating the requested\n        derivative order at ``x0``.\n\n    Examples\n    ========\n\n    >>> from sympy import apply_finite_diff\n    >>> cube = lambda arg: (1.0*arg)**3\n    >>> xlist = range(-3,3+1)\n    >>> apply_finite_diff(2, xlist, map(cube, xlist), 2) - 12 # doctest: +SKIP\n    -3.55271367880050e-15\n\n    we see that the example above only contain rounding errors.\n    apply_finite_diff can also be used on more abstract objects:\n\n    >>> from sympy import IndexedBase, Idx\n    >>> x, y = map(IndexedBase, 'xy')\n    >>> i = Idx('i')\n    >>> x_list, y_list = zip(*[(x[i+j], y[i+j]) for j in range(-1,2)])\n    >>> apply_finite_diff(1, x_list, y_list, x[i])\n    ((x[i + 1] - x[i])/(-x[i - 1] + x[i]) - 1)*y[i]/(x[i + 1] - x[i]) -\n    (x[i + 1] - x[i])*y[i - 1]/((x[i + 1] - x[i - 1])*(-x[i - 1] + x[i])) +\n    (-x[i - 1] + x[i])*y[i + 1]/((x[i + 1] - x[i - 1])*(x[i + 1] - x[i]))\n\n    Notes\n    =====\n\n    Order = 0 corresponds to interpolation.\n    Only supply so many points you think makes sense\n    to around x0 when extracting the derivative (the function\n    need to be well behaved within that region). Also beware\n    of Runge's phenomenon.\n\n    See also\n    ========\n\n    sympy.calculus.finite_diff.finite_diff_weights\n\n    References\n    ==========\n\n    Fortran 90 implementation with Python interface for numerics: finitediff_\n\n    .. _finitediff: https://github.com/bjodah/finitediff\n\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "differentiate_finite",
    "full_id": "sympy.calculus.finite_diff.differentiate_finite",
    "type": "function",
    "description": "Differentiate expr and replace Derivatives with finite differences.\n\n    Parameters\n    ==========\n\n    expr : expression\n    \\*symbols : differentiate with respect to symbols\n    points: sequence, coefficient or undefined function, optional\n        see ``Derivative.as_finite_difference``\n    x0: number or Symbol, optional\n        see ``Derivative.as_finite_difference``\n    wrt: Symbol, optional\n        see ``Derivative.as_finite_difference``\n\n    Examples\n    ========\n\n    >>> from sympy import sin, Function, differentiate_finite\n    >>> from sympy.abc import x, y, h\n    >>> f, g = Function('f'), Function('g')\n    >>> differentiate_finite(f(x)*g(x), x, points=[x-h, x+h])\n    -f(-h + x)*g(-h + x)/(2*h) + f(h + x)*g(h + x)/(2*h)\n\n    ``differentiate_finite`` works on any expression, including the expressions\n    with embedded derivatives:\n\n    >>> differentiate_finite(f(x) + sin(x), x, 2)\n    -2*f(x) + f(x - 1) + f(x + 1) - 2*sin(x) + sin(x - 1) + sin(x + 1)\n    >>> differentiate_finite(f(x, y), x, y)\n    f(x - 1/2, y - 1/2) - f(x - 1/2, y + 1/2) - f(x + 1/2, y - 1/2) + f(x + 1/2, y + 1/2)\n    >>> differentiate_finite(f(x)*g(x).diff(x), x)\n    (-g(x) + g(x + 1))*f(x + 1/2) - (g(x) - g(x - 1))*f(x - 1/2)\n\n    To make finite difference with non-constant discretization step use\n    undefined functions:\n\n    >>> dx = Function('dx')\n    >>> differentiate_finite(f(x)*g(x).diff(x), points=dx(x))\n    -(-g(x - dx(x)/2 - dx(x - dx(x)/2)/2)/dx(x - dx(x)/2) +\n    g(x - dx(x)/2 + dx(x - dx(x)/2)/2)/dx(x - dx(x)/2))*f(x - dx(x)/2)/dx(x) +\n    (-g(x + dx(x)/2 - dx(x + dx(x)/2)/2)/dx(x + dx(x)/2) +\n    g(x + dx(x)/2 + dx(x + dx(x)/2)/2)/dx(x + dx(x)/2))*f(x + dx(x)/2)/dx(x)\n\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "finite_diff_weights",
    "full_id": "sympy.calculus.finite_diff.finite_diff_weights",
    "type": "function",
    "description": "\n    Calculates the finite difference weights for an arbitrarily spaced\n    one-dimensional grid (``x_list``) for derivatives at ``x0`` of order\n    0, 1, ..., up to ``order`` using a recursive formula. Order of accuracy\n    is at least ``len(x_list) - order``, if ``x_list`` is defined correctly.\n\n    Parameters\n    ==========\n\n    order: int\n        Up to what derivative order weights should be calculated.\n        0 corresponds to interpolation.\n    x_list: sequence\n        Sequence of (unique) values for the independent variable.\n        It is useful (but not necessary) to order ``x_list`` from\n        nearest to furthest from ``x0``; see examples below.\n    x0: Number or Symbol\n        Root or value of the independent variable for which the finite\n        difference weights should be generated. Default is ``S.One``.\n\n    Returns\n    =======\n\n    list\n        A list of sublists, each corresponding to coefficients for\n        increasing derivative order, and each containing lists of\n        coefficients for increasing subsets of x_list.\n\n    Examples\n    ========\n\n    >>> from sympy import finite_diff_weights, S\n    >>> res = finite_diff_weights(1, [-S(1)/2, S(1)/2, S(3)/2, S(5)/2], 0)\n    >>> res\n    [[[1, 0, 0, 0],\n      [1/2, 1/2, 0, 0],\n      [3/8, 3/4, -1/8, 0],\n      [5/16, 15/16, -5/16, 1/16]],\n     [[0, 0, 0, 0],\n      [-1, 1, 0, 0],\n      [-1, 1, 0, 0],\n      [-23/24, 7/8, 1/8, -1/24]]]\n    >>> res[0][-1]  # FD weights for 0th derivative, using full x_list\n    [5/16, 15/16, -5/16, 1/16]\n    >>> res[1][-1]  # FD weights for 1st derivative\n    [-23/24, 7/8, 1/8, -1/24]\n    >>> res[1][-2]  # FD weights for 1st derivative, using x_list[:-1]\n    [-1, 1, 0, 0]\n    >>> res[1][-1][0]  # FD weight for 1st deriv. for x_list[0]\n    -23/24\n    >>> res[1][-1][1]  # FD weight for 1st deriv. for x_list[1], etc.\n    7/8\n\n    Each sublist contains the most accurate formula at the end.\n    Note, that in the above example ``res[1][1]`` is the same as ``res[1][2]``.\n    Since res[1][2] has an order of accuracy of\n    ``len(x_list[:3]) - order = 3 - 1 = 2``, the same is true for ``res[1][1]``!\n\n    >>> res = finite_diff_weights(1, [S(0), S(1), -S(1), S(2), -S(2)], 0)[1]\n    >>> res\n    [[0, 0, 0, 0, 0],\n     [-1, 1, 0, 0, 0],\n     [0, 1/2, -1/2, 0, 0],\n     [-1/2, 1, -1/3, -1/6, 0],\n     [0, 2/3, -2/3, -1/12, 1/12]]\n    >>> res[0]  # no approximation possible, using x_list[0] only\n    [0, 0, 0, 0, 0]\n    >>> res[1]  # classic forward step approximation\n    [-1, 1, 0, 0, 0]\n    >>> res[2]  # classic centered approximation\n    [0, 1/2, -1/2, 0, 0]\n    >>> res[3:]  # higher order approximations\n    [[-1/2, 1, -1/3, -1/6, 0], [0, 2/3, -2/3, -1/12, 1/12]]\n\n    Let us compare this to a differently defined ``x_list``. Pay attention to\n    ``foo[i][k]`` corresponding to the gridpoint defined by ``x_list[k]``.\n\n    >>> foo = finite_diff_weights(1, [-S(2), -S(1), S(0), S(1), S(2)], 0)[1]\n    >>> foo\n    [[0, 0, 0, 0, 0],\n     [-1, 1, 0, 0, 0],\n     [1/2, -2, 3/2, 0, 0],\n     [1/6, -1, 1/2, 1/3, 0],\n     [1/12, -2/3, 0, 2/3, -1/12]]\n    >>> foo[1]  # not the same and of lower accuracy as res[1]!\n    [-1, 1, 0, 0, 0]\n    >>> foo[2]  # classic double backward step approximation\n    [1/2, -2, 3/2, 0, 0]\n    >>> foo[4]  # the same as res[4]\n    [1/12, -2/3, 0, 2/3, -1/12]\n\n    Note that, unless you plan on using approximations based on subsets of\n    ``x_list``, the order of gridpoints does not matter.\n\n    The capability to generate weights at arbitrary points can be\n    used e.g. to minimize Runge's phenomenon by using Chebyshev nodes:\n\n    >>> from sympy import cos, symbols, pi, simplify\n    >>> N, (h, x) = 4, symbols('h x')\n    >>> x_list = [x+h*cos(i*pi/(N)) for i in range(N,-1,-1)] # chebyshev nodes\n    >>> print(x_list)\n    [-h + x, -sqrt(2)*h/2 + x, x, sqrt(2)*h/2 + x, h + x]\n    >>> mycoeffs = finite_diff_weights(1, x_list, 0)[1][4]\n    >>> [simplify(c) for c in  mycoeffs] #doctest: +NORMALIZE_WHITESPACE\n    [(h**3/2 + h**2*x - 3*h*x**2 - 4*x**3)/h**4,\n    (-sqrt(2)*h**3 - 4*h**2*x + 3*sqrt(2)*h*x**2 + 8*x**3)/h**4,\n    (6*h**2*x - 8*x**3)/h**4,\n    (sqrt(2)*h**3 - 4*h**2*x - 3*sqrt(2)*h*x**2 + 8*x**3)/h**4,\n    (-h**3/2 + h**2*x + 3*h*x**2 - 4*x**3)/h**4]\n\n    Notes\n    =====\n\n    If weights for a finite difference approximation of 3rd order\n    derivative is wanted, weights for 0th, 1st and 2nd order are\n    calculated \"for free\", so are formulae using subsets of ``x_list``.\n    This is something one can take advantage of to save computational cost.\n    Be aware that one should define ``x_list`` from nearest to furthest from\n    ``x0``. If not, subsets of ``x_list`` will yield poorer approximations,\n    which might not grand an order of accuracy of ``len(x_list) - order``.\n\n    See also\n    ========\n\n    sympy.calculus.finite_diff.apply_finite_diff\n\n    References\n    ==========\n\n    .. [1] Generation of Finite Difference Formulas on Arbitrarily Spaced\n            Grids, Bengt Fornberg; Mathematics of computation; 51; 184;\n            (1988); 699-706; doi:10.1090/S0025-5718-1988-0935077-0\n\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "continuous_domain",
    "full_id": "sympy.calculus.util.continuous_domain",
    "type": "function",
    "description": "\n    Returns the domain on which the function expression f is continuous.\n\n    This function is limited by the ability to determine the various\n    singularities and discontinuities of the given function.\n    The result is either given as a union of intervals or constructed using\n    other set operations.\n\n    Parameters\n    ==========\n\n    f : :py:class:`~.Expr`\n        The concerned function.\n    symbol : :py:class:`~.Symbol`\n        The variable for which the intervals are to be determined.\n    domain : :py:class:`~.Interval`\n        The domain over which the continuity of the symbol has to be checked.\n\n    Examples\n    ========\n\n    >>> from sympy import Interval, Symbol, S, tan, log, pi, sqrt\n    >>> from sympy.calculus.util import continuous_domain\n    >>> x = Symbol('x')\n    >>> continuous_domain(1/x, x, S.Reals)\n    Union(Interval.open(-oo, 0), Interval.open(0, oo))\n    >>> continuous_domain(tan(x), x, Interval(0, pi))\n    Union(Interval.Ropen(0, pi/2), Interval.Lopen(pi/2, pi))\n    >>> continuous_domain(sqrt(x - 2), x, Interval(-5, 5))\n    Interval(2, 5)\n    >>> continuous_domain(log(2*x - 1), x, S.Reals)\n    Interval.open(1/2, oo)\n\n    Returns\n    =======\n\n    :py:class:`~.Interval`\n        Union of all intervals where the function is continuous.\n\n    Raises\n    ======\n\n    NotImplementedError\n        If the method to determine continuity of such a function\n        has not yet been developed.\n\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "function_range",
    "full_id": "sympy.calculus.util.function_range",
    "type": "function",
    "description": "\n    Finds the range of a function in a given domain.\n    This method is limited by the ability to determine the singularities and\n    determine limits.\n\n    Parameters\n    ==========\n\n    f : :py:class:`~.Expr`\n        The concerned function.\n    symbol : :py:class:`~.Symbol`\n        The variable for which the range of function is to be determined.\n    domain : :py:class:`~.Interval`\n        The domain under which the range of the function has to be found.\n\n    Examples\n    ========\n\n    >>> from sympy import Interval, Symbol, S, exp, log, pi, sqrt, sin, tan\n    >>> from sympy.calculus.util import function_range\n    >>> x = Symbol('x')\n    >>> function_range(sin(x), x, Interval(0, 2*pi))\n    Interval(-1, 1)\n    >>> function_range(tan(x), x, Interval(-pi/2, pi/2))\n    Interval(-oo, oo)\n    >>> function_range(1/x, x, S.Reals)\n    Union(Interval.open(-oo, 0), Interval.open(0, oo))\n    >>> function_range(exp(x), x, S.Reals)\n    Interval.open(0, oo)\n    >>> function_range(log(x), x, S.Reals)\n    Interval(-oo, oo)\n    >>> function_range(sqrt(x), x, Interval(-5, 9))\n    Interval(0, 3)\n\n    Returns\n    =======\n\n    :py:class:`~.Interval`\n        Union of all ranges for all intervals under domain where function is\n        continuous.\n\n    Raises\n    ======\n\n    NotImplementedError\n        If any of the intervals, in the given domain, for which function\n        is continuous are not finite or real,\n        OR if the critical points of the function on the domain cannot be found.\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "is_convex",
    "full_id": "sympy.calculus.util.is_convex",
    "type": "function",
    "description": "Determines the  convexity of the function passed in the argument.\n\n    Parameters\n    ==========\n\n    f : :py:class:`~.Expr`\n        The concerned function.\n    syms : Tuple of :py:class:`~.Symbol`\n        The variables with respect to which the convexity is to be determined.\n    domain : :py:class:`~.Interval`, optional\n        The domain over which the convexity of the function has to be checked.\n        If unspecified, S.Reals will be the default domain.\n\n    Returns\n    =======\n\n    bool\n        The method returns ``True`` if the function is convex otherwise it\n        returns ``False``.\n\n    Raises\n    ======\n\n    NotImplementedError\n        The check for the convexity of multivariate functions is not implemented yet.\n\n    Notes\n    =====\n\n    To determine concavity of a function pass `-f` as the concerned function.\n    To determine logarithmic convexity of a function pass `\\log(f)` as\n    concerned function.\n    To determine logarithmic concavity of a function pass `-\\log(f)` as\n    concerned function.\n\n    Currently, convexity check of multivariate functions is not handled.\n\n    Examples\n    ========\n\n    >>> from sympy import is_convex, symbols, exp, oo, Interval\n    >>> x = symbols('x')\n    >>> is_convex(exp(x), x)\n    True\n    >>> is_convex(x**3, x, domain = Interval(-1, oo))\n    False\n    >>> is_convex(1/x**2, x, domain=Interval.open(0, oo))\n    True\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Convex_function\n    .. [2] http://www.ifp.illinois.edu/~angelia/L3_convfunc.pdf\n    .. [3] https://en.wikipedia.org/wiki/Logarithmically_convex_function\n    .. [4] https://en.wikipedia.org/wiki/Logarithmically_concave_function\n    .. [5] https://en.wikipedia.org/wiki/Concave_function\n\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "lcim",
    "full_id": "sympy.calculus.util.lcim",
    "type": "function",
    "description": "Returns the least common integral multiple of a list of numbers.\n\n    The numbers can be rational or irrational or a mixture of both.\n    `None` is returned for incommensurable numbers.\n\n    Parameters\n    ==========\n\n    numbers : list\n        Numbers (rational and/or irrational) for which lcim is to be found.\n\n    Returns\n    =======\n\n    number\n        lcim if it exists, otherwise ``None`` for incommensurable numbers.\n\n    Examples\n    ========\n\n    >>> from sympy.calculus.util import lcim\n    >>> from sympy import S, pi\n    >>> lcim([S(1)/2, S(3)/4, S(5)/6])\n    15/2\n    >>> lcim([2*pi, 3*pi, pi, pi/2])\n    6*pi\n    >>> lcim([S(1), 2*pi])\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "maximum",
    "full_id": "sympy.calculus.util.maximum",
    "type": "function",
    "description": "\n    Returns the maximum value of a function in the given domain.\n\n    Parameters\n    ==========\n\n    f : :py:class:`~.Expr`\n        The concerned function.\n    symbol : :py:class:`~.Symbol`\n        The variable for maximum value needs to be determined.\n    domain : :py:class:`~.Interval`\n        The domain over which the maximum have to be checked.\n        If unspecified, then the global maximum is returned.\n\n    Returns\n    =======\n\n    number\n        Maximum value of the function in given domain.\n\n    Examples\n    ========\n\n    >>> from sympy import Interval, Symbol, S, sin, cos, pi, maximum\n    >>> x = Symbol('x')\n\n    >>> f = -x**2 + 2*x + 5\n    >>> maximum(f, x, S.Reals)\n    6\n\n    >>> maximum(sin(x), x, Interval(-pi, pi/4))\n    sqrt(2)/2\n\n    >>> maximum(sin(x)*cos(x), x)\n    1/2\n\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "minimum",
    "full_id": "sympy.calculus.util.minimum",
    "type": "function",
    "description": "\n    Returns the minimum value of a function in the given domain.\n\n    Parameters\n    ==========\n\n    f : :py:class:`~.Expr`\n        The concerned function.\n    symbol : :py:class:`~.Symbol`\n        The variable for minimum value needs to be determined.\n    domain : :py:class:`~.Interval`\n        The domain over which the minimum have to be checked.\n        If unspecified, then the global minimum is returned.\n\n    Returns\n    =======\n\n    number\n        Minimum value of the function in the given domain.\n\n    Examples\n    ========\n\n    >>> from sympy import Interval, Symbol, S, sin, cos, minimum\n    >>> x = Symbol('x')\n\n    >>> f = x**2 + 2*x + 5\n    >>> minimum(f, x, S.Reals)\n    4\n\n    >>> minimum(sin(x), x, Interval(2, 3))\n    sin(3)\n\n    >>> minimum(sin(x)*cos(x), x)\n    -1/2\n\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "not_empty_in",
    "full_id": "sympy.calculus.util.not_empty_in",
    "type": "function",
    "description": "\n    Finds the domain of the functions in ``finset_intersection`` in which the\n    ``finite_set`` is not-empty.\n\n    Parameters\n    ==========\n\n    finset_intersection : Intersection of FiniteSet\n        The unevaluated intersection of FiniteSet containing\n        real-valued functions with Union of Sets\n    syms : Tuple of symbols\n        Symbol for which domain is to be found\n\n    Raises\n    ======\n\n    NotImplementedError\n        The algorithms to find the non-emptiness of the given FiniteSet are\n        not yet implemented.\n    ValueError\n        The input is not valid.\n    RuntimeError\n        It is a bug, please report it to the github issue tracker\n        (https://github.com/sympy/sympy/issues).\n\n    Examples\n    ========\n\n    >>> from sympy import FiniteSet, Interval, not_empty_in, oo\n    >>> from sympy.abc import x\n    >>> not_empty_in(FiniteSet(x/2).intersect(Interval(0, 1)), x)\n    Interval(0, 2)\n    >>> not_empty_in(FiniteSet(x, x**2).intersect(Interval(1, 2)), x)\n    Union(Interval(1, 2), Interval(-sqrt(2), -1))\n    >>> not_empty_in(FiniteSet(x**2/(x + 2)).intersect(Interval(1, oo)), x)\n    Union(Interval.Lopen(-2, -1), Interval(2, oo))\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "periodicity",
    "full_id": "sympy.calculus.util.periodicity",
    "type": "function",
    "description": "\n    Tests the given function for periodicity in the given symbol.\n\n    Parameters\n    ==========\n\n    f : :py:class:`~.Expr`\n        The concerned function.\n    symbol : :py:class:`~.Symbol`\n        The variable for which the period is to be determined.\n    check : bool, optional\n        The flag to verify whether the value being returned is a period or not.\n\n    Returns\n    =======\n\n    period\n        The period of the function is returned.\n        ``None`` is returned when the function is aperiodic or has a complex period.\n        The value of $0$ is returned as the period of a constant function.\n\n    Raises\n    ======\n\n    NotImplementedError\n        The value of the period computed cannot be verified.\n\n\n    Notes\n    =====\n\n    Currently, we do not support functions with a complex period.\n    The period of functions having complex periodic values such\n    as ``exp``, ``sinh`` is evaluated to ``None``.\n\n    The value returned might not be the \"fundamental\" period of the given\n    function i.e. it may not be the smallest periodic value of the function.\n\n    The verification of the period through the ``check`` flag is not reliable\n    due to internal simplification of the given expression. Hence, it is set\n    to ``False`` by default.\n\n    Examples\n    ========\n    >>> from sympy import periodicity, Symbol, sin, cos, tan, exp\n    >>> x = Symbol('x')\n    >>> f = sin(x) + sin(2*x) + sin(3*x)\n    >>> periodicity(f, x)\n    2*pi\n    >>> periodicity(sin(x)*cos(x), x)\n    pi\n    >>> periodicity(exp(tan(2*x) - 1), x)\n    pi/2\n    >>> periodicity(sin(4*x)**cos(2*x), x)\n    pi\n    >>> periodicity(exp(x), x)\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "stationary_points",
    "full_id": "sympy.calculus.util.stationary_points",
    "type": "function",
    "description": "\n    Returns the stationary points of a function (where derivative of the\n    function is 0) in the given domain.\n\n    Parameters\n    ==========\n\n    f : :py:class:`~.Expr`\n        The concerned function.\n    symbol : :py:class:`~.Symbol`\n        The variable for which the stationary points are to be determined.\n    domain : :py:class:`~.Interval`\n        The domain over which the stationary points have to be checked.\n        If unspecified, ``S.Reals`` will be the default domain.\n\n    Returns\n    =======\n\n    Set\n        A set of stationary points for the function. If there are no\n        stationary point, an :py:class:`~.EmptySet` is returned.\n\n    Examples\n    ========\n\n    >>> from sympy import Interval, Symbol, S, sin, pi, pprint, stationary_points\n    >>> x = Symbol('x')\n\n    >>> stationary_points(1/x, x, S.Reals)\n    EmptySet\n\n    >>> pprint(stationary_points(sin(x), x), use_unicode=False)\n              pi                              3*pi\n    {2*n*pi + -- | n in Integers} U {2*n*pi + ---- | n in Integers}\n              2                                2\n\n    >>> stationary_points(sin(x),x, Interval(0, 4*pi))\n    {pi/2, 3*pi/2, 5*pi/2, 7*pi/2}\n\n    ",
    "section": "Finite difference weights",
    "url": "https://docs.sympy.org/latest/modules/calculus/index.html"
  },
  {
    "name": "RGS",
    "full_id": "sympy.combinatorics.partitions.Partition.RGS",
    "type": "property",
    "description": "\n        Returns the \"restricted growth string\" of the partition.\n\n        Explanation\n        ===========\n\n        The RGS is returned as a list of indices, L, where L[i] indicates\n        the block in which element i appears. For example, in a partition\n        of 3 elements (a, b, c) into 2 blocks ([c], [a, b]) the RGS is\n        [1, 1, 0]: \"a\" is in block 1, \"b\" is in block 1 and \"c\" is in block 0.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Partition\n        >>> a = Partition([1, 2], [3], [4, 5])\n        >>> a.members\n        (1, 2, 3, 4, 5)\n        >>> a.RGS\n        (0, 0, 1, 2, 2)\n        >>> a + 1\n        Partition({3}, {4}, {5}, {1, 2})\n        >>> _.RGS\n        (0, 0, 1, 2, 3)\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "from_rgs",
    "full_id": "sympy.combinatorics.partitions.Partition.from_rgs",
    "type": "method",
    "description": "\n        Creates a set partition from a restricted growth string.\n\n        Explanation\n        ===========\n\n        The indices given in rgs are assumed to be the index\n        of the element as given in elements *as provided* (the\n        elements are not sorted by this routine). Block numbering\n        starts from 0. If any block was not referenced in ``rgs``\n        an error will be raised.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Partition\n        >>> Partition.from_rgs([0, 1, 2, 0, 1], list('abcde'))\n        Partition({c}, {a, d}, {b, e})\n        >>> Partition.from_rgs([0, 1, 2, 0, 1], list('cbead'))\n        Partition({e}, {a, c}, {b, d})\n        >>> a = Partition([1, 4], [2], [3, 5])\n        >>> Partition.from_rgs(a.RGS, a.members)\n        Partition({2}, {1, 4}, {3, 5})\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "partition",
    "full_id": "sympy.combinatorics.partitions.Partition.partition",
    "type": "property",
    "description": "Return partition as a sorted list of lists.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Partition\n        >>> Partition([1], [2, 3]).partition\n        [[1], [2, 3]]\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "rank",
    "full_id": "sympy.combinatorics.partitions.Partition.rank",
    "type": "property",
    "description": "\n        Gets the rank of a partition.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Partition\n        >>> a = Partition([1, 2], [3], [4, 5])\n        >>> a.rank\n        13\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "sort_key",
    "full_id": "sympy.combinatorics.partitions.Partition.sort_key",
    "type": "method",
    "description": "Return a canonical key that can be used for sorting.\n\n        Ordering is based on the size and sorted elements of the partition\n        and ties are broken with the rank.\n\n        Examples\n        ========\n\n        >>> from sympy import default_sort_key\n        >>> from sympy.combinatorics import Partition\n        >>> from sympy.abc import x\n        >>> a = Partition([1, 2])\n        >>> b = Partition([3, 4])\n        >>> c = Partition([1, x])\n        >>> d = Partition(list(range(4)))\n        >>> l = [d, b, a + 1, a, c]\n        >>> l.sort(key=default_sort_key); l\n        [Partition({1, 2}), Partition({1}, {2}), Partition({1, x}), Partition({3, 4}), Partition({0, 1, 2, 3})]\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "as_dict",
    "full_id": "sympy.combinatorics.partitions.IntegerPartition.as_dict",
    "type": "method",
    "description": "Return the partition as a dictionary whose keys are the\n        partition integers and the values are the multiplicity of that\n        integer.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.partitions import IntegerPartition\n        >>> IntegerPartition([1]*3 + [2] + [3]*4).as_dict()\n        {1: 3, 2: 1, 3: 4}\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "as_ferrers",
    "full_id": "sympy.combinatorics.partitions.IntegerPartition.as_ferrers",
    "type": "method",
    "description": "\n        Prints the ferrer diagram of a partition.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.partitions import IntegerPartition\n        >>> print(IntegerPartition([1, 1, 5]).as_ferrers())\n        #####\n        #\n        #\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "conjugate",
    "full_id": "sympy.combinatorics.partitions.IntegerPartition.conjugate",
    "type": "property",
    "description": "\n        Computes the conjugate partition of itself.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.partitions import IntegerPartition\n        >>> a = IntegerPartition([6, 3, 3, 2, 1])\n        >>> a.conjugate\n        [5, 4, 3, 1, 1, 1]\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "next_lex",
    "full_id": "sympy.combinatorics.partitions.IntegerPartition.next_lex",
    "type": "method",
    "description": "Return the next partition of the integer, n, in lexical order,\n        wrapping around to [n] if the partition is [1, ..., 1].\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.partitions import IntegerPartition\n        >>> p = IntegerPartition([3, 1])\n        >>> print(p.next_lex())\n        [4]\n        >>> p.partition < p.next_lex().partition\n        True\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "prev_lex",
    "full_id": "sympy.combinatorics.partitions.IntegerPartition.prev_lex",
    "type": "method",
    "description": "Return the previous partition of the integer, n, in lexical order,\n        wrapping around to [1, ..., 1] if the partition is [n].\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.partitions import IntegerPartition\n        >>> p = IntegerPartition([4])\n        >>> print(p.prev_lex())\n        [3, 1]\n        >>> p.partition > p.prev_lex().partition\n        True\n        ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "random_integer_partition",
    "full_id": "sympy.combinatorics.partitions.random_integer_partition",
    "type": "function",
    "description": "\n    Generates a random integer partition summing to ``n`` as a list\n    of reverse-sorted integers.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.partitions import random_integer_partition\n\n    For the following, a seed is given so a known value can be shown; in\n    practice, the seed would not be given.\n\n    >>> random_integer_partition(100, seed=[1, 1, 12, 1, 2, 1, 85, 1])\n    [85, 12, 2, 1]\n    >>> random_integer_partition(10, seed=[1, 2, 3, 1, 5, 1])\n    [5, 3, 1, 1]\n    >>> random_integer_partition(1)\n    [1]\n    ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "RGS_generalized",
    "full_id": "sympy.combinatorics.partitions.RGS_generalized",
    "type": "function",
    "description": "\n    Computes the m + 1 generalized unrestricted growth strings\n    and returns them as rows in matrix.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.partitions import RGS_generalized\n    >>> RGS_generalized(6)\n    Matrix([\n    [  1,   1,   1,  1,  1, 1, 1],\n    [  1,   2,   3,  4,  5, 6, 0],\n    [  2,   5,  10, 17, 26, 0, 0],\n    [  5,  15,  37, 77,  0, 0, 0],\n    [ 15,  52, 151,  0,  0, 0, 0],\n    [ 52, 203,   0,  0,  0, 0, 0],\n    [203,   0,   0,  0,  0, 0, 0]])\n    ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "RGS_enum",
    "full_id": "sympy.combinatorics.partitions.RGS_enum",
    "type": "function",
    "description": "\n    RGS_enum computes the total number of restricted growth strings\n    possible for a superset of size m.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.partitions import RGS_enum\n    >>> from sympy.combinatorics import Partition\n    >>> RGS_enum(4)\n    15\n    >>> RGS_enum(5)\n    52\n    >>> RGS_enum(6)\n    203\n\n    We can check that the enumeration is correct by actually generating\n    the partitions. Here, the 15 partitions of 4 items are generated:\n\n    >>> a = Partition(list(range(4)))\n    >>> s = set()\n    >>> for i in range(20):\n    ...     s.add(a)\n    ...     a += 1\n    ...\n    >>> assert len(s) == 15\n\n    ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "RGS_unrank",
    "full_id": "sympy.combinatorics.partitions.RGS_unrank",
    "type": "function",
    "description": "\n    Gives the unranked restricted growth string for a given\n    superset size.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.partitions import RGS_unrank\n    >>> RGS_unrank(14, 4)\n    [0, 1, 2, 3]\n    >>> RGS_unrank(0, 4)\n    [0, 0, 0, 0]\n    ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "RGS_rank",
    "full_id": "sympy.combinatorics.partitions.RGS_rank",
    "type": "function",
    "description": "\n    Computes the rank of a restricted growth string.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.partitions import RGS_rank, RGS_unrank\n    >>> RGS_rank([0, 1, 2, 1, 3])\n    42\n    >>> RGS_rank(RGS_unrank(4, 7))\n    4\n    ",
    "section": "Partitions",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/partitions.html"
  },
  {
    "name": "apply",
    "full_id": "sympy.combinatorics.permutations.Permutation.apply",
    "type": "method",
    "description": "Apply the permutation to an expression.\n\n        Parameters\n        ==========\n\n        i : Expr\n            It should be an integer between $0$ and $n-1$ where $n$\n            is the size of the permutation.\n\n            If it is a symbol or a symbolic expression that can\n            have integer values, an ``AppliedPermutation`` object\n            will be returned which can represent an unevaluated\n            function.\n\n        Notes\n        =====\n\n        Any permutation can be defined as a bijective function\n        $\\sigma : \\{ 0, 1, \\dots, n-1 \\} \\rightarrow \\{ 0, 1, \\dots, n-1 \\}$\n        where $n$ denotes the size of the permutation.\n\n        The definition may even be extended for any set with distinctive\n        elements, such that the permutation can even be applied for\n        real numbers or such, however, it is not implemented for now for\n        computational reasons and the integrity with the group theory\n        module.\n\n        This function is similar to the ``__call__`` magic, however,\n        ``__call__`` magic already has some other applications like\n        permuting an array or attaching new cycles, which would\n        not always be mathematically consistent.\n\n        This also guarantees that the return type is a SymPy integer,\n        which guarantees the safety to use assumptions.\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "array_form",
    "full_id": "sympy.combinatorics.permutations.Permutation.array_form",
    "type": "property",
    "description": "\n        Return a copy of the attribute _array_form\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([[2, 0], [3, 1]])\n        >>> p.array_form\n        [2, 3, 0, 1]\n        >>> Permutation([[2, 0, 3, 1]]).array_form\n        [3, 2, 0, 1]\n        >>> Permutation([2, 0, 3, 1]).array_form\n        [2, 0, 3, 1]\n        >>> Permutation([[1, 2], [4, 5]]).array_form\n        [0, 2, 1, 3, 5, 4]\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "ascents",
    "full_id": "sympy.combinatorics.permutations.Permutation.ascents",
    "type": "method",
    "description": "\n        Returns the positions of ascents in a permutation, ie, the location\n        where p[i] < p[i+1]\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([4, 0, 1, 3, 2])\n        >>> p.ascents()\n        [1, 2]\n\n        See Also\n        ========\n\n        descents, inversions, min, max\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "atoms",
    "full_id": "sympy.combinatorics.permutations.Permutation.atoms",
    "type": "method",
    "description": "\n        Returns all the elements of a permutation\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation([0, 1, 2, 3, 4, 5]).atoms()\n        {0, 1, 2, 3, 4, 5}\n        >>> Permutation([[0, 1], [2, 3], [4, 5]]).atoms()\n        {0, 1, 2, 3, 4, 5}\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "cardinality",
    "full_id": "sympy.combinatorics.permutations.Permutation.cardinality",
    "type": "property",
    "description": "\n        Returns the number of all possible permutations.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 2, 3])\n        >>> p.cardinality\n        24\n\n        See Also\n        ========\n\n        length, order, rank, size\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "commutator",
    "full_id": "sympy.combinatorics.permutations.Permutation.commutator",
    "type": "method",
    "description": "Return the commutator of ``self`` and ``x``: ``~x*~self*x*self``\n\n        If f and g are part of a group, G, then the commutator of f and g\n        is the group identity iff f and g commute, i.e. fg == gf.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> from sympy import init_printing\n        >>> init_printing(perm_cyclic=False, pretty_print=False)\n        >>> p = Permutation([0, 2, 3, 1])\n        >>> x = Permutation([2, 0, 3, 1])\n        >>> c = p.commutator(x); c\n        Permutation([2, 1, 3, 0])\n        >>> c == ~x*~p*x*p\n        True\n\n        >>> I = Permutation(3)\n        >>> p = [I + i for i in range(6)]\n        >>> for i in range(len(p)):\n        ...     for j in range(len(p)):\n        ...         c = p[i].commutator(p[j])\n        ...         if p[i]*p[j] == p[j]*p[i]:\n        ...             assert c == I\n        ...         else:\n        ...             assert c != I\n        ...\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Commutator\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "commutes_with",
    "full_id": "sympy.combinatorics.permutations.Permutation.commutes_with",
    "type": "method",
    "description": "\n        Checks if the elements are commuting.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> a = Permutation([1, 4, 3, 0, 2, 5])\n        >>> b = Permutation([0, 1, 2, 3, 4, 5])\n        >>> a.commutes_with(b)\n        True\n        >>> b = Permutation([2, 3, 5, 4, 1, 0])\n        >>> a.commutes_with(b)\n        False\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "cycle_structure",
    "full_id": "sympy.combinatorics.permutations.Permutation.cycle_structure",
    "type": "property",
    "description": "Return the cycle structure of the permutation as a dictionary\n        indicating the multiplicity of each cycle length.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation(3).cycle_structure\n        {1: 4}\n        >>> Permutation(0, 4, 3)(1, 2)(5, 6).cycle_structure\n        {2: 2, 3: 1}\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "cycles",
    "full_id": "sympy.combinatorics.permutations.Permutation.cycles",
    "type": "property",
    "description": "\n        Returns the number of cycles contained in the permutation\n        (including singletons).\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation([0, 1, 2]).cycles\n        3\n        >>> Permutation([0, 1, 2]).full_cyclic_form\n        [[0], [1], [2]]\n        >>> Permutation(0, 1)(2, 3).cycles\n        2\n\n        See Also\n        ========\n        sympy.functions.combinatorial.numbers.stirling\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "cyclic_form",
    "full_id": "sympy.combinatorics.permutations.Permutation.cyclic_form",
    "type": "property",
    "description": "\n        This is used to convert to the cyclic notation\n        from the canonical notation. Singletons are omitted.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 3, 1, 2])\n        >>> p.cyclic_form\n        [[1, 3, 2]]\n        >>> Permutation([1, 0, 2, 4, 3, 5]).cyclic_form\n        [[0, 1], [3, 4]]\n\n        See Also\n        ========\n\n        array_form, full_cyclic_form\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "descents",
    "full_id": "sympy.combinatorics.permutations.Permutation.descents",
    "type": "method",
    "description": "\n        Returns the positions of descents in a permutation, ie, the location\n        where p[i] > p[i+1]\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([4, 0, 1, 3, 2])\n        >>> p.descents()\n        [0, 3]\n\n        See Also\n        ========\n\n        ascents, inversions, min, max\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "from_inversion_vector",
    "full_id": "sympy.combinatorics.permutations.Permutation.from_inversion_vector",
    "type": "method",
    "description": "\n        Calculates the permutation from the inversion vector.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> from sympy import init_printing\n        >>> init_printing(perm_cyclic=False, pretty_print=False)\n        >>> Permutation.from_inversion_vector([3, 2, 1, 0, 0])\n        Permutation([3, 2, 1, 0, 4, 5])\n\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "from_sequence",
    "full_id": "sympy.combinatorics.permutations.Permutation.from_sequence",
    "type": "method",
    "description": "Return the permutation needed to obtain ``i`` from the sorted\n        elements of ``i``. If custom sorting is desired, a key can be given.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n\n        >>> Permutation.from_sequence('SymPy')\n        (4)(0 1 3)\n        >>> _(sorted(\"SymPy\"))\n        ['S', 'y', 'm', 'P', 'y']\n        >>> Permutation.from_sequence('SymPy', key=lambda x: x.lower())\n        (4)(0 2)(1 3)\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "full_cyclic_form",
    "full_id": "sympy.combinatorics.permutations.Permutation.full_cyclic_form",
    "type": "property",
    "description": "Return permutation in cyclic form including singletons.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation([0, 2, 1]).full_cyclic_form\n        [[0], [1, 2]]\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "get_adjacency_distance",
    "full_id": "sympy.combinatorics.permutations.Permutation.get_adjacency_distance",
    "type": "method",
    "description": "\n        Computes the adjacency distance between two permutations.\n\n        Explanation\n        ===========\n\n        This metric counts the number of times a pair i,j of jobs is\n        adjacent in both p and p'. If n_adj is this quantity then\n        the adjacency distance is n - n_adj - 1 [1]\n\n        [1] Reeves, Colin R. Landscapes, Operators and Heuristic search, Annals\n        of Operational Research, 86, pp 473-490. (1999)\n\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 3, 1, 2, 4])\n        >>> q = Permutation.josephus(4, 5, 2)\n        >>> p.get_adjacency_distance(q)\n        3\n        >>> r = Permutation([0, 2, 1, 4, 3])\n        >>> p.get_adjacency_distance(r)\n        4\n\n        See Also\n        ========\n\n        get_precedence_matrix, get_precedence_distance, get_adjacency_matrix\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "get_adjacency_matrix",
    "full_id": "sympy.combinatorics.permutations.Permutation.get_adjacency_matrix",
    "type": "method",
    "description": "\n        Computes the adjacency matrix of a permutation.\n\n        Explanation\n        ===========\n\n        If job i is adjacent to job j in a permutation p\n        then we set m[i, j] = 1 where m is the adjacency\n        matrix of p.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation.josephus(3, 6, 1)\n        >>> p.get_adjacency_matrix()\n        Matrix([\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 0, 1],\n        [0, 1, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 1, 0, 0]])\n        >>> q = Permutation([0, 1, 2, 3])\n        >>> q.get_adjacency_matrix()\n        Matrix([\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]])\n\n        See Also\n        ========\n\n        get_precedence_matrix, get_precedence_distance, get_adjacency_distance\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "get_positional_distance",
    "full_id": "sympy.combinatorics.permutations.Permutation.get_positional_distance",
    "type": "method",
    "description": "\n        Computes the positional distance between two permutations.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 3, 1, 2, 4])\n        >>> q = Permutation.josephus(4, 5, 2)\n        >>> r = Permutation([3, 1, 4, 0, 2])\n        >>> p.get_positional_distance(q)\n        12\n        >>> p.get_positional_distance(r)\n        12\n\n        See Also\n        ========\n\n        get_precedence_distance, get_adjacency_distance\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "get_precedence_distance",
    "full_id": "sympy.combinatorics.permutations.Permutation.get_precedence_distance",
    "type": "method",
    "description": "\n        Computes the precedence distance between two permutations.\n\n        Explanation\n        ===========\n\n        Suppose p and p' represent n jobs. The precedence metric\n        counts the number of times a job j is preceded by job i\n        in both p and p'. This metric is commutative.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([2, 0, 4, 3, 1])\n        >>> q = Permutation([3, 1, 2, 4, 0])\n        >>> p.get_precedence_distance(q)\n        7\n        >>> q.get_precedence_distance(p)\n        7\n\n        See Also\n        ========\n\n        get_precedence_matrix, get_adjacency_matrix, get_adjacency_distance\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "get_precedence_matrix",
    "full_id": "sympy.combinatorics.permutations.Permutation.get_precedence_matrix",
    "type": "method",
    "description": "\n        Gets the precedence matrix. This is used for computing the\n        distance between two permutations.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> from sympy import init_printing\n        >>> init_printing(perm_cyclic=False, pretty_print=False)\n        >>> p = Permutation.josephus(3, 6, 1)\n        >>> p\n        Permutation([2, 5, 3, 1, 4, 0])\n        >>> p.get_precedence_matrix()\n        Matrix([\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 0],\n        [1, 1, 0, 1, 1, 1],\n        [1, 1, 0, 0, 1, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 1, 0]])\n\n        See Also\n        ========\n\n        get_precedence_distance, get_adjacency_matrix, get_adjacency_distance\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "index",
    "full_id": "sympy.combinatorics.permutations.Permutation.index",
    "type": "method",
    "description": "\n        Returns the index of a permutation.\n\n        The index of a permutation is the sum of all subscripts j such\n        that p[j] is greater than p[j+1].\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([3, 0, 2, 1, 4])\n        >>> p.index()\n        2\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "inversion_vector",
    "full_id": "sympy.combinatorics.permutations.Permutation.inversion_vector",
    "type": "method",
    "description": "Return the inversion vector of the permutation.\n\n        The inversion vector consists of elements whose value\n        indicates the number of elements in the permutation\n        that are lesser than it and lie on its right hand side.\n\n        The inversion vector is the same as the Lehmer encoding of a\n        permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([4, 8, 0, 7, 1, 5, 3, 6, 2])\n        >>> p.inversion_vector()\n        [4, 7, 0, 5, 0, 2, 1, 1]\n        >>> p = Permutation([3, 2, 1, 0])\n        >>> p.inversion_vector()\n        [3, 2, 1]\n\n        The inversion vector increases lexicographically with the rank\n        of the permutation, the -ith element cycling through 0..i.\n\n        >>> p = Permutation(2)\n        >>> while p:\n        ...     print('%s %s %s' % (p, p.inversion_vector(), p.rank()))\n        ...     p = p.next_lex()\n        (2) [0, 0] 0\n        (1 2) [0, 1] 1\n        (2)(0 1) [1, 0] 2\n        (0 1 2) [1, 1] 3\n        (0 2 1) [2, 0] 4\n        (0 2) [2, 1] 5\n\n        See Also\n        ========\n\n        from_inversion_vector\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "inversions",
    "full_id": "sympy.combinatorics.permutations.Permutation.inversions",
    "type": "method",
    "description": "\n        Computes the number of inversions of a permutation.\n\n        Explanation\n        ===========\n\n        An inversion is where i > j but p[i] < p[j].\n\n        For small length of p, it iterates over all i and j\n        values and calculates the number of inversions.\n        For large length of p, it uses a variation of merge\n        sort to calculate the number of inversions.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 2, 3, 4, 5])\n        >>> p.inversions()\n        0\n        >>> Permutation([3, 2, 1, 0]).inversions()\n        6\n\n        See Also\n        ========\n\n        descents, ascents, min, max\n\n        References\n        ==========\n\n        .. [1] https://www.cp.eng.chula.ac.th/~prabhas//teaching/algo/algo2008/count-inv.htm\n\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "is_Empty",
    "full_id": "sympy.combinatorics.permutations.Permutation.is_Empty",
    "type": "property",
    "description": "\n        Checks to see if the permutation is a set with zero elements\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation([]).is_Empty\n        True\n        >>> Permutation([0]).is_Empty\n        False\n\n        See Also\n        ========\n\n        is_Singleton\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "is_Identity",
    "full_id": "sympy.combinatorics.permutations.Permutation.is_Identity",
    "type": "property",
    "description": "\n        Returns True if the Permutation is an identity permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([])\n        >>> p.is_Identity\n        True\n        >>> p = Permutation([[0], [1], [2]])\n        >>> p.is_Identity\n        True\n        >>> p = Permutation([0, 1, 2])\n        >>> p.is_Identity\n        True\n        >>> p = Permutation([0, 2, 1])\n        >>> p.is_Identity\n        False\n\n        See Also\n        ========\n\n        order\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "is_Singleton",
    "full_id": "sympy.combinatorics.permutations.Permutation.is_Singleton",
    "type": "property",
    "description": "\n        Checks to see if the permutation contains only one number and is\n        thus the only possible permutation of this set of numbers\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation([0]).is_Singleton\n        True\n        >>> Permutation([0, 1]).is_Singleton\n        False\n\n        See Also\n        ========\n\n        is_Empty\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "is_even",
    "full_id": "sympy.combinatorics.permutations.Permutation.is_even",
    "type": "property",
    "description": "\n        Checks if a permutation is even.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 2, 3])\n        >>> p.is_even\n        True\n        >>> p = Permutation([3, 2, 1, 0])\n        >>> p.is_even\n        True\n\n        See Also\n        ========\n\n        is_odd\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "is_odd",
    "full_id": "sympy.combinatorics.permutations.Permutation.is_odd",
    "type": "property",
    "description": "\n        Checks if a permutation is odd.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 2, 3])\n        >>> p.is_odd\n        False\n        >>> p = Permutation([3, 2, 0, 1])\n        >>> p.is_odd\n        True\n\n        See Also\n        ========\n\n        is_even\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "josephus",
    "full_id": "sympy.combinatorics.permutations.Permutation.josephus",
    "type": "method",
    "description": "Return as a permutation the shuffling of range(n) using the Josephus\n        scheme in which every m-th item is selected until all have been chosen.\n        The returned permutation has elements listed by the order in which they\n        were selected.\n\n        The parameter ``s`` stops the selection process when there are ``s``\n        items remaining and these are selected by continuing the selection,\n        counting by 1 rather than by ``m``.\n\n        Consider selecting every 3rd item from 6 until only 2 remain::\n\n            choices    chosen\n            ========   ======\n              012345\n              01 345   2\n              01 34    25\n              01  4    253\n              0   4    2531\n              0        25314\n                       253140\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation.josephus(3, 6, 2).array_form\n        [2, 5, 3, 1, 4, 0]\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Flavius_Josephus\n        .. [2] https://en.wikipedia.org/wiki/Josephus_problem\n        .. [3] https://web.archive.org/web/20171008094331/http://www.wou.edu/~burtonl/josephus.html\n\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "length",
    "full_id": "sympy.combinatorics.permutations.Permutation.length",
    "type": "method",
    "description": "\n        Returns the number of integers moved by a permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation([0, 3, 2, 1]).length()\n        2\n        >>> Permutation([[0, 1], [2, 3]]).length()\n        4\n\n        See Also\n        ========\n\n        min, max, support, cardinality, order, rank, size\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "list",
    "full_id": "sympy.combinatorics.permutations.Permutation.list",
    "type": "method",
    "description": "Return the permutation as an explicit list, possibly\n        trimming unmoved elements if size is less than the maximum\n        element in the permutation; if this is desired, setting\n        ``size=-1`` will guarantee such trimming.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation(2, 3)(4, 5)\n        >>> p.list()\n        [0, 1, 3, 2, 5, 4]\n        >>> p.list(10)\n        [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]\n\n        Passing a length too small will trim trailing, unchanged elements\n        in the permutation:\n\n        >>> Permutation(2, 4)(1, 2, 4).list(-1)\n        [0, 2, 1]\n        >>> Permutation(3).list(-1)\n        []\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "max",
    "full_id": "sympy.combinatorics.permutations.Permutation.max",
    "type": "method",
    "description": "\n        The maximum element moved by the permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([1, 0, 2, 3, 4])\n        >>> p.max()\n        1\n\n        See Also\n        ========\n\n        min, descents, ascents, inversions\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "min",
    "full_id": "sympy.combinatorics.permutations.Permutation.min",
    "type": "method",
    "description": "\n        The minimum element moved by the permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 4, 3, 2])\n        >>> p.min()\n        2\n\n        See Also\n        ========\n\n        max, descents, ascents, inversions\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "mul_inv",
    "full_id": "sympy.combinatorics.permutations.Permutation.mul_inv",
    "type": "method",
    "description": "\n        other*~self, self and other have _array_form\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "next_lex",
    "full_id": "sympy.combinatorics.permutations.Permutation.next_lex",
    "type": "method",
    "description": "\n        Returns the next permutation in lexicographical order.\n        If self is the last permutation in lexicographical order\n        it returns None.\n        See [4] section 2.4.\n\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([2, 3, 1, 0])\n        >>> p = Permutation([2, 3, 1, 0]); p.rank()\n        17\n        >>> p = p.next_lex(); p.rank()\n        18\n\n        See Also\n        ========\n\n        rank, unrank_lex\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "next_nonlex",
    "full_id": "sympy.combinatorics.permutations.Permutation.next_nonlex",
    "type": "method",
    "description": "\n        Returns the next permutation in nonlex order [3].\n        If self is the last permutation in this order it returns None.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> from sympy import init_printing\n        >>> init_printing(perm_cyclic=False, pretty_print=False)\n        >>> p = Permutation([2, 0, 3, 1]); p.rank_nonlex()\n        5\n        >>> p = p.next_nonlex(); p\n        Permutation([3, 0, 1, 2])\n        >>> p.rank_nonlex()\n        6\n\n        See Also\n        ========\n\n        rank_nonlex, unrank_nonlex\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "next_trotterjohnson",
    "full_id": "sympy.combinatorics.permutations.Permutation.next_trotterjohnson",
    "type": "method",
    "description": "\n        Returns the next permutation in Trotter-Johnson order.\n        If self is the last permutation it returns None.\n        See [4] section 2.4. If it is desired to generate all such\n        permutations, they can be generated in order more quickly\n        with the ``generate_bell`` function.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> from sympy import init_printing\n        >>> init_printing(perm_cyclic=False, pretty_print=False)\n        >>> p = Permutation([3, 0, 2, 1])\n        >>> p.rank_trotterjohnson()\n        4\n        >>> p = p.next_trotterjohnson(); p\n        Permutation([0, 3, 2, 1])\n        >>> p.rank_trotterjohnson()\n        5\n\n        See Also\n        ========\n\n        rank_trotterjohnson, unrank_trotterjohnson, sympy.utilities.iterables.generate_bell\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "order",
    "full_id": "sympy.combinatorics.permutations.Permutation.order",
    "type": "method",
    "description": "\n        Computes the order of a permutation.\n\n        When the permutation is raised to the power of its\n        order it equals the identity permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> from sympy import init_printing\n        >>> init_printing(perm_cyclic=False, pretty_print=False)\n        >>> p = Permutation([3, 1, 5, 2, 4, 0])\n        >>> p.order()\n        4\n        >>> (p**(p.order()))\n        Permutation([], size=6)\n\n        See Also\n        ========\n\n        identity, cardinality, length, rank, size\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "parity",
    "full_id": "sympy.combinatorics.permutations.Permutation.parity",
    "type": "method",
    "description": "\n        Computes the parity of a permutation.\n\n        Explanation\n        ===========\n\n        The parity of a permutation reflects the parity of the\n        number of inversions in the permutation, i.e., the\n        number of pairs of x and y such that ``x > y`` but ``p[x] < p[y]``.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 2, 3])\n        >>> p.parity()\n        0\n        >>> p = Permutation([3, 2, 0, 1])\n        >>> p.parity()\n        1\n\n        See Also\n        ========\n\n        _af_parity\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "random",
    "full_id": "sympy.combinatorics.permutations.Permutation.random",
    "type": "method",
    "description": "\n        Generates a random permutation of length ``n``.\n\n        Uses the underlying Python pseudo-random number generator.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation.random(2) in (Permutation([1, 0]), Permutation([0, 1]))\n        True\n\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "rank",
    "full_id": "sympy.combinatorics.permutations.Permutation.rank",
    "type": "method",
    "description": "\n        Returns the lexicographic rank of the permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 2, 3])\n        >>> p.rank()\n        0\n        >>> p = Permutation([3, 2, 1, 0])\n        >>> p.rank()\n        23\n\n        See Also\n        ========\n\n        next_lex, unrank_lex, cardinality, length, order, size\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "rank_nonlex",
    "full_id": "sympy.combinatorics.permutations.Permutation.rank_nonlex",
    "type": "method",
    "description": "\n        This is a linear time ranking algorithm that does not\n        enforce lexicographic order [3].\n\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 2, 3])\n        >>> p.rank_nonlex()\n        23\n\n        See Also\n        ========\n\n        next_nonlex, unrank_nonlex\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "rank_trotterjohnson",
    "full_id": "sympy.combinatorics.permutations.Permutation.rank_trotterjohnson",
    "type": "method",
    "description": "\n        Returns the Trotter Johnson rank, which we get from the minimal\n        change algorithm. See [4] section 2.4.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 2, 3])\n        >>> p.rank_trotterjohnson()\n        0\n        >>> p = Permutation([0, 2, 1, 3])\n        >>> p.rank_trotterjohnson()\n        7\n\n        See Also\n        ========\n\n        unrank_trotterjohnson, next_trotterjohnson\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "resize",
    "full_id": "sympy.combinatorics.permutations.Permutation.resize",
    "type": "method",
    "description": "Resize the permutation to the new size ``n``.\n\n        Parameters\n        ==========\n\n        n : int\n            The new size of the permutation.\n\n        Raises\n        ======\n\n        ValueError\n            If the permutation cannot be resized to the given size.\n            This may only happen when resized to a smaller size than\n            the original.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n\n        Increasing the size of a permutation:\n\n        >>> p = Permutation(0, 1, 2)\n        >>> p = p.resize(5)\n        >>> p\n        (4)(0 1 2)\n\n        Decreasing the size of the permutation:\n\n        >>> p = p.resize(4)\n        >>> p\n        (3)(0 1 2)\n\n        If resizing to the specific size breaks the cycles:\n\n        >>> p.resize(2)\n        Traceback (most recent call last):\n        ...\n        ValueError: The permutation cannot be resized to 2 because the\n        cycle (0, 1, 2) may break.\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "rmul",
    "full_id": "sympy.combinatorics.permutations.Permutation.rmul",
    "type": "method",
    "description": "\n        Return product of Permutations [a, b, c, ...] as the Permutation whose\n        ith value is a(b(c(i))).\n\n        a, b, c, ... can be Permutation objects or tuples.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n\n        >>> a, b = [1, 0, 2], [0, 2, 1]\n        >>> a = Permutation(a); b = Permutation(b)\n        >>> list(Permutation.rmul(a, b))\n        [1, 2, 0]\n        >>> [a(b(i)) for i in range(3)]\n        [1, 2, 0]\n\n        This handles the operands in reverse order compared to the ``*`` operator:\n\n        >>> a = Permutation(a); b = Permutation(b)\n        >>> list(a*b)\n        [2, 0, 1]\n        >>> [b(a(i)) for i in range(3)]\n        [2, 0, 1]\n\n        Notes\n        =====\n\n        All items in the sequence will be parsed by Permutation as\n        necessary as long as the first item is a Permutation:\n\n        >>> Permutation.rmul(a, [0, 2, 1]) == Permutation.rmul(a, b)\n        True\n\n        The reverse order of arguments will raise a TypeError.\n\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "rmul_with_af",
    "full_id": "sympy.combinatorics.permutations.Permutation.rmul_with_af",
    "type": "method",
    "description": "\n        same as rmul, but the elements of args are Permutation objects\n        which have _array_form\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "runs",
    "full_id": "sympy.combinatorics.permutations.Permutation.runs",
    "type": "method",
    "description": "\n        Returns the runs of a permutation.\n\n        An ascending sequence in a permutation is called a run [5].\n\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([2, 5, 7, 3, 6, 0, 1, 4, 8])\n        >>> p.runs()\n        [[2, 5, 7], [3, 6], [0, 1, 4, 8]]\n        >>> q = Permutation([1,3,2,0])\n        >>> q.runs()\n        [[1, 3], [2], [0]]\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "signature",
    "full_id": "sympy.combinatorics.permutations.Permutation.signature",
    "type": "method",
    "description": "\n        Gives the signature of the permutation needed to place the\n        elements of the permutation in canonical order.\n\n        The signature is calculated as (-1)^<number of inversions>\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([0, 1, 2])\n        >>> p.inversions()\n        0\n        >>> p.signature()\n        1\n        >>> q = Permutation([0,2,1])\n        >>> q.inversions()\n        1\n        >>> q.signature()\n        -1\n\n        See Also\n        ========\n\n        inversions\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "size",
    "full_id": "sympy.combinatorics.permutations.Permutation.size",
    "type": "property",
    "description": "\n        Returns the number of elements in the permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> Permutation([[3, 2], [0, 1]]).size\n        4\n\n        See Also\n        ========\n\n        cardinality, length, order, rank\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "support",
    "full_id": "sympy.combinatorics.permutations.Permutation.support",
    "type": "method",
    "description": "Return the elements in permutation, P, for which P[i] != i.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([[3, 2], [0, 1], [4]])\n        >>> p.array_form\n        [1, 0, 3, 2, 4]\n        >>> p.support()\n        [0, 1, 2, 3]\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "transpositions",
    "full_id": "sympy.combinatorics.permutations.Permutation.transpositions",
    "type": "method",
    "description": "\n        Return the permutation decomposed into a list of transpositions.\n\n        Explanation\n        ===========\n\n        It is always possible to express a permutation as the product of\n        transpositions, see [1]\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> p = Permutation([[1, 2, 3], [0, 4, 5, 6, 7]])\n        >>> t = p.transpositions()\n        >>> t\n        [(0, 7), (0, 6), (0, 5), (0, 4), (1, 3), (1, 2)]\n        >>> print(''.join(str(c) for c in t))\n        (0, 7)(0, 6)(0, 5)(0, 4)(1, 3)(1, 2)\n        >>> Permutation.rmul(*[Permutation([ti], size=p.size) for ti in t]) == p\n        True\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Transposition_%28mathematics%29#Properties\n\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "unrank_lex",
    "full_id": "sympy.combinatorics.permutations.Permutation.unrank_lex",
    "type": "method",
    "description": "\n        Lexicographic permutation unranking.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> from sympy import init_printing\n        >>> init_printing(perm_cyclic=False, pretty_print=False)\n        >>> a = Permutation.unrank_lex(5, 10)\n        >>> a.rank()\n        10\n        >>> a\n        Permutation([0, 2, 4, 1, 3])\n\n        See Also\n        ========\n\n        rank, next_lex\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "unrank_nonlex",
    "full_id": "sympy.combinatorics.permutations.Permutation.unrank_nonlex",
    "type": "method",
    "description": "\n        This is a linear time unranking algorithm that does not\n        respect lexicographic order [3].\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> from sympy import init_printing\n        >>> init_printing(perm_cyclic=False, pretty_print=False)\n        >>> Permutation.unrank_nonlex(4, 5)\n        Permutation([2, 0, 3, 1])\n        >>> Permutation.unrank_nonlex(4, -1)\n        Permutation([0, 1, 2, 3])\n\n        See Also\n        ========\n\n        next_nonlex, rank_nonlex\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "unrank_trotterjohnson",
    "full_id": "sympy.combinatorics.permutations.Permutation.unrank_trotterjohnson",
    "type": "method",
    "description": "\n        Trotter Johnson permutation unranking. See [4] section 2.4.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation\n        >>> from sympy import init_printing\n        >>> init_printing(perm_cyclic=False, pretty_print=False)\n        >>> Permutation.unrank_trotterjohnson(5, 10)\n        Permutation([0, 3, 1, 2, 4])\n\n        See Also\n        ========\n\n        rank_trotterjohnson, next_trotterjohnson\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "list",
    "full_id": "sympy.combinatorics.permutations.Cycle.list",
    "type": "method",
    "description": "Return the cycles as an explicit list starting from 0 up\n        to the greater of the largest value in the cycles and size.\n\n        Truncation of trailing unmoved items will occur when size\n        is less than the maximum element in the cycle; if this is\n        desired, setting ``size=-1`` will guarantee such trimming.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Cycle\n        >>> p = Cycle(2, 3)(4, 5)\n        >>> p.list()\n        [0, 1, 3, 2, 5, 4]\n        >>> p.list(10)\n        [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]\n\n        Passing a length too small will trim trailing, unchanged elements\n        in the permutation:\n\n        >>> Cycle(2, 4)(1, 2, 4).list(-1)\n        [0, 2, 1]\n        ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "_af_parity",
    "full_id": "sympy.combinatorics.permutations._af_parity",
    "type": "function",
    "description": "\n    Computes the parity of a permutation in array form.\n\n    Explanation\n    ===========\n\n    The parity of a permutation reflects the parity of the\n    number of inversions in the permutation, i.e., the\n    number of pairs of x and y such that x > y but p[x] < p[y].\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.permutations import _af_parity\n    >>> _af_parity([0, 1, 2, 3])\n    0\n    >>> _af_parity([3, 2, 0, 1])\n    1\n\n    See Also\n    ========\n\n    Permutation\n    ",
    "section": "Permutations",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "symmetric",
    "full_id": "Generators.symmetric",
    "type": "method",
    "description": "Doc not available.",
    "section": "Generators",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/permutations.html"
  },
  {
    "name": "__contains__",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.__contains__",
    "type": "method",
    "description": "Return ``True`` if *i* is contained in PermutationGroup.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> p = Permutation(1, 2, 3)\n        >>> Permutation(3) in PermutationGroup(p)\n        True\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "__mul__",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.__mul__",
    "type": "method",
    "description": "\n        Return the direct product of two permutation groups as a permutation\n        group.\n\n        Explanation\n        ===========\n\n        This implementation realizes the direct product by shifting the index\n        set for the generators of the second group: so if we have ``G`` acting\n        on ``n1`` points and ``H`` acting on ``n2`` points, ``G*H`` acts on\n        ``n1 + n2`` points.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import CyclicGroup\n        >>> G = CyclicGroup(5)\n        >>> H = G*G\n        >>> H\n        PermutationGroup([\n            (9)(0 1 2 3 4),\n            (5 6 7 8 9)])\n        >>> H.order()\n        25\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "__new__",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.__new__",
    "type": "method",
    "description": "The default constructor. Accepts Cycle and Permutation forms.\n        Removes duplicates unless ``dups`` keyword is ``False``.\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_coset_representative",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._coset_representative",
    "type": "method",
    "description": "Return the representative of Hg from the transversal that\n        would be computed by ``self.coset_transversal(H)``.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_distinct_primes_lemma",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._distinct_primes_lemma",
    "type": "method",
    "description": "Subroutine to test if there is only one cyclic group for the\n        order.",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_eval_is_alt_sym_monte_carlo",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._eval_is_alt_sym_monte_carlo",
    "type": "method",
    "description": "A test using monte-carlo algorithm.\n\n        Parameters\n        ==========\n\n        eps : float, optional\n            The criterion for the incorrect ``False`` return.\n\n        perms : list[Permutation], optional\n            If explicitly given, it tests over the given candidates\n            for testing.\n\n            If ``None``, it randomly computes ``N_eps`` and chooses\n            ``N_eps`` sample of the permutation from the group.\n\n        See Also\n        ========\n\n        _check_cycles_alt_sym\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_eval_is_alt_sym_naive",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._eval_is_alt_sym_naive",
    "type": "method",
    "description": "A naive test using the group order.",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_p_elements_group",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._p_elements_group",
    "type": "method",
    "description": "\n        For an abelian p-group, return the subgroup consisting of\n        all elements of order p (and the identity)\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_random_pr_init",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._random_pr_init",
    "type": "method",
    "description": "Initialize random generators for the product replacement algorithm.\n\n        Explanation\n        ===========\n\n        The implementation uses a modification of the original product\n        replacement algorithm due to Leedham-Green, as described in [1],\n        pp. 69-71; also, see [2], pp. 27-29 for a detailed theoretical\n        analysis of the original product replacement algorithm, and [4].\n\n        The product replacement algorithm is used for producing random,\n        uniformly distributed elements of a group `G` with a set of generators\n        `S`. For the initialization ``_random_pr_init``, a list ``R`` of\n        `\\max\\{r, |S|\\}` group generators is created as the attribute\n        ``G._random_gens``, repeating elements of `S` if necessary, and the\n        identity element of `G` is appended to ``R`` - we shall refer to this\n        last element as the accumulator. Then the function ``random_pr()``\n        is called ``n`` times, randomizing the list ``R`` while preserving\n        the generation of `G` by ``R``. The function ``random_pr()`` itself\n        takes two random elements ``g, h`` among all elements of ``R`` but\n        the accumulator and replaces ``g`` with a randomly chosen element\n        from `\\{gh, g(~h), hg, (~h)g\\}`. Then the accumulator is multiplied\n        by whatever ``g`` was replaced by. The new value of the accumulator is\n        then returned by ``random_pr()``.\n\n        The elements returned will eventually (for ``n`` large enough) become\n        uniformly distributed across `G` ([5]). For practical purposes however,\n        the values ``n = 50, r = 11`` are suggested in [1].\n\n        Notes\n        =====\n\n        THIS FUNCTION HAS SIDE EFFECTS: it changes the attribute\n        self._random_gens\n\n        See Also\n        ========\n\n        random_pr\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_sylow_alt_sym",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._sylow_alt_sym",
    "type": "method",
    "description": "\n        Return a p-Sylow subgroup of a symmetric or an\n        alternating group.\n\n        Explanation\n        ===========\n\n        The algorithm for this is hinted at in [1], Chapter 4,\n        Exercise 4.\n\n        For Sym(n) with n = p^i, the idea is as follows. Partition\n        the interval [0..n-1] into p equal parts, each of length p^(i-1):\n        [0..p^(i-1)-1], [p^(i-1)..2*p^(i-1)-1]...[(p-1)*p^(i-1)..p^i-1].\n        Find a p-Sylow subgroup of Sym(p^(i-1)) (treated as a subgroup\n        of ``self``) acting on each of the parts. Call the subgroups\n        P_1, P_2...P_p. The generators for the subgroups P_2...P_p\n        can be obtained from those of P_1 by applying a \"shifting\"\n        permutation to them, that is, a permutation mapping [0..p^(i-1)-1]\n        to the second part (the other parts are obtained by using the shift\n        multiple times). The union of this permutation and the generators\n        of P_1 is a p-Sylow subgroup of ``self``.\n\n        For n not equal to a power of p, partition\n        [0..n-1] in accordance with how n would be written in base p.\n        E.g. for p=2 and n=11, 11 = 2^3 + 2^2 + 1 so the partition\n        is [[0..7], [8..9], {10}]. To generate a p-Sylow subgroup,\n        take the union of the generators for each of the parts.\n        For the above example, {(0 1), (0 2)(1 3), (0 4), (1 5)(2 7)}\n        from the first part, {(8 9)} from the second part and\n        nothing from the third. This gives 4 generators in total, and\n        the subgroup they generate is p-Sylow.\n\n        Alternating groups are treated the same except when p=2. In this\n        case, (0 1)(s s+1) should be added for an appropriate s (the start\n        of a part) for each part in the partitions.\n\n        See Also\n        ========\n\n        sylow_subgroup, is_alt_sym\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_union_find_merge",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._union_find_merge",
    "type": "method",
    "description": "Merges two classes in a union-find data structure.\n\n        Explanation\n        ===========\n\n        Used in the implementation of Atkinson's algorithm as suggested in [1],\n        pp. 83-87. The class merging process uses union by rank as an\n        optimization. ([7])\n\n        Notes\n        =====\n\n        THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,\n        ``parents``, the list of class sizes, ``ranks``, and the list of\n        elements that are not representatives, ``not_rep``, are changed due to\n        class merging.\n\n        See Also\n        ========\n\n        minimal_block, _union_find_rep\n\n        References\n        ==========\n\n        .. [1] Holt, D., Eick, B., O'Brien, E.\n               \"Handbook of computational group theory\"\n\n        .. [7] https://algorithmist.com/wiki/Union_find\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_union_find_rep",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._union_find_rep",
    "type": "method",
    "description": "Find representative of a class in a union-find data structure.\n\n        Explanation\n        ===========\n\n        Used in the implementation of Atkinson's algorithm as suggested in [1],\n        pp. 83-87. After the representative of the class to which ``num``\n        belongs is found, path compression is performed as an optimization\n        ([7]).\n\n        Notes\n        =====\n\n        THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,\n        ``parents``, is altered due to path compression.\n\n        See Also\n        ========\n\n        minimal_block, _union_find_merge\n\n        References\n        ==========\n\n        .. [1] Holt, D., Eick, B., O'Brien, E.\n               \"Handbook of computational group theory\"\n\n        .. [7] https://algorithmist.com/wiki/Union_find\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "_verify",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup._verify",
    "type": "method",
    "description": "\n        Return a list of relators ``rels`` in generators ``gens`_h` that\n        are mapped to ``H.generators`` by ``phi`` so that given a finite\n        presentation <gens_k | rels_k> of ``K`` on a subset of ``gens_h``\n        <gens_h | rels_k + rels> is a finite presentation of ``H``.\n\n        Explanation\n        ===========\n\n        ``H`` should be generated by the union of ``K.generators`` and ``z``\n        (a single generator), and ``H.stabilizer(alpha) == K``; ``phi`` is a\n        canonical injection from a free group into a permutation group\n        containing ``H``.\n\n        The algorithm is described in [1], Chapter 6.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import free_group, Permutation, PermutationGroup\n        >>> from sympy.combinatorics.homomorphisms import homomorphism\n        >>> from sympy.combinatorics.fp_groups import FpGroup\n\n        >>> H = PermutationGroup(Permutation(0, 2), Permutation (1, 5))\n        >>> K = PermutationGroup(Permutation(5)(0, 2))\n        >>> F = free_group(\"x_0 x_1\")[0]\n        >>> gens = F.generators\n        >>> phi = homomorphism(F, H, F.generators, H.generators)\n        >>> rels_k = [gens[0]**2] # relators for presentation of K\n        >>> z= Permutation(1, 5)\n        >>> check, rels_h = H._verify(K, phi, z, 1)\n        >>> check\n        True\n        >>> rels = rels_k + rels_h\n        >>> G = FpGroup(F, rels) # presentation of H\n        >>> G.order() == H.order()\n        True\n\n        See also\n        ========\n\n        strong_presentation, presentation, stabilizer\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "abelian_invariants",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.abelian_invariants",
    "type": "method",
    "description": "\n        Returns the abelian invariants for the given group.\n        Let ``G`` be a nontrivial finite abelian group. Then G is isomorphic to\n        the direct product of finitely many nontrivial cyclic groups of\n        prime-power order.\n\n        Explanation\n        ===========\n\n        The prime-powers that occur as the orders of the factors are uniquely\n        determined by G. More precisely, the primes that occur in the orders of the\n        factors in any such decomposition of ``G`` are exactly the primes that divide\n        ``|G|`` and for any such prime ``p``, if the orders of the factors that are\n        p-groups in one such decomposition of ``G`` are ``p^{t_1} >= p^{t_2} >= ... p^{t_r}``,\n        then the orders of the factors that are p-groups in any such decomposition of ``G``\n        are ``p^{t_1} >= p^{t_2} >= ... p^{t_r}``.\n\n        The uniquely determined integers ``p^{t_1} >= p^{t_2} >= ... p^{t_r}``, taken\n        for all primes that divide ``|G|`` are called the invariants of the nontrivial\n        group ``G`` as suggested in ([14], p. 542).\n\n        Notes\n        =====\n\n        We adopt the convention that the invariants of a trivial group are [].\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([0, 2, 1])\n        >>> b = Permutation([1, 0, 2])\n        >>> G = PermutationGroup([a, b])\n        >>> G.abelian_invariants()\n        [2]\n        >>> from sympy.combinatorics import CyclicGroup\n        >>> G = CyclicGroup(7)\n        >>> G.abelian_invariants()\n        [7]\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "base",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.base",
    "type": "property",
    "description": "Return a base from the Schreier-Sims algorithm.\n\n        Explanation\n        ===========\n\n        For a permutation group `G`, a base is a sequence of points\n        `B = (b_1, b_2, \\dots, b_k)` such that no element of `G` apart\n        from the identity fixes all the points in `B`. The concepts of\n        a base and strong generating set and their applications are\n        discussed in depth in [1], pp. 87-89 and [2], pp. 55-57.\n\n        An alternative way to think of `B` is that it gives the\n        indices of the stabilizer cosets that contain more than the\n        identity permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> G = PermutationGroup([Permutation(0, 1, 3)(2, 4)])\n        >>> G.base\n        [0, 2]\n\n        See Also\n        ========\n\n        strong_gens, basic_transversals, basic_orbits, basic_stabilizers\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "baseswap",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.baseswap",
    "type": "method",
    "description": "Swap two consecutive base points in base and strong generating set.\n\n        Explanation\n        ===========\n\n        If a base for a group `G` is given by `(b_1, b_2, \\dots, b_k)`, this\n        function returns a base `(b_1, b_2, \\dots, b_{i+1}, b_i, \\dots, b_k)`,\n        where `i` is given by ``pos``, and a strong generating set relative\n        to that base. The original base and strong generating set are not\n        modified.\n\n        The randomized version (default) is of Las Vegas type.\n\n        Parameters\n        ==========\n\n        base, strong_gens\n            The base and strong generating set.\n        pos\n            The position at which swapping is performed.\n        randomized\n            A switch between randomized and deterministic version.\n        transversals\n            The transversals for the basic orbits, if known.\n        basic_orbits\n            The basic orbits, if known.\n        strong_gens_distr\n            The strong generators distributed by basic stabilizers, if known.\n\n        Returns\n        =======\n\n        (base, strong_gens)\n            ``base`` is the new base, and ``strong_gens`` is a generating set\n            relative to it.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import SymmetricGroup\n        >>> from sympy.combinatorics.testutil import _verify_bsgs\n        >>> from sympy.combinatorics.perm_groups import PermutationGroup\n        >>> S = SymmetricGroup(4)\n        >>> S.schreier_sims()\n        >>> S.base\n        [0, 1, 2]\n        >>> base, gens = S.baseswap(S.base, S.strong_gens, 1, randomized=False)\n        >>> base, gens\n        ([0, 2, 1],\n        [(0 1 2 3), (3)(0 1), (1 3 2),\n         (2 3), (1 3)])\n\n        check that base, gens is a BSGS\n\n        >>> S1 = PermutationGroup(gens)\n        >>> _verify_bsgs(S1, base, gens)\n        True\n\n        See Also\n        ========\n\n        schreier_sims\n\n        Notes\n        =====\n\n        The deterministic version of the algorithm is discussed in\n        [1], pp. 102-103; the randomized version is discussed in [1], p.103, and\n        [2], p.98. It is of Las Vegas type.\n        Notice that [1] contains a mistake in the pseudocode and\n        discussion of BASESWAP: on line 3 of the pseudocode,\n        `|\\beta_{i+1}^{\\left\\langle T\\right\\rangle}|` should be replaced by\n        `|\\beta_{i}^{\\left\\langle T\\right\\rangle}|`, and the same for the\n        discussion of the algorithm.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "basic_orbits",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits",
    "type": "property",
    "description": "\n        Return the basic orbits relative to a base and strong generating set.\n\n        Explanation\n        ===========\n\n        If `(b_1, b_2, \\dots, b_k)` is a base for a group `G`, and\n        `G^{(i)} = G_{b_1, b_2, \\dots, b_{i-1}}` is the ``i``-th basic stabilizer\n        (so that `G^{(1)} = G`), the ``i``-th basic orbit relative to this base\n        is the orbit of `b_i` under `G^{(i)}`. See [1], pp. 87-89 for more\n        information.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import SymmetricGroup\n        >>> S = SymmetricGroup(4)\n        >>> S.basic_orbits\n        [[0, 1, 2, 3], [1, 2, 3], [2, 3]]\n\n        See Also\n        ========\n\n        base, strong_gens, basic_transversals, basic_stabilizers\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "basic_stabilizers",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers",
    "type": "property",
    "description": "\n        Return a chain of stabilizers relative to a base and strong generating\n        set.\n\n        Explanation\n        ===========\n\n        The ``i``-th basic stabilizer `G^{(i)}` relative to a base\n        `(b_1, b_2, \\dots, b_k)` is `G_{b_1, b_2, \\dots, b_{i-1}}`. For more\n        information, see [1], pp. 87-89.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import AlternatingGroup\n        >>> A = AlternatingGroup(4)\n        >>> A.schreier_sims()\n        >>> A.base\n        [0, 1]\n        >>> for g in A.basic_stabilizers:\n        ...     print(g)\n        ...\n        PermutationGroup([\n            (3)(0 1 2),\n            (1 2 3)])\n        PermutationGroup([\n            (1 2 3)])\n\n        See Also\n        ========\n\n        base, strong_gens, basic_orbits, basic_transversals\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "basic_transversals",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals",
    "type": "property",
    "description": "\n        Return basic transversals relative to a base and strong generating set.\n\n        Explanation\n        ===========\n\n        The basic transversals are transversals of the basic orbits. They\n        are provided as a list of dictionaries, each dictionary having\n        keys - the elements of one of the basic orbits, and values - the\n        corresponding transversal elements. See [1], pp. 87-89 for more\n        information.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import AlternatingGroup\n        >>> A = AlternatingGroup(4)\n        >>> A.basic_transversals\n        [{0: (3), 1: (3)(0 1 2), 2: (3)(0 2 1), 3: (0 3 1)}, {1: (3), 2: (1 2 3), 3: (1 3 2)}]\n\n        See Also\n        ========\n\n        strong_gens, base, basic_orbits, basic_stabilizers\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "center",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.center",
    "type": "method",
    "description": "\n        Return the center of a permutation group.\n\n        Explanation\n        ===========\n\n        The center for a group `G` is defined as\n        `Z(G) = \\{z\\in G | \\forall g\\in G, zg = gz \\}`,\n        the set of elements of `G` that commute with all elements of `G`.\n        It is equal to the centralizer of `G` inside `G`, and is naturally a\n        subgroup of `G` ([9]).\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> D = DihedralGroup(4)\n        >>> G = D.center()\n        >>> G.order()\n        2\n\n        See Also\n        ========\n\n        centralizer\n\n        Notes\n        =====\n\n        This is a naive implementation that is a straightforward application\n        of ``.centralizer()``\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "centralizer",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.centralizer",
    "type": "method",
    "description": "\n        Return the centralizer of a group/set/element.\n\n        Explanation\n        ===========\n\n        The centralizer of a set of permutations ``S`` inside\n        a group ``G`` is the set of elements of ``G`` that commute with all\n        elements of ``S``::\n\n            `C_G(S) = \\{ g \\in G | gs = sg \\forall s \\in S\\}` ([10])\n\n        Usually, ``S`` is a subset of ``G``, but if ``G`` is a proper subgroup of\n        the full symmetric group, we allow for ``S`` to have elements outside\n        ``G``.\n\n        It is naturally a subgroup of ``G``; the centralizer of a permutation\n        group is equal to the centralizer of any set of generators for that\n        group, since any element commuting with the generators commutes with\n        any product of the  generators.\n\n        Parameters\n        ==========\n\n        other\n            a permutation group/list of permutations/single permutation\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n        ... CyclicGroup)\n        >>> S = SymmetricGroup(6)\n        >>> C = CyclicGroup(6)\n        >>> H = S.centralizer(C)\n        >>> H.is_subgroup(C)\n        True\n\n        See Also\n        ========\n\n        subgroup_search\n\n        Notes\n        =====\n\n        The implementation is an application of ``.subgroup_search()`` with\n        tests using a specific base for the group ``G``.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "commutator",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.commutator",
    "type": "method",
    "description": "\n        Return the commutator of two subgroups.\n\n        Explanation\n        ===========\n\n        For a permutation group ``K`` and subgroups ``G``, ``H``, the\n        commutator of ``G`` and ``H`` is defined as the group generated\n        by all the commutators `[g, h] = hgh^{-1}g^{-1}` for ``g`` in ``G`` and\n        ``h`` in ``H``. It is naturally a subgroup of ``K`` ([1], p.27).\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n        ... AlternatingGroup)\n        >>> S = SymmetricGroup(5)\n        >>> A = AlternatingGroup(5)\n        >>> G = S.commutator(S, A)\n        >>> G.is_subgroup(A)\n        True\n\n        See Also\n        ========\n\n        derived_subgroup\n\n        Notes\n        =====\n\n        The commutator of two subgroups `H, G` is equal to the normal closure\n        of the commutators of all the generators, i.e. `hgh^{-1}g^{-1}` for `h`\n        a generator of `H` and `g` a generator of `G` ([1], p.28)\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "composition_series",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.composition_series",
    "type": "method",
    "description": "\n        Return the composition series for a group as a list\n        of permutation groups.\n\n        Explanation\n        ===========\n\n        The composition series for a group `G` is defined as a\n        subnormal series `G = H_0 > H_1 > H_2 \\ldots` A composition\n        series is a subnormal series such that each factor group\n        `H(i+1) / H(i)` is simple.\n        A subnormal series is a composition series only if it is of\n        maximum length.\n\n        The algorithm works as follows:\n        Starting with the derived series the idea is to fill\n        the gap between `G = der[i]` and `H = der[i+1]` for each\n        `i` independently. Since, all subgroups of the abelian group\n        `G/H` are normal so, first step is to take the generators\n        `g` of `G` and add them to generators of `H` one by one.\n\n        The factor groups formed are not simple in general. Each\n        group is obtained from the previous one by adding one\n        generator `g`, if the previous group is denoted by `H`\n        then the next group `K` is generated by `g` and `H`.\n        The factor group `K/H` is cyclic and it's order is\n        `K.order()//G.order()`. The series is then extended between\n        `K` and `H` by groups generated by powers of `g` and `H`.\n        The series formed is then prepended to the already existing\n        series.\n\n        Examples\n        ========\n        >>> from sympy.combinatorics.named_groups import SymmetricGroup\n        >>> from sympy.combinatorics.named_groups import CyclicGroup\n        >>> S = SymmetricGroup(12)\n        >>> G = S.sylow_subgroup(2)\n        >>> C = G.composition_series()\n        >>> [H.order() for H in C]\n        [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]\n        >>> G = S.sylow_subgroup(3)\n        >>> C = G.composition_series()\n        >>> [H.order() for H in C]\n        [243, 81, 27, 9, 3, 1]\n        >>> G = CyclicGroup(12)\n        >>> C = G.composition_series()\n        >>> [H.order() for H in C]\n        [12, 6, 3, 1]\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "conjugacy_class",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.conjugacy_class",
    "type": "method",
    "description": "Return the conjugacy class of an element in the group.\n\n        Explanation\n        ===========\n\n        The conjugacy class of an element ``g`` in a group ``G`` is the set of\n        elements ``x`` in ``G`` that are conjugate with ``g``, i.e. for which\n\n            ``g = xax^{-1}``\n\n        for some ``a`` in ``G``.\n\n        Note that conjugacy is an equivalence relation, and therefore that\n        conjugacy classes are partitions of ``G``. For a list of all the\n        conjugacy classes of the group, use the conjugacy_classes() method.\n\n        In a permutation group, each conjugacy class corresponds to a particular\n        `cycle structure': for example, in ``S_3``, the conjugacy classes are:\n\n            * the identity class, ``{()}``\n            * all transpositions, ``{(1 2), (1 3), (2 3)}``\n            * all 3-cycles, ``{(1 2 3), (1 3 2)}``\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, SymmetricGroup\n        >>> S3 = SymmetricGroup(3)\n        >>> S3.conjugacy_class(Permutation(0, 1, 2))\n        {(0 1 2), (0 2 1)}\n\n        Notes\n        =====\n\n        This procedure computes the conjugacy class directly by finding the\n        orbit of the element under conjugation in G. This algorithm is only\n        feasible for permutation groups of relatively small order, but is like\n        the orbit() function itself in that respect.\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "conjugacy_classes",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.conjugacy_classes",
    "type": "method",
    "description": "Return the conjugacy classes of the group.\n\n        Explanation\n        ===========\n\n        As described in the documentation for the .conjugacy_class() function,\n        conjugacy is an equivalence relation on a group G which partitions the\n        set of elements. This method returns a list of all these conjugacy\n        classes of G.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import SymmetricGroup\n        >>> SymmetricGroup(3).conjugacy_classes()\n        [{(2)}, {(0 1 2), (0 2 1)}, {(0 2), (1 2), (2)(0 1)}]\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.contains",
    "type": "method",
    "description": "Test if permutation ``g`` belong to self, ``G``.\n\n        Explanation\n        ===========\n\n        If ``g`` is an element of ``G`` it can be written as a product\n        of factors drawn from the cosets of ``G``'s stabilizers. To see\n        if ``g`` is one of the actual generators defining the group use\n        ``G.has(g)``.\n\n        If ``strict`` is not ``True``, ``g`` will be resized, if necessary,\n        to match the size of permutations in ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n\n        >>> a = Permutation(1, 2)\n        >>> b = Permutation(2, 3, 1)\n        >>> G = PermutationGroup(a, b, degree=5)\n        >>> G.contains(G[0]) # trivial check\n        True\n        >>> elem = Permutation([[2, 3]], size=5)\n        >>> G.contains(elem)\n        True\n        >>> G.contains(Permutation(4)(0, 1, 2, 3))\n        False\n\n        If strict is False, a permutation will be resized, if\n        necessary:\n\n        >>> H = PermutationGroup(Permutation(5))\n        >>> H.contains(Permutation(3))\n        False\n        >>> H.contains(Permutation(3), strict=False)\n        True\n\n        To test if a given permutation is present in the group:\n\n        >>> elem in G.generators\n        False\n        >>> G.has(elem)\n        False\n\n        See Also\n        ========\n\n        coset_factor, sympy.core.basic.Basic.has, __contains__\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "coset_factor",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.coset_factor",
    "type": "method",
    "description": "Return ``G``'s (self's) coset factorization of ``g``\n\n        Explanation\n        ===========\n\n        If ``g`` is an element of ``G`` then it can be written as the product\n        of permutations drawn from the Schreier-Sims coset decomposition,\n\n        The permutations returned in ``f`` are those for which\n        the product gives ``g``: ``g = f[n]*...f[1]*f[0]`` where ``n = len(B)``\n        and ``B = G.base``. f[i] is one of the permutations in\n        ``self._basic_orbits[i]``.\n\n        If factor_index==True,\n        returns a tuple ``[b[0],..,b[n]]``, where ``b[i]``\n        belongs to ``self._basic_orbits[i]``\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)\n        >>> b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)\n        >>> G = PermutationGroup([a, b])\n\n        Define g:\n\n        >>> g = Permutation(7)(1, 2, 4)(3, 6, 5)\n\n        Confirm that it is an element of G:\n\n        >>> G.contains(g)\n        True\n\n        Thus, it can be written as a product of factors (up to\n        3) drawn from u. See below that a factor from u1 and u2\n        and the Identity permutation have been used:\n\n        >>> f = G.coset_factor(g)\n        >>> f[2]*f[1]*f[0] == g\n        True\n        >>> f1 = G.coset_factor(g, True); f1\n        [0, 4, 4]\n        >>> tr = G.basic_transversals\n        >>> f[0] == tr[0][f1[0]]\n        True\n\n        If g is not an element of G then [] is returned:\n\n        >>> c = Permutation(5, 6, 7)\n        >>> G.coset_factor(c)\n        []\n\n        See Also\n        ========\n\n        sympy.combinatorics.util._strip\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "coset_rank",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.coset_rank",
    "type": "method",
    "description": "rank using Schreier-Sims representation.\n\n        Explanation\n        ===========\n\n        The coset rank of ``g`` is the ordering number in which\n        it appears in the lexicographic listing according to the\n        coset decomposition\n\n        The ordering is the same as in G.generate(method='coset').\n        If ``g`` does not belong to the group it returns None.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)\n        >>> b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)\n        >>> G = PermutationGroup([a, b])\n        >>> c = Permutation(7)(2, 4)(3, 5)\n        >>> G.coset_rank(c)\n        16\n        >>> G.coset_unrank(16)\n        (7)(2 4)(3 5)\n\n        See Also\n        ========\n\n        coset_factor\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "coset_table",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.coset_table",
    "type": "method",
    "description": "Return the standardised (right) coset table of self in H as\n        a list of lists.\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "coset_transversal",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.coset_transversal",
    "type": "method",
    "description": "Return a transversal of the right cosets of self by its subgroup H\n        using the second method described in [1], Subsection 4.6.7\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "coset_unrank",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.coset_unrank",
    "type": "method",
    "description": "unrank using Schreier-Sims representation\n\n        coset_unrank is the inverse operation of coset_rank\n        if 0 <= rank < order; otherwise it returns None.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "degree",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.degree",
    "type": "property",
    "description": "Returns the size of the permutations in the group.\n\n        Explanation\n        ===========\n\n        The number of permutations comprising the group is given by\n        ``len(group)``; the number of permutations that can be generated\n        by the group is given by ``group.order()``.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([1, 0, 2])\n        >>> G = PermutationGroup([a])\n        >>> G.degree\n        3\n        >>> len(G)\n        1\n        >>> G.order()\n        2\n        >>> list(G.generate())\n        [(2), (2)(0 1)]\n\n        See Also\n        ========\n\n        order\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "derived_series",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.derived_series",
    "type": "method",
    "description": "Return the derived series for the group.\n\n        Explanation\n        ===========\n\n        The derived series for a group `G` is defined as\n        `G = G_0 > G_1 > G_2 > \\ldots` where `G_i = [G_{i-1}, G_{i-1}]`,\n        i.e. `G_i` is the derived subgroup of `G_{i-1}`, for\n        `i\\in\\mathbb{N}`. When we have `G_k = G_{k-1}` for some\n        `k\\in\\mathbb{N}`, the series terminates.\n\n        Returns\n        =======\n\n        A list of permutation groups containing the members of the derived\n        series in the order `G = G_0, G_1, G_2, \\ldots`.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n        ... AlternatingGroup, DihedralGroup)\n        >>> A = AlternatingGroup(5)\n        >>> len(A.derived_series())\n        1\n        >>> S = SymmetricGroup(4)\n        >>> len(S.derived_series())\n        4\n        >>> S.derived_series()[1].is_subgroup(AlternatingGroup(4))\n        True\n        >>> S.derived_series()[2].is_subgroup(DihedralGroup(2))\n        True\n\n        See Also\n        ========\n\n        derived_subgroup\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "derived_subgroup",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup",
    "type": "method",
    "description": "Compute the derived subgroup.\n\n        Explanation\n        ===========\n\n        The derived subgroup, or commutator subgroup is the subgroup generated\n        by all commutators `[g, h] = hgh^{-1}g^{-1}` for `g, h\\in G` ; it is\n        equal to the normal closure of the set of commutators of the generators\n        ([1], p.28, [11]).\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([1, 0, 2, 4, 3])\n        >>> b = Permutation([0, 1, 3, 2, 4])\n        >>> G = PermutationGroup([a, b])\n        >>> C = G.derived_subgroup()\n        >>> list(C.generate(af=True))\n        [[0, 1, 2, 3, 4], [0, 1, 3, 4, 2], [0, 1, 4, 2, 3]]\n\n        See Also\n        ========\n\n        derived_series\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "elements",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.elements",
    "type": "property",
    "description": "Returns all the elements of the permutation group as a list\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> p = PermutationGroup(Permutation(1, 3), Permutation(1, 2))\n        >>> p.elements\n        [(3), (3)(1 2), (1 3), (2 3), (1 2 3), (1 3 2)]\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "equals",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.equals",
    "type": "method",
    "description": "Return ``True`` if PermutationGroup generated by elements in the\n        group are same i.e they represent the same PermutationGroup.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> p = Permutation(0, 1, 2, 3, 4, 5)\n        >>> G = PermutationGroup([p, p**2])\n        >>> H = PermutationGroup([p**2, p])\n        >>> G.generators == H.generators\n        False\n        >>> G.equals(H)\n        True\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "generate",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.generate",
    "type": "method",
    "description": "Return iterator to generate the elements of the group.\n\n        Explanation\n        ===========\n\n        Iteration is done with one of these methods::\n\n          method='coset'  using the Schreier-Sims coset representation\n          method='dimino' using the Dimino method\n\n        If ``af = True`` it yields the array form of the permutations\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import PermutationGroup\n        >>> from sympy.combinatorics.polyhedron import tetrahedron\n\n        The permutation group given in the tetrahedron object is also\n        true groups:\n\n        >>> G = tetrahedron.pgroup\n        >>> G.is_group\n        True\n\n        Also the group generated by the permutations in the tetrahedron\n        pgroup -- even the first two -- is a proper group:\n\n        >>> H = PermutationGroup(G[0], G[1])\n        >>> J = PermutationGroup(list(H.generate())); J\n        PermutationGroup([\n            (0 1)(2 3),\n            (1 2 3),\n            (1 3 2),\n            (0 3 1),\n            (0 2 3),\n            (0 3)(1 2),\n            (0 1 3),\n            (3)(0 2 1),\n            (0 3 2),\n            (3)(0 1 2),\n            (0 2)(1 3)])\n        >>> _.is_group\n        True\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "generate_dimino",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.generate_dimino",
    "type": "method",
    "description": "Yield group elements using Dimino's algorithm.\n\n        If ``af == True`` it yields the array form of the permutations.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([0, 2, 1, 3])\n        >>> b = Permutation([0, 2, 3, 1])\n        >>> g = PermutationGroup([a, b])\n        >>> list(g.generate_dimino(af=True))\n        [[0, 1, 2, 3], [0, 2, 1, 3], [0, 2, 3, 1],\n         [0, 1, 3, 2], [0, 3, 2, 1], [0, 3, 1, 2]]\n\n        References\n        ==========\n\n        .. [1] The Implementation of Various Algorithms for Permutation Groups in\n               the Computer Algebra System: AXIOM, N.J. Doye, M.Sc. Thesis\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "generate_schreier_sims",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.generate_schreier_sims",
    "type": "method",
    "description": "Yield group elements using the Schreier-Sims representation\n        in coset_rank order\n\n        If ``af = True`` it yields the array form of the permutations\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([0, 2, 1, 3])\n        >>> b = Permutation([0, 2, 3, 1])\n        >>> g = PermutationGroup([a, b])\n        >>> list(g.generate_schreier_sims(af=True))\n        [[0, 1, 2, 3], [0, 2, 1, 3], [0, 3, 2, 1],\n         [0, 1, 3, 2], [0, 2, 3, 1], [0, 3, 1, 2]]\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "generator_product",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.generator_product",
    "type": "method",
    "description": "\n        Return a list of strong generators `[s1, \\dots, sn]`\n        s.t `g = sn \\times \\dots \\times s1`. If ``original=True``, make the\n        list contain only the original group generators\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "generators",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.generators",
    "type": "property",
    "description": "Returns the generators of the group.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([0, 2, 1])\n        >>> b = Permutation([1, 0, 2])\n        >>> G = PermutationGroup([a, b])\n        >>> G.generators\n        [(1 2), (2)(0 1)]\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "identity",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.identity",
    "type": "property",
    "description": "\n        Return the identity element of the permutation group.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "index",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.index",
    "type": "method",
    "description": "\n        Returns the index of a permutation group.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation(1,2,3)\n        >>> b =Permutation(3)\n        >>> G = PermutationGroup([a])\n        >>> H = PermutationGroup([b])\n        >>> G.index(H)\n        3\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_abelian",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_abelian",
    "type": "property",
    "description": "Test if the group is Abelian.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([0, 2, 1])\n        >>> b = Permutation([1, 0, 2])\n        >>> G = PermutationGroup([a, b])\n        >>> G.is_abelian\n        False\n        >>> a = Permutation([0, 2, 1])\n        >>> G = PermutationGroup([a])\n        >>> G.is_abelian\n        True\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_alt_sym",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym",
    "type": "method",
    "description": "Monte Carlo test for the symmetric/alternating group for degrees\n        >= 8.\n\n        Explanation\n        ===========\n\n        More specifically, it is one-sided Monte Carlo with the\n        answer True (i.e., G is symmetric/alternating) guaranteed to be\n        correct, and the answer False being incorrect with probability eps.\n\n        For degree < 8, the order of the group is checked so the test\n        is deterministic.\n\n        Notes\n        =====\n\n        The algorithm itself uses some nontrivial results from group theory and\n        number theory:\n        1) If a transitive group ``G`` of degree ``n`` contains an element\n        with a cycle of length ``n/2 < p < n-2`` for ``p`` a prime, ``G`` is the\n        symmetric or alternating group ([1], pp. 81-82)\n        2) The proportion of elements in the symmetric/alternating group having\n        the property described in 1) is approximately `\\log(2)/\\log(n)`\n        ([1], p.82; [2], pp. 226-227).\n        The helper function ``_check_cycles_alt_sym`` is used to\n        go over the cycles in a permutation and look for ones satisfying 1).\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> D = DihedralGroup(10)\n        >>> D.is_alt_sym()\n        False\n\n        See Also\n        ========\n\n        _check_cycles_alt_sym\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_alternating",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_alternating",
    "type": "property",
    "description": "Return ``True`` if the group is alternating.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import AlternatingGroup\n        >>> g = AlternatingGroup(5)\n        >>> g.is_alternating\n        True\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> g = PermutationGroup(\n        ...     Permutation(0, 1, 2, 3, 4),\n        ...     Permutation(2, 3, 4))\n        >>> g.is_alternating\n        True\n\n        Notes\n        =====\n\n        This uses a naive test involving the computation of the full\n        group order.\n        If you need more quicker taxonomy for large groups, you can use\n        :meth:`PermutationGroup.is_alt_sym`.\n        However, :meth:`PermutationGroup.is_alt_sym` may not be accurate\n        and is not able to distinguish between an alternating group and\n        a symmetric group.\n\n        See Also\n        ========\n\n        is_alt_sym\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_cyclic",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_cyclic",
    "type": "property",
    "description": "\n        Return ``True`` if the group is Cyclic.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import AbelianGroup\n        >>> G = AbelianGroup(3, 4)\n        >>> G.is_cyclic\n        True\n        >>> G = AbelianGroup(4, 4)\n        >>> G.is_cyclic\n        False\n\n        Notes\n        =====\n\n        If the order of a group $n$ can be factored into the distinct\n        primes $p_1, p_2, \\dots , p_s$ and if\n\n        .. math::\n            \\forall i, j \\in \\{1, 2, \\dots, s \\}:\n            p_i \\not \\equiv 1 \\pmod {p_j}\n\n        holds true, there is only one group of the order $n$ which\n        is a cyclic group [1]_. This is a generalization of the lemma\n        that the group of order $15, 35, \\dots$ are cyclic.\n\n        And also, these additional lemmas can be used to test if a\n        group is cyclic if the order of the group is already found.\n\n        - If the group is abelian and the order of the group is\n          square-free, the group is cyclic.\n        - If the order of the group is less than $6$ and is not $4$, the\n          group is cyclic.\n        - If the order of the group is prime, the group is cyclic.\n\n        References\n        ==========\n\n        .. [1] 1978: John S. Rose: A Course on Group Theory,\n            Introduction to Finite Group Theory: 1.4\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_dihedral",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_dihedral",
    "type": "property",
    "description": "\n        Return ``True`` if the group is dihedral.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.perm_groups import PermutationGroup\n        >>> from sympy.combinatorics.permutations import Permutation\n        >>> from sympy.combinatorics.named_groups import SymmetricGroup, CyclicGroup\n        >>> G = PermutationGroup(Permutation(1, 6)(2, 5)(3, 4), Permutation(0, 1, 2, 3, 4, 5, 6))\n        >>> G.is_dihedral\n        True\n        >>> G = SymmetricGroup(3)\n        >>> G.is_dihedral\n        True\n        >>> G = CyclicGroup(6)\n        >>> G.is_dihedral\n        False\n\n        References\n        ==========\n\n        .. [Di1] https://math.stackexchange.com/questions/827230/given-a-cayley-table-is-there-an-algorithm-to-determine-if-it-is-a-dihedral-gro/827273#827273\n        .. [Di2] https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral.pdf\n        .. [Di3] https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral2.pdf\n        .. [Di4] https://en.wikipedia.org/wiki/Dihedral_group\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_elementary",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_elementary",
    "type": "method",
    "description": "Return ``True`` if the group is elementary abelian. An elementary\n        abelian group is a finite abelian group, where every nontrivial\n        element has order `p`, where `p` is a prime.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([0, 2, 1])\n        >>> G = PermutationGroup([a])\n        >>> G.is_elementary(2)\n        True\n        >>> a = Permutation([0, 2, 1, 3])\n        >>> b = Permutation([3, 1, 2, 0])\n        >>> G = PermutationGroup([a, b])\n        >>> G.is_elementary(2)\n        True\n        >>> G.is_elementary(3)\n        False\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_nilpotent",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_nilpotent",
    "type": "property",
    "description": "Test if the group is nilpotent.\n\n        Explanation\n        ===========\n\n        A group `G` is nilpotent if it has a central series of finite length.\n        Alternatively, `G` is nilpotent if its lower central series terminates\n        with the trivial group. Every nilpotent group is also solvable\n        ([1], p.29, [12]).\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n        ... CyclicGroup)\n        >>> C = CyclicGroup(6)\n        >>> C.is_nilpotent\n        True\n        >>> S = SymmetricGroup(5)\n        >>> S.is_nilpotent\n        False\n\n        See Also\n        ========\n\n        lower_central_series, is_solvable\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_normal",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_normal",
    "type": "method",
    "description": "Test if ``G=self`` is a normal subgroup of ``gr``.\n\n        Explanation\n        ===========\n\n        G is normal in gr if\n        for each g2 in G, g1 in gr, ``g = g1*g2*g1**-1`` belongs to G\n        It is sufficient to check this for each g1 in gr.generators and\n        g2 in G.generators.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([1, 2, 0])\n        >>> b = Permutation([1, 0, 2])\n        >>> G = PermutationGroup([a, b])\n        >>> G1 = PermutationGroup([a, Permutation([2, 0, 1])])\n        >>> G1.is_normal(G)\n        True\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_perfect",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_perfect",
    "type": "property",
    "description": "Return ``True`` if the group is perfect.\n        A group is perfect if it equals to its derived subgroup.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation(1,2,3)(4,5)\n        >>> b = Permutation(1,2,3,4,5)\n        >>> G = PermutationGroup([a, b])\n        >>> G.is_perfect\n        False\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_polycyclic",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_polycyclic",
    "type": "property",
    "description": "Return ``True`` if a group is polycyclic. A group is polycyclic if\n        it has a subnormal series with cyclic factors. For finite groups,\n        this is the same as if the group is solvable.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([0, 2, 1, 3])\n        >>> b = Permutation([2, 0, 1, 3])\n        >>> G = PermutationGroup([a, b])\n        >>> G.is_polycyclic\n        True\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_primitive",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_primitive",
    "type": "method",
    "description": "Test if a group is primitive.\n\n        Explanation\n        ===========\n\n        A permutation group ``G`` acting on a set ``S`` is called primitive if\n        ``S`` contains no nontrivial block under the action of ``G``\n        (a block is nontrivial if its cardinality is more than ``1``).\n\n        Notes\n        =====\n\n        The algorithm is described in [1], p.83, and uses the function\n        minimal_block to search for blocks of the form `\\{0, k\\}` for ``k``\n        ranging over representatives for the orbits of `G_0`, the stabilizer of\n        ``0``. This algorithm has complexity `O(n^2)` where ``n`` is the degree\n        of the group, and will perform badly if `G_0` is small.\n\n        There are two implementations offered: one finds `G_0`\n        deterministically using the function ``stabilizer``, and the other\n        (default) produces random elements of `G_0` using ``random_stab``,\n        hoping that they generate a subgroup of `G_0` with not too many more\n        orbits than `G_0` (this is suggested in [1], p.83). Behavior is changed\n        by the ``randomized`` flag.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> D = DihedralGroup(10)\n        >>> D.is_primitive()\n        False\n\n        See Also\n        ========\n\n        minimal_block, random_stab\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_solvable",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_solvable",
    "type": "property",
    "description": "Test if the group is solvable.\n\n        ``G`` is solvable if its derived series terminates with the trivial\n        group ([1], p.29).\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import SymmetricGroup\n        >>> S = SymmetricGroup(3)\n        >>> S.is_solvable\n        True\n\n        See Also\n        ========\n\n        is_nilpotent, derived_series\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_subgroup",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_subgroup",
    "type": "method",
    "description": "Return ``True`` if all elements of ``self`` belong to ``G``.\n\n        If ``strict`` is ``False`` then if ``self``'s degree is smaller\n        than ``G``'s, the elements will be resized to have the same degree.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> from sympy.combinatorics import SymmetricGroup, CyclicGroup\n\n        Testing is strict by default: the degree of each group must be the\n        same:\n\n        >>> p = Permutation(0, 1, 2, 3, 4, 5)\n        >>> G1 = PermutationGroup([Permutation(0, 1, 2), Permutation(0, 1)])\n        >>> G2 = PermutationGroup([Permutation(0, 2), Permutation(0, 1, 2)])\n        >>> G3 = PermutationGroup([p, p**2])\n        >>> assert G1.order() == G2.order() == G3.order() == 6\n        >>> G1.is_subgroup(G2)\n        True\n        >>> G1.is_subgroup(G3)\n        False\n        >>> G3.is_subgroup(PermutationGroup(G3[1]))\n        False\n        >>> G3.is_subgroup(PermutationGroup(G3[0]))\n        True\n\n        To ignore the size, set ``strict`` to ``False``:\n\n        >>> S3 = SymmetricGroup(3)\n        >>> S5 = SymmetricGroup(5)\n        >>> S3.is_subgroup(S5, strict=False)\n        True\n        >>> C7 = CyclicGroup(7)\n        >>> G = S5*C7\n        >>> S5.is_subgroup(G, False)\n        True\n        >>> C7.is_subgroup(G, 0)\n        False\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_symmetric",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_symmetric",
    "type": "property",
    "description": "Return ``True`` if the group is symmetric.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import SymmetricGroup\n        >>> g = SymmetricGroup(5)\n        >>> g.is_symmetric\n        True\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> g = PermutationGroup(\n        ...     Permutation(0, 1, 2, 3, 4),\n        ...     Permutation(2, 3))\n        >>> g.is_symmetric\n        True\n\n        Notes\n        =====\n\n        This uses a naive test involving the computation of the full\n        group order.\n        If you need more quicker taxonomy for large groups, you can use\n        :meth:`PermutationGroup.is_alt_sym`.\n        However, :meth:`PermutationGroup.is_alt_sym` may not be accurate\n        and is not able to distinguish between an alternating group and\n        a symmetric group.\n\n        See Also\n        ========\n\n        is_alt_sym\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_transitive",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_transitive",
    "type": "method",
    "description": "Test if the group is transitive.\n\n        Explanation\n        ===========\n\n        A group is transitive if it has a single orbit.\n\n        If ``strict`` is ``False`` the group is transitive if it has\n        a single orbit of length different from 1.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([0, 2, 1, 3])\n        >>> b = Permutation([2, 0, 1, 3])\n        >>> G1 = PermutationGroup([a, b])\n        >>> G1.is_transitive()\n        False\n        >>> G1.is_transitive(strict=False)\n        True\n        >>> c = Permutation([2, 3, 0, 1])\n        >>> G2 = PermutationGroup([a, c])\n        >>> G2.is_transitive()\n        True\n        >>> d = Permutation([1, 0, 2, 3])\n        >>> e = Permutation([0, 1, 3, 2])\n        >>> G3 = PermutationGroup([d, e])\n        >>> G3.is_transitive() or G3.is_transitive(strict=False)\n        False\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "is_trivial",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.is_trivial",
    "type": "property",
    "description": "Test if the group is the trivial group.\n\n        This is true if the group contains only the identity permutation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> G = PermutationGroup([Permutation([0, 1, 2])])\n        >>> G.is_trivial\n        True\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "lower_central_series",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.lower_central_series",
    "type": "method",
    "description": "Return the lower central series for the group.\n\n        The lower central series for a group `G` is the series\n        `G = G_0 > G_1 > G_2 > \\ldots` where\n        `G_k = [G, G_{k-1}]`, i.e. every term after the first is equal to the\n        commutator of `G` and the previous term in `G1` ([1], p.29).\n\n        Returns\n        =======\n\n        A list of permutation groups in the order `G = G_0, G_1, G_2, \\ldots`\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import (AlternatingGroup,\n        ... DihedralGroup)\n        >>> A = AlternatingGroup(4)\n        >>> len(A.lower_central_series())\n        2\n        >>> A.lower_central_series()[1].is_subgroup(DihedralGroup(2))\n        True\n\n        See Also\n        ========\n\n        commutator, derived_series\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "make_perm",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.make_perm",
    "type": "method",
    "description": "\n        Multiply ``n`` randomly selected permutations from\n        pgroup together, starting with the identity\n        permutation. If ``n`` is a list of integers, those\n        integers will be used to select the permutations and they\n        will be applied in L to R order: make_perm((A, B, C)) will\n        give CBA(I) where I is the identity permutation.\n\n        ``seed`` is used to set the seed for the random selection\n        of permutations from pgroup. If this is a list of integers,\n        the corresponding permutations from pgroup will be selected\n        in the order give. This is mainly used for testing purposes.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a, b = [Permutation([1, 0, 3, 2]), Permutation([1, 3, 0, 2])]\n        >>> G = PermutationGroup([a, b])\n        >>> G.make_perm(1, [0])\n        (0 1)(2 3)\n        >>> G.make_perm(3, [0, 1, 0])\n        (0 2 3 1)\n        >>> G.make_perm([0, 1, 0])\n        (0 2 3 1)\n\n        See Also\n        ========\n\n        random\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "max_div",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.max_div",
    "type": "property",
    "description": "Maximum proper divisor of the degree of a permutation group.\n\n        Explanation\n        ===========\n\n        Obviously, this is the degree divided by its minimal proper divisor\n        (larger than ``1``, if one exists). As it is guaranteed to be prime,\n        the ``sieve`` from ``sympy.ntheory`` is used.\n        This function is also used as an optimization tool for the functions\n        ``minimal_block`` and ``_union_find_merge``.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> G = PermutationGroup([Permutation([0, 2, 1, 3])])\n        >>> G.max_div\n        2\n\n        See Also\n        ========\n\n        minimal_block, _union_find_merge\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "minimal_block",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.minimal_block",
    "type": "method",
    "description": "For a transitive group, finds the block system generated by\n        ``points``.\n\n        Explanation\n        ===========\n\n        If a group ``G`` acts on a set ``S``, a nonempty subset ``B`` of ``S``\n        is called a block under the action of ``G`` if for all ``g`` in ``G``\n        we have ``gB = B`` (``g`` fixes ``B``) or ``gB`` and ``B`` have no\n        common points (``g`` moves ``B`` entirely). ([1], p.23; [6]).\n\n        The distinct translates ``gB`` of a block ``B`` for ``g`` in ``G``\n        partition the set ``S`` and this set of translates is known as a block\n        system. Moreover, we obviously have that all blocks in the partition\n        have the same size, hence the block size divides ``|S|`` ([1], p.23).\n        A ``G``-congruence is an equivalence relation ``~`` on the set ``S``\n        such that ``a ~ b`` implies ``g(a) ~ g(b)`` for all ``g`` in ``G``.\n        For a transitive group, the equivalence classes of a ``G``-congruence\n        and the blocks of a block system are the same thing ([1], p.23).\n\n        The algorithm below checks the group for transitivity, and then finds\n        the ``G``-congruence generated by the pairs ``(p_0, p_1), (p_0, p_2),\n        ..., (p_0,p_{k-1})`` which is the same as finding the maximal block\n        system (i.e., the one with minimum block size) such that\n        ``p_0, ..., p_{k-1}`` are in the same block ([1], p.83).\n\n        It is an implementation of Atkinson's algorithm, as suggested in [1],\n        and manipulates an equivalence relation on the set ``S`` using a\n        union-find data structure. The running time is just above\n        `O(|points||S|)`. ([1], pp. 83-87; [7]).\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> D = DihedralGroup(10)\n        >>> D.minimal_block([0, 5])\n        [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n        >>> D.minimal_block([0, 1])\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n        See Also\n        ========\n\n        _union_find_rep, _union_find_merge, is_transitive, is_primitive\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "minimal_blocks",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.minimal_blocks",
    "type": "method",
    "description": "\n        For a transitive group, return the list of all minimal\n        block systems. If a group is intransitive, return `False`.\n\n        Examples\n        ========\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> DihedralGroup(6).minimal_blocks()\n        [[0, 1, 0, 1, 0, 1], [0, 1, 2, 0, 1, 2]]\n        >>> G = PermutationGroup(Permutation(1,2,5))\n        >>> G.minimal_blocks()\n        False\n\n        See Also\n        ========\n\n        minimal_block, is_transitive, is_primitive\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "normal_closure",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.normal_closure",
    "type": "method",
    "description": "Return the normal closure of a subgroup/set of permutations.\n\n        Explanation\n        ===========\n\n        If ``S`` is a subset of a group ``G``, the normal closure of ``A`` in ``G``\n        is defined as the intersection of all normal subgroups of ``G`` that\n        contain ``A`` ([1], p.14). Alternatively, it is the group generated by\n        the conjugates ``x^{-1}yx`` for ``x`` a generator of ``G`` and ``y`` a\n        generator of the subgroup ``\\left\\langle S\\right\\rangle`` generated by\n        ``S`` (for some chosen generating set for ``\\left\\langle S\\right\\rangle``)\n        ([1], p.73).\n\n        Parameters\n        ==========\n\n        other\n            a subgroup/list of permutations/single permutation\n        k\n            an implementation-specific parameter that determines the number\n            of conjugates that are adjoined to ``other`` at once\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n        ... CyclicGroup, AlternatingGroup)\n        >>> S = SymmetricGroup(5)\n        >>> C = CyclicGroup(5)\n        >>> G = S.normal_closure(C)\n        >>> G.order()\n        60\n        >>> G.is_subgroup(AlternatingGroup(5))\n        True\n\n        See Also\n        ========\n\n        commutator, derived_subgroup, random_pr\n\n        Notes\n        =====\n\n        The algorithm is described in [1], pp. 73-74; it makes use of the\n        generation of random elements for permutation groups by the product\n        replacement algorithm.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "orbit",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.orbit",
    "type": "method",
    "description": "Compute the orbit of alpha `\\{g(\\alpha) | g \\in G\\}` as a set.\n\n        Explanation\n        ===========\n\n        The time complexity of the algorithm used here is `O(|Orb|*r)` where\n        `|Orb|` is the size of the orbit and ``r`` is the number of generators of\n        the group. For a more detailed analysis, see [1], p.78, [2], pp. 19-21.\n        Here alpha can be a single point, or a list of points.\n\n        If alpha is a single point, the ordinary orbit is computed.\n        if alpha is a list of points, there are three available options:\n\n        'union' - computes the union of the orbits of the points in the list\n        'tuples' - computes the orbit of the list interpreted as an ordered\n        tuple under the group action ( i.e., g((1,2,3)) = (g(1), g(2), g(3)) )\n        'sets' - computes the orbit of the list interpreted as a sets\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([1, 2, 0, 4, 5, 6, 3])\n        >>> G = PermutationGroup([a])\n        >>> G.orbit(0)\n        {0, 1, 2}\n        >>> G.orbit([0, 4], 'union')\n        {0, 1, 2, 3, 4, 5, 6}\n\n        See Also\n        ========\n\n        orbit_transversal\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "orbit_rep",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.orbit_rep",
    "type": "method",
    "description": "Return a group element which sends ``alpha`` to ``beta``.\n\n        Explanation\n        ===========\n\n        If ``beta`` is not in the orbit of ``alpha``, the function returns\n        ``False``. This implementation makes use of the schreier vector.\n        For a proof of correctness, see [1], p.80\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import AlternatingGroup\n        >>> G = AlternatingGroup(5)\n        >>> G.orbit_rep(0, 4)\n        (0 4 1 2 3)\n\n        See Also\n        ========\n\n        schreier_vector\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "orbit_transversal",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.orbit_transversal",
    "type": "method",
    "description": "Computes a transversal for the orbit of ``alpha`` as a set.\n\n        Explanation\n        ===========\n\n        For a permutation group `G`, a transversal for the orbit\n        `Orb = \\{g(\\alpha) | g \\in G\\}` is a set\n        `\\{g_\\beta | g_\\beta(\\alpha) = \\beta\\}` for `\\beta \\in Orb`.\n        Note that there may be more than one possible transversal.\n        If ``pairs`` is set to ``True``, it returns the list of pairs\n        `(\\beta, g_\\beta)`. For a proof of correctness, see [1], p.79\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> G = DihedralGroup(6)\n        >>> G.orbit_transversal(0)\n        [(5), (0 1 2 3 4 5), (0 5)(1 4)(2 3), (0 2 4)(1 3 5), (5)(0 4)(1 3), (0 3)(1 4)(2 5)]\n\n        See Also\n        ========\n\n        orbit\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "orbits",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.orbits",
    "type": "method",
    "description": "Return the orbits of ``self``, ordered according to lowest element\n        in each orbit.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation(1, 5)(2, 3)(4, 0, 6)\n        >>> b = Permutation(1, 5)(3, 4)(2, 6, 0)\n        >>> G = PermutationGroup([a, b])\n        >>> G.orbits()\n        [{0, 2, 3, 4, 6}, {1, 5}]\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "order",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.order",
    "type": "method",
    "description": "Return the order of the group: the number of permutations that\n        can be generated from elements of the group.\n\n        The number of permutations comprising the group is given by\n        ``len(group)``; the length of each permutation in the group is\n        given by ``group.size``.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n\n        >>> a = Permutation([1, 0, 2])\n        >>> G = PermutationGroup([a])\n        >>> G.degree\n        3\n        >>> len(G)\n        1\n        >>> G.order()\n        2\n        >>> list(G.generate())\n        [(2), (2)(0 1)]\n\n        >>> a = Permutation([0, 2, 1])\n        >>> b = Permutation([1, 0, 2])\n        >>> G = PermutationGroup([a, b])\n        >>> G.order()\n        6\n\n        See Also\n        ========\n\n        degree\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "pointwise_stabilizer",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.pointwise_stabilizer",
    "type": "method",
    "description": "Return the pointwise stabilizer for a set of points.\n\n        Explanation\n        ===========\n\n        For a permutation group `G` and a set of points\n        `\\{p_1, p_2,\\ldots, p_k\\}`, the pointwise stabilizer of\n        `p_1, p_2, \\ldots, p_k` is defined as\n        `G_{p_1,\\ldots, p_k} =\n        \\{g\\in G | g(p_i) = p_i \\forall i\\in\\{1, 2,\\ldots,k\\}\\}` ([1],p20).\n        It is a subgroup of `G`.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import SymmetricGroup\n        >>> S = SymmetricGroup(7)\n        >>> Stab = S.pointwise_stabilizer([2, 3, 5])\n        >>> Stab.is_subgroup(S.stabilizer(2).stabilizer(3).stabilizer(5))\n        True\n\n        See Also\n        ========\n\n        stabilizer, schreier_sims_incremental\n\n        Notes\n        =====\n\n        When incremental == True,\n        rather than the obvious implementation using successive calls to\n        ``.stabilizer()``, this uses the incremental Schreier-Sims algorithm\n        to obtain a base with starting segment - the given points.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "polycyclic_group",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.polycyclic_group",
    "type": "method",
    "description": "\n        Return the PolycyclicGroup instance with below parameters:\n\n        Explanation\n        ===========\n\n        * pc_sequence : Polycyclic sequence is formed by collecting all\n          the missing generators between the adjacent groups in the\n          derived series of given permutation group.\n\n        * pc_series : Polycyclic series is formed by adding all the missing\n          generators of ``der[i+1]`` in ``der[i]``, where ``der`` represents\n          the derived series.\n\n        * relative_order : A list, computed by the ratio of adjacent groups in\n          pc_series.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "presentation",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.presentation",
    "type": "method",
    "description": "\n        Return an `FpGroup` presentation of the group.\n\n        The algorithm is described in [1], Chapter 6.1.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "random",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.random",
    "type": "method",
    "description": "Return a random group element",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "random_pr",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.random_pr",
    "type": "method",
    "description": "Return a random group element using product replacement.\n\n        Explanation\n        ===========\n\n        For the details of the product replacement algorithm, see\n        ``_random_pr_init`` In ``random_pr`` the actual 'product replacement'\n        is performed. Notice that if the attribute ``_random_gens``\n        is empty, it needs to be initialized by ``_random_pr_init``.\n\n        See Also\n        ========\n\n        _random_pr_init\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "random_stab",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.random_stab",
    "type": "method",
    "description": "Random element from the stabilizer of ``alpha``.\n\n        The schreier vector for ``alpha`` is an optional argument used\n        for speeding up repeated calls. The algorithm is described in [1], p.81\n\n        See Also\n        ========\n\n        random_pr, orbit_rep\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "schreier_sims",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims",
    "type": "method",
    "description": "Schreier-Sims algorithm.\n\n        Explanation\n        ===========\n\n        It computes the generators of the chain of stabilizers\n        `G > G_{b_1} > .. > G_{b1,..,b_r} > 1`\n        in which `G_{b_1,..,b_i}` stabilizes `b_1,..,b_i`,\n        and the corresponding ``s`` cosets.\n        An element of the group can be written as the product\n        `h_1*..*h_s`.\n\n        We use the incremental Schreier-Sims algorithm.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([0, 2, 1])\n        >>> b = Permutation([1, 0, 2])\n        >>> G = PermutationGroup([a, b])\n        >>> G.schreier_sims()\n        >>> G.basic_transversals\n        [{0: (2)(0 1), 1: (2), 2: (1 2)},\n         {0: (2), 2: (0 2)}]\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "schreier_sims_incremental",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_incremental",
    "type": "method",
    "description": "Extend a sequence of points and generating set to a base and strong\n        generating set.\n\n        Parameters\n        ==========\n\n        base\n            The sequence of points to be extended to a base. Optional\n            parameter with default value ``[]``.\n        gens\n            The generating set to be extended to a strong generating set\n            relative to the base obtained. Optional parameter with default\n            value ``self.generators``.\n\n        slp_dict\n            If `True`, return a dictionary `{g: gens}` for each strong\n            generator `g` where `gens` is a list of strong generators\n            coming before `g` in `strong_gens`, such that the product\n            of the elements of `gens` is equal to `g`.\n\n        Returns\n        =======\n\n        (base, strong_gens)\n            ``base`` is the base obtained, and ``strong_gens`` is the strong\n            generating set relative to it. The original parameters ``base``,\n            ``gens`` remain unchanged.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import AlternatingGroup\n        >>> from sympy.combinatorics.testutil import _verify_bsgs\n        >>> A = AlternatingGroup(7)\n        >>> base = [2, 3]\n        >>> seq = [2, 3]\n        >>> base, strong_gens = A.schreier_sims_incremental(base=seq)\n        >>> _verify_bsgs(A, base, strong_gens)\n        True\n        >>> base[:2]\n        [2, 3]\n\n        Notes\n        =====\n\n        This version of the Schreier-Sims algorithm runs in polynomial time.\n        There are certain assumptions in the implementation - if the trivial\n        group is provided, ``base`` and ``gens`` are returned immediately,\n        as any sequence of points is a base for the trivial group. If the\n        identity is present in the generators ``gens``, it is removed as\n        it is a redundant generator.\n        The implementation is described in [1], pp. 90-93.\n\n        See Also\n        ========\n\n        schreier_sims, schreier_sims_random\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "schreier_sims_random",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_random",
    "type": "method",
    "description": "Randomized Schreier-Sims algorithm.\n\n        Explanation\n        ===========\n\n        The randomized Schreier-Sims algorithm takes the sequence ``base``\n        and the generating set ``gens``, and extends ``base`` to a base, and\n        ``gens`` to a strong generating set relative to that base with\n        probability of a wrong answer at most `2^{-consec\\_succ}`,\n        provided the random generators are sufficiently random.\n\n        Parameters\n        ==========\n\n        base\n            The sequence to be extended to a base.\n        gens\n            The generating set to be extended to a strong generating set.\n        consec_succ\n            The parameter defining the probability of a wrong answer.\n        _random_prec\n            An internal parameter used for testing purposes.\n\n        Returns\n        =======\n\n        (base, strong_gens)\n            ``base`` is the base and ``strong_gens`` is the strong generating\n            set relative to it.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.testutil import _verify_bsgs\n        >>> from sympy.combinatorics.named_groups import SymmetricGroup\n        >>> S = SymmetricGroup(5)\n        >>> base, strong_gens = S.schreier_sims_random(consec_succ=5)\n        >>> _verify_bsgs(S, base, strong_gens) #doctest: +SKIP\n        True\n\n        Notes\n        =====\n\n        The algorithm is described in detail in [1], pp. 97-98. It extends\n        the orbits ``orbs`` and the permutation groups ``stabs`` to\n        basic orbits and basic stabilizers for the base and strong generating\n        set produced in the end.\n        The idea of the extension process\n        is to \"sift\" random group elements through the stabilizer chain\n        and amend the stabilizers/orbits along the way when a sift\n        is not successful.\n        The helper function ``_strip`` is used to attempt\n        to decompose a random group element according to the current\n        state of the stabilizer chain and report whether the element was\n        fully decomposed (successful sift) or not (unsuccessful sift). In\n        the latter case, the level at which the sift failed is reported and\n        used to amend ``stabs``, ``base``, ``gens`` and ``orbs`` accordingly.\n        The halting condition is for ``consec_succ`` consecutive successful\n        sifts to pass. This makes sure that the current ``base`` and ``gens``\n        form a BSGS with probability at least `1 - 1/\\text{consec\\_succ}`.\n\n        See Also\n        ========\n\n        schreier_sims\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "schreier_vector",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.schreier_vector",
    "type": "method",
    "description": "Computes the schreier vector for ``alpha``.\n\n        Explanation\n        ===========\n\n        The Schreier vector efficiently stores information\n        about the orbit of ``alpha``. It can later be used to quickly obtain\n        elements of the group that send ``alpha`` to a particular element\n        in the orbit. Notice that the Schreier vector depends on the order\n        in which the group generators are listed. For a definition, see [3].\n        Since list indices start from zero, we adopt the convention to use\n        \"None\" instead of 0 to signify that an element does not belong\n        to the orbit.\n        For the algorithm and its correctness, see [2], pp.78-80.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([2, 4, 6, 3, 1, 5, 0])\n        >>> b = Permutation([0, 1, 3, 5, 4, 6, 2])\n        >>> G = PermutationGroup([a, b])\n        >>> G.schreier_vector(0)\n        [-1, None, 0, 1, None, 1, 0]\n\n        See Also\n        ========\n\n        orbit\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "stabilizer",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.stabilizer",
    "type": "method",
    "description": "Return the stabilizer subgroup of ``alpha``.\n\n        Explanation\n        ===========\n\n        The stabilizer of `\\alpha` is the group `G_\\alpha =\n        \\{g \\in G | g(\\alpha) = \\alpha\\}`.\n        For a proof of correctness, see [1], p.79.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> G = DihedralGroup(6)\n        >>> G.stabilizer(5)\n        PermutationGroup([\n            (5)(0 4)(1 3)])\n\n        See Also\n        ========\n\n        orbit\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "strong_gens",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.strong_gens",
    "type": "property",
    "description": "Return a strong generating set from the Schreier-Sims algorithm.\n\n        Explanation\n        ===========\n\n        A generating set `S = \\{g_1, g_2, \\dots, g_t\\}` for a permutation group\n        `G` is a strong generating set relative to the sequence of points\n        (referred to as a \"base\") `(b_1, b_2, \\dots, b_k)` if, for\n        `1 \\leq i \\leq k` we have that the intersection of the pointwise\n        stabilizer `G^{(i+1)} := G_{b_1, b_2, \\dots, b_i}` with `S` generates\n        the pointwise stabilizer `G^{(i+1)}`. The concepts of a base and\n        strong generating set and their applications are discussed in depth\n        in [1], pp. 87-89 and [2], pp. 55-57.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> D = DihedralGroup(4)\n        >>> D.strong_gens\n        [(0 1 2 3), (0 3)(1 2), (1 3)]\n        >>> D.base\n        [0, 1]\n\n        See Also\n        ========\n\n        base, basic_transversals, basic_orbits, basic_stabilizers\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "strong_presentation",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.strong_presentation",
    "type": "method",
    "description": "\n        Return a strong finite presentation of group. The generators\n        of the returned group are in the same order as the strong\n        generators of group.\n\n        The algorithm is based on Sims' Verify algorithm described\n        in [1], Chapter 6.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> P = DihedralGroup(4)\n        >>> G = P.strong_presentation()\n        >>> P.order() == G.order()\n        True\n\n        See Also\n        ========\n\n        presentation, _verify\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "subgroup",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.subgroup",
    "type": "method",
    "description": "\n        Return the subgroup generated by `gens` which is a list of\n        elements of the group\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "subgroup_search",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.subgroup_search",
    "type": "method",
    "description": "Find the subgroup of all elements satisfying the property ``prop``.\n\n        Explanation\n        ===========\n\n        This is done by a depth-first search with respect to base images that\n        uses several tests to prune the search tree.\n\n        Parameters\n        ==========\n\n        prop\n            The property to be used. Has to be callable on group elements\n            and always return ``True`` or ``False``. It is assumed that\n            all group elements satisfying ``prop`` indeed form a subgroup.\n        base\n            A base for the supergroup.\n        strong_gens\n            A strong generating set for the supergroup.\n        tests\n            A list of callables of length equal to the length of ``base``.\n            These are used to rule out group elements by partial base images,\n            so that ``tests[l](g)`` returns False if the element ``g`` is known\n            not to satisfy prop base on where g sends the first ``l + 1`` base\n            points.\n        init_subgroup\n            if a subgroup of the sought group is\n            known in advance, it can be passed to the function as this\n            parameter.\n\n        Returns\n        =======\n\n        res\n            The subgroup of all elements satisfying ``prop``. The generating\n            set for this group is guaranteed to be a strong generating set\n            relative to the base ``base``.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n        ... AlternatingGroup)\n        >>> from sympy.combinatorics.testutil import _verify_bsgs\n        >>> S = SymmetricGroup(7)\n        >>> prop_even = lambda x: x.is_even\n        >>> base, strong_gens = S.schreier_sims_incremental()\n        >>> G = S.subgroup_search(prop_even, base=base, strong_gens=strong_gens)\n        >>> G.is_subgroup(AlternatingGroup(7))\n        True\n        >>> _verify_bsgs(G, base, G.generators)\n        True\n\n        Notes\n        =====\n\n        This function is extremely lengthy and complicated and will require\n        some careful attention. The implementation is described in\n        [1], pp. 114-117, and the comments for the code here follow the lines\n        of the pseudocode in the book for clarity.\n\n        The complexity is exponential in general, since the search process by\n        itself visits all members of the supergroup. However, there are a lot\n        of tests which are used to prune the search tree, and users can define\n        their own tests via the ``tests`` parameter, so in practice, and for\n        some computations, it's not terrible.\n\n        A crucial part in the procedure is the frequent base change performed\n        (this is line 11 in the pseudocode) in order to obtain a new basic\n        stabilizer. The book mentiones that this can be done by using\n        ``.baseswap(...)``, however the current implementation uses a more\n        straightforward way to find the next basic stabilizer - calling the\n        function ``.stabilizer(...)`` on the previous basic stabilizer.\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "sylow_subgroup",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.sylow_subgroup",
    "type": "method",
    "description": "\n        Return a p-Sylow subgroup of the group.\n\n        The algorithm is described in [1], Chapter 4, Section 7\n\n        Examples\n        ========\n        >>> from sympy.combinatorics.named_groups import DihedralGroup\n        >>> from sympy.combinatorics.named_groups import SymmetricGroup\n        >>> from sympy.combinatorics.named_groups import AlternatingGroup\n\n        >>> D = DihedralGroup(6)\n        >>> S = D.sylow_subgroup(2)\n        >>> S.order()\n        4\n        >>> G = SymmetricGroup(6)\n        >>> S = G.sylow_subgroup(5)\n        >>> S.order()\n        5\n\n        >>> G1 = AlternatingGroup(3)\n        >>> G2 = AlternatingGroup(5)\n        >>> G3 = AlternatingGroup(9)\n\n        >>> S1 = G1.sylow_subgroup(3)\n        >>> S2 = G2.sylow_subgroup(3)\n        >>> S3 = G3.sylow_subgroup(3)\n\n        >>> len1 = len(S1.lower_central_series())\n        >>> len2 = len(S2.lower_central_series())\n        >>> len3 = len(S3.lower_central_series())\n\n        >>> len1 == len2\n        True\n        >>> len1 < len3\n        True\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "transitivity_degree",
    "full_id": "sympy.combinatorics.perm_groups.PermutationGroup.transitivity_degree",
    "type": "property",
    "description": "Compute the degree of transitivity of the group.\n\n        Explanation\n        ===========\n\n        A permutation group `G` acting on `\\Omega = \\{0, 1, \\dots, n-1\\}` is\n        ``k``-fold transitive, if, for any `k` points\n        `(a_1, a_2, \\dots, a_k) \\in \\Omega` and any `k` points\n        `(b_1, b_2, \\dots, b_k) \\in \\Omega` there exists `g \\in  G` such that\n        `g(a_1) = b_1, g(a_2) = b_2, \\dots, g(a_k) = b_k`\n        The degree of transitivity of `G` is the maximum ``k`` such that\n        `G` is ``k``-fold transitive. ([8])\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Permutation, PermutationGroup\n        >>> a = Permutation([1, 2, 0])\n        >>> b = Permutation([1, 0, 2])\n        >>> G = PermutationGroup([a, b])\n        >>> G.transitivity_degree\n        3\n\n        See Also\n        ========\n\n        is_transitive, orbit\n\n        ",
    "section": "Permutation Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html"
  },
  {
    "name": "array_form",
    "full_id": "sympy.combinatorics.polyhedron.Polyhedron.array_form",
    "type": "property",
    "description": "Return the indices of the corners.\n\n        The indices are given relative to the original position of corners.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.polyhedron import tetrahedron\n        >>> tetrahedron = tetrahedron.copy()\n        >>> tetrahedron.array_form\n        [0, 1, 2, 3]\n\n        >>> tetrahedron.rotate(0)\n        >>> tetrahedron.array_form\n        [0, 2, 3, 1]\n        >>> tetrahedron.pgroup[0].array_form\n        [0, 2, 3, 1]\n\n        See Also\n        ========\n\n        corners, cyclic_form\n        ",
    "section": "Polyhedron",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/polyhedron.html"
  },
  {
    "name": "corners",
    "full_id": "sympy.combinatorics.polyhedron.Polyhedron.corners",
    "type": "property",
    "description": "\n        Get the corners of the Polyhedron.\n\n        The method ``vertices`` is an alias for ``corners``.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Polyhedron\n        >>> from sympy.abc import a, b, c, d\n        >>> p = Polyhedron(list('abcd'))\n        >>> p.corners == p.vertices == (a, b, c, d)\n        True\n\n        See Also\n        ========\n\n        array_form, cyclic_form\n        ",
    "section": "Polyhedron",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/polyhedron.html"
  },
  {
    "name": "cyclic_form",
    "full_id": "sympy.combinatorics.polyhedron.Polyhedron.cyclic_form",
    "type": "property",
    "description": "Return the indices of the corners in cyclic notation.\n\n        The indices are given relative to the original position of corners.\n\n        See Also\n        ========\n\n        corners, array_form\n        ",
    "section": "Polyhedron",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/polyhedron.html"
  },
  {
    "name": "edges",
    "full_id": "sympy.combinatorics.polyhedron.Polyhedron.edges",
    "type": "property",
    "description": "\n        Given the faces of the polyhedra we can get the edges.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Polyhedron\n        >>> from sympy.abc import a, b, c\n        >>> corners = (a, b, c)\n        >>> faces = [(0, 1, 2)]\n        >>> Polyhedron(corners, faces).edges\n        {(0, 1), (0, 2), (1, 2)}\n\n        ",
    "section": "Polyhedron",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/polyhedron.html"
  },
  {
    "name": "faces",
    "full_id": "sympy.combinatorics.polyhedron.Polyhedron.faces",
    "type": "property",
    "description": "\n        Get the faces of the Polyhedron.\n        ",
    "section": "Polyhedron",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/polyhedron.html"
  },
  {
    "name": "pgroup",
    "full_id": "sympy.combinatorics.polyhedron.Polyhedron.pgroup",
    "type": "property",
    "description": "\n        Get the permutations of the Polyhedron.\n        ",
    "section": "Polyhedron",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/polyhedron.html"
  },
  {
    "name": "reset",
    "full_id": "sympy.combinatorics.polyhedron.Polyhedron.reset",
    "type": "method",
    "description": "Return corners to their original positions.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.polyhedron import tetrahedron as T\n        >>> T = T.copy()\n        >>> T.corners\n        (0, 1, 2, 3)\n        >>> T.rotate(0)\n        >>> T.corners\n        (0, 2, 3, 1)\n        >>> T.reset()\n        >>> T.corners\n        (0, 1, 2, 3)\n        ",
    "section": "Polyhedron",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/polyhedron.html"
  },
  {
    "name": "rotate",
    "full_id": "sympy.combinatorics.polyhedron.Polyhedron.rotate",
    "type": "method",
    "description": "\n        Apply a permutation to the polyhedron *in place*. The permutation\n        may be given as a Permutation instance or an integer indicating\n        which permutation from pgroup of the Polyhedron should be\n        applied.\n\n        This is an operation that is analogous to rotation about\n        an axis by a fixed increment.\n\n        Notes\n        =====\n\n        When a Permutation is applied, no check is done to see if that\n        is a valid permutation for the Polyhedron. For example, a cube\n        could be given a permutation which effectively swaps only 2\n        vertices. A valid permutation (that rotates the object in a\n        physical way) will be obtained if one only uses\n        permutations from the ``pgroup`` of the Polyhedron. On the other\n        hand, allowing arbitrary rotations (applications of permutations)\n        gives a way to follow named elements rather than indices since\n        Polyhedron allows vertices to be named while Permutation works\n        only with indices.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Polyhedron, Permutation\n        >>> from sympy.combinatorics.polyhedron import cube\n        >>> cube = cube.copy()\n        >>> cube.corners\n        (0, 1, 2, 3, 4, 5, 6, 7)\n        >>> cube.rotate(0)\n        >>> cube.corners\n        (1, 2, 3, 0, 5, 6, 7, 4)\n\n        A non-physical \"rotation\" that is not prohibited by this method:\n\n        >>> cube.reset()\n        >>> cube.rotate(Permutation([[1, 2]], size=8))\n        >>> cube.corners\n        (0, 2, 1, 3, 4, 5, 6, 7)\n\n        Polyhedron can be used to follow elements of set that are\n        identified by letters instead of integers:\n\n        >>> shadow = h5 = Polyhedron(list('abcde'))\n        >>> p = Permutation([3, 0, 1, 2, 4])\n        >>> h5.rotate(p)\n        >>> h5.corners\n        (d, a, b, c, e)\n        >>> _ == shadow.corners\n        True\n        >>> copy = h5.copy()\n        >>> h5.rotate(p)\n        >>> h5.corners == copy.corners\n        False\n        ",
    "section": "Polyhedron",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/polyhedron.html"
  },
  {
    "name": "size",
    "full_id": "sympy.combinatorics.polyhedron.Polyhedron.size",
    "type": "property",
    "description": "\n        Get the number of corners of the Polyhedron.\n        ",
    "section": "Polyhedron",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/polyhedron.html"
  },
  {
    "name": "edges",
    "full_id": "sympy.combinatorics.prufer.Prufer.edges",
    "type": "method",
    "description": "Return a list of edges and the number of nodes from the given runs\n        that connect nodes in an integer-labelled tree.\n\n        All node numbers will be shifted so that the minimum node is 0. It is\n        not a problem if edges are repeated in the runs; only unique edges are\n        returned. There is no assumption made about what the range of the node\n        labels should be, but all nodes from the smallest through the largest\n        must be present.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> Prufer.edges([1, 2, 3], [2, 4, 5]) # a T\n        ([[0, 1], [1, 2], [1, 3], [3, 4]], 5)\n\n        Duplicate edges are removed:\n\n        >>> Prufer.edges([0, 1, 2, 3], [1, 4, 5], [1, 4, 6]) # a K\n        ([[0, 1], [1, 2], [1, 4], [2, 3], [4, 5], [4, 6]], 7)\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "next",
    "full_id": "sympy.combinatorics.prufer.Prufer.next",
    "type": "method",
    "description": "Generates the Prufer sequence that is delta beyond the current one.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> a = Prufer([[0, 1], [0, 2], [0, 3]])\n        >>> b = a.next(1) # == a.next()\n        >>> b.tree_repr\n        [[0, 2], [0, 1], [1, 3]]\n        >>> b.rank\n        1\n\n        See Also\n        ========\n\n        prufer_rank, rank, prev, size\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "nodes",
    "full_id": "sympy.combinatorics.prufer.Prufer.nodes",
    "type": "property",
    "description": "Returns the number of nodes in the tree.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> Prufer([[0, 3], [1, 3], [2, 3], [3, 4], [4, 5]]).nodes\n        6\n        >>> Prufer([1, 0, 0]).nodes\n        5\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "prev",
    "full_id": "sympy.combinatorics.prufer.Prufer.prev",
    "type": "method",
    "description": "Generates the Prufer sequence that is -delta before the current one.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> a = Prufer([[0, 1], [1, 2], [2, 3], [1, 4]])\n        >>> a.rank\n        36\n        >>> b = a.prev()\n        >>> b\n        Prufer([1, 2, 0])\n        >>> b.rank\n        35\n\n        See Also\n        ========\n\n        prufer_rank, rank, next, size\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "prufer_rank",
    "full_id": "sympy.combinatorics.prufer.Prufer.prufer_rank",
    "type": "method",
    "description": "Computes the rank of a Prufer sequence.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> a = Prufer([[0, 1], [0, 2], [0, 3]])\n        >>> a.prufer_rank()\n        0\n\n        See Also\n        ========\n\n        rank, next, prev, size\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "prufer_repr",
    "full_id": "sympy.combinatorics.prufer.Prufer.prufer_repr",
    "type": "property",
    "description": "Returns Prufer sequence for the Prufer object.\n\n        This sequence is found by removing the highest numbered vertex,\n        recording the node it was attached to, and continuing until only\n        two vertices remain. The Prufer sequence is the list of recorded nodes.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> Prufer([[0, 3], [1, 3], [2, 3], [3, 4], [4, 5]]).prufer_repr\n        [3, 3, 3, 4]\n        >>> Prufer([1, 0, 0]).prufer_repr\n        [1, 0, 0]\n\n        See Also\n        ========\n\n        to_prufer\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "rank",
    "full_id": "sympy.combinatorics.prufer.Prufer.rank",
    "type": "property",
    "description": "Returns the rank of the Prufer sequence.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> p = Prufer([[0, 3], [1, 3], [2, 3], [3, 4], [4, 5]])\n        >>> p.rank\n        778\n        >>> p.next(1).rank\n        779\n        >>> p.prev().rank\n        777\n\n        See Also\n        ========\n\n        prufer_rank, next, prev, size\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "size",
    "full_id": "sympy.combinatorics.prufer.Prufer.size",
    "type": "property",
    "description": "Return the number of possible trees of this Prufer object.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> Prufer([0]*4).size == Prufer([6]*4).size == 1296\n        True\n\n        See Also\n        ========\n\n        prufer_rank, rank, next, prev\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "to_prufer",
    "full_id": "sympy.combinatorics.prufer.Prufer.to_prufer",
    "type": "method",
    "description": "Return the Prufer sequence for a tree given as a list of edges where\n        ``n`` is the number of nodes in the tree.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> a = Prufer([[0, 1], [0, 2], [0, 3]])\n        >>> a.prufer_repr\n        [0, 0]\n        >>> Prufer.to_prufer([[0, 1], [0, 2], [0, 3]], 4)\n        [0, 0]\n\n        See Also\n        ========\n        prufer_repr: returns Prufer sequence of a Prufer object.\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "to_tree",
    "full_id": "sympy.combinatorics.prufer.Prufer.to_tree",
    "type": "method",
    "description": "Return the tree (as a list of edges) of the given Prufer sequence.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> a = Prufer([0, 2], 4)\n        >>> a.tree_repr\n        [[0, 1], [0, 2], [2, 3]]\n        >>> Prufer.to_tree([0, 2])\n        [[0, 1], [0, 2], [2, 3]]\n\n        References\n        ==========\n\n        .. [1] https://hamberg.no/erlend/posts/2010-11-06-prufer-sequence-compact-tree-representation.html\n\n        See Also\n        ========\n        tree_repr: returns tree representation of a Prufer object.\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "tree_repr",
    "full_id": "sympy.combinatorics.prufer.Prufer.tree_repr",
    "type": "property",
    "description": "Returns the tree representation of the Prufer object.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> Prufer([[0, 3], [1, 3], [2, 3], [3, 4], [4, 5]]).tree_repr\n        [[0, 3], [1, 3], [2, 3], [3, 4], [4, 5]]\n        >>> Prufer([1, 0, 0]).tree_repr\n        [[1, 2], [0, 1], [0, 3], [0, 4]]\n\n        See Also\n        ========\n\n        to_tree\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "unrank",
    "full_id": "sympy.combinatorics.prufer.Prufer.unrank",
    "type": "method",
    "description": "Finds the unranked Prufer sequence.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics.prufer import Prufer\n        >>> Prufer.unrank(0, 4)\n        Prufer([0, 0])\n\n        ",
    "section": "Prufer Sequences",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/prufer.html"
  },
  {
    "name": "bitlist_from_subset",
    "full_id": "sympy.combinatorics.subsets.Subset.bitlist_from_subset",
    "type": "method",
    "description": "\n        Gets the bitlist corresponding to a subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> Subset.bitlist_from_subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        '0011'\n\n        See Also\n        ========\n\n        subset_from_bitlist\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "cardinality",
    "full_id": "sympy.combinatorics.subsets.Subset.cardinality",
    "type": "property",
    "description": "\n        Returns the number of all possible subsets.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.cardinality\n        16\n\n        See Also\n        ========\n\n        subset, superset, size, superset_size\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "iterate_binary",
    "full_id": "sympy.combinatorics.subsets.Subset.iterate_binary",
    "type": "method",
    "description": "\n        This is a helper function. It iterates over the\n        binary subsets by ``k`` steps. This variable can be\n        both positive or negative.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.iterate_binary(-2).subset\n        ['d']\n        >>> a = Subset(['a', 'b', 'c'], ['a', 'b', 'c', 'd'])\n        >>> a.iterate_binary(2).subset\n        []\n\n        See Also\n        ========\n\n        next_binary, prev_binary\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "iterate_graycode",
    "full_id": "sympy.combinatorics.subsets.Subset.iterate_graycode",
    "type": "method",
    "description": "\n        Helper function used for prev_gray and next_gray.\n        It performs ``k`` step overs to get the respective Gray codes.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset([1, 2, 3], [1, 2, 3, 4])\n        >>> a.iterate_graycode(3).subset\n        [1, 4]\n        >>> a.iterate_graycode(-2).subset\n        [1, 2, 4]\n\n        See Also\n        ========\n\n        next_gray, prev_gray\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "next_binary",
    "full_id": "sympy.combinatorics.subsets.Subset.next_binary",
    "type": "method",
    "description": "\n        Generates the next binary ordered subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.next_binary().subset\n        ['b']\n        >>> a = Subset(['a', 'b', 'c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.next_binary().subset\n        []\n\n        See Also\n        ========\n\n        prev_binary, iterate_binary\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "next_gray",
    "full_id": "sympy.combinatorics.subsets.Subset.next_gray",
    "type": "method",
    "description": "\n        Generates the next Gray code ordered subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset([1, 2, 3], [1, 2, 3, 4])\n        >>> a.next_gray().subset\n        [1, 3]\n\n        See Also\n        ========\n\n        iterate_graycode, prev_gray\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "next_lexicographic",
    "full_id": "sympy.combinatorics.subsets.Subset.next_lexicographic",
    "type": "method",
    "description": "\n        Generates the next lexicographically ordered subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.next_lexicographic().subset\n        ['d']\n        >>> a = Subset(['d'], ['a', 'b', 'c', 'd'])\n        >>> a.next_lexicographic().subset\n        []\n\n        See Also\n        ========\n\n        prev_lexicographic\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "prev_binary",
    "full_id": "sympy.combinatorics.subsets.Subset.prev_binary",
    "type": "method",
    "description": "\n        Generates the previous binary ordered subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset([], ['a', 'b', 'c', 'd'])\n        >>> a.prev_binary().subset\n        ['a', 'b', 'c', 'd']\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.prev_binary().subset\n        ['c']\n\n        See Also\n        ========\n\n        next_binary, iterate_binary\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "prev_gray",
    "full_id": "sympy.combinatorics.subsets.Subset.prev_gray",
    "type": "method",
    "description": "\n        Generates the previous Gray code ordered subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset([2, 3, 4], [1, 2, 3, 4, 5])\n        >>> a.prev_gray().subset\n        [2, 3, 4, 5]\n\n        See Also\n        ========\n\n        iterate_graycode, next_gray\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "prev_lexicographic",
    "full_id": "sympy.combinatorics.subsets.Subset.prev_lexicographic",
    "type": "method",
    "description": "\n        Generates the previous lexicographically ordered subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset([], ['a', 'b', 'c', 'd'])\n        >>> a.prev_lexicographic().subset\n        ['d']\n        >>> a = Subset(['c','d'], ['a', 'b', 'c', 'd'])\n        >>> a.prev_lexicographic().subset\n        ['c']\n\n        See Also\n        ========\n\n        next_lexicographic\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "rank_binary",
    "full_id": "sympy.combinatorics.subsets.Subset.rank_binary",
    "type": "property",
    "description": "\n        Computes the binary ordered rank.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset([], ['a','b','c','d'])\n        >>> a.rank_binary\n        0\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.rank_binary\n        3\n\n        See Also\n        ========\n\n        iterate_binary, unrank_binary\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "rank_gray",
    "full_id": "sympy.combinatorics.subsets.Subset.rank_gray",
    "type": "property",
    "description": "\n        Computes the Gray code ranking of the subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c','d'], ['a','b','c','d'])\n        >>> a.rank_gray\n        2\n        >>> a = Subset([2, 4, 5], [1, 2, 3, 4, 5, 6])\n        >>> a.rank_gray\n        27\n\n        See Also\n        ========\n\n        iterate_graycode, unrank_gray\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "rank_lexicographic",
    "full_id": "sympy.combinatorics.subsets.Subset.rank_lexicographic",
    "type": "property",
    "description": "\n        Computes the lexicographic ranking of the subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.rank_lexicographic\n        14\n        >>> a = Subset([2, 4, 5], [1, 2, 3, 4, 5, 6])\n        >>> a.rank_lexicographic\n        43\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "size",
    "full_id": "sympy.combinatorics.subsets.Subset.size",
    "type": "property",
    "description": "\n        Gets the size of the subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.size\n        2\n\n        See Also\n        ========\n\n        subset, superset, superset_size, cardinality\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "subset",
    "full_id": "sympy.combinatorics.subsets.Subset.subset",
    "type": "property",
    "description": "\n        Gets the subset represented by the current instance.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.subset\n        ['c', 'd']\n\n        See Also\n        ========\n\n        superset, size, superset_size, cardinality\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "subset_from_bitlist",
    "full_id": "sympy.combinatorics.subsets.Subset.subset_from_bitlist",
    "type": "method",
    "description": "\n        Gets the subset defined by the bitlist.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> Subset.subset_from_bitlist(['a', 'b', 'c', 'd'], '0011').subset\n        ['c', 'd']\n\n        See Also\n        ========\n\n        bitlist_from_subset\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "subset_indices",
    "full_id": "sympy.combinatorics.subsets.Subset.subset_indices",
    "type": "method",
    "description": "Return indices of subset in superset in a list; the list is empty\n        if all elements of ``subset`` are not in ``superset``.\n\n        Examples\n        ========\n\n            >>> from sympy.combinatorics import Subset\n            >>> superset = [1, 3, 2, 5, 4]\n            >>> Subset.subset_indices([3, 2, 1], superset)\n            [1, 2, 0]\n            >>> Subset.subset_indices([1, 6], superset)\n            []\n            >>> Subset.subset_indices([], superset)\n            []\n\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "superset",
    "full_id": "sympy.combinatorics.subsets.Subset.superset",
    "type": "property",
    "description": "\n        Gets the superset of the subset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.superset\n        ['a', 'b', 'c', 'd']\n\n        See Also\n        ========\n\n        subset, size, superset_size, cardinality\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "superset_size",
    "full_id": "sympy.combinatorics.subsets.Subset.superset_size",
    "type": "property",
    "description": "\n        Returns the size of the superset.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> a = Subset(['c', 'd'], ['a', 'b', 'c', 'd'])\n        >>> a.superset_size\n        4\n\n        See Also\n        ========\n\n        subset, superset, size, cardinality\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "unrank_binary",
    "full_id": "sympy.combinatorics.subsets.Subset.unrank_binary",
    "type": "method",
    "description": "\n        Gets the binary ordered subset of the specified rank.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> Subset.unrank_binary(4, ['a', 'b', 'c', 'd']).subset\n        ['b']\n\n        See Also\n        ========\n\n        iterate_binary, rank_binary\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "unrank_gray",
    "full_id": "sympy.combinatorics.subsets.Subset.unrank_gray",
    "type": "method",
    "description": "\n        Gets the Gray code ordered subset of the specified rank.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import Subset\n        >>> Subset.unrank_gray(4, ['a', 'b', 'c']).subset\n        ['a', 'b']\n        >>> Subset.unrank_gray(0, ['a', 'b', 'c']).subset\n        []\n\n        See Also\n        ========\n\n        iterate_graycode, rank_gray\n        ",
    "section": "Subsets",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/subsets.html"
  },
  {
    "name": "current",
    "full_id": "sympy.combinatorics.graycode.GrayCode.current",
    "type": "property",
    "description": "\n        Returns the currently referenced Gray code as a bit string.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import GrayCode\n        >>> GrayCode(3, start='100').current\n        '100'\n        ",
    "section": "Gray Code",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/graycode.html"
  },
  {
    "name": "generate_gray",
    "full_id": "sympy.combinatorics.graycode.GrayCode.generate_gray",
    "type": "method",
    "description": "\n        Generates the sequence of bit vectors of a Gray Code.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import GrayCode\n        >>> a = GrayCode(3)\n        >>> list(a.generate_gray())\n        ['000', '001', '011', '010', '110', '111', '101', '100']\n        >>> list(a.generate_gray(start='011'))\n        ['011', '010', '110', '111', '101', '100']\n        >>> list(a.generate_gray(rank=4))\n        ['110', '111', '101', '100']\n\n        See Also\n        ========\n\n        skip\n\n        References\n        ==========\n\n        .. [1] Knuth, D. (2011). The Art of Computer Programming,\n               Vol 4, Addison Wesley\n\n        ",
    "section": "Gray Code",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/graycode.html"
  },
  {
    "name": "n",
    "full_id": "sympy.combinatorics.graycode.GrayCode.n",
    "type": "property",
    "description": "\n        Returns the dimension of the Gray code.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import GrayCode\n        >>> a = GrayCode(5)\n        >>> a.n\n        5\n        ",
    "section": "Gray Code",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/graycode.html"
  },
  {
    "name": "next",
    "full_id": "sympy.combinatorics.graycode.GrayCode.next",
    "type": "method",
    "description": "\n        Returns the Gray code a distance ``delta`` (default = 1) from the\n        current value in canonical order.\n\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import GrayCode\n        >>> a = GrayCode(3, start='110')\n        >>> a.next().current\n        '111'\n        >>> a.next(-1).current\n        '010'\n        ",
    "section": "Gray Code",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/graycode.html"
  },
  {
    "name": "rank",
    "full_id": "sympy.combinatorics.graycode.GrayCode.rank",
    "type": "property",
    "description": "\n        Ranks the Gray code.\n\n        A ranking algorithm determines the position (or rank)\n        of a combinatorial object among all the objects w.r.t.\n        a given order. For example, the 4 bit binary reflected\n        Gray code (BRGC) '0101' has a rank of 6 as it appears in\n        the 6th position in the canonical ordering of the family\n        of 4 bit Gray codes.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import GrayCode\n        >>> a = GrayCode(3)\n        >>> list(a.generate_gray())\n        ['000', '001', '011', '010', '110', '111', '101', '100']\n        >>> GrayCode(3, start='100').rank\n        7\n        >>> GrayCode(3, rank=7).current\n        '100'\n\n        See Also\n        ========\n\n        unrank\n\n        References\n        ==========\n\n        .. [1] https://web.archive.org/web/20200224064753/http://statweb.stanford.edu/~susan/courses/s208/node12.html\n\n        ",
    "section": "Gray Code",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/graycode.html"
  },
  {
    "name": "selections",
    "full_id": "sympy.combinatorics.graycode.GrayCode.selections",
    "type": "property",
    "description": "\n        Returns the number of bit vectors in the Gray code.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import GrayCode\n        >>> a = GrayCode(3)\n        >>> a.selections\n        8\n        ",
    "section": "Gray Code",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/graycode.html"
  },
  {
    "name": "skip",
    "full_id": "sympy.combinatorics.graycode.GrayCode.skip",
    "type": "method",
    "description": "\n        Skips the bit generation.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import GrayCode\n        >>> a = GrayCode(3)\n        >>> for i in a.generate_gray():\n        ...     if i == '010':\n        ...         a.skip()\n        ...     print(i)\n        ...\n        000\n        001\n        011\n        010\n        111\n        101\n        100\n\n        See Also\n        ========\n\n        generate_gray\n        ",
    "section": "Gray Code",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/graycode.html"
  },
  {
    "name": "unrank",
    "full_id": "sympy.combinatorics.graycode.GrayCode.unrank",
    "type": "method",
    "description": "\n        Unranks an n-bit sized Gray code of rank k. This method exists\n        so that a derivative GrayCode class can define its own code of\n        a given rank.\n\n        The string here is generated in reverse order to allow for tail-call\n        optimization.\n\n        Examples\n        ========\n\n        >>> from sympy.combinatorics import GrayCode\n        >>> GrayCode(5, rank=3).current\n        '00010'\n        >>> GrayCode.unrank(5, 3)\n        '00010'\n\n        See Also\n        ========\n\n        rank\n        ",
    "section": "Gray Code",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/graycode.html"
  },
  {
    "name": "SymmetricGroup",
    "full_id": "sympy.combinatorics.named_groups.SymmetricGroup",
    "type": "function",
    "description": "\n    Generates the symmetric group on ``n`` elements as a permutation group.\n\n    Explanation\n    ===========\n\n    The generators taken are the ``n``-cycle\n    ``(0 1 2 ... n-1)`` and the transposition ``(0 1)`` (in cycle notation).\n    (See [1]). After the group is generated, some of its basic properties\n    are set.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import SymmetricGroup\n    >>> G = SymmetricGroup(4)\n    >>> G.is_group\n    True\n    >>> G.order()\n    24\n    >>> list(G.generate_schreier_sims(af=True))\n    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 1, 2, 0], [0, 2, 3, 1],\n    [1, 3, 0, 2], [2, 0, 1, 3], [3, 2, 0, 1], [0, 3, 1, 2], [1, 0, 2, 3],\n    [2, 1, 3, 0], [3, 0, 1, 2], [0, 1, 3, 2], [1, 2, 0, 3], [2, 3, 1, 0],\n    [3, 1, 0, 2], [0, 2, 1, 3], [1, 3, 2, 0], [2, 0, 3, 1], [3, 2, 1, 0],\n    [0, 3, 2, 1], [1, 0, 3, 2], [2, 1, 0, 3], [3, 0, 2, 1]]\n\n    See Also\n    ========\n\n    CyclicGroup, DihedralGroup, AlternatingGroup\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Symmetric_group#Generators_and_relations\n\n    ",
    "section": "Named Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/named_groups.html"
  },
  {
    "name": "CyclicGroup",
    "full_id": "sympy.combinatorics.named_groups.CyclicGroup",
    "type": "function",
    "description": "\n    Generates the cyclic group of order ``n`` as a permutation group.\n\n    Explanation\n    ===========\n\n    The generator taken is the ``n``-cycle ``(0 1 2 ... n-1)``\n    (in cycle notation). After the group is generated, some of its basic\n    properties are set.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\n    >>> G = CyclicGroup(6)\n    >>> G.is_group\n    True\n    >>> G.order()\n    6\n    >>> list(G.generate_schreier_sims(af=True))\n    [[0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 0], [2, 3, 4, 5, 0, 1],\n    [3, 4, 5, 0, 1, 2], [4, 5, 0, 1, 2, 3], [5, 0, 1, 2, 3, 4]]\n\n    See Also\n    ========\n\n    SymmetricGroup, DihedralGroup, AlternatingGroup\n\n    ",
    "section": "Named Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/named_groups.html"
  },
  {
    "name": "DihedralGroup",
    "full_id": "sympy.combinatorics.named_groups.DihedralGroup",
    "type": "function",
    "description": "\n    Generates the dihedral group `D_n` as a permutation group.\n\n    Explanation\n    ===========\n\n    The dihedral group `D_n` is the group of symmetries of the regular\n    ``n``-gon. The generators taken are the ``n``-cycle ``a = (0 1 2 ... n-1)``\n    (a rotation of the ``n``-gon) and ``b = (0 n-1)(1 n-2)...``\n    (a reflection of the ``n``-gon) in cycle rotation. It is easy to see that\n    these satisfy ``a**n = b**2 = 1`` and ``bab = ~a`` so they indeed generate\n    `D_n` (See [1]). After the group is generated, some of its basic properties\n    are set.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import DihedralGroup\n    >>> G = DihedralGroup(5)\n    >>> G.is_group\n    True\n    >>> a = list(G.generate_dimino())\n    >>> [perm.cyclic_form for perm in a]\n    [[], [[0, 1, 2, 3, 4]], [[0, 2, 4, 1, 3]],\n    [[0, 3, 1, 4, 2]], [[0, 4, 3, 2, 1]], [[0, 4], [1, 3]],\n    [[1, 4], [2, 3]], [[0, 1], [2, 4]], [[0, 2], [3, 4]],\n    [[0, 3], [1, 2]]]\n\n    See Also\n    ========\n\n    SymmetricGroup, CyclicGroup, AlternatingGroup\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Dihedral_group\n\n    ",
    "section": "Named Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/named_groups.html"
  },
  {
    "name": "AlternatingGroup",
    "full_id": "sympy.combinatorics.named_groups.AlternatingGroup",
    "type": "function",
    "description": "\n    Generates the alternating group on ``n`` elements as a permutation group.\n\n    Explanation\n    ===========\n\n    For ``n > 2``, the generators taken are ``(0 1 2), (0 1 2 ... n-1)`` for\n    ``n`` odd\n    and ``(0 1 2), (1 2 ... n-1)`` for ``n`` even (See [1], p.31, ex.6.9.).\n    After the group is generated, some of its basic properties are set.\n    The cases ``n = 1, 2`` are handled separately.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import AlternatingGroup\n    >>> G = AlternatingGroup(4)\n    >>> G.is_group\n    True\n    >>> a = list(G.generate_dimino())\n    >>> len(a)\n    12\n    >>> all(perm.is_even for perm in a)\n    True\n\n    See Also\n    ========\n\n    SymmetricGroup, CyclicGroup, DihedralGroup\n\n    References\n    ==========\n\n    .. [1] Armstrong, M. \"Groups and Symmetry\"\n\n    ",
    "section": "Named Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/named_groups.html"
  },
  {
    "name": "AbelianGroup",
    "full_id": "sympy.combinatorics.named_groups.AbelianGroup",
    "type": "function",
    "description": "\n    Returns the direct product of cyclic groups with the given orders.\n\n    Explanation\n    ===========\n\n    According to the structure theorem for finite abelian groups ([1]),\n    every finite abelian group can be written as the direct product of\n    finitely many cyclic groups.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import AbelianGroup\n    >>> AbelianGroup(3, 4)\n    PermutationGroup([\n            (6)(0 1 2),\n            (3 4 5 6)])\n    >>> _.is_group\n    True\n\n    See Also\n    ========\n\n    DirectProduct\n\n    References\n    ==========\n\n    .. [1] https://groupprops.subwiki.org/wiki/Structure_theorem_for_finitely_generated_abelian_groups\n\n    ",
    "section": "Named Groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/named_groups.html"
  },
  {
    "name": "four_group",
    "full_id": "sympy.combinatorics.galois.four_group",
    "type": "function",
    "description": "\n    Return a representation of the Klein four-group as a transitive subgroup\n    of S4.\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "M20",
    "full_id": "sympy.combinatorics.galois.M20",
    "type": "function",
    "description": "\n    Return a representation of the metacyclic group M20, a transitive subgroup\n    of S5 that is one of the possible Galois groups for polys of degree 5.\n\n    Notes\n    =====\n\n    See [1], Page 323.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "S3_in_S6",
    "full_id": "sympy.combinatorics.galois.S3_in_S6",
    "type": "function",
    "description": "\n    Return a representation of S3 as a transitive subgroup of S6.\n\n    Notes\n    =====\n\n    The representation is found by viewing the group as the symmetries of a\n    triangular prism.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "A4_in_S6",
    "full_id": "sympy.combinatorics.galois.A4_in_S6",
    "type": "function",
    "description": "\n    Return a representation of A4 as a transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "S4m",
    "full_id": "sympy.combinatorics.galois.S4m",
    "type": "function",
    "description": "\n    Return a representation of the S4- transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "S4p",
    "full_id": "sympy.combinatorics.galois.S4p",
    "type": "function",
    "description": "\n    Return a representation of the S4+ transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "A4xC2",
    "full_id": "sympy.combinatorics.galois.A4xC2",
    "type": "function",
    "description": "\n    Return a representation of the (A4 x C2) transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "S4xC2",
    "full_id": "sympy.combinatorics.galois.S4xC2",
    "type": "function",
    "description": "\n    Return a representation of the (S4 x C2) transitive subgroup of S6.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "G18",
    "full_id": "sympy.combinatorics.galois.G18",
    "type": "function",
    "description": "\n    Return a representation of the group G18, a transitive subgroup of S6\n    isomorphic to the semidirect product of C3^2 with C2.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "G36m",
    "full_id": "sympy.combinatorics.galois.G36m",
    "type": "function",
    "description": "\n    Return a representation of the group G36-, a transitive subgroup of S6\n    isomorphic to the semidirect product of C3^2 with C2^2.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "G36p",
    "full_id": "sympy.combinatorics.galois.G36p",
    "type": "function",
    "description": "\n    Return a representation of the group G36+, a transitive subgroup of S6\n    isomorphic to the semidirect product of C3^2 with C4.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "G72",
    "full_id": "sympy.combinatorics.galois.G72",
    "type": "function",
    "description": "\n    Return a representation of the group G72, a transitive subgroup of S6\n    isomorphic to the semidirect product of C3^2 with D4.\n\n    Notes\n    =====\n\n    See [1], Page 325.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "PSL2F5",
    "full_id": "sympy.combinatorics.galois.PSL2F5",
    "type": "function",
    "description": "\n    Return a representation of the group $PSL_2(\\mathbb{F}_5)$, as a transitive\n    subgroup of S6, isomorphic to $A_5$.\n\n    Notes\n    =====\n\n    This was computed using :py:func:`~.find_transitive_subgroups_of_S6`.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "PGL2F5",
    "full_id": "sympy.combinatorics.galois.PGL2F5",
    "type": "function",
    "description": "\n    Return a representation of the group $PGL_2(\\mathbb{F}_5)$, as a transitive\n    subgroup of S6, isomorphic to $S_5$.\n\n    Notes\n    =====\n\n    See [1], Page 325.\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "find_transitive_subgroups_of_S6",
    "full_id": "sympy.combinatorics.galois.find_transitive_subgroups_of_S6",
    "type": "function",
    "description": "\n    Search for certain transitive subgroups of $S_6$.\n\n    The symmetric group $S_6$ has 16 different transitive subgroups, up to\n    conjugacy. Some are more easily constructed than others. For example, the\n    dihedral group $D_6$ is immediately found, but it is not at all obvious how\n    to realize $S_4$ or $S_5$ *transitively* within $S_6$.\n\n    In some cases there are well-known constructions that can be used. For\n    example, $S_5$ is isomorphic to $PGL_2(\\mathbb{F}_5)$, which acts in a\n    natural way on the projective line $P^1(\\mathbb{F}_5)$, a set of order 6.\n\n    In absence of such special constructions however, we can simply search for\n    generators. For example, transitive instances of $A_4$ and $S_4$ can be\n    found within $S_6$ in this way.\n\n    Once we are engaged in such searches, it may then be easier (if less\n    elegant) to find even those groups like $S_5$ that do have special\n    constructions, by mere search.\n\n    This function locates generators for transitive instances in $S_6$ of the\n    following subgroups:\n\n    * $A_4$\n    * $S_4^-$ ($S_4$ not contained within $A_6$)\n    * $S_4^+$ ($S_4$ contained within $A_6$)\n    * $A_4 \\times C_2$\n    * $S_4 \\times C_2$\n    * $G_{18}   = C_3^2 \\rtimes C_2$\n    * $G_{36}^- = C_3^2 \\rtimes C_2^2$\n    * $G_{36}^+ = C_3^2 \\rtimes C_4$\n    * $G_{72}   = C_3^2 \\rtimes D_4$\n    * $A_5$\n    * $S_5$\n\n    Note: Each of these groups also has a dedicated function in this module\n    that returns the group immediately, using generators that were found by\n    this search procedure.\n\n    The search procedure serves as a record of how these generators were\n    found. Also, due to randomness in the generation of the elements of\n    permutation groups, it can be called again, in order to (probably) get\n    different generators for the same groups.\n\n    Parameters\n    ==========\n\n    targets : list of :py:class:`~.S6TransitiveSubgroups` values\n        The groups you want to find.\n\n    print_report : bool (default False)\n        If True, print to stdout the generators found for each group.\n\n    Returns\n    =======\n\n    dict\n        mapping each name in *targets* to the :py:class:`~.PermutationGroup`\n        that was found\n\n    References\n    ==========\n\n    .. [2] https://en.wikipedia.org/wiki/Projective_linear_group#Exceptional_isomorphisms\n    .. [3] https://en.wikipedia.org/wiki/Automorphisms_of_the_symmetric_and_alternating_groups#PGL%282,5%29\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/galois.html"
  },
  {
    "name": "is_nilpotent_number",
    "full_id": "sympy.combinatorics.group_numbers.is_nilpotent_number",
    "type": "function",
    "description": "\n    Check whether `n` is a nilpotent number. A number `n` is said to be\n    nilpotent if and only if every finite group of order `n` is nilpotent.\n    For more information see [1]_.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.group_numbers import is_nilpotent_number\n    >>> from sympy import randprime\n    >>> is_nilpotent_number(21)\n    False\n    >>> is_nilpotent_number(randprime(1, 30)**12)\n    True\n\n    References\n    ==========\n\n    .. [1] Pakianathan, J., Shankar, K., Nilpotent Numbers,\n           The American Mathematical Monthly, 107(7), 631-634.\n    .. [2] https://oeis.org/A056867\n\n    ",
    "section": "Number of groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/group_numbers.html"
  },
  {
    "name": "is_abelian_number",
    "full_id": "sympy.combinatorics.group_numbers.is_abelian_number",
    "type": "function",
    "description": "\n    Check whether `n` is an abelian number. A number `n` is said to be abelian\n    if and only if every finite group of order `n` is abelian. For more\n    information see [1]_.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.group_numbers import is_abelian_number\n    >>> from sympy import randprime\n    >>> is_abelian_number(4)\n    True\n    >>> is_abelian_number(randprime(1, 2000)**2)\n    True\n    >>> is_abelian_number(60)\n    False\n\n    References\n    ==========\n\n    .. [1] Pakianathan, J., Shankar, K., Nilpotent Numbers,\n           The American Mathematical Monthly, 107(7), 631-634.\n    .. [2] https://oeis.org/A051532\n\n    ",
    "section": "Number of groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/group_numbers.html"
  },
  {
    "name": "is_cyclic_number",
    "full_id": "sympy.combinatorics.group_numbers.is_cyclic_number",
    "type": "function",
    "description": "\n    Check whether `n` is a cyclic number. A number `n` is said to be cyclic\n    if and only if every finite group of order `n` is cyclic. For more\n    information see [1]_.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.group_numbers import is_cyclic_number\n    >>> from sympy import randprime\n    >>> is_cyclic_number(15)\n    True\n    >>> is_cyclic_number(randprime(1, 2000)**2)\n    False\n    >>> is_cyclic_number(4)\n    False\n\n    References\n    ==========\n\n    .. [1] Pakianathan, J., Shankar, K., Nilpotent Numbers,\n           The American Mathematical Monthly, 107(7), 631-634.\n    .. [2] https://oeis.org/A003277\n\n    ",
    "section": "Number of groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/group_numbers.html"
  },
  {
    "name": "groups_count",
    "full_id": "sympy.combinatorics.group_numbers.groups_count",
    "type": "function",
    "description": "Number of groups of order `n`.\n    In [1]_, ``gnu(n)`` is given, so we follow this notation here as well.\n\n    Parameters\n    ==========\n\n    n : Integer\n        ``n`` is a positive integer\n\n    Returns\n    =======\n\n    int : ``gnu(n)``\n\n    Raises\n    ======\n\n    ValueError\n        Number of groups of order ``n`` is unknown or not implemented.\n        For example, gnu(`2^{11}`) is not yet known.\n        On the other hand, gnu(12) is known to be 5,\n        but this has not yet been implemented in this function.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.group_numbers import groups_count\n    >>> groups_count(3) # There is only one cyclic group of order 3\n    1\n    >>> # There are two groups of order 10: the cyclic group and the dihedral group\n    >>> groups_count(10)\n    2\n\n    See Also\n    ========\n\n    is_cyclic_number\n        `n` is cyclic iff gnu(n) = 1\n\n    References\n    ==========\n\n    .. [1] John H. Conway, Heiko Dietrich and E.A. O'Brien,\n           Counting groups: gnus, moas and other exotica\n           The Mathematical Intelligencer 30, 6-15 (2008)\n           https://doi.org/10.1007/BF02985731\n    .. [2] https://oeis.org/A000001\n\n    ",
    "section": "Number of groups",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/group_numbers.html"
  },
  {
    "name": "_base_ordering",
    "full_id": "sympy.combinatorics.util._base_ordering",
    "type": "function",
    "description": "\n    Order `\\{0, 1, \\dots, n-1\\}` so that base points come first and in order.\n\n    Parameters\n    ==========\n\n    base : the base\n    degree : the degree of the associated permutation group\n\n    Returns\n    =======\n\n    A list ``base_ordering`` such that ``base_ordering[point]`` is the\n    number of ``point`` in the ordering.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import SymmetricGroup\n    >>> from sympy.combinatorics.util import _base_ordering\n    >>> S = SymmetricGroup(4)\n    >>> S.schreier_sims()\n    >>> _base_ordering(S.base, S.degree)\n    [0, 1, 2, 3]\n\n    Notes\n    =====\n\n    This is used in backtrack searches, when we define a relation `\\ll` on\n    the underlying set for a permutation group of degree `n`,\n    `\\{0, 1, \\dots, n-1\\}`, so that if `(b_1, b_2, \\dots, b_k)` is a base we\n    have `b_i \\ll b_j` whenever `i<j` and `b_i \\ll a` for all\n    `i\\in\\{1,2, \\dots, k\\}` and `a` is not in the base. The idea is developed\n    and applied to backtracking algorithms in [1], pp.108-132. The points\n    that are not in the base are taken in increasing order.\n\n    References\n    ==========\n\n    .. [1] Holt, D., Eick, B., O'Brien, E.\n           \"Handbook of computational group theory\"\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/util.html"
  },
  {
    "name": "_check_cycles_alt_sym",
    "full_id": "sympy.combinatorics.util._check_cycles_alt_sym",
    "type": "function",
    "description": "\n    Checks for cycles of prime length p with n/2 < p < n-2.\n\n    Explanation\n    ===========\n\n    Here `n` is the degree of the permutation. This is a helper function for\n    the function is_alt_sym from sympy.combinatorics.perm_groups.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.util import _check_cycles_alt_sym\n    >>> from sympy.combinatorics import Permutation\n    >>> a = Permutation([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [11, 12]])\n    >>> _check_cycles_alt_sym(a)\n    False\n    >>> b = Permutation([[0, 1, 2, 3, 4, 5, 6], [7, 8, 9, 10]])\n    >>> _check_cycles_alt_sym(b)\n    True\n\n    See Also\n    ========\n\n    sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/util.html"
  },
  {
    "name": "_distribute_gens_by_base",
    "full_id": "sympy.combinatorics.util._distribute_gens_by_base",
    "type": "function",
    "description": "\n    Distribute the group elements ``gens`` by membership in basic stabilizers.\n\n    Explanation\n    ===========\n\n    Notice that for a base `(b_1, b_2, \\dots, b_k)`, the basic stabilizers\n    are defined as `G^{(i)} = G_{b_1, \\dots, b_{i-1}}` for\n    `i \\in\\{1, 2, \\dots, k\\}`.\n\n    Parameters\n    ==========\n\n    base : a sequence of points in `\\{0, 1, \\dots, n-1\\}`\n    gens : a list of elements of a permutation group of degree `n`.\n\n    Returns\n    =======\n    list\n        List of length `k`, where `k` is the length of *base*. The `i`-th entry\n        contains those elements in *gens* which fix the first `i` elements of\n        *base* (so that the `0`-th entry is equal to *gens* itself). If no\n        element fixes the first `i` elements of *base*, the `i`-th element is\n        set to a list containing the identity element.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import DihedralGroup\n    >>> from sympy.combinatorics.util import _distribute_gens_by_base\n    >>> D = DihedralGroup(3)\n    >>> D.schreier_sims()\n    >>> D.strong_gens\n    [(0 1 2), (0 2), (1 2)]\n    >>> D.base\n    [0, 1]\n    >>> _distribute_gens_by_base(D.base, D.strong_gens)\n    [[(0 1 2), (0 2), (1 2)],\n     [(1 2)]]\n\n    See Also\n    ========\n\n    _strong_gens_from_distr, _orbits_transversals_from_bsgs,\n    _handle_precomputed_bsgs\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/util.html"
  },
  {
    "name": "_handle_precomputed_bsgs",
    "full_id": "sympy.combinatorics.util._handle_precomputed_bsgs",
    "type": "function",
    "description": "\n    Calculate BSGS-related structures from those present.\n\n    Explanation\n    ===========\n\n    The base and strong generating set must be provided; if any of the\n    transversals, basic orbits or distributed strong generators are not\n    provided, they will be calculated from the base and strong generating set.\n\n    Parameters\n    ==========\n\n    base : the base\n    strong_gens : the strong generators\n    transversals : basic transversals\n    basic_orbits : basic orbits\n    strong_gens_distr : strong generators distributed by membership in basic stabilizers\n\n    Returns\n    =======\n\n    (transversals, basic_orbits, strong_gens_distr)\n        where *transversals* are the basic transversals, *basic_orbits* are the\n        basic orbits, and *strong_gens_distr* are the strong generators distributed\n        by membership in basic stabilizers.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import DihedralGroup\n    >>> from sympy.combinatorics.util import _handle_precomputed_bsgs\n    >>> D = DihedralGroup(3)\n    >>> D.schreier_sims()\n    >>> _handle_precomputed_bsgs(D.base, D.strong_gens,\n    ... basic_orbits=D.basic_orbits)\n    ([{0: (2), 1: (0 1 2), 2: (0 2)}, {1: (2), 2: (1 2)}], [[0, 1, 2], [1, 2]], [[(0 1 2), (0 2), (1 2)], [(1 2)]])\n\n    See Also\n    ========\n\n    _orbits_transversals_from_bsgs, _distribute_gens_by_base\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/util.html"
  },
  {
    "name": "_orbits_transversals_from_bsgs",
    "full_id": "sympy.combinatorics.util._orbits_transversals_from_bsgs",
    "type": "function",
    "description": "\n    Compute basic orbits and transversals from a base and strong generating set.\n\n    Explanation\n    ===========\n\n    The generators are provided as distributed across the basic stabilizers.\n    If the optional argument ``transversals_only`` is set to True, only the\n    transversals are returned.\n\n    Parameters\n    ==========\n\n    base : The base.\n    strong_gens_distr : Strong generators distributed by membership in basic stabilizers.\n    transversals_only : bool, default: False\n        A flag switching between returning only the\n        transversals and both orbits and transversals.\n    slp : bool, default: False\n        If ``True``, return a list of dictionaries containing the\n        generator presentations of the elements of the transversals,\n        i.e. the list of indices of generators from ``strong_gens_distr[i]``\n        such that their product is the relevant transversal element.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import SymmetricGroup\n    >>> from sympy.combinatorics.util import _distribute_gens_by_base\n    >>> S = SymmetricGroup(3)\n    >>> S.schreier_sims()\n    >>> strong_gens_distr = _distribute_gens_by_base(S.base, S.strong_gens)\n    >>> (S.base, strong_gens_distr)\n    ([0, 1], [[(0 1 2), (2)(0 1), (1 2)], [(1 2)]])\n\n    See Also\n    ========\n\n    _distribute_gens_by_base, _handle_precomputed_bsgs\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/util.html"
  },
  {
    "name": "_remove_gens",
    "full_id": "sympy.combinatorics.util._remove_gens",
    "type": "function",
    "description": "\n    Remove redundant generators from a strong generating set.\n\n    Parameters\n    ==========\n\n    base : a base\n    strong_gens : a strong generating set relative to *base*\n    basic_orbits : basic orbits\n    strong_gens_distr : strong generators distributed by membership in basic stabilizers\n\n    Returns\n    =======\n\n    A strong generating set with respect to ``base`` which is a subset of\n    ``strong_gens``.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import SymmetricGroup\n    >>> from sympy.combinatorics.util import _remove_gens\n    >>> from sympy.combinatorics.testutil import _verify_bsgs\n    >>> S = SymmetricGroup(15)\n    >>> base, strong_gens = S.schreier_sims_incremental()\n    >>> new_gens = _remove_gens(base, strong_gens)\n    >>> len(new_gens)\n    14\n    >>> _verify_bsgs(S, base, new_gens)\n    True\n\n    Notes\n    =====\n\n    This procedure is outlined in [1],p.95.\n\n    References\n    ==========\n\n    .. [1] Holt, D., Eick, B., O'Brien, E.\n           \"Handbook of computational group theory\"\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/util.html"
  },
  {
    "name": "_strip",
    "full_id": "sympy.combinatorics.util._strip",
    "type": "function",
    "description": "\n    Attempt to decompose a permutation using a (possibly partial) BSGS\n    structure.\n\n    Explanation\n    ===========\n\n    This is done by treating the sequence ``base`` as an actual base, and\n    the orbits ``orbits`` and transversals ``transversals`` as basic orbits and\n    transversals relative to it.\n\n    This process is called \"sifting\". A sift is unsuccessful when a certain\n    orbit element is not found or when after the sift the decomposition\n    does not end with the identity element.\n\n    The argument ``transversals`` is a list of dictionaries that provides\n    transversal elements for the orbits ``orbits``.\n\n    Parameters\n    ==========\n\n    g : permutation to be decomposed\n    base : sequence of points\n    orbits : list\n        A list in which the ``i``-th entry is an orbit of ``base[i]``\n        under some subgroup of the pointwise stabilizer of `\n        `base[0], base[1], ..., base[i - 1]``. The groups themselves are implicit\n        in this function since the only information we need is encoded in the orbits\n        and transversals\n    transversals : list\n        A list of orbit transversals associated with the orbits *orbits*.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import Permutation, SymmetricGroup\n    >>> from sympy.combinatorics.util import _strip\n    >>> S = SymmetricGroup(5)\n    >>> S.schreier_sims()\n    >>> g = Permutation([0, 2, 3, 1, 4])\n    >>> _strip(g, S.base, S.basic_orbits, S.basic_transversals)\n    ((4), 5)\n\n    Notes\n    =====\n\n    The algorithm is described in [1],pp.89-90. The reason for returning\n    both the current state of the element being decomposed and the level\n    at which the sifting ends is that they provide important information for\n    the randomized version of the Schreier-Sims algorithm.\n\n    References\n    ==========\n\n    .. [1] Holt, D., Eick, B., O'Brien, E.\"Handbook of computational group theory\"\n\n    See Also\n    ========\n\n    sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims\n    sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_random\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/util.html"
  },
  {
    "name": "_strong_gens_from_distr",
    "full_id": "sympy.combinatorics.util._strong_gens_from_distr",
    "type": "function",
    "description": "\n    Retrieve strong generating set from generators of basic stabilizers.\n\n    This is just the union of the generators of the first and second basic\n    stabilizers.\n\n    Parameters\n    ==========\n\n    strong_gens_distr : strong generators distributed by membership in basic stabilizers\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics import SymmetricGroup\n    >>> from sympy.combinatorics.util import (_strong_gens_from_distr,\n    ... _distribute_gens_by_base)\n    >>> S = SymmetricGroup(3)\n    >>> S.schreier_sims()\n    >>> S.strong_gens\n    [(0 1 2), (2)(0 1), (1 2)]\n    >>> strong_gens_distr = _distribute_gens_by_base(S.base, S.strong_gens)\n    >>> _strong_gens_from_distr(strong_gens_distr)\n    [(0 1 2), (2)(0 1), (1 2)]\n\n    See Also\n    ========\n\n    _distribute_gens_by_base\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/util.html"
  },
  {
    "name": "DirectProduct",
    "full_id": "sympy.combinatorics.group_constructs.DirectProduct",
    "type": "function",
    "description": "\n    Returns the direct product of several groups as a permutation group.\n\n    Explanation\n    ===========\n\n    This is implemented much like the __mul__ procedure for taking the direct\n    product of two permutation groups, but the idea of shifting the\n    generators is realized in the case of an arbitrary number of groups.\n    A call to DirectProduct(G1, G2, ..., Gn) is generally expected to be faster\n    than a call to G1*G2*...*Gn (and thus the need for this algorithm).\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.group_constructs import DirectProduct\n    >>> from sympy.combinatorics.named_groups import CyclicGroup\n    >>> C = CyclicGroup(4)\n    >>> G = DirectProduct(C, C, C)\n    >>> G.order()\n    64\n\n    See Also\n    ========\n\n    sympy.combinatorics.perm_groups.PermutationGroup.__mul__\n\n    ",
    "section": "Group constructors",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/group_constructs.html"
  },
  {
    "name": "_cmp_perm_lists",
    "full_id": "sympy.combinatorics.testutil._cmp_perm_lists",
    "type": "function",
    "description": "\n    Compare two lists of permutations as sets.\n\n    Explanation\n    ===========\n\n    This is used for testing purposes. Since the array form of a\n    permutation is currently a list, Permutation is not hashable\n    and cannot be put into a set.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.permutations import Permutation\n    >>> from sympy.combinatorics.testutil import _cmp_perm_lists\n    >>> a = Permutation([0, 2, 3, 4, 1])\n    >>> b = Permutation([1, 2, 0, 4, 3])\n    >>> c = Permutation([3, 4, 0, 1, 2])\n    >>> ls1 = [a, b, c]\n    >>> ls2 = [b, c, a]\n    >>> _cmp_perm_lists(ls1, ls2)\n    True\n\n    ",
    "section": "Test Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/testutil.html"
  },
  {
    "name": "_naive_list_centralizer",
    "full_id": "sympy.combinatorics.testutil._naive_list_centralizer",
    "type": "function",
    "description": "No description available",
    "section": "Test Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/testutil.html"
  },
  {
    "name": "_verify_bsgs",
    "full_id": "sympy.combinatorics.testutil._verify_bsgs",
    "type": "function",
    "description": "\n    Verify the correctness of a base and strong generating set.\n\n    Explanation\n    ===========\n\n    This is a naive implementation using the definition of a base and a strong\n    generating set relative to it. There are other procedures for\n    verifying a base and strong generating set, but this one will\n    serve for more robust testing.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import AlternatingGroup\n    >>> from sympy.combinatorics.testutil import _verify_bsgs\n    >>> A = AlternatingGroup(4)\n    >>> A.schreier_sims()\n    >>> _verify_bsgs(A, A.base, A.strong_gens)\n    True\n\n    See Also\n    ========\n\n    sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims\n\n    ",
    "section": "Test Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/testutil.html"
  },
  {
    "name": "_verify_centralizer",
    "full_id": "sympy.combinatorics.testutil._verify_centralizer",
    "type": "function",
    "description": "\n    Verify the centralizer of a group/set/element inside another group.\n\n    This is used for testing ``.centralizer()`` from\n    ``sympy.combinatorics.perm_groups``\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n    ... AlternatingGroup)\n    >>> from sympy.combinatorics.perm_groups import PermutationGroup\n    >>> from sympy.combinatorics.permutations import Permutation\n    >>> from sympy.combinatorics.testutil import _verify_centralizer\n    >>> S = SymmetricGroup(5)\n    >>> A = AlternatingGroup(5)\n    >>> centr = PermutationGroup([Permutation([0, 1, 2, 3, 4])])\n    >>> _verify_centralizer(S, A, centr)\n    True\n\n    See Also\n    ========\n\n    _naive_list_centralizer,\n    sympy.combinatorics.perm_groups.PermutationGroup.centralizer,\n    _cmp_perm_lists\n\n    ",
    "section": "Test Utilities",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/testutil.html"
  },
  {
    "name": "canonicalize",
    "full_id": "sympy.combinatorics.tensor_can.canonicalize",
    "type": "function",
    "description": "\n    canonicalize tensor formed by tensors\n\n    Parameters\n    ==========\n\n    g : permutation representing the tensor\n\n    dummies : list representing the dummy indices\n      it can be a list of dummy indices of the same type\n      or a list of lists of dummy indices, one list for each\n      type of index;\n      the dummy indices must come after the free indices,\n      and put in order contravariant, covariant\n      [d0, -d0, d1,-d1,...]\n\n    msym :  symmetry of the metric(s)\n        it can be an integer or a list;\n        in the first case it is the symmetry of the dummy index metric;\n        in the second case it is the list of the symmetries of the\n        index metric for each type\n\n    v : list, (base_i, gens_i, n_i, sym_i) for tensors of type `i`\n\n    base_i, gens_i : BSGS for tensors of this type.\n        The BSGS should have minimal base under lexicographic ordering;\n        if not, an attempt is made do get the minimal BSGS;\n        in case of failure,\n        canonicalize_naive is used, which is much slower.\n\n    n_i :    number of tensors of type `i`.\n\n    sym_i :  symmetry under exchange of component tensors of type `i`.\n\n        Both for msym and sym_i the cases are\n            * None  no symmetry\n            * 0     commuting\n            * 1     anticommuting\n\n    Returns\n    =======\n\n    0 if the tensor is zero, else return the array form of\n    the permutation representing the canonical form of the tensor.\n\n    Algorithm\n    =========\n\n    First one uses canonical_free to get the minimum tensor under\n    lexicographic order, using only the slot symmetries.\n    If the component tensors have not minimal BSGS, it is attempted\n    to find it; if the attempt fails canonicalize_naive\n    is used instead.\n\n    Compute the residual slot symmetry keeping fixed the free indices\n    using tensor_gens(base, gens, list_free_indices, sym).\n\n    Reduce the problem eliminating the free indices.\n\n    Then use double_coset_can_rep and lift back the result reintroducing\n    the free indices.\n\n    Examples\n    ========\n\n    one type of index with commuting metric;\n\n    `A_{a b}` and `B_{a b}` antisymmetric and commuting\n\n    `T = A_{d0 d1} * B^{d0}{}_{d2} * B^{d2 d1}`\n\n    `ord = [d0,-d0,d1,-d1,d2,-d2]` order of the indices\n\n    g = [1, 3, 0, 5, 4, 2, 6, 7]\n\n    `T_c = 0`\n\n    >>> from sympy.combinatorics.tensor_can import get_symmetric_group_sgs, canonicalize, bsgs_direct_product\n    >>> from sympy.combinatorics import Permutation\n    >>> base2a, gens2a = get_symmetric_group_sgs(2, 1)\n    >>> t0 = (base2a, gens2a, 1, 0)\n    >>> t1 = (base2a, gens2a, 2, 0)\n    >>> g = Permutation([1, 3, 0, 5, 4, 2, 6, 7])\n    >>> canonicalize(g, range(6), 0, t0, t1)\n    0\n\n    same as above, but with `B_{a b}` anticommuting\n\n    `T_c = -A^{d0 d1} * B_{d0}{}^{d2} * B_{d1 d2}`\n\n    can = [0,2,1,4,3,5,7,6]\n\n    >>> t1 = (base2a, gens2a, 2, 1)\n    >>> canonicalize(g, range(6), 0, t0, t1)\n    [0, 2, 1, 4, 3, 5, 7, 6]\n\n    two types of indices `[a,b,c,d,e,f]` and `[m,n]`, in this order,\n    both with commuting metric\n\n    `f^{a b c}` antisymmetric, commuting\n\n    `A_{m a}` no symmetry, commuting\n\n    `T = f^c{}_{d a} * f^f{}_{e b} * A_m{}^d * A^{m b} * A_n{}^a * A^{n e}`\n\n    ord = [c,f,a,-a,b,-b,d,-d,e,-e,m,-m,n,-n]\n\n    g = [0,7,3, 1,9,5, 11,6, 10,4, 13,2, 12,8, 14,15]\n\n    The canonical tensor is\n    `T_c = -f^{c a b} * f^{f d e} * A^m{}_a * A_{m d} * A^n{}_b * A_{n e}`\n\n    can = [0,2,4, 1,6,8, 10,3, 11,7, 12,5, 13,9, 15,14]\n\n    >>> base_f, gens_f = get_symmetric_group_sgs(3, 1)\n    >>> base1, gens1 = get_symmetric_group_sgs(1)\n    >>> base_A, gens_A = bsgs_direct_product(base1, gens1, base1, gens1)\n    >>> t0 = (base_f, gens_f, 2, 0)\n    >>> t1 = (base_A, gens_A, 4, 0)\n    >>> dummies = [range(2, 10), range(10, 14)]\n    >>> g = Permutation([0, 7, 3, 1, 9, 5, 11, 6, 10, 4, 13, 2, 12, 8, 14, 15])\n    >>> canonicalize(g, dummies, [0, 0], t0, t1)\n    [0, 2, 4, 1, 6, 8, 10, 3, 11, 7, 12, 5, 13, 9, 15, 14]\n    ",
    "section": "Tensor Canonicalization",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/tensor_can.html"
  },
  {
    "name": "double_coset_can_rep",
    "full_id": "sympy.combinatorics.tensor_can.double_coset_can_rep",
    "type": "function",
    "description": "\n    Butler-Portugal algorithm for tensor canonicalization with dummy indices.\n\n    Parameters\n    ==========\n\n      dummies\n        list of lists of dummy indices,\n        one list for each type of index;\n        the dummy indices are put in order contravariant, covariant\n        [d0, -d0, d1, -d1, ...].\n\n      sym\n        list of the symmetries of the index metric for each type.\n\n      possible symmetries of the metrics\n              * 0     symmetric\n              * 1     antisymmetric\n              * None  no symmetry\n\n      b_S\n        base of a minimal slot symmetry BSGS.\n\n      sgens\n        generators of the slot symmetry BSGS.\n\n      S_transversals\n        transversals for the slot BSGS.\n\n      g\n        permutation representing the tensor.\n\n    Returns\n    =======\n\n    Return 0 if the tensor is zero, else return the array form of\n    the permutation representing the canonical form of the tensor.\n\n    Notes\n    =====\n\n    A tensor with dummy indices can be represented in a number\n    of equivalent ways which typically grows exponentially with\n    the number of indices. To be able to establish if two tensors\n    with many indices are equal becomes computationally very slow\n    in absence of an efficient algorithm.\n\n    The Butler-Portugal algorithm [3] is an efficient algorithm to\n    put tensors in canonical form, solving the above problem.\n\n    Portugal observed that a tensor can be represented by a permutation,\n    and that the class of tensors equivalent to it under slot and dummy\n    symmetries is equivalent to the double coset `D*g*S`\n    (Note: in this documentation we use the conventions for multiplication\n    of permutations p, q with (p*q)(i) = p[q[i]] which is opposite\n    to the one used in the Permutation class)\n\n    Using the algorithm by Butler to find a representative of the\n    double coset one can find a canonical form for the tensor.\n\n    To see this correspondence,\n    let `g` be a permutation in array form; a tensor with indices `ind`\n    (the indices including both the contravariant and the covariant ones)\n    can be written as\n\n    `t = T(ind[g[0]], \\dots, ind[g[n-1]])`,\n\n    where `n = len(ind)`;\n    `g` has size `n + 2`, the last two indices for the sign of the tensor\n    (trick introduced in [4]).\n\n    A slot symmetry transformation `s` is a permutation acting on the slots\n    `t \\rightarrow T(ind[(g*s)[0]], \\dots, ind[(g*s)[n-1]])`\n\n    A dummy symmetry transformation acts on `ind`\n    `t \\rightarrow T(ind[(d*g)[0]], \\dots, ind[(d*g)[n-1]])`\n\n    Being interested only in the transformations of the tensor under\n    these symmetries, one can represent the tensor by `g`, which transforms\n    as\n\n    `g -> d*g*s`, so it belongs to the coset `D*g*S`, or in other words\n    to the set of all permutations allowed by the slot and dummy symmetries.\n\n    Let us explain the conventions by an example.\n\n    Given a tensor `T^{d3 d2 d1}{}_{d1 d2 d3}` with the slot symmetries\n          `T^{a0 a1 a2 a3 a4 a5} = -T^{a2 a1 a0 a3 a4 a5}`\n\n          `T^{a0 a1 a2 a3 a4 a5} = -T^{a4 a1 a2 a3 a0 a5}`\n\n    and symmetric metric, find the tensor equivalent to it which\n    is the lowest under the ordering of indices:\n    lexicographic ordering `d1, d2, d3` and then contravariant\n    before covariant index; that is the canonical form of the tensor.\n\n    The canonical form is `-T^{d1 d2 d3}{}_{d1 d2 d3}`\n    obtained using `T^{a0 a1 a2 a3 a4 a5} = -T^{a2 a1 a0 a3 a4 a5}`.\n\n    To convert this problem in the input for this function,\n    use the following ordering of the index names\n    (- for covariant for short) `d1, -d1, d2, -d2, d3, -d3`\n\n    `T^{d3 d2 d1}{}_{d1 d2 d3}` corresponds to `g = [4, 2, 0, 1, 3, 5, 6, 7]`\n    where the last two indices are for the sign\n\n    `sgens = [Permutation(0, 2)(6, 7), Permutation(0, 4)(6, 7)]`\n\n    sgens[0] is the slot symmetry `-(0, 2)`\n    `T^{a0 a1 a2 a3 a4 a5} = -T^{a2 a1 a0 a3 a4 a5}`\n\n    sgens[1] is the slot symmetry `-(0, 4)`\n    `T^{a0 a1 a2 a3 a4 a5} = -T^{a4 a1 a2 a3 a0 a5}`\n\n    The dummy symmetry group D is generated by the strong base generators\n    `[(0, 1), (2, 3), (4, 5), (0, 2)(1, 3), (0, 4)(1, 5)]`\n    where the first three interchange covariant and contravariant\n    positions of the same index (d1 <-> -d1) and the last two interchange\n    the dummy indices themselves (d1 <-> d2).\n\n    The dummy symmetry acts from the left\n    `d = [1, 0, 2, 3, 4, 5, 6, 7]`  exchange `d1 \\leftrightarrow -d1`\n    `T^{d3 d2 d1}{}_{d1 d2 d3} == T^{d3 d2}{}_{d1}{}^{d1}{}_{d2 d3}`\n\n    `g=[4, 2, 0, 1, 3, 5, 6, 7]  -> [4, 2, 1, 0, 3, 5, 6, 7] = _af_rmul(d, g)`\n    which differs from `_af_rmul(g, d)`.\n\n    The slot symmetry acts from the right\n    `s = [2, 1, 0, 3, 4, 5, 7, 6]`  exchanges slots 0 and 2 and changes sign\n    `T^{d3 d2 d1}{}_{d1 d2 d3} == -T^{d1 d2 d3}{}_{d1 d2 d3}`\n\n    `g=[4,2,0,1,3,5,6,7]  -> [0, 2, 4, 1, 3, 5, 7, 6] = _af_rmul(g, s)`\n\n    Example in which the tensor is zero, same slot symmetries as above:\n    `T^{d2}{}_{d1 d3}{}^{d1 d3}{}_{d2}`\n\n    `= -T^{d3}{}_{d1 d3}{}^{d1 d2}{}_{d2}`   under slot symmetry `-(0,4)`;\n\n    `= T_{d3 d1}{}^{d3}{}^{d1 d2}{}_{d2}`    under slot symmetry `-(0,2)`;\n\n    `= T^{d3}{}_{d1 d3}{}^{d1 d2}{}_{d2}`    symmetric metric;\n\n    `= 0`  since two of these lines have tensors differ only for the sign.\n\n    The double coset D*g*S consists of permutations `h = d*g*s` corresponding\n    to equivalent tensors; if there are two `h` which are the same apart\n    from the sign, return zero; otherwise\n    choose as representative the tensor with indices\n    ordered lexicographically according to `[d1, -d1, d2, -d2, d3, -d3]`\n    that is ``rep = min(D*g*S) = min([d*g*s for d in D for s in S])``\n\n    The indices are fixed one by one; first choose the lowest index\n    for slot 0, then the lowest remaining index for slot 1, etc.\n    Doing this one obtains a chain of stabilizers\n\n    `S \\rightarrow S_{b0} \\rightarrow S_{b0,b1} \\rightarrow \\dots` and\n    `D \\rightarrow D_{p0} \\rightarrow D_{p0,p1} \\rightarrow \\dots`\n\n    where ``[b0, b1, ...] = range(b)`` is a base of the symmetric group;\n    the strong base `b_S` of S is an ordered sublist of it;\n    therefore it is sufficient to compute once the\n    strong base generators of S using the Schreier-Sims algorithm;\n    the stabilizers of the strong base generators are the\n    strong base generators of the stabilizer subgroup.\n\n    ``dbase = [p0, p1, ...]`` is not in general in lexicographic order,\n    so that one must recompute the strong base generators each time;\n    however this is trivial, there is no need to use the Schreier-Sims\n    algorithm for D.\n\n    The algorithm keeps a TAB of elements `(s_i, d_i, h_i)`\n    where `h_i = d_i \\times g \\times s_i` satisfying `h_i[j] = p_j` for `0 \\le j < i`\n    starting from `s_0 = id, d_0 = id, h_0 = g`.\n\n    The equations `h_0[0] = p_0, h_1[1] = p_1, \\dots` are solved in this order,\n    choosing each time the lowest possible value of p_i\n\n    For `j < i`\n    `d_i*g*s_i*S_{b_0, \\dots, b_{i-1}}*b_j = D_{p_0, \\dots, p_{i-1}}*p_j`\n    so that for dx in `D_{p_0,\\dots,p_{i-1}}` and sx in\n    `S_{base[0], \\dots, base[i-1]}` one has `dx*d_i*g*s_i*sx*b_j = p_j`\n\n    Search for dx, sx such that this equation holds for `j = i`;\n    it can be written as `s_i*sx*b_j = J, dx*d_i*g*J = p_j`\n    `sx*b_j = s_i**-1*J; sx = trace(s_i**-1, S_{b_0,...,b_{i-1}})`\n    `dx**-1*p_j = d_i*g*J; dx = trace(d_i*g*J, D_{p_0,...,p_{i-1}})`\n\n    `s_{i+1} = s_i*trace(s_i**-1*J, S_{b_0,...,b_{i-1}})`\n    `d_{i+1} = trace(d_i*g*J, D_{p_0,...,p_{i-1}})**-1*d_i`\n    `h_{i+1}*b_i = d_{i+1}*g*s_{i+1}*b_i = p_i`\n\n    `h_n*b_j = p_j` for all j, so that `h_n` is the solution.\n\n    Add the found `(s, d, h)` to TAB1.\n\n    At the end of the iteration sort TAB1 with respect to the `h`;\n    if there are two consecutive `h` in TAB1 which differ only for the\n    sign, the tensor is zero, so return 0;\n    if there are two consecutive `h` which are equal, keep only one.\n\n    Then stabilize the slot generators under `i` and the dummy generators\n    under `p_i`.\n\n    Assign `TAB = TAB1` at the end of the iteration step.\n\n    At the end `TAB` contains a unique `(s, d, h)`, since all the slots\n    of the tensor `h` have been fixed to have the minimum value according\n    to the symmetries. The algorithm returns `h`.\n\n    It is important that the slot BSGS has lexicographic minimal base,\n    otherwise there is an `i` which does not belong to the slot base\n    for which `p_i` is fixed by the dummy symmetry only, while `i`\n    is not invariant from the slot stabilizer, so `p_i` is not in\n    general the minimal value.\n\n    This algorithm differs slightly from the original algorithm [3]:\n      the canonical form is minimal lexicographically, and\n      the BSGS has minimal base under lexicographic order.\n      Equal tensors `h` are eliminated from TAB.\n\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.permutations import Permutation\n    >>> from sympy.combinatorics.tensor_can import double_coset_can_rep, get_transversals\n    >>> gens = [Permutation(x) for x in [[2, 1, 0, 3, 4, 5, 7, 6], [4, 1, 2, 3, 0, 5, 7, 6]]]\n    >>> base = [0, 2]\n    >>> g = Permutation([4, 2, 0, 1, 3, 5, 6, 7])\n    >>> transversals = get_transversals(base, gens)\n    >>> double_coset_can_rep([list(range(6))], [0], base, gens, transversals, g)\n    [0, 1, 2, 3, 4, 5, 7, 6]\n\n    >>> g = Permutation([4, 1, 3, 0, 5, 2, 6, 7])\n    >>> double_coset_can_rep([list(range(6))], [0], base, gens, transversals, g)\n    0\n    ",
    "section": "Tensor Canonicalization",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/tensor_can.html"
  },
  {
    "name": "get_symmetric_group_sgs",
    "full_id": "sympy.combinatorics.tensor_can.get_symmetric_group_sgs",
    "type": "function",
    "description": "\n    Return base, gens of the minimal BSGS for (anti)symmetric tensor\n\n    Parameters\n    ==========\n\n    n : rank of the tensor\n    antisym : bool\n        ``antisym = False`` symmetric tensor\n        ``antisym = True``  antisymmetric tensor\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.tensor_can import get_symmetric_group_sgs\n    >>> get_symmetric_group_sgs(3)\n    ([0, 1], [(4)(0 1), (4)(1 2)])\n    ",
    "section": "Tensor Canonicalization",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/tensor_can.html"
  },
  {
    "name": "bsgs_direct_product",
    "full_id": "sympy.combinatorics.tensor_can.bsgs_direct_product",
    "type": "function",
    "description": "\n    Direct product of two BSGS.\n\n    Parameters\n    ==========\n\n    base1 : base of the first BSGS.\n\n    gens1 : strong generating sequence of the first BSGS.\n\n    base2, gens2 : similarly for the second BSGS.\n\n    signed : flag for signed permutations.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.tensor_can import (get_symmetric_group_sgs, bsgs_direct_product)\n    >>> base1, gens1 = get_symmetric_group_sgs(1)\n    >>> base2, gens2 = get_symmetric_group_sgs(2)\n    >>> bsgs_direct_product(base1, gens1, base2, gens2)\n    ([1], [(4)(1 2)])\n    ",
    "section": "Tensor Canonicalization",
    "url": "https://docs.sympy.org/latest/modules/combinatorics/tensor_can.html"
  },
  {
    "name": "as_base_exp",
    "full_id": "sympy.core.function.Function.as_base_exp",
    "type": "method",
    "description": "\n        Returns the method as the 2-tuple (base, exponent).\n        ",
    "section": "Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/index.html"
  },
  {
    "name": "fdiff",
    "full_id": "sympy.core.function.Function.fdiff",
    "type": "method",
    "description": "\n        Returns the first derivative of the function.\n        ",
    "section": "Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/index.html"
  },
  {
    "name": "is_singular",
    "full_id": "sympy.core.function.Function.is_singular",
    "type": "method",
    "description": "\n        Tests whether the argument is an essential singularity\n        or a branch point, or the functions is non-holomorphic.\n        ",
    "section": "Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/index.html"
  },
  {
    "name": "as_real_imag",
    "full_id": "sympy.functions.elementary.complexes.re.as_real_imag",
    "type": "method",
    "description": "\n        Returns the real number with a zero imaginary part.\n\n        ",
    "section": "Complex Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "as_real_imag",
    "full_id": "sympy.functions.elementary.complexes.im.as_real_imag",
    "type": "method",
    "description": "\n        Return the imaginary part with a zero real part.\n\n        ",
    "section": "Complex Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "fdiff",
    "full_id": "sympy.functions.elementary.complexes.Abs.fdiff",
    "type": "method",
    "description": "\n        Get the first derivative of the argument to Abs().\n\n        ",
    "section": "Complex Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "inverse",
    "full_id": "sympy.functions.elementary.trigonometric.tan.inverse",
    "type": "method",
    "description": "\n        Returns the inverse of this function.\n        ",
    "section": "Trigonometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "as_real_imag",
    "full_id": "sympy.functions.elementary.hyperbolic.sinh.as_real_imag",
    "type": "method",
    "description": "\n        Returns this function as a complex coordinate.\n        ",
    "section": "Hyperbolic Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "fdiff",
    "full_id": "sympy.functions.elementary.hyperbolic.sinh.fdiff",
    "type": "method",
    "description": "\n        Returns the first derivative of this function.\n        ",
    "section": "Hyperbolic Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "taylor_term",
    "full_id": "sympy.functions.elementary.hyperbolic.sinh.taylor_term",
    "type": "method",
    "description": "\n        Returns the next term in the Taylor series expansion.\n        ",
    "section": "Hyperbolic Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "fdiff",
    "full_id": "sympy.functions.elementary.hyperbolic.csch.fdiff",
    "type": "method",
    "description": "\n        Returns the first derivative of this function\n        ",
    "section": "Hyperbolic Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "taylor_term",
    "full_id": "sympy.functions.elementary.hyperbolic.csch.taylor_term",
    "type": "method",
    "description": "\n        Returns the next term in the Taylor series expansion\n        ",
    "section": "Hyperbolic Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "as_real_imag",
    "full_id": "sympy.functions.elementary.exponential.exp.as_real_imag",
    "type": "method",
    "description": "\n        Returns this function as a 2-tuple representing a complex number.\n\n        Examples\n        ========\n\n        >>> from sympy import exp, I\n        >>> from sympy.abc import x\n        >>> exp(x).as_real_imag()\n        (exp(re(x))*cos(im(x)), exp(re(x))*sin(im(x)))\n        >>> exp(1).as_real_imag()\n        (E, 0)\n        >>> exp(I).as_real_imag()\n        (cos(1), sin(1))\n        >>> exp(1+I).as_real_imag()\n        (E*cos(1), E*sin(1))\n\n        See Also\n        ========\n\n        sympy.functions.elementary.complexes.re\n        sympy.functions.elementary.complexes.im\n        ",
    "section": "Exponential",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "base",
    "full_id": "sympy.functions.elementary.exponential.exp.base",
    "type": "property",
    "description": "\n        Returns the base of the exponential function.\n        ",
    "section": "Exponential",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "taylor_term",
    "full_id": "sympy.functions.elementary.exponential.exp.taylor_term",
    "type": "method",
    "description": "\n        Calculates the next term in the Taylor series expansion.\n        ",
    "section": "Exponential",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "fdiff",
    "full_id": "sympy.functions.elementary.exponential.LambertW.fdiff",
    "type": "method",
    "description": "\n        Return the first derivative of this function.\n        ",
    "section": "Exponential",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "as_base_exp",
    "full_id": "sympy.functions.elementary.exponential.log.as_base_exp",
    "type": "method",
    "description": "\n        Returns this function in the form (base, exponent).\n        ",
    "section": "Exponential",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "as_real_imag",
    "full_id": "sympy.functions.elementary.exponential.log.as_real_imag",
    "type": "method",
    "description": "\n        Returns this function as a complex coordinate.\n\n        Examples\n        ========\n\n        >>> from sympy import I, log\n        >>> from sympy.abc import x\n        >>> log(x).as_real_imag()\n        (log(Abs(x)), arg(x))\n        >>> log(I).as_real_imag()\n        (0, pi/2)\n        >>> log(1 + I).as_real_imag()\n        (log(sqrt(2)), pi/4)\n        >>> log(I*x).as_real_imag()\n        (log(Abs(x)), arg(I*x))\n\n        ",
    "section": "Exponential",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "inverse",
    "full_id": "sympy.functions.elementary.exponential.log.inverse",
    "type": "method",
    "description": "\n        Returns `e^x`, the inverse function of `\\log(x)`.\n        ",
    "section": "Exponential",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "taylor_term",
    "full_id": "sympy.functions.elementary.exponential.log.taylor_term",
    "type": "method",
    "description": "\n        Returns the next term in the Taylor series expansion of `\\log(1+x)`.\n        ",
    "section": "Exponential",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "cond",
    "full_id": "sympy.functions.elementary.piecewise.ExprCondPair.cond",
    "type": "property",
    "description": "\n        Returns the condition of this pair.\n        ",
    "section": "Piecewise",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "expr",
    "full_id": "sympy.functions.elementary.piecewise.ExprCondPair.expr",
    "type": "property",
    "description": "\n        Returns the expression of this pair.\n        ",
    "section": "Piecewise",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "_eval_integral",
    "full_id": "sympy.functions.elementary.piecewise.Piecewise._eval_integral",
    "type": "method",
    "description": "Return the indefinite integral of the\n        Piecewise such that subsequent substitution of x with a\n        value will give the value of the integral (not including\n        the constant of integration) up to that point. To only\n        integrate the individual parts of Piecewise, use the\n        ``piecewise_integrate`` method.\n\n        Examples\n        ========\n\n        >>> from sympy import Piecewise\n        >>> from sympy.abc import x\n        >>> p = Piecewise((0, x < 0), (1, x < 1), (2, True))\n        >>> p.integrate(x)\n        Piecewise((0, x < 0), (x, x < 1), (2*x - 1, True))\n        >>> p.piecewise_integrate(x)\n        Piecewise((0, x < 0), (x, x < 1), (2*x, True))\n\n        See Also\n        ========\n        Piecewise.piecewise_integrate\n        ",
    "section": "Piecewise",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "as_expr_set_pairs",
    "full_id": "sympy.functions.elementary.piecewise.Piecewise.as_expr_set_pairs",
    "type": "method",
    "description": "Return tuples for each argument of self that give\n        the expression and the interval in which it is valid\n        which is contained within the given domain.\n        If a condition cannot be converted to a set, an error\n        will be raised. The variable of the conditions is\n        assumed to be real; sets of real values are returned.\n\n        Examples\n        ========\n\n        >>> from sympy import Piecewise, Interval\n        >>> from sympy.abc import x\n        >>> p = Piecewise(\n        ...     (1, x < 2),\n        ...     (2,(x > 0) & (x < 4)),\n        ...     (3, True))\n        >>> p.as_expr_set_pairs()\n        [(1, Interval.open(-oo, 2)),\n         (2, Interval.Ropen(2, 4)),\n         (3, Interval(4, oo))]\n        >>> p.as_expr_set_pairs(Interval(0, 3))\n        [(1, Interval.Ropen(0, 2)),\n         (2, Interval(2, 3))]\n        ",
    "section": "Piecewise",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.functions.elementary.piecewise.Piecewise.doit",
    "type": "method",
    "description": "\n        Evaluate this piecewise function.\n        ",
    "section": "Piecewise",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.functions.elementary.piecewise.Piecewise.eval",
    "type": "method",
    "description": "Either return a modified version of the args or, if no\n        modifications were made, return None.\n\n        Modifications that are made here:\n\n        1. relationals are made canonical\n        2. any False conditions are dropped\n        3. any repeat of a previous condition is ignored\n        4. any args past one with a true condition are dropped\n\n        If there are no args left, nan will be returned.\n        If there is a single arg with a True condition, its\n        corresponding expression will be returned.\n\n        EXAMPLES\n        ========\n\n        >>> from sympy import Piecewise\n        >>> from sympy.abc import x\n        >>> cond = -x < -1\n        >>> args = [(1, cond), (4, cond), (3, False), (2, True), (5, x < 1)]\n        >>> Piecewise(*args, evaluate=False)\n        Piecewise((1, -x < -1), (4, -x < -1), (2, True))\n        >>> Piecewise(*args)\n        Piecewise((1, x > 1), (2, True))\n        ",
    "section": "Piecewise",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "piecewise_integrate",
    "full_id": "sympy.functions.elementary.piecewise.Piecewise.piecewise_integrate",
    "type": "method",
    "description": "Return the Piecewise with each expression being\n        replaced with its antiderivative. To obtain a continuous\n        antiderivative, use the :func:`~.integrate` function or method.\n\n        Examples\n        ========\n\n        >>> from sympy import Piecewise\n        >>> from sympy.abc import x\n        >>> p = Piecewise((0, x < 0), (1, x < 1), (2, True))\n        >>> p.piecewise_integrate(x)\n        Piecewise((0, x < 0), (x, x < 1), (2*x, True))\n\n        Note that this does not give a continuous function, e.g.\n        at x = 1 the 3rd condition applies and the antiderivative\n        there is 2*x so the value of the antiderivative is 2:\n\n        >>> anti = _\n        >>> anti.subs(x, 1)\n        2\n\n        The continuous derivative accounts for the integral *up to*\n        the point of interest, however:\n\n        >>> p.integrate(x)\n        Piecewise((0, x < 0), (x, x < 1), (2*x - 1, True))\n        >>> _.subs(x, 1)\n        1\n\n        See Also\n        ========\n        Piecewise._eval_integral\n        ",
    "section": "Piecewise",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "piecewise_exclusive",
    "full_id": "sympy.functions.elementary.piecewise.piecewise_exclusive",
    "type": "function",
    "description": "\n    Rewrite :class:`Piecewise` with mutually exclusive conditions.\n\n    Explanation\n    ===========\n\n    SymPy represents the conditions of a :class:`Piecewise` in an\n    \"if-elif\"-fashion, allowing more than one condition to be simultaneously\n    True. The interpretation is that the first condition that is True is the\n    case that holds. While this is a useful representation computationally it\n    is not how a piecewise formula is typically shown in a mathematical text.\n    The :func:`piecewise_exclusive` function can be used to rewrite any\n    :class:`Piecewise` with more typical mutually exclusive conditions.\n\n    Note that further manipulation of the resulting :class:`Piecewise`, e.g.\n    simplifying it, will most likely make it non-exclusive. Hence, this is\n    primarily a function to be used in conjunction with printing the Piecewise\n    or if one would like to reorder the expression-condition pairs.\n\n    If it is not possible to determine that all possibilities are covered by\n    the different cases of the :class:`Piecewise` then a final\n    :class:`~sympy.core.numbers.NaN` case will be included explicitly. This\n    can be prevented by passing ``skip_nan=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import piecewise_exclusive, Symbol, Piecewise, S\n    >>> x = Symbol('x', real=True)\n    >>> p = Piecewise((0, x < 0), (S.Half, x <= 0), (1, True))\n    >>> piecewise_exclusive(p)\n    Piecewise((0, x < 0), (1/2, Eq(x, 0)), (1, x > 0))\n    >>> piecewise_exclusive(Piecewise((2, x > 1)))\n    Piecewise((2, x > 1), (nan, x <= 1))\n    >>> piecewise_exclusive(Piecewise((2, x > 1)), skip_nan=True)\n    Piecewise((2, x > 1))\n\n    Parameters\n    ==========\n\n    expr: a SymPy expression.\n        Any :class:`Piecewise` in the expression will be rewritten.\n    skip_nan: ``bool`` (default ``False``)\n        If ``skip_nan`` is set to ``True`` then a final\n        :class:`~sympy.core.numbers.NaN` case will not be included.\n    deep:  ``bool`` (default ``True``)\n        If ``deep`` is ``True`` then :func:`piecewise_exclusive` will rewrite\n        any :class:`Piecewise` subexpressions in ``expr`` rather than just\n        rewriting ``expr`` itself.\n\n    Returns\n    =======\n\n    An expression equivalent to ``expr`` but where all :class:`Piecewise` have\n    been rewritten with mutually exclusive conditions.\n\n    See Also\n    ========\n\n    Piecewise\n    piecewise_fold\n    ",
    "section": "Piecewise",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "piecewise_fold",
    "full_id": "sympy.functions.elementary.piecewise.piecewise_fold",
    "type": "function",
    "description": "\n    Takes an expression containing a piecewise function and returns the\n    expression in piecewise form. In addition, any ITE conditions are\n    rewritten in negation normal form and simplified.\n\n    The final Piecewise is evaluated (default) but if the raw form\n    is desired, send ``evaluate=False``; if trivial evaluation is\n    desired, send ``evaluate=None`` and duplicate conditions and\n    processing of True and False will be handled.\n\n    Examples\n    ========\n\n    >>> from sympy import Piecewise, piecewise_fold, S\n    >>> from sympy.abc import x\n    >>> p = Piecewise((x, x < 1), (1, S(1) <= x))\n    >>> piecewise_fold(x*p)\n    Piecewise((x**2, x < 1), (x, True))\n\n    See Also\n    ========\n\n    Piecewise\n    piecewise_exclusive\n    ",
    "section": "Piecewise",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "root",
    "full_id": "sympy.functions.elementary.miscellaneous.root",
    "type": "function",
    "description": "Returns the *k*-th *n*-th root of ``arg``.\n\n    Parameters\n    ==========\n\n    k : int, optional\n        Should be an integer in $\\{0, 1, ..., n-1\\}$.\n        Defaults to the principal root if $0$.\n\n    evaluate : bool, optional\n        The parameter determines if the expression should be evaluated.\n        If ``None``, its value is taken from\n        ``global_parameters.evaluate``.\n\n    Examples\n    ========\n\n    >>> from sympy import root, Rational\n    >>> from sympy.abc import x, n\n\n    >>> root(x, 2)\n    sqrt(x)\n\n    >>> root(x, 3)\n    x**(1/3)\n\n    >>> root(x, n)\n    x**(1/n)\n\n    >>> root(x, -Rational(2, 3))\n    x**(-3/2)\n\n    To get the k-th n-th root, specify k:\n\n    >>> root(-2, 3, 2)\n    -(-1)**(2/3)*2**(1/3)\n\n    To get all n n-th roots you can use the rootof function.\n    The following examples show the roots of unity for n\n    equal 2, 3 and 4:\n\n    >>> from sympy import rootof\n\n    >>> [rootof(x**2 - 1, i) for i in range(2)]\n    [-1, 1]\n\n    >>> [rootof(x**3 - 1,i) for i in range(3)]\n    [1, -1/2 - sqrt(3)*I/2, -1/2 + sqrt(3)*I/2]\n\n    >>> [rootof(x**4 - 1,i) for i in range(4)]\n    [-1, 1, -I, I]\n\n    SymPy, like other symbolic algebra systems, returns the\n    complex root of negative numbers. This is the principal\n    root and differs from the text-book result that one might\n    be expecting. For example, the cube root of -8 does not\n    come back as -2:\n\n    >>> root(-8, 3)\n    2*(-1)**(1/3)\n\n    The real_root function can be used to either make the principal\n    result real (or simply to return the real root directly):\n\n    >>> from sympy import real_root\n    >>> real_root(_)\n    -2\n    >>> real_root(-32, 5)\n    -2\n\n    Alternatively, the n//2-th n-th root of a negative number can be\n    computed with root:\n\n    >>> root(-32, 5, 5//2)\n    -2\n\n    See Also\n    ========\n\n    sympy.polys.rootoftools.rootof\n    sympy.core.intfunc.integer_nthroot\n    sqrt, real_root\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Square_root\n    .. [2] https://en.wikipedia.org/wiki/Real_root\n    .. [3] https://en.wikipedia.org/wiki/Root_of_unity\n    .. [4] https://en.wikipedia.org/wiki/Principal_value\n    .. [5] https://mathworld.wolfram.com/CubeRoot.html\n\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "sqrt",
    "full_id": "sympy.functions.elementary.miscellaneous.sqrt",
    "type": "function",
    "description": "Returns the principal square root.\n\n    Parameters\n    ==========\n\n    evaluate : bool, optional\n        The parameter determines if the expression should be evaluated.\n        If ``None``, its value is taken from\n        ``global_parameters.evaluate``.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt, Symbol, S\n    >>> x = Symbol('x')\n\n    >>> sqrt(x)\n    sqrt(x)\n\n    >>> sqrt(x)**2\n    x\n\n    Note that sqrt(x**2) does not simplify to x.\n\n    >>> sqrt(x**2)\n    sqrt(x**2)\n\n    This is because the two are not equal to each other in general.\n    For example, consider x == -1:\n\n    >>> from sympy import Eq\n    >>> Eq(sqrt(x**2), x).subs(x, -1)\n    False\n\n    This is because sqrt computes the principal square root, so the square may\n    put the argument in a different branch.  This identity does hold if x is\n    positive:\n\n    >>> y = Symbol('y', positive=True)\n    >>> sqrt(y**2)\n    y\n\n    You can force this simplification by using the powdenest() function with\n    the force option set to True:\n\n    >>> from sympy import powdenest\n    >>> sqrt(x**2)\n    sqrt(x**2)\n    >>> powdenest(sqrt(x**2), force=True)\n    x\n\n    To get both branches of the square root you can use the rootof function:\n\n    >>> from sympy import rootof\n\n    >>> [rootof(x**2-3,i) for i in (0,1)]\n    [-sqrt(3), sqrt(3)]\n\n    Although ``sqrt`` is printed, there is no ``sqrt`` function so looking for\n    ``sqrt`` in an expression will fail:\n\n    >>> from sympy.utilities.misc import func_name\n    >>> func_name(sqrt(x))\n    'Pow'\n    >>> sqrt(x).has(sqrt)\n    False\n\n    To find ``sqrt`` look for ``Pow`` with an exponent of ``1/2``:\n\n    >>> (x + 1/sqrt(x)).find(lambda i: i.is_Pow and abs(i.exp) is S.Half)\n    {1/sqrt(x)}\n\n    See Also\n    ========\n\n    sympy.polys.rootoftools.rootof, root, real_root\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Square_root\n    .. [2] https://en.wikipedia.org/wiki/Principal_value\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "cbrt",
    "full_id": "sympy.functions.elementary.miscellaneous.cbrt",
    "type": "function",
    "description": "Returns the principal cube root.\n\n    Parameters\n    ==========\n\n    evaluate : bool, optional\n        The parameter determines if the expression should be evaluated.\n        If ``None``, its value is taken from\n        ``global_parameters.evaluate``.\n\n    Examples\n    ========\n\n    >>> from sympy import cbrt, Symbol\n    >>> x = Symbol('x')\n\n    >>> cbrt(x)\n    x**(1/3)\n\n    >>> cbrt(x)**3\n    x\n\n    Note that cbrt(x**3) does not simplify to x.\n\n    >>> cbrt(x**3)\n    (x**3)**(1/3)\n\n    This is because the two are not equal to each other in general.\n    For example, consider `x == -1`:\n\n    >>> from sympy import Eq\n    >>> Eq(cbrt(x**3), x).subs(x, -1)\n    False\n\n    This is because cbrt computes the principal cube root, this\n    identity does hold if `x` is positive:\n\n    >>> y = Symbol('y', positive=True)\n    >>> cbrt(y**3)\n    y\n\n    See Also\n    ========\n\n    sympy.polys.rootoftools.rootof, root, real_root\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Cube_root\n    .. [2] https://en.wikipedia.org/wiki/Principal_value\n\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "real_root",
    "full_id": "sympy.functions.elementary.miscellaneous.real_root",
    "type": "function",
    "description": "Return the real *n*'th-root of *arg* if possible.\n\n    Parameters\n    ==========\n\n    n : int or None, optional\n        If *n* is ``None``, then all instances of\n        $(-n)^{1/\\text{odd}}$ will be changed to $-n^{1/\\text{odd}}$.\n        This will only create a real root of a principal root.\n        The presence of other factors may cause the result to not be\n        real.\n\n    evaluate : bool, optional\n        The parameter determines if the expression should be evaluated.\n        If ``None``, its value is taken from\n        ``global_parameters.evaluate``.\n\n    Examples\n    ========\n\n    >>> from sympy import root, real_root\n\n    >>> real_root(-8, 3)\n    -2\n    >>> root(-8, 3)\n    2*(-1)**(1/3)\n    >>> real_root(_)\n    -2\n\n    If one creates a non-principal root and applies real_root, the\n    result will not be real (so use with caution):\n\n    >>> root(-8, 3, 2)\n    -2*(-1)**(2/3)\n    >>> real_root(_)\n    -2*(-1)**(2/3)\n\n    See Also\n    ========\n\n    sympy.polys.rootoftools.rootof\n    sympy.core.intfunc.integer_nthroot\n    root, sqrt\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/functions/elementary.html"
  },
  {
    "name": "stirling",
    "full_id": "sympy.functions.combinatorial.numbers.stirling",
    "type": "function",
    "description": "Return Stirling number $S(n, k)$ of the first or second (default) kind.\n\n    The sum of all Stirling numbers of the second kind for $k = 1$\n    through $n$ is ``bell(n)``. The recurrence relationship for these numbers\n    is:\n\n    .. math :: {0 \\brace 0} = 1; {n \\brace 0} = {0 \\brace k} = 0;\n\n    .. math :: {{n+1} \\brace k} = j {n \\brace k} + {n \\brace {k-1}}\n\n    where $j$ is:\n        $n$ for Stirling numbers of the first kind,\n        $-n$ for signed Stirling numbers of the first kind,\n        $k$ for Stirling numbers of the second kind.\n\n    The first kind of Stirling number counts the number of permutations of\n    ``n`` distinct items that have ``k`` cycles; the second kind counts the\n    ways in which ``n`` distinct items can be partitioned into ``k`` parts.\n    If ``d`` is given, the \"reduced Stirling number of the second kind\" is\n    returned: $S^{d}(n, k) = S(n - d + 1, k - d + 1)$ with $n \\ge k \\ge d$.\n    (This counts the ways to partition $n$ consecutive integers into $k$\n    groups with no pairwise difference less than $d$. See example below.)\n\n    To obtain the signed Stirling numbers of the first kind, use keyword\n    ``signed=True``. Using this keyword automatically sets ``kind`` to 1.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import stirling, bell\n    >>> from sympy.combinatorics import Permutation\n    >>> from sympy.utilities.iterables import multiset_partitions, permutations\n\n    First kind (unsigned by default):\n\n    >>> [stirling(6, i, kind=1) for i in range(7)]\n    [0, 120, 274, 225, 85, 15, 1]\n    >>> perms = list(permutations(range(4)))\n    >>> [sum(Permutation(p).cycles == i for p in perms) for i in range(5)]\n    [0, 6, 11, 6, 1]\n    >>> [stirling(4, i, kind=1) for i in range(5)]\n    [0, 6, 11, 6, 1]\n\n    First kind (signed):\n\n    >>> [stirling(4, i, signed=True) for i in range(5)]\n    [0, -6, 11, -6, 1]\n\n    Second kind:\n\n    >>> [stirling(10, i) for i in range(12)]\n    [0, 1, 511, 9330, 34105, 42525, 22827, 5880, 750, 45, 1, 0]\n    >>> sum(_) == bell(10)\n    True\n    >>> len(list(multiset_partitions(range(4), 2))) == stirling(4, 2)\n    True\n\n    Reduced second kind:\n\n    >>> from sympy import subsets, oo\n    >>> def delta(p):\n    ...    if len(p) == 1:\n    ...        return oo\n    ...    return min(abs(i[0] - i[1]) for i in subsets(p, 2))\n    >>> parts = multiset_partitions(range(5), 3)\n    >>> d = 2\n    >>> sum(1 for p in parts if all(delta(i) >= d for i in p))\n    7\n    >>> stirling(5, 3, 2)\n    7\n\n    See Also\n    ========\n    sympy.utilities.iterables.multiset_partitions\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind\n    .. [2] https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\n\n    ",
    "section": "Combinatorial",
    "url": "https://docs.sympy.org/latest/modules/functions/combinatorial.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.functions.special.delta_functions.DiracDelta.eval",
    "type": "method",
    "description": "\n        Returns a simplified form or a value of DiracDelta depending on the\n        argument passed by the DiracDelta object.\n\n        Explanation\n        ===========\n\n        The ``eval()`` method is automatically called when the ``DiracDelta``\n        class is about to be instantiated and it returns either some simplified\n        instance or the unevaluated instance depending on the argument passed.\n        In other words, ``eval()`` method is not needed to be called explicitly,\n        it is being called and evaluated once the object is called.\n\n        Examples\n        ========\n\n        >>> from sympy import DiracDelta, S\n        >>> from sympy.abc import x\n\n        >>> DiracDelta(x)\n        DiracDelta(x)\n\n        >>> DiracDelta(-x, 1)\n        -DiracDelta(x, 1)\n\n        >>> DiracDelta(1)\n        0\n\n        >>> DiracDelta(5, 1)\n        0\n\n        >>> DiracDelta(0)\n        DiracDelta(0)\n\n        >>> DiracDelta(-1)\n        0\n\n        >>> DiracDelta(S.NaN)\n        nan\n\n        >>> DiracDelta(x - 100).subs(x, 5)\n        0\n\n        >>> DiracDelta(x - 100).subs(x, 100)\n        DiracDelta(0)\n\n        Parameters\n        ==========\n\n        k : integer\n            order of derivative\n\n        arg : argument passed to DiracDelta\n\n        ",
    "section": "Dirac Delta and Related Discontinuous Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "fdiff",
    "full_id": "sympy.functions.special.delta_functions.DiracDelta.fdiff",
    "type": "method",
    "description": "\n        Returns the first derivative of a DiracDelta Function.\n\n        Explanation\n        ===========\n\n        The difference between ``diff()`` and ``fdiff()`` is: ``diff()`` is the\n        user-level function and ``fdiff()`` is an object method. ``fdiff()`` is\n        a convenience method available in the ``Function`` class. It returns\n        the derivative of the function without considering the chain rule.\n        ``diff(function, x)`` calls ``Function._eval_derivative`` which in turn\n        calls ``fdiff()`` internally to compute the derivative of the function.\n\n        Examples\n        ========\n\n        >>> from sympy import DiracDelta, diff\n        >>> from sympy.abc import x\n\n        >>> DiracDelta(x).fdiff()\n        DiracDelta(x, 1)\n\n        >>> DiracDelta(x, 1).fdiff()\n        DiracDelta(x, 2)\n\n        >>> DiracDelta(x**2 - 1).fdiff()\n        DiracDelta(x**2 - 1, 1)\n\n        >>> diff(DiracDelta(x, 1)).fdiff()\n        DiracDelta(x, 3)\n\n        Parameters\n        ==========\n\n        argindex : integer\n            degree of derivative\n\n        ",
    "section": "Dirac Delta and Related Discontinuous Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "is_simple",
    "full_id": "sympy.functions.special.delta_functions.DiracDelta.is_simple",
    "type": "method",
    "description": "\n        Tells whether the argument(args[0]) of DiracDelta is a linear\n        expression in *x*.\n\n        Examples\n        ========\n\n        >>> from sympy import DiracDelta, cos\n        >>> from sympy.abc import x, y\n\n        >>> DiracDelta(x*y).is_simple(x)\n        True\n        >>> DiracDelta(x*y).is_simple(y)\n        True\n\n        >>> DiracDelta(x**2 + x - 2).is_simple(x)\n        False\n\n        >>> DiracDelta(cos(x)).is_simple(x)\n        False\n\n        Parameters\n        ==========\n\n        x : can be a symbol\n\n        See Also\n        ========\n\n        sympy.simplify.simplify.simplify, DiracDelta\n\n        ",
    "section": "Dirac Delta and Related Discontinuous Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.functions.special.delta_functions.Heaviside.eval",
    "type": "method",
    "description": "\n        Returns a simplified form or a value of Heaviside depending on the\n        argument passed by the Heaviside object.\n\n        Explanation\n        ===========\n\n        The ``eval()`` method is automatically called when the ``Heaviside``\n        class is about to be instantiated and it returns either some simplified\n        instance or the unevaluated instance depending on the argument passed.\n        In other words, ``eval()`` method is not needed to be called explicitly,\n        it is being called and evaluated once the object is called.\n\n        Examples\n        ========\n\n        >>> from sympy import Heaviside, S\n        >>> from sympy.abc import x\n\n        >>> Heaviside(x)\n        Heaviside(x)\n\n        >>> Heaviside(19)\n        1\n\n        >>> Heaviside(0)\n        1/2\n\n        >>> Heaviside(0, 1)\n        1\n\n        >>> Heaviside(-5)\n        0\n\n        >>> Heaviside(S.NaN)\n        nan\n\n        >>> Heaviside(x - 100).subs(x, 5)\n        0\n\n        >>> Heaviside(x - 100).subs(x, 105)\n        1\n\n        Parameters\n        ==========\n\n        arg : argument passed by Heaviside object\n\n        H0 : value of Heaviside(0)\n\n        ",
    "section": "Dirac Delta and Related Discontinuous Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "fdiff",
    "full_id": "sympy.functions.special.delta_functions.Heaviside.fdiff",
    "type": "method",
    "description": "\n        Returns the first derivative of a Heaviside Function.\n\n        Examples\n        ========\n\n        >>> from sympy import Heaviside, diff\n        >>> from sympy.abc import x\n\n        >>> Heaviside(x).fdiff()\n        DiracDelta(x)\n\n        >>> Heaviside(x**2 - 1).fdiff()\n        DiracDelta(x**2 - 1)\n\n        >>> diff(Heaviside(x)).fdiff()\n        DiracDelta(x, 1)\n\n        Parameters\n        ==========\n\n        argindex : integer\n            order of derivative\n\n        ",
    "section": "Dirac Delta and Related Discontinuous Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "pargs",
    "full_id": "sympy.functions.special.delta_functions.Heaviside.pargs",
    "type": "property",
    "description": "Args without default S.Half",
    "section": "Dirac Delta and Related Discontinuous Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.functions.special.singularity_functions.SingularityFunction.eval",
    "type": "method",
    "description": "\n        Returns a simplified form or a value of Singularity Function depending\n        on the argument passed by the object.\n\n        Explanation\n        ===========\n\n        The ``eval()`` method is automatically called when the\n        ``SingularityFunction`` class is about to be instantiated and it\n        returns either some simplified instance or the unevaluated instance\n        depending on the argument passed. In other words, ``eval()`` method is\n        not needed to be called explicitly, it is being called and evaluated\n        once the object is called.\n\n        Examples\n        ========\n\n        >>> from sympy import SingularityFunction, Symbol, nan\n        >>> from sympy.abc import x, a, n\n        >>> SingularityFunction(x, a, n)\n        SingularityFunction(x, a, n)\n        >>> SingularityFunction(5, 3, 2)\n        4\n        >>> SingularityFunction(x, a, nan)\n        nan\n        >>> SingularityFunction(x, 3, 0).subs(x, 3)\n        1\n        >>> SingularityFunction(4, 1, 5)\n        243\n        >>> x = Symbol('x', positive = True)\n        >>> a = Symbol('a', negative = True)\n        >>> n = Symbol('n', nonnegative = True)\n        >>> SingularityFunction(x, a, n)\n        (-a + x)**n\n        >>> x = Symbol('x', negative = True)\n        >>> a = Symbol('a', positive = True)\n        >>> SingularityFunction(x, a, n)\n        0\n\n        ",
    "section": "Dirac Delta and Related Discontinuous Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "fdiff",
    "full_id": "sympy.functions.special.singularity_functions.SingularityFunction.fdiff",
    "type": "method",
    "description": "\n        Returns the first derivative of a DiracDelta Function.\n\n        Explanation\n        ===========\n\n        The difference between ``diff()`` and ``fdiff()`` is: ``diff()`` is the\n        user-level function and ``fdiff()`` is an object method. ``fdiff()`` is\n        a convenience method available in the ``Function`` class. It returns\n        the derivative of the function without considering the chain rule.\n        ``diff(function, x)`` calls ``Function._eval_derivative`` which in turn\n        calls ``fdiff()`` internally to compute the derivative of the function.\n\n        ",
    "section": "Dirac Delta and Related Discontinuous Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "E1",
    "full_id": "sympy.functions.special.error_functions.E1",
    "type": "function",
    "description": "\n    Classical case of the generalized exponential integral.\n\n    Explanation\n    ===========\n\n    This is equivalent to ``expint(1, z)``.\n\n    Examples\n    ========\n\n    >>> from sympy import E1\n    >>> E1(0)\n    expint(1, 0)\n\n    >>> E1(5)\n    expint(1, 5)\n\n    See Also\n    ========\n\n    Ei: Exponential integral.\n    expint: Generalised exponential integral.\n    li: Logarithmic integral.\n    Li: Offset logarithmic integral.\n    Si: Sine integral.\n    Ci: Cosine integral.\n    Shi: Hyperbolic sine integral.\n    Chi: Hyperbolic cosine integral.\n\n    ",
    "section": "Exponential, Logarithmic and Trigonometric Integrals",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "argument",
    "full_id": "sympy.functions.special.bessel.BesselBase.argument",
    "type": "property",
    "description": "The argument of the Bessel-type function.",
    "section": "Bessel Type Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "order",
    "full_id": "sympy.functions.special.bessel.BesselBase.order",
    "type": "property",
    "description": "The order of the Bessel-type function.",
    "section": "Bessel Type Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "jn_zeros",
    "full_id": "sympy.functions.special.bessel.jn_zeros",
    "type": "function",
    "description": "\n    Zeros of the spherical Bessel function of the first kind.\n\n    Explanation\n    ===========\n\n    This returns an array of zeros of $jn$ up to the $k$-th zero.\n\n    * method = \"sympy\": uses `mpmath.besseljzero\n      <https://mpmath.org/doc/current/functions/bessel.html#mpmath.besseljzero>`_\n    * method = \"scipy\": uses the\n      `SciPy's sph_jn <https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jn_zeros.html>`_\n      and\n      `newton <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html>`_\n      to find all\n      roots, which is faster than computing the zeros using a general\n      numerical solver, but it requires SciPy and only works with low\n      precision floating point numbers. (The function used with\n      method=\"sympy\" is a recent addition to mpmath; before that a general\n      solver was used.)\n\n    Examples\n    ========\n\n    >>> from sympy import jn_zeros\n    >>> jn_zeros(2, 4, dps=5)\n    [5.7635, 9.095, 12.323, 15.515]\n\n    See Also\n    ========\n\n    jn, yn, besselj, besselk, bessely\n\n    Parameters\n    ==========\n\n    n : integer\n        order of Bessel function\n\n    k : integer\n        number of zeros to return\n\n\n    ",
    "section": "Bessel Type Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "bspline_basis",
    "full_id": "sympy.functions.special.bsplines.bspline_basis",
    "type": "function",
    "description": "\n    The $n$-th B-spline at $x$ of degree $d$ with knots.\n\n    Explanation\n    ===========\n\n    B-Splines are piecewise polynomials of degree $d$. They are defined on a\n    set of knots, which is a sequence of integers or floats.\n\n    Examples\n    ========\n\n    The 0th degree splines have a value of 1 on a single interval:\n\n        >>> from sympy import bspline_basis\n        >>> from sympy.abc import x\n        >>> d = 0\n        >>> knots = tuple(range(5))\n        >>> bspline_basis(d, knots, 0, x)\n        Piecewise((1, (x >= 0) & (x <= 1)), (0, True))\n\n    For a given ``(d, knots)`` there are ``len(knots)-d-1`` B-splines\n    defined, that are indexed by ``n`` (starting at 0).\n\n    Here is an example of a cubic B-spline:\n\n        >>> bspline_basis(3, tuple(range(5)), 0, x)\n        Piecewise((x**3/6, (x >= 0) & (x <= 1)),\n                  (-x**3/2 + 2*x**2 - 2*x + 2/3,\n                  (x >= 1) & (x <= 2)),\n                  (x**3/2 - 4*x**2 + 10*x - 22/3,\n                  (x >= 2) & (x <= 3)),\n                  (-x**3/6 + 2*x**2 - 8*x + 32/3,\n                  (x >= 3) & (x <= 4)),\n                  (0, True))\n\n    By repeating knot points, you can introduce discontinuities in the\n    B-splines and their derivatives:\n\n        >>> d = 1\n        >>> knots = (0, 0, 2, 3, 4)\n        >>> bspline_basis(d, knots, 0, x)\n        Piecewise((1 - x/2, (x >= 0) & (x <= 2)), (0, True))\n\n    It is quite time consuming to construct and evaluate B-splines. If\n    you need to evaluate a B-spline many times, it is best to lambdify them\n    first:\n\n        >>> from sympy import lambdify\n        >>> d = 3\n        >>> knots = tuple(range(10))\n        >>> b0 = bspline_basis(d, knots, 0, x)\n        >>> f = lambdify(x, b0)\n        >>> y = f(0.5)\n\n    Parameters\n    ==========\n\n    d : integer\n        degree of bspline\n\n    knots : list of integer values\n        list of knots points of bspline\n\n    n : integer\n        $n$-th B-spline\n\n    x : symbol\n\n    See Also\n    ========\n\n    bspline_basis_set\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/B-spline\n\n    ",
    "section": "B-Splines",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "bspline_basis_set",
    "full_id": "sympy.functions.special.bsplines.bspline_basis_set",
    "type": "function",
    "description": "\n    Return the ``len(knots)-d-1`` B-splines at *x* of degree *d*\n    with *knots*.\n\n    Explanation\n    ===========\n\n    This function returns a list of piecewise polynomials that are the\n    ``len(knots)-d-1`` B-splines of degree *d* for the given knots.\n    This function calls ``bspline_basis(d, knots, n, x)`` for different\n    values of *n*.\n\n    Examples\n    ========\n\n    >>> from sympy import bspline_basis_set\n    >>> from sympy.abc import x\n    >>> d = 2\n    >>> knots = range(5)\n    >>> splines = bspline_basis_set(d, knots, x)\n    >>> splines\n    [Piecewise((x**2/2, (x >= 0) & (x <= 1)),\n               (-x**2 + 3*x - 3/2, (x >= 1) & (x <= 2)),\n               (x**2/2 - 3*x + 9/2, (x >= 2) & (x <= 3)),\n               (0, True)),\n    Piecewise((x**2/2 - x + 1/2, (x >= 1) & (x <= 2)),\n              (-x**2 + 5*x - 11/2, (x >= 2) & (x <= 3)),\n              (x**2/2 - 4*x + 8, (x >= 3) & (x <= 4)),\n              (0, True))]\n\n    Parameters\n    ==========\n\n    d : integer\n        degree of bspline\n\n    knots : list of integers\n        list of knots points of bspline\n\n    x : symbol\n\n    See Also\n    ========\n\n    bspline_basis\n\n    ",
    "section": "B-Splines",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "interpolating_spline",
    "full_id": "sympy.functions.special.bsplines.interpolating_spline",
    "type": "function",
    "description": "\n    Return spline of degree *d*, passing through the given *X*\n    and *Y* values.\n\n    Explanation\n    ===========\n\n    This function returns a piecewise function such that each part is\n    a polynomial of degree not greater than *d*. The value of *d*\n    must be 1 or greater and the values of *X* must be strictly\n    increasing.\n\n    Examples\n    ========\n\n    >>> from sympy import interpolating_spline\n    >>> from sympy.abc import x\n    >>> interpolating_spline(1, x, [1, 2, 4, 7], [3, 6, 5, 7])\n    Piecewise((3*x, (x >= 1) & (x <= 2)),\n            (7 - x/2, (x >= 2) & (x <= 4)),\n            (2*x/3 + 7/3, (x >= 4) & (x <= 7)))\n    >>> interpolating_spline(3, x, [-2, 0, 1, 3, 4], [4, 2, 1, 1, 3])\n    Piecewise((7*x**3/117 + 7*x**2/117 - 131*x/117 + 2, (x >= -2) & (x <= 1)),\n            (10*x**3/117 - 2*x**2/117 - 122*x/117 + 77/39, (x >= 1) & (x <= 4)))\n\n    Parameters\n    ==========\n\n    d : integer\n        Degree of Bspline strictly greater than equal to one\n\n    x : symbol\n\n    X : list of strictly increasing real values\n        list of X coordinates through which the spline passes\n\n    Y : list of real values\n        list of corresponding Y coordinates through which the spline passes\n\n    See Also\n    ========\n\n    bspline_basis_set, interpolating_poly\n\n    ",
    "section": "B-Splines",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "ap",
    "full_id": "sympy.functions.special.hyper.hyper.ap",
    "type": "property",
    "description": "Numerator parameters of the hypergeometric function.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "argument",
    "full_id": "sympy.functions.special.hyper.hyper.argument",
    "type": "property",
    "description": "Argument of the hypergeometric function.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "bq",
    "full_id": "sympy.functions.special.hyper.hyper.bq",
    "type": "property",
    "description": "Denominator parameters of the hypergeometric function.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "convergence_statement",
    "full_id": "sympy.functions.special.hyper.hyper.convergence_statement",
    "type": "property",
    "description": "Return a condition on z under which the series converges.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "eta",
    "full_id": "sympy.functions.special.hyper.hyper.eta",
    "type": "property",
    "description": "A quantity related to the convergence of the series.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "radius_of_convergence",
    "full_id": "sympy.functions.special.hyper.hyper.radius_of_convergence",
    "type": "property",
    "description": "\n        Compute the radius of convergence of the defining series.\n\n        Explanation\n        ===========\n\n        Note that even if this is not ``oo``, the function may still be\n        evaluated outside of the radius of convergence by analytic\n        continuation. But if this is zero, then the function is not actually\n        defined anywhere else.\n\n        Examples\n        ========\n\n        >>> from sympy import hyper\n        >>> from sympy.abc import z\n        >>> hyper((1, 2), [3], z).radius_of_convergence\n        1\n        >>> hyper((1, 2, 3), [4], z).radius_of_convergence\n        0\n        >>> hyper((1, 2), (3, 4), z).radius_of_convergence\n        oo\n\n        ",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "an",
    "full_id": "sympy.functions.special.hyper.meijerg.an",
    "type": "property",
    "description": "First set of numerator parameters.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "aother",
    "full_id": "sympy.functions.special.hyper.meijerg.aother",
    "type": "property",
    "description": "Second set of numerator parameters.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "ap",
    "full_id": "sympy.functions.special.hyper.meijerg.ap",
    "type": "property",
    "description": "Combined numerator parameters.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "argument",
    "full_id": "sympy.functions.special.hyper.meijerg.argument",
    "type": "property",
    "description": "Argument of the Meijer G-function.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "bm",
    "full_id": "sympy.functions.special.hyper.meijerg.bm",
    "type": "property",
    "description": "First set of denominator parameters.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "bother",
    "full_id": "sympy.functions.special.hyper.meijerg.bother",
    "type": "property",
    "description": "Second set of denominator parameters.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "bq",
    "full_id": "sympy.functions.special.hyper.meijerg.bq",
    "type": "property",
    "description": "Combined denominator parameters.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "delta",
    "full_id": "sympy.functions.special.hyper.meijerg.delta",
    "type": "property",
    "description": "A quantity related to the convergence region of the integral,\n        c.f. references.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "get_period",
    "full_id": "sympy.functions.special.hyper.meijerg.get_period",
    "type": "method",
    "description": "\n        Return a number $P$ such that $G(x*exp(I*P)) == G(x)$.\n\n        Examples\n        ========\n\n        >>> from sympy import meijerg, pi, S\n        >>> from sympy.abc import z\n\n        >>> meijerg([1], [], [], [], z).get_period()\n        2*pi\n        >>> meijerg([pi], [], [], [], z).get_period()\n        oo\n        >>> meijerg([1, 2], [], [], [], z).get_period()\n        oo\n        >>> meijerg([1,1], [2], [1, S(1)/2, S(1)/3], [1], z).get_period()\n        12*pi\n\n        ",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "integrand",
    "full_id": "sympy.functions.special.hyper.meijerg.integrand",
    "type": "method",
    "description": "Get the defining integrand D(s).",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "is_number",
    "full_id": "sympy.functions.special.hyper.meijerg.is_number",
    "type": "property",
    "description": "Returns true if expression has numeric data only.",
    "section": "Hypergeometric Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "jacobi_normalized",
    "full_id": "sympy.functions.special.polynomials.jacobi_normalized",
    "type": "function",
    "description": "\n    Jacobi polynomial $P_n^{\\left(\\alpha, \\beta\\right)}(x)$.\n\n    Explanation\n    ===========\n\n    ``jacobi_normalized(n, alpha, beta, x)`` gives the $n$th\n    Jacobi polynomial in $x$, $P_n^{\\left(\\alpha, \\beta\\right)}(x)$.\n\n    The Jacobi polynomials are orthogonal on $[-1, 1]$ with respect\n    to the weight $\\left(1-x\\right)^\\alpha \\left(1+x\\right)^\\beta$.\n\n    This functions returns the polynomials normilzed:\n\n    .. math::\n\n        \\int_{-1}^{1}\n          P_m^{\\left(\\alpha, \\beta\\right)}(x)\n          P_n^{\\left(\\alpha, \\beta\\right)}(x)\n          (1-x)^{\\alpha} (1+x)^{\\beta} \\mathrm{d}x\n        = \\delta_{m,n}\n\n    Examples\n    ========\n\n    >>> from sympy import jacobi_normalized\n    >>> from sympy.abc import n,a,b,x\n\n    >>> jacobi_normalized(n, a, b, x)\n    jacobi(n, a, b, x)/sqrt(2**(a + b + 1)*gamma(a + n + 1)*gamma(b + n + 1)/((a + b + 2*n + 1)*factorial(n)*gamma(a + b + n + 1)))\n\n    Parameters\n    ==========\n\n    n : integer degree of polynomial\n\n    a : alpha value\n\n    b : beta value\n\n    x : symbol\n\n    See Also\n    ========\n\n    gegenbauer,\n    chebyshevt_root, chebyshevu, chebyshevu_root,\n    legendre, assoc_legendre,\n    hermite, hermite_prob,\n    laguerre, assoc_laguerre,\n    sympy.polys.orthopolys.jacobi_poly,\n    sympy.polys.orthopolys.gegenbauer_poly\n    sympy.polys.orthopolys.chebyshevt_poly\n    sympy.polys.orthopolys.chebyshevu_poly\n    sympy.polys.orthopolys.hermite_poly\n    sympy.polys.orthopolys.legendre_poly\n    sympy.polys.orthopolys.laguerre_poly\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Jacobi_polynomials\n    .. [2] https://mathworld.wolfram.com/JacobiPolynomial.html\n    .. [3] https://functions.wolfram.com/Polynomials/JacobiP/\n\n    ",
    "section": "Jacobi Polynomials",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "Ynm_c",
    "full_id": "sympy.functions.special.spherical_harmonics.Ynm_c",
    "type": "function",
    "description": "\n    Conjugate spherical harmonics defined as\n\n    .. math::\n        \\overline{Y_n^m(\\theta, \\varphi)} := (-1)^m Y_n^{-m}(\\theta, \\varphi).\n\n    Examples\n    ========\n\n    >>> from sympy import Ynm_c, Symbol, simplify\n    >>> from sympy.abc import n,m\n    >>> theta = Symbol(\"theta\")\n    >>> phi = Symbol(\"phi\")\n    >>> Ynm_c(n, m, theta, phi)\n    (-1)**(2*m)*exp(-2*I*m*phi)*Ynm(n, m, theta, phi)\n    >>> Ynm_c(n, m, -theta, phi)\n    (-1)**(2*m)*exp(-2*I*m*phi)*Ynm(n, m, theta, phi)\n\n    For specific integers $n$ and $m$ we can evaluate the harmonics\n    to more useful expressions:\n\n    >>> simplify(Ynm_c(0, 0, theta, phi).expand(func=True))\n    1/(2*sqrt(pi))\n    >>> simplify(Ynm_c(1, -1, theta, phi).expand(func=True))\n    sqrt(6)*exp(I*(-phi + 2*conjugate(phi)))*sin(theta)/(4*sqrt(pi))\n\n    See Also\n    ========\n\n    Ynm, Znm\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Spherical_harmonics\n    .. [2] https://mathworld.wolfram.com/SphericalHarmonic.html\n    .. [3] https://functions.wolfram.com/Polynomials/SphericalHarmonicY/\n\n    ",
    "section": "Spherical Harmonics",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "Eijk",
    "full_id": "sympy.functions.special.tensor_functions.Eijk",
    "type": "function",
    "description": "\n    Represent the Levi-Civita symbol.\n\n    This is a compatibility wrapper to ``LeviCivita()``.\n\n    See Also\n    ========\n\n    LeviCivita\n\n    ",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "eval_levicivita",
    "full_id": "sympy.functions.special.tensor_functions.eval_levicivita",
    "type": "function",
    "description": "Evaluate Levi-Civita symbol.",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.functions.special.tensor_functions.KroneckerDelta.eval",
    "type": "method",
    "description": "\n        Evaluates the discrete delta function.\n\n        Examples\n        ========\n\n        >>> from sympy import KroneckerDelta\n        >>> from sympy.abc import i, j, k\n\n        >>> KroneckerDelta(i, j)\n        KroneckerDelta(i, j)\n        >>> KroneckerDelta(i, i)\n        1\n        >>> KroneckerDelta(i, i + 1)\n        0\n        >>> KroneckerDelta(i, i + 1 + k)\n        KroneckerDelta(i, i + k + 1)\n\n        # indirect doctest\n\n        ",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "indices_contain_equal_information",
    "full_id": "sympy.functions.special.tensor_functions.KroneckerDelta.indices_contain_equal_information",
    "type": "property",
    "description": "\n        Returns True if indices are either both above or below fermi.\n\n        Examples\n        ========\n\n        >>> from sympy import KroneckerDelta, Symbol\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n        >>> q = Symbol('q')\n        >>> KroneckerDelta(p, q).indices_contain_equal_information\n        True\n        >>> KroneckerDelta(p, q+1).indices_contain_equal_information\n        True\n        >>> KroneckerDelta(i, p).indices_contain_equal_information\n        False\n\n        ",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "is_above_fermi",
    "full_id": "sympy.functions.special.tensor_functions.KroneckerDelta.is_above_fermi",
    "type": "property",
    "description": "\n        True if Delta can be non-zero above fermi.\n\n        Examples\n        ========\n\n        >>> from sympy import KroneckerDelta, Symbol\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n        >>> q = Symbol('q')\n        >>> KroneckerDelta(p, a).is_above_fermi\n        True\n        >>> KroneckerDelta(p, i).is_above_fermi\n        False\n        >>> KroneckerDelta(p, q).is_above_fermi\n        True\n\n        See Also\n        ========\n\n        is_below_fermi, is_only_below_fermi, is_only_above_fermi\n\n        ",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "is_below_fermi",
    "full_id": "sympy.functions.special.tensor_functions.KroneckerDelta.is_below_fermi",
    "type": "property",
    "description": "\n        True if Delta can be non-zero below fermi.\n\n        Examples\n        ========\n\n        >>> from sympy import KroneckerDelta, Symbol\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n        >>> q = Symbol('q')\n        >>> KroneckerDelta(p, a).is_below_fermi\n        False\n        >>> KroneckerDelta(p, i).is_below_fermi\n        True\n        >>> KroneckerDelta(p, q).is_below_fermi\n        True\n\n        See Also\n        ========\n\n        is_above_fermi, is_only_above_fermi, is_only_below_fermi\n\n        ",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "is_only_above_fermi",
    "full_id": "sympy.functions.special.tensor_functions.KroneckerDelta.is_only_above_fermi",
    "type": "property",
    "description": "\n        True if Delta is restricted to above fermi.\n\n        Examples\n        ========\n\n        >>> from sympy import KroneckerDelta, Symbol\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n        >>> q = Symbol('q')\n        >>> KroneckerDelta(p, a).is_only_above_fermi\n        True\n        >>> KroneckerDelta(p, q).is_only_above_fermi\n        False\n        >>> KroneckerDelta(p, i).is_only_above_fermi\n        False\n\n        See Also\n        ========\n\n        is_above_fermi, is_below_fermi, is_only_below_fermi\n\n        ",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "is_only_below_fermi",
    "full_id": "sympy.functions.special.tensor_functions.KroneckerDelta.is_only_below_fermi",
    "type": "property",
    "description": "\n        True if Delta is restricted to below fermi.\n\n        Examples\n        ========\n\n        >>> from sympy import KroneckerDelta, Symbol\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n        >>> q = Symbol('q')\n        >>> KroneckerDelta(p, i).is_only_below_fermi\n        True\n        >>> KroneckerDelta(p, q).is_only_below_fermi\n        False\n        >>> KroneckerDelta(p, a).is_only_below_fermi\n        False\n\n        See Also\n        ========\n\n        is_above_fermi, is_below_fermi, is_only_above_fermi\n\n        ",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "killable_index",
    "full_id": "sympy.functions.special.tensor_functions.KroneckerDelta.killable_index",
    "type": "property",
    "description": "\n        Returns the index which is preferred to substitute in the final\n        expression.\n\n        Explanation\n        ===========\n\n        The index to substitute is the index with less information regarding\n        fermi level. If indices contain the same information, 'a' is preferred\n        before 'b'.\n\n        Examples\n        ========\n\n        >>> from sympy import KroneckerDelta, Symbol\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> j = Symbol('j', below_fermi=True)\n        >>> p = Symbol('p')\n        >>> KroneckerDelta(p, i).killable_index\n        p\n        >>> KroneckerDelta(p, a).killable_index\n        p\n        >>> KroneckerDelta(i, j).killable_index\n        j\n\n        See Also\n        ========\n\n        preferred_index\n\n        ",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "preferred_index",
    "full_id": "sympy.functions.special.tensor_functions.KroneckerDelta.preferred_index",
    "type": "property",
    "description": "\n        Returns the index which is preferred to keep in the final expression.\n\n        Explanation\n        ===========\n\n        The preferred index is the index with more information regarding fermi\n        level. If indices contain the same information, 'a' is preferred before\n        'b'.\n\n        Examples\n        ========\n\n        >>> from sympy import KroneckerDelta, Symbol\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> j = Symbol('j', below_fermi=True)\n        >>> p = Symbol('p')\n        >>> KroneckerDelta(p, i).preferred_index\n        i\n        >>> KroneckerDelta(p, a).preferred_index\n        a\n        >>> KroneckerDelta(i, j).preferred_index\n        i\n\n        See Also\n        ========\n\n        killable_index\n\n        ",
    "section": "Tensor Functions",
    "url": "https://docs.sympy.org/latest/modules/functions/special.html"
  },
  {
    "name": "_check_antecedents",
    "full_id": "sympy.integrals.meijerint._check_antecedents",
    "type": "function",
    "description": "Return a condition under which the integral theorem applies.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_check_antecedents_1",
    "full_id": "sympy.integrals.meijerint._check_antecedents_1",
    "type": "function",
    "description": "\n    Return a condition under which the mellin transform of g exists.\n    Any power of x has already been absorbed into the G function,\n    so this is just $\\int_0^\\infty g\\, dx$.\n\n    See [L, section 5.6.1]. (Note that s=1.)\n\n    If ``helper`` is True, only check if the MT exists at infinity, i.e. if\n    $\\int_1^\\infty g\\, dx$ exists.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_check_antecedents_inversion",
    "full_id": "sympy.integrals.meijerint._check_antecedents_inversion",
    "type": "function",
    "description": "Check antecedents for the laplace inversion integral.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_condsimp",
    "full_id": "sympy.integrals.meijerint._condsimp",
    "type": "function",
    "description": "\n    Do naive simplifications on ``cond``.\n\n    Explanation\n    ===========\n\n    Note that this routine is completely ad-hoc, simplification rules being\n    added as need arises rather than following any logical pattern.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import _condsimp as simp\n    >>> from sympy import Or, Eq\n    >>> from sympy.abc import x, y\n    >>> simp(Or(x < y, Eq(x, y)))\n    x <= y\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_create_lookup_table",
    "full_id": "sympy.integrals.meijerint._create_lookup_table",
    "type": "function",
    "description": "Add formulae for the function -> meijerg lookup table.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_dummy",
    "full_id": "sympy.integrals.meijerint._dummy",
    "type": "function",
    "description": "\n    Return a dummy. This will return the same dummy if the same token+name is\n    requested more than once, and it is not already in expr.\n    This is for being cache-friendly.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_dummy_",
    "full_id": "sympy.integrals.meijerint._dummy_",
    "type": "function",
    "description": "\n    Return a dummy associated to name and token. Same effect as declaring\n    it globally.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_eval_cond",
    "full_id": "sympy.integrals.meijerint._eval_cond",
    "type": "function",
    "description": "Re-evaluate the conditions.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_exponents",
    "full_id": "sympy.integrals.meijerint._exponents",
    "type": "function",
    "description": "\n    Find the exponents of ``x`` (not including zero) in ``expr``.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import _exponents\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin\n    >>> _exponents(x, x)\n    {1}\n    >>> _exponents(x**2, x)\n    {2}\n    >>> _exponents(x**2 + x, x)\n    {1, 2}\n    >>> _exponents(x**3*sin(x + x**y) + 1/x, x)\n    {-1, 1, 3, y}\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_find_splitting_points",
    "full_id": "sympy.integrals.meijerint._find_splitting_points",
    "type": "function",
    "description": "\n    Find numbers a such that a linear substitution x -> x + a would\n    (hopefully) simplify expr.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import _find_splitting_points as fsp\n    >>> from sympy import sin\n    >>> from sympy.abc import x\n    >>> fsp(x, x)\n    {0}\n    >>> fsp((x-1)**3, x)\n    {1}\n    >>> fsp(sin(x+3)*x, x)\n    {-3, 0}\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_flip_g",
    "full_id": "sympy.integrals.meijerint._flip_g",
    "type": "function",
    "description": "Turn the G function into one of inverse argument\n    (i.e. G(1/x) -> G'(x))",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_functions",
    "full_id": "sympy.integrals.meijerint._functions",
    "type": "function",
    "description": "Find the types of functions in expr, to estimate the complexity.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_get_coeff_exp",
    "full_id": "sympy.integrals.meijerint._get_coeff_exp",
    "type": "function",
    "description": "\n    When expr is known to be of the form c*x**b, with c and/or b possibly 1,\n    return c, b.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, a, b\n    >>> from sympy.integrals.meijerint import _get_coeff_exp\n    >>> _get_coeff_exp(a*x**b, x)\n    (a, b)\n    >>> _get_coeff_exp(x, x)\n    (1, 1)\n    >>> _get_coeff_exp(2*x, x)\n    (2, 1)\n    >>> _get_coeff_exp(x**3, x)\n    (1, 3)\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_guess_expansion",
    "full_id": "sympy.integrals.meijerint._guess_expansion",
    "type": "function",
    "description": "Try to guess sensible rewritings for integrand f(x).",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_inflate_fox_h",
    "full_id": "sympy.integrals.meijerint._inflate_fox_h",
    "type": "function",
    "description": "\n    Let d denote the integrand in the definition of the G function ``g``.\n    Consider the function H which is defined in the same way, but with\n    integrand d/Gamma(a*s) (contour conventions as usual).\n\n    If ``a`` is rational, the function H can be written as C*G, for a constant C\n    and a G-function G.\n\n    This function returns C, G.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_inflate_g",
    "full_id": "sympy.integrals.meijerint._inflate_g",
    "type": "function",
    "description": "Return C, h such that h is a G function of argument z**n and\n    g = C*h.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_int0oo",
    "full_id": "sympy.integrals.meijerint._int0oo",
    "type": "function",
    "description": "\n    Express integral from zero to infinity g1*g2 using a G function,\n    assuming the necessary conditions are fulfilled.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import _int0oo\n    >>> from sympy.abc import s, t, m\n    >>> from sympy import meijerg, S\n    >>> g1 = meijerg([], [], [-S(1)/2, 0], [], s**2*t/4)\n    >>> g2 = meijerg([], [], [m/2], [-m/2], t/4)\n    >>> _int0oo(g1, g2, t)\n    4*meijerg(((0, 1/2), ()), ((m/2,), (-m/2,)), s**(-2))/s**2\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_int0oo_1",
    "full_id": "sympy.integrals.meijerint._int0oo_1",
    "type": "function",
    "description": "\n    Evaluate $\\int_0^\\infty g\\, dx$ using G functions,\n    assuming the necessary conditions are fulfilled.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import a, b, c, d, x, y\n    >>> from sympy import meijerg\n    >>> from sympy.integrals.meijerint import _int0oo_1\n    >>> _int0oo_1(meijerg([a], [b], [c], [d], x*y), x)\n    gamma(-a)*gamma(c + 1)/(y*gamma(-d)*gamma(b + 1))\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_int_inversion",
    "full_id": "sympy.integrals.meijerint._int_inversion",
    "type": "function",
    "description": "\n    Compute the laplace inversion integral, assuming the formula applies.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_is_analytic",
    "full_id": "sympy.integrals.meijerint._is_analytic",
    "type": "function",
    "description": "Check if f(x), when expressed using G functions on the positive reals,\n    will in fact agree with the G functions almost everywhere",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_meijerint_definite_2",
    "full_id": "sympy.integrals.meijerint._meijerint_definite_2",
    "type": "function",
    "description": "\n    Try to integrate f dx from zero to infinity.\n\n    The body of this function computes various 'simplifications'\n    f1, f2, ... of f (e.g. by calling expand_mul(), trigexpand()\n    - see _guess_expansion) and calls _meijerint_definite_3 with each of\n    these in succession.\n    If _meijerint_definite_3 succeeds with any of the simplified functions,\n    returns this result.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_meijerint_definite_3",
    "full_id": "sympy.integrals.meijerint._meijerint_definite_3",
    "type": "function",
    "description": "\n    Try to integrate f dx from zero to infinity.\n\n    This function calls _meijerint_definite_4 to try to compute the\n    integral. If this fails, it tries using linearity.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_meijerint_definite_4",
    "full_id": "sympy.integrals.meijerint._meijerint_definite_4",
    "type": "function",
    "description": "\n    Try to integrate f dx from zero to infinity.\n\n    Explanation\n    ===========\n\n    This function tries to apply the integration theorems found in literature,\n    i.e. it tries to rewrite f as either one or a product of two G-functions.\n\n    The parameter ``only_double`` is used internally in the recursive algorithm\n    to disable trying to rewrite f as a single G-function.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_meijerint_indefinite_1",
    "full_id": "sympy.integrals.meijerint._meijerint_indefinite_1",
    "type": "function",
    "description": "Helper that does not attempt any substitution.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_mul_args",
    "full_id": "sympy.integrals.meijerint._mul_args",
    "type": "function",
    "description": "\n    Return a list ``L`` such that ``Mul(*L) == f``.\n\n    If ``f`` is not a ``Mul`` or ``Pow``, ``L=[f]``.\n    If ``f=g**n`` for an integer ``n``, ``L=[g]*n``.\n    If ``f`` is a ``Mul``, ``L`` comes from applying ``_mul_args`` to all factors of ``f``.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_mul_as_two_parts",
    "full_id": "sympy.integrals.meijerint._mul_as_two_parts",
    "type": "function",
    "description": "\n    Find all the ways to split ``f`` into a product of two terms.\n    Return None on failure.\n\n    Explanation\n    ===========\n\n    Although the order is canonical from multiset_partitions, this is\n    not necessarily the best order to process the terms. For example,\n    if the case of len(gs) == 2 is removed and multiset is allowed to\n    sort the terms, some tests fail.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import _mul_as_two_parts\n    >>> from sympy import sin, exp, ordered\n    >>> from sympy.abc import x\n    >>> list(ordered(_mul_as_two_parts(x*sin(x)*exp(x))))\n    [(x, exp(x)*sin(x)), (x*exp(x), sin(x)), (x*sin(x), exp(x))]\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_my_principal_branch",
    "full_id": "sympy.integrals.meijerint._my_principal_branch",
    "type": "function",
    "description": "Bring expr nearer to its principal branch by removing superfluous\n    factors.\n    This function does *not* guarantee to yield the principal branch,\n    to avoid introducing opaque principal_branch() objects,\n    unless full_pb=True.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_mytype",
    "full_id": "sympy.integrals.meijerint._mytype",
    "type": "function",
    "description": "Create a hashable entity describing the type of f.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_rewrite1",
    "full_id": "sympy.integrals.meijerint._rewrite1",
    "type": "function",
    "description": "\n    Try to rewrite ``f`` using a (sum of) single G functions with argument a*x**b.\n    Return fac, po, g such that f = fac*po*g, fac is independent of ``x``.\n    and po = x**s.\n    Here g is a result from _rewrite_single.\n    Return None on failure.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_rewrite2",
    "full_id": "sympy.integrals.meijerint._rewrite2",
    "type": "function",
    "description": "\n    Try to rewrite ``f`` as a product of two G functions of arguments a*x**b.\n    Return fac, po, g1, g2 such that f = fac*po*g1*g2, where fac is\n    independent of x and po is x**s.\n    Here g1 and g2 are results of _rewrite_single.\n    Returns None on failure.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_rewrite_inversion",
    "full_id": "sympy.integrals.meijerint._rewrite_inversion",
    "type": "function",
    "description": "Absorb ``po`` == x**s into g.",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_rewrite_saxena",
    "full_id": "sympy.integrals.meijerint._rewrite_saxena",
    "type": "function",
    "description": "\n    Rewrite the integral ``fac*po*g1*g2`` from 0 to oo in terms of G\n    functions with argument ``c*x``.\n\n    Explanation\n    ===========\n\n    Return C, f1, f2 such that integral C f1 f2 from 0 to infinity equals\n    integral fac ``po``, ``g1``, ``g2`` from 0 to infinity.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import _rewrite_saxena\n    >>> from sympy.abc import s, t, m\n    >>> from sympy import meijerg\n    >>> g1 = meijerg([], [], [0], [], s*t)\n    >>> g2 = meijerg([], [], [m/2], [-m/2], t**2/4)\n    >>> r = _rewrite_saxena(1, t**0, g1, g2, t)\n    >>> r[0]\n    s/(4*sqrt(pi))\n    >>> r[1]\n    meijerg(((), ()), ((-1/2, 0), ()), s**2*t/4)\n    >>> r[2]\n    meijerg(((), ()), ((m/2,), (-m/2,)), t/4)\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_rewrite_saxena_1",
    "full_id": "sympy.integrals.meijerint._rewrite_saxena_1",
    "type": "function",
    "description": "\n    Rewrite the integral fac*po*g dx, from zero to infinity, as\n    integral fac*G, where G has argument a*x. Note po=x**s.\n    Return fac, G.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_rewrite_single",
    "full_id": "sympy.integrals.meijerint._rewrite_single",
    "type": "function",
    "description": "\n    Try to rewrite f as a sum of single G functions of the form\n    C*x**s*G(a*x**b), where b is a rational number and C is independent of x.\n    We guarantee that result.argument.as_coeff_mul(x) returns (a, (x**b,))\n    or (a, ()).\n    Returns a list of tuples (C, s, G) and a condition cond.\n    Returns None on failure.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "_split_mul",
    "full_id": "sympy.integrals.meijerint._split_mul",
    "type": "function",
    "description": "\n    Split expression ``f`` into fac, po, g, where fac is a constant factor,\n    po = x**s for some s independent of s, and g is \"the rest\".\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import _split_mul\n    >>> from sympy import sin\n    >>> from sympy.abc import s, x\n    >>> _split_mul((3*x)**s*sin(x**2)*x, x)\n    (3**s, x*x**s, sin(x**2))\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "meijerint_definite",
    "full_id": "sympy.integrals.meijerint.meijerint_definite",
    "type": "function",
    "description": "\n    Integrate ``f`` over the interval [``a``, ``b``], by rewriting it as a product\n    of two G functions, or as a single G function.\n\n    Return res, cond, where cond are convergence conditions.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import meijerint_definite\n    >>> from sympy import exp, oo\n    >>> from sympy.abc import x\n    >>> meijerint_definite(exp(-x**2), x, -oo, oo)\n    (sqrt(pi), True)\n\n    This function is implemented as a succession of functions\n    meijerint_definite, _meijerint_definite_2, _meijerint_definite_3,\n    _meijerint_definite_4. Each function in the list calls the next one\n    (presumably) several times. This means that calling meijerint_definite\n    can be very costly.\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "meijerint_indefinite",
    "full_id": "sympy.integrals.meijerint.meijerint_indefinite",
    "type": "function",
    "description": "\n    Compute an indefinite integral of ``f`` by rewriting it as a G function.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.meijerint import meijerint_indefinite\n    >>> from sympy import sin\n    >>> from sympy.abc import x\n    >>> meijerint_indefinite(sin(x), x)\n    -cos(x)\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "meijerint_inversion",
    "full_id": "sympy.integrals.meijerint.meijerint_inversion",
    "type": "function",
    "description": "\n    Compute the inverse laplace transform\n    $\\int_{c+i\\infty}^{c-i\\infty} f(x) e^{tx}\\, dx$,\n    for real c larger than the real part of all singularities of ``f``.\n\n    Note that ``t`` is always assumed real and positive.\n\n    Return None if the integral does not exist or could not be evaluated.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, t\n    >>> from sympy.integrals.meijerint import meijerint_inversion\n    >>> meijerint_inversion(1/x, x, t)\n    Heaviside(t)\n    ",
    "section": "Internal API Reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/g-functions.html"
  },
  {
    "name": "mellin_transform",
    "full_id": "sympy.integrals.transforms.mellin_transform",
    "type": "function",
    "description": "\n    Compute the Mellin transform `F(s)` of `f(x)`,\n\n    .. math :: F(s) = \\int_0^\\infty x^{s-1} f(x) \\mathrm{d}x.\n\n    For all \"sensible\" functions, this converges absolutely in a strip\n      `a < \\operatorname{Re}(s) < b`.\n\n    Explanation\n    ===========\n\n    The Mellin transform is related via change of variables to the Fourier\n    transform, and also to the (bilateral) Laplace transform.\n\n    This function returns ``(F, (a, b), cond)``\n    where ``F`` is the Mellin transform of ``f``, ``(a, b)`` is the fundamental strip\n    (as above), and ``cond`` are auxiliary convergence conditions.\n\n    If the integral cannot be computed in closed form, this function returns\n    an unevaluated :class:`MellinTransform` object.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`. If ``noconds=False``,\n    then only `F` will be returned (i.e. not ``cond``, and also not the strip\n    ``(a, b)``).\n\n    Examples\n    ========\n\n    >>> from sympy import mellin_transform, exp\n    >>> from sympy.abc import x, s\n    >>> mellin_transform(exp(-x), x, s)\n    (gamma(s), (0, oo), True)\n\n    See Also\n    ========\n\n    inverse_mellin_transform, laplace_transform, fourier_transform\n    hankel_transform, inverse_hankel_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "inverse_mellin_transform",
    "full_id": "sympy.integrals.transforms.inverse_mellin_transform",
    "type": "function",
    "description": "\n    Compute the inverse Mellin transform of `F(s)` over the fundamental\n    strip given by ``strip=(a, b)``.\n\n    Explanation\n    ===========\n\n    This can be defined as\n\n    .. math:: f(x) = \\frac{1}{2\\pi i} \\int_{c - i\\infty}^{c + i\\infty} x^{-s} F(s) \\mathrm{d}s,\n\n    for any `c` in the fundamental strip. Under certain regularity\n    conditions on `F` and/or `f`,\n    this recovers `f` from its Mellin transform `F`\n    (and vice versa), for positive real `x`.\n\n    One of `a` or `b` may be passed as ``None``; a suitable `c` will be\n    inferred.\n\n    If the integral cannot be computed in closed form, this function returns\n    an unevaluated :class:`InverseMellinTransform` object.\n\n    Note that this function will assume x to be positive and real, regardless\n    of the SymPy assumptions!\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n\n    Examples\n    ========\n\n    >>> from sympy import inverse_mellin_transform, oo, gamma\n    >>> from sympy.abc import x, s\n    >>> inverse_mellin_transform(gamma(s), s, x, (0, oo))\n    exp(-x)\n\n    The fundamental strip matters:\n\n    >>> f = 1/(s**2 - 1)\n    >>> inverse_mellin_transform(f, s, x, (-oo, -1))\n    x*(1 - 1/x**2)*Heaviside(x - 1)/2\n    >>> inverse_mellin_transform(f, s, x, (-1, 1))\n    -x*Heaviside(1 - x)/2 - Heaviside(x - 1)/(2*x)\n    >>> inverse_mellin_transform(f, s, x, (1, oo))\n    (1/2 - x**2/2)*Heaviside(1 - x)/x\n\n    See Also\n    ========\n\n    mellin_transform\n    hankel_transform, inverse_hankel_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "laplace_transform",
    "full_id": "sympy.integrals.transforms.laplace_transform",
    "type": "function",
    "description": "\n    Compute the Laplace Transform `F(s)` of `f(t)`,\n\n    .. math :: F(s) = \\int_{0^{-}}^\\infty e^{-st} f(t) \\mathrm{d}t.\n\n    Explanation\n    ===========\n\n    For all sensible functions, this converges absolutely in a\n    half-plane\n\n    .. math :: a < \\operatorname{Re}(s)\n\n    This function returns ``(F, a, cond)`` where ``F`` is the Laplace\n    transform of ``f``, `a` is the half-plane of convergence, and `cond` are\n    auxiliary convergence conditions.\n\n    The implementation is rule-based, and if you are interested in which\n    rules are applied, and whether integration is attempted, you can switch\n    debug information on by setting ``sympy.SYMPY_DEBUG=True``. The numbers\n    of the rules in the debug information (and the code) refer to Bateman's\n    Tables of Integral Transforms [1].\n\n    The lower bound is `0-`, meaning that this bound should be approached\n    from the lower side. This is only necessary if distributions are involved.\n    At present, it is only done if `f(t)` contains ``DiracDelta``, in which\n    case the Laplace transform is computed implicitly as\n\n    .. math ::\n        F(s) = \\lim_{\\tau\\to 0^{-}} \\int_{\\tau}^\\infty e^{-st}\n        f(t) \\mathrm{d}t\n\n    by applying rules.\n\n    If the Laplace transform cannot be fully computed in closed form, this\n    function returns expressions containing unevaluated\n    :class:`LaplaceTransform` objects.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`. If\n    ``noconds=True``, only `F` will be returned (i.e. not ``cond``, and also\n    not the plane ``a``).\n\n    .. deprecated:: 1.9\n        Legacy behavior for matrices where ``laplace_transform`` with\n        ``noconds=False`` (the default) returns a Matrix whose elements are\n        tuples. The behavior of ``laplace_transform`` for matrices will change\n        in a future release of SymPy to return a tuple of the transformed\n        Matrix and the convergence conditions for the matrix as a whole. Use\n        ``legacy_matrix=False`` to enable the new behavior.\n\n    Examples\n    ========\n\n    >>> from sympy import DiracDelta, exp, laplace_transform\n    >>> from sympy.abc import t, s, a\n    >>> laplace_transform(t**4, t, s)\n    (24/s**5, 0, True)\n    >>> laplace_transform(t**a, t, s)\n    (gamma(a + 1)/(s*s**a), 0, re(a) > -1)\n    >>> laplace_transform(DiracDelta(t)-a*exp(-a*t), t, s, simplify=True)\n    (s/(a + s), -re(a), True)\n\n    There are also helper functions that make it easy to solve differential\n    equations by Laplace transform. For example, to solve\n\n    .. math :: m x''(t) + d x'(t) + k x(t) = 0\n\n    with initial value `0` and initial derivative `v`:\n\n    >>> from sympy import Function, laplace_correspondence, diff, solve\n    >>> from sympy import laplace_initial_conds, inverse_laplace_transform\n    >>> from sympy.abc import d, k, m, v\n    >>> x = Function('x')\n    >>> X = Function('X')\n    >>> f = m*diff(x(t), t, 2) + d*diff(x(t), t) + k*x(t)\n    >>> F = laplace_transform(f, t, s, noconds=True)\n    >>> F = laplace_correspondence(F, {x: X})\n    >>> F = laplace_initial_conds(F, t, {x: [0, v]})\n    >>> F\n    d*s*X(s) + k*X(s) + m*(s**2*X(s) - v)\n    >>> Xs = solve(F, X(s))[0]\n    >>> Xs\n    m*v/(d*s + k + m*s**2)\n    >>> inverse_laplace_transform(Xs, s, t)\n    2*v*exp(-d*t/(2*m))*sin(t*sqrt((-d**2 + 4*k*m)/m**2)/2)*Heaviside(t)/sqrt((-d**2 + 4*k*m)/m**2)\n\n    References\n    ==========\n\n    .. [1] Erdelyi, A. (ed.), Tables of Integral Transforms, Volume 1,\n           Bateman Manuscript Prooject, McGraw-Hill (1954), available:\n           https://resolver.caltech.edu/CaltechAUTHORS:20140123-101456353\n\n    See Also\n    ========\n\n    inverse_laplace_transform, mellin_transform, fourier_transform\n    hankel_transform, inverse_hankel_transform\n\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "laplace_correspondence",
    "full_id": "sympy.integrals.transforms.laplace_correspondence",
    "type": "function",
    "description": "\n    This helper function takes a function `f` that is the result of a\n    ``laplace_transform`` or an ``inverse_laplace_transform``.  It replaces all\n    unevaluated ``LaplaceTransform(y(t), t, s)`` by `Y(s)` for any `s` and\n    all ``InverseLaplaceTransform(Y(s), s, t)`` by `y(t)` for any `t` if\n    ``fdict`` contains a correspondence ``{y: Y}``.\n\n    Parameters\n    ==========\n\n    f : sympy expression\n        Expression containing unevaluated ``LaplaceTransform`` or\n        ``LaplaceTransform`` objects.\n    fdict : dictionary\n        Dictionary containing one or more function correspondences,\n        e.g., ``{x: X, y: Y}`` meaning that ``X`` and ``Y`` are the\n        Laplace transforms of ``x`` and ``y``, respectively.\n\n    Examples\n    ========\n\n    >>> from sympy import laplace_transform, diff, Function\n    >>> from sympy import laplace_correspondence, inverse_laplace_transform\n    >>> from sympy.abc import t, s\n    >>> y = Function(\"y\")\n    >>> Y = Function(\"Y\")\n    >>> z = Function(\"z\")\n    >>> Z = Function(\"Z\")\n    >>> f = laplace_transform(diff(y(t), t, 1) + z(t), t, s, noconds=True)\n    >>> laplace_correspondence(f, {y: Y, z: Z})\n    s*Y(s) + Z(s) - y(0)\n    >>> f = inverse_laplace_transform(Y(s), s, t)\n    >>> laplace_correspondence(f, {y: Y})\n    y(t)\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "laplace_initial_conds",
    "full_id": "sympy.integrals.transforms.laplace_initial_conds",
    "type": "function",
    "description": "\n    This helper function takes a function `f` that is the result of a\n    ``laplace_transform``.  It takes an fdict of the form ``{y: [1, 4, 2]}``,\n    where the values in the list are the initial value, the initial slope, the\n    initial second derivative, etc., of the function `y(t)`, and replaces all\n    unevaluated initial conditions.\n\n    Parameters\n    ==========\n\n    f : sympy expression\n        Expression containing initial conditions of unevaluated functions.\n    t : sympy expression\n        Variable for which the initial conditions are to be applied.\n    fdict : dictionary\n        Dictionary containing a list of initial conditions for every\n        function, e.g., ``{y: [0, 1, 2], x: [3, 4, 5]}``. The order\n        of derivatives is ascending, so `0`, `1`, `2` are `y(0)`, `y'(0)`,\n        and `y''(0)`, respectively.\n\n    Examples\n    ========\n\n    >>> from sympy import laplace_transform, diff, Function\n    >>> from sympy import laplace_correspondence, laplace_initial_conds\n    >>> from sympy.abc import t, s\n    >>> y = Function(\"y\")\n    >>> Y = Function(\"Y\")\n    >>> f = laplace_transform(diff(y(t), t, 3), t, s, noconds=True)\n    >>> g = laplace_correspondence(f, {y: Y})\n    >>> laplace_initial_conds(g, t, {y: [2, 4, 8, 16, 32]})\n    s**3*Y(s) - 2*s**2 - 4*s - 8\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.integrals.transforms.LaplaceTransform.doit",
    "type": "method",
    "description": "\n        Try to evaluate the transform in closed form.\n\n        Explanation\n        ===========\n\n        Standard hints are the following:\n        - ``noconds``:  if True, do not return convergence conditions. The\n        default setting is `True`.\n        - ``simplify``: if True, it simplifies the final result. The\n        default setting is `False`.\n        ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "inverse_laplace_transform",
    "full_id": "sympy.integrals.transforms.inverse_laplace_transform",
    "type": "function",
    "description": "\n    Compute the inverse Laplace transform of `F(s)`, defined as\n\n    .. math ::\n        f(t) = \\frac{1}{2\\pi i} \\int_{c-i\\infty}^{c+i\\infty} e^{st}\n        F(s) \\mathrm{d}s,\n\n    for `c` so large that `F(s)` has no singularites in the\n    half-plane `\\operatorname{Re}(s) > c-\\epsilon`.\n\n    Explanation\n    ===========\n\n    The plane can be specified by\n    argument ``plane``, but will be inferred if passed as None.\n\n    Under certain regularity conditions, this recovers `f(t)` from its\n    Laplace Transform `F(s)`, for non-negative `t`, and vice\n    versa.\n\n    If the integral cannot be computed in closed form, this function returns\n    an unevaluated :class:`InverseLaplaceTransform` object.\n\n    Note that this function will always assume `t` to be real,\n    regardless of the SymPy assumption on `t`.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n\n    Examples\n    ========\n\n    >>> from sympy import inverse_laplace_transform, exp, Symbol\n    >>> from sympy.abc import s, t\n    >>> a = Symbol('a', positive=True)\n    >>> inverse_laplace_transform(exp(-a*s)/s, s, t)\n    Heaviside(-a + t)\n\n    See Also\n    ========\n\n    laplace_transform\n    hankel_transform, inverse_hankel_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "fourier_transform",
    "full_id": "sympy.integrals.transforms.fourier_transform",
    "type": "function",
    "description": "\n    Compute the unitary, ordinary-frequency Fourier transform of ``f``, defined\n    as\n\n    .. math:: F(k) = \\int_{-\\infty}^\\infty f(x) e^{-2\\pi i x k} \\mathrm{d} x.\n\n    Explanation\n    ===========\n\n    If the transform cannot be computed in closed form, this\n    function returns an unevaluated :class:`FourierTransform` object.\n\n    For other Fourier transform conventions, see the function\n    :func:`sympy.integrals.transforms._fourier_transform`.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n    Note that for this transform, by default ``noconds=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import fourier_transform, exp\n    >>> from sympy.abc import x, k\n    >>> fourier_transform(exp(-x**2), x, k)\n    sqrt(pi)*exp(-pi**2*k**2)\n    >>> fourier_transform(exp(-x**2), x, k, noconds=False)\n    (sqrt(pi)*exp(-pi**2*k**2), True)\n\n    See Also\n    ========\n\n    inverse_fourier_transform\n    sine_transform, inverse_sine_transform\n    cosine_transform, inverse_cosine_transform\n    hankel_transform, inverse_hankel_transform\n    mellin_transform, laplace_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "_fourier_transform",
    "full_id": "sympy.integrals.transforms._fourier_transform",
    "type": "function",
    "description": "\n    Compute a general Fourier-type transform\n\n    .. math::\n\n        F(k) = a \\int_{-\\infty}^{\\infty} e^{bixk} f(x)\\, dx.\n\n    For suitable choice of *a* and *b*, this reduces to the standard Fourier\n    and inverse Fourier transforms.\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "inverse_fourier_transform",
    "full_id": "sympy.integrals.transforms.inverse_fourier_transform",
    "type": "function",
    "description": "\n    Compute the unitary, ordinary-frequency inverse Fourier transform of `F`,\n    defined as\n\n    .. math:: f(x) = \\int_{-\\infty}^\\infty F(k) e^{2\\pi i x k} \\mathrm{d} k.\n\n    Explanation\n    ===========\n\n    If the transform cannot be computed in closed form, this\n    function returns an unevaluated :class:`InverseFourierTransform` object.\n\n    For other Fourier transform conventions, see the function\n    :func:`sympy.integrals.transforms._fourier_transform`.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n    Note that for this transform, by default ``noconds=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import inverse_fourier_transform, exp, sqrt, pi\n    >>> from sympy.abc import x, k\n    >>> inverse_fourier_transform(sqrt(pi)*exp(-(pi*k)**2), k, x)\n    exp(-x**2)\n    >>> inverse_fourier_transform(sqrt(pi)*exp(-(pi*k)**2), k, x, noconds=False)\n    (exp(-x**2), True)\n\n    See Also\n    ========\n\n    fourier_transform\n    sine_transform, inverse_sine_transform\n    cosine_transform, inverse_cosine_transform\n    hankel_transform, inverse_hankel_transform\n    mellin_transform, laplace_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "sine_transform",
    "full_id": "sympy.integrals.transforms.sine_transform",
    "type": "function",
    "description": "\n    Compute the unitary, ordinary-frequency sine transform of `f`, defined\n    as\n\n    .. math:: F(k) = \\sqrt{\\frac{2}{\\pi}} \\int_{0}^\\infty f(x) \\sin(2\\pi x k) \\mathrm{d} x.\n\n    Explanation\n    ===========\n\n    If the transform cannot be computed in closed form, this\n    function returns an unevaluated :class:`SineTransform` object.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n    Note that for this transform, by default ``noconds=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import sine_transform, exp\n    >>> from sympy.abc import x, k, a\n    >>> sine_transform(x*exp(-a*x**2), x, k)\n    sqrt(2)*k*exp(-k**2/(4*a))/(4*a**(3/2))\n    >>> sine_transform(x**(-a), x, k)\n    2**(1/2 - a)*k**(a - 1)*gamma(1 - a/2)/gamma(a/2 + 1/2)\n\n    See Also\n    ========\n\n    fourier_transform, inverse_fourier_transform\n    inverse_sine_transform\n    cosine_transform, inverse_cosine_transform\n    hankel_transform, inverse_hankel_transform\n    mellin_transform, laplace_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "inverse_sine_transform",
    "full_id": "sympy.integrals.transforms.inverse_sine_transform",
    "type": "function",
    "description": "\n    Compute the unitary, ordinary-frequency inverse sine transform of `F`,\n    defined as\n\n    .. math:: f(x) = \\sqrt{\\frac{2}{\\pi}} \\int_{0}^\\infty F(k) \\sin(2\\pi x k) \\mathrm{d} k.\n\n    Explanation\n    ===========\n\n    If the transform cannot be computed in closed form, this\n    function returns an unevaluated :class:`InverseSineTransform` object.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n    Note that for this transform, by default ``noconds=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import inverse_sine_transform, exp, sqrt, gamma\n    >>> from sympy.abc import x, k, a\n    >>> inverse_sine_transform(2**((1-2*a)/2)*k**(a - 1)*\n    ...     gamma(-a/2 + 1)/gamma((a+1)/2), k, x)\n    x**(-a)\n    >>> inverse_sine_transform(sqrt(2)*k*exp(-k**2/(4*a))/(4*sqrt(a)**3), k, x)\n    x*exp(-a*x**2)\n\n    See Also\n    ========\n\n    fourier_transform, inverse_fourier_transform\n    sine_transform\n    cosine_transform, inverse_cosine_transform\n    hankel_transform, inverse_hankel_transform\n    mellin_transform, laplace_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "cosine_transform",
    "full_id": "sympy.integrals.transforms.cosine_transform",
    "type": "function",
    "description": "\n    Compute the unitary, ordinary-frequency cosine transform of `f`, defined\n    as\n\n    .. math:: F(k) = \\sqrt{\\frac{2}{\\pi}} \\int_{0}^\\infty f(x) \\cos(2\\pi x k) \\mathrm{d} x.\n\n    Explanation\n    ===========\n\n    If the transform cannot be computed in closed form, this\n    function returns an unevaluated :class:`CosineTransform` object.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n    Note that for this transform, by default ``noconds=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import cosine_transform, exp, sqrt, cos\n    >>> from sympy.abc import x, k, a\n    >>> cosine_transform(exp(-a*x), x, k)\n    sqrt(2)*a/(sqrt(pi)*(a**2 + k**2))\n    >>> cosine_transform(exp(-a*sqrt(x))*cos(a*sqrt(x)), x, k)\n    a*exp(-a**2/(2*k))/(2*k**(3/2))\n\n    See Also\n    ========\n\n    fourier_transform, inverse_fourier_transform,\n    sine_transform, inverse_sine_transform\n    inverse_cosine_transform\n    hankel_transform, inverse_hankel_transform\n    mellin_transform, laplace_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "inverse_cosine_transform",
    "full_id": "sympy.integrals.transforms.inverse_cosine_transform",
    "type": "function",
    "description": "\n    Compute the unitary, ordinary-frequency inverse cosine transform of `F`,\n    defined as\n\n    .. math:: f(x) = \\sqrt{\\frac{2}{\\pi}} \\int_{0}^\\infty F(k) \\cos(2\\pi x k) \\mathrm{d} k.\n\n    Explanation\n    ===========\n\n    If the transform cannot be computed in closed form, this\n    function returns an unevaluated :class:`InverseCosineTransform` object.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n    Note that for this transform, by default ``noconds=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import inverse_cosine_transform, sqrt, pi\n    >>> from sympy.abc import x, k, a\n    >>> inverse_cosine_transform(sqrt(2)*a/(sqrt(pi)*(a**2 + k**2)), k, x)\n    exp(-a*x)\n    >>> inverse_cosine_transform(1/sqrt(k), k, x)\n    1/sqrt(x)\n\n    See Also\n    ========\n\n    fourier_transform, inverse_fourier_transform,\n    sine_transform, inverse_sine_transform\n    cosine_transform\n    hankel_transform, inverse_hankel_transform\n    mellin_transform, laplace_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "hankel_transform",
    "full_id": "sympy.integrals.transforms.hankel_transform",
    "type": "function",
    "description": "\n    Compute the Hankel transform of `f`, defined as\n\n    .. math:: F_\\nu(k) = \\int_{0}^\\infty f(r) J_\\nu(k r) r \\mathrm{d} r.\n\n    Explanation\n    ===========\n\n    If the transform cannot be computed in closed form, this\n    function returns an unevaluated :class:`HankelTransform` object.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n    Note that for this transform, by default ``noconds=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import hankel_transform, inverse_hankel_transform\n    >>> from sympy import exp\n    >>> from sympy.abc import r, k, m, nu, a\n\n    >>> ht = hankel_transform(1/r**m, r, k, nu)\n    >>> ht\n    2*k**(m - 2)*gamma(-m/2 + nu/2 + 1)/(2**m*gamma(m/2 + nu/2))\n\n    >>> inverse_hankel_transform(ht, k, r, nu)\n    r**(-m)\n\n    >>> ht = hankel_transform(exp(-a*r), r, k, 0)\n    >>> ht\n    a/(k**3*(a**2/k**2 + 1)**(3/2))\n\n    >>> inverse_hankel_transform(ht, k, r, 0)\n    exp(-a*r)\n\n    See Also\n    ========\n\n    fourier_transform, inverse_fourier_transform\n    sine_transform, inverse_sine_transform\n    cosine_transform, inverse_cosine_transform\n    inverse_hankel_transform\n    mellin_transform, laplace_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "inverse_hankel_transform",
    "full_id": "sympy.integrals.transforms.inverse_hankel_transform",
    "type": "function",
    "description": "\n    Compute the inverse Hankel transform of `F` defined as\n\n    .. math:: f(r) = \\int_{0}^\\infty F_\\nu(k) J_\\nu(k r) k \\mathrm{d} k.\n\n    Explanation\n    ===========\n\n    If the transform cannot be computed in closed form, this\n    function returns an unevaluated :class:`InverseHankelTransform` object.\n\n    For a description of possible hints, refer to the docstring of\n    :func:`sympy.integrals.transforms.IntegralTransform.doit`.\n    Note that for this transform, by default ``noconds=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import hankel_transform, inverse_hankel_transform\n    >>> from sympy import exp\n    >>> from sympy.abc import r, k, m, nu, a\n\n    >>> ht = hankel_transform(1/r**m, r, k, nu)\n    >>> ht\n    2*k**(m - 2)*gamma(-m/2 + nu/2 + 1)/(2**m*gamma(m/2 + nu/2))\n\n    >>> inverse_hankel_transform(ht, k, r, nu)\n    r**(-m)\n\n    >>> ht = hankel_transform(exp(-a*r), r, k, 0)\n    >>> ht\n    a/(k**3*(a**2/k**2 + 1)**(3/2))\n\n    >>> inverse_hankel_transform(ht, k, r, 0)\n    exp(-a*r)\n\n    See Also\n    ========\n\n    fourier_transform, inverse_fourier_transform\n    sine_transform, inverse_sine_transform\n    cosine_transform, inverse_cosine_transform\n    hankel_transform\n    mellin_transform, laplace_transform\n    ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.integrals.transforms.IntegralTransform.doit",
    "type": "method",
    "description": "\n        Try to evaluate the transform in closed form.\n\n        Explanation\n        ===========\n\n        This general function handles linearity, but apart from that leaves\n        pretty much everything to _compute_transform.\n\n        Standard hints are the following:\n\n        - ``simplify``: whether or not to simplify the result\n        - ``noconds``: if True, do not return convergence conditions\n        - ``needeval``: if True, raise IntegralTransformError instead of\n                        returning IntegralTransform objects\n\n        The default values of these hints depend on the concrete transform,\n        usually the default is\n        ``(simplify, noconds, needeval) = (True, False, False)``.\n        ",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "function",
    "full_id": "sympy.integrals.transforms.IntegralTransform.function",
    "type": "property",
    "description": "The function to be transformed.",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "function_variable",
    "full_id": "sympy.integrals.transforms.IntegralTransform.function_variable",
    "type": "property",
    "description": "The dependent variable of the function to be transformed.",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "transform_variable",
    "full_id": "sympy.integrals.transforms.IntegralTransform.transform_variable",
    "type": "property",
    "description": "The independent transform variable.",
    "section": "Integral Transforms",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "ratint",
    "full_id": "sympy.integrals.rationaltools.ratint",
    "type": "function",
    "description": "\n    Performs indefinite integration of rational functions.\n\n    Explanation\n    ===========\n\n    Given a field :math:`K` and a rational function :math:`f = p/q`,\n    where :math:`p` and :math:`q` are polynomials in :math:`K[x]`,\n    returns a function :math:`g` such that :math:`f = g'`.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.rationaltools import ratint\n    >>> from sympy.abc import x\n\n    >>> ratint(36/(x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2), x)\n    (12*x + 6)/(x**2 - 1) + 4*log(x - 2) - 4*log(x + 1)\n\n    References\n    ==========\n\n    .. [1] M. Bronstein, Symbolic Integration I: Transcendental\n       Functions, Second Edition, Springer-Verlag, 2005, pp. 35-70\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.Integral.doit\n    sympy.integrals.rationaltools.ratint_logpart\n    sympy.integrals.rationaltools.ratint_ratpart\n\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "ratint_ratpart",
    "full_id": "sympy.integrals.rationaltools.ratint_ratpart",
    "type": "function",
    "description": "\n    Horowitz-Ostrogradsky algorithm.\n\n    Explanation\n    ===========\n\n    Given a field K and polynomials f and g in K[x], such that f and g\n    are coprime and deg(f) < deg(g), returns fractions A and B in K(x),\n    such that f/g = A' + B and B has square-free denominator.\n\n    Examples\n    ========\n\n        >>> from sympy.integrals.rationaltools import ratint_ratpart\n        >>> from sympy.abc import x, y\n        >>> from sympy import Poly\n        >>> ratint_ratpart(Poly(1, x, domain='ZZ'),\n        ... Poly(x + 1, x, domain='ZZ'), x)\n        (0, 1/(x + 1))\n        >>> ratint_ratpart(Poly(1, x, domain='EX'),\n        ... Poly(x**2 + y**2, x, domain='EX'), x)\n        (0, 1/(x**2 + y**2))\n        >>> ratint_ratpart(Poly(36, x, domain='ZZ'),\n        ... Poly(x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2, x, domain='ZZ'), x)\n        ((12*x + 6)/(x**2 - 1), 12/(x**2 - x - 2))\n\n    See Also\n    ========\n\n    ratint, ratint_logpart\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "ratint_logpart",
    "full_id": "sympy.integrals.rationaltools.ratint_logpart",
    "type": "function",
    "description": "\n    Lazard-Rioboo-Trager algorithm.\n\n    Explanation\n    ===========\n\n    Given a field K and polynomials f and g in K[x], such that f and g\n    are coprime, deg(f) < deg(g) and g is square-free, returns a list\n    of tuples (s_i, q_i) of polynomials, for i = 1..n, such that s_i\n    in K[t, x] and q_i in K[t], and::\n\n                           ___    ___\n                 d  f   d  \\  `   \\  `\n                 -- - = --  )      )   a log(s_i(a, x))\n                 dx g   dx /__,   /__,\n                          i=1..n a | q_i(a) = 0\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.rationaltools import ratint_logpart\n    >>> from sympy.abc import x\n    >>> from sympy import Poly\n    >>> ratint_logpart(Poly(1, x, domain='ZZ'),\n    ... Poly(x**2 + x + 1, x, domain='ZZ'), x)\n    [(Poly(x + 3*_t/2 + 1/2, x, domain='QQ[_t]'),\n    ...Poly(3*_t**2 + 1, _t, domain='ZZ'))]\n    >>> ratint_logpart(Poly(12, x, domain='ZZ'),\n    ... Poly(x**2 - x - 2, x, domain='ZZ'), x)\n    [(Poly(x - 3*_t/8 - 1/2, x, domain='QQ[_t]'),\n    ...Poly(-_t**2 + 16, _t, domain='ZZ'))]\n\n    See Also\n    ========\n\n    ratint, ratint_ratpart\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "trigintegrate",
    "full_id": "sympy.integrals.trigonometry.trigintegrate",
    "type": "function",
    "description": "\n    Integrate f = Mul(trig) over x.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, cos, tan, sec\n    >>> from sympy.integrals.trigonometry import trigintegrate\n    >>> from sympy.abc import x\n\n    >>> trigintegrate(sin(x)*cos(x), x)\n    sin(x)**2/2\n\n    >>> trigintegrate(sin(x)**2, x)\n    x/2 - sin(x)*cos(x)/2\n\n    >>> trigintegrate(tan(x)*sec(x), x)\n    1/cos(x)\n\n    >>> trigintegrate(sin(x)*tan(x), x)\n    -log(sin(x) - 1)/2 + log(sin(x) + 1)/2 - sin(x)\n\n    References\n    ==========\n\n    .. [1] https://en.wikibooks.org/wiki/Calculus/Integration_techniques\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.Integral.doit\n    sympy.integrals.integrals.Integral\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "deltaintegrate",
    "full_id": "sympy.integrals.deltafunctions.deltaintegrate",
    "type": "function",
    "description": "\n    deltaintegrate(f, x)\n\n    Explanation\n    ===========\n\n    The idea for integration is the following:\n\n    - If we are dealing with a DiracDelta expression, i.e. DiracDelta(g(x)),\n      we try to simplify it.\n\n      If we could simplify it, then we integrate the resulting expression.\n      We already know we can integrate a simplified expression, because only\n      simple DiracDelta expressions are involved.\n\n      If we couldn't simplify it, there are two cases:\n\n      1) The expression is a simple expression: we return the integral,\n         taking care if we are dealing with a Derivative or with a proper\n         DiracDelta.\n\n      2) The expression is not simple (i.e. DiracDelta(cos(x))): we can do\n         nothing at all.\n\n    - If the node is a multiplication node having a DiracDelta term:\n\n      First we expand it.\n\n      If the expansion did work, then we try to integrate the expansion.\n\n      If not, we try to extract a simple DiracDelta term, then we have two\n      cases:\n\n      1) We have a simple DiracDelta term, so we return the integral.\n\n      2) We didn't have a simple term, but we do have an expression with\n         simplified DiracDelta terms, so we integrate this expression.\n\n    Examples\n    ========\n\n        >>> from sympy.abc import x, y, z\n        >>> from sympy.integrals.deltafunctions import deltaintegrate\n        >>> from sympy import sin, cos, DiracDelta\n        >>> deltaintegrate(x*sin(x)*cos(x)*DiracDelta(x - 1), x)\n        sin(1)*cos(1)*Heaviside(x - 1)\n        >>> deltaintegrate(y**2*DiracDelta(x - z)*DiracDelta(y - z), y)\n        z**2*DiracDelta(x - z)*Heaviside(y - z)\n\n    See Also\n    ========\n\n    sympy.functions.special.delta_functions.DiracDelta\n    sympy.integrals.integrals.Integral\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "singularityintegrate",
    "full_id": "sympy.integrals.singularityfunctions.singularityintegrate",
    "type": "function",
    "description": "\n    This function handles the indefinite integrations of Singularity functions.\n    The ``integrate`` function calls this function internally whenever an\n    instance of SingularityFunction is passed as argument.\n\n    Explanation\n    ===========\n\n    The idea for integration is the following:\n\n    - If we are dealing with a SingularityFunction expression,\n      i.e. ``SingularityFunction(x, a, n)``, we just return\n      ``SingularityFunction(x, a, n + 1)/(n + 1)`` if ``n >= 0`` and\n      ``SingularityFunction(x, a, n + 1)`` if ``n < 0``.\n\n    - If the node is a multiplication or power node having a\n      SingularityFunction term we rewrite the whole expression in terms of\n      Heaviside and DiracDelta and then integrate the output. Lastly, we\n      rewrite the output of integration back in terms of SingularityFunction.\n\n    - If none of the above case arises, we return None.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.singularityfunctions import singularityintegrate\n    >>> from sympy import SingularityFunction, symbols, Function\n    >>> x, a, n, y = symbols('x a n y')\n    >>> f = Function('f')\n    >>> singularityintegrate(SingularityFunction(x, a, 3), x)\n    SingularityFunction(x, a, 4)/4\n    >>> singularityintegrate(5*SingularityFunction(x, 5, -2), x)\n    5*SingularityFunction(x, 5, -1)\n    >>> singularityintegrate(6*SingularityFunction(x, 5, -1), x)\n    6*SingularityFunction(x, 5, 0)\n    >>> singularityintegrate(x*SingularityFunction(x, 0, -1), x)\n    0\n    >>> singularityintegrate(SingularityFunction(x, 1, -1) * f(x), x)\n    f(1)*SingularityFunction(x, 1, 0)\n\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "risch_integrate",
    "full_id": "sympy.integrals.risch.risch_integrate",
    "type": "function",
    "description": "\n    The Risch Integration Algorithm.\n\n    Explanation\n    ===========\n\n    Only transcendental functions are supported.  Currently, only exponentials\n    and logarithms are supported, but support for trigonometric functions is\n    forthcoming.\n\n    If this function returns an unevaluated Integral in the result, it means\n    that it has proven that integral to be nonelementary.  Any errors will\n    result in raising NotImplementedError.  The unevaluated Integral will be\n    an instance of NonElementaryIntegral, a subclass of Integral.\n\n    handle_first may be either 'exp' or 'log'.  This changes the order in\n    which the extension is built, and may result in a different (but\n    equivalent) solution (for an example of this, see issue 5109).  It is also\n    possible that the integral may be computed with one but not the other,\n    because not all cases have been implemented yet.  It defaults to 'log' so\n    that the outer extension is exponential when possible, because more of the\n    exponential case has been implemented.\n\n    If ``separate_integral`` is ``True``, the result is returned as a tuple (ans, i),\n    where the integral is ans + i, ans is elementary, and i is either a\n    NonElementaryIntegral or 0.  This useful if you want to try further\n    integrating the NonElementaryIntegral part using other algorithms to\n    possibly get a solution in terms of special functions.  It is False by\n    default.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.risch import risch_integrate\n    >>> from sympy import exp, log, pprint\n    >>> from sympy.abc import x\n\n    First, we try integrating exp(-x**2). Except for a constant factor of\n    2/sqrt(pi), this is the famous error function.\n\n    >>> pprint(risch_integrate(exp(-x**2), x))\n      /\n     |\n     |    2\n     |  -x\n     | e    dx\n     |\n    /\n\n    The unevaluated Integral in the result means that risch_integrate() has\n    proven that exp(-x**2) does not have an elementary anti-derivative.\n\n    In many cases, risch_integrate() can split out the elementary\n    anti-derivative part from the nonelementary anti-derivative part.\n    For example,\n\n    >>> pprint(risch_integrate((2*log(x)**2 - log(x) - x**2)/(log(x)**3 -\n    ... x**2*log(x)), x))\n                                             /\n                                            |\n      log(-x + log(x))   log(x + log(x))    |   1\n    - ---------------- + --------------- +  | ------ dx\n             2                  2           | log(x)\n                                            |\n                                           /\n\n    This means that it has proven that the integral of 1/log(x) is\n    nonelementary.  This function is also known as the logarithmic integral,\n    and is often denoted as Li(x).\n\n    risch_integrate() currently only accepts purely transcendental functions\n    with exponentials and logarithms, though note that this can include\n    nested exponentials and logarithms, as well as exponentials with bases\n    other than E.\n\n    >>> pprint(risch_integrate(exp(x)*exp(exp(x)), x))\n     / x\\\n     \\e /\n    e\n    >>> pprint(risch_integrate(exp(exp(x)), x))\n      /\n     |\n     |  / x\\\n     |  \\e /\n     | e     dx\n     |\n    /\n\n    >>> pprint(risch_integrate(x*x**x*log(x) + x**x + x*x**x, x))\n       x\n    x*x\n    >>> pprint(risch_integrate(x**x, x))\n      /\n     |\n     |  x\n     | x  dx\n     |\n    /\n\n    >>> pprint(risch_integrate(-1/(x*log(x)*log(log(x))**2), x))\n         1\n    -----------\n    log(log(x))\n\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "manualintegrate",
    "full_id": "sympy.integrals.manualintegrate.manualintegrate",
    "type": "function",
    "description": "manualintegrate(f, var)\n\n    Explanation\n    ===========\n\n    Compute indefinite integral of a single variable using an algorithm that\n    resembles what a student would do by hand.\n\n    Unlike :func:`~.integrate`, var can only be a single symbol.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, cos, tan, exp, log, integrate\n    >>> from sympy.integrals.manualintegrate import manualintegrate\n    >>> from sympy.abc import x\n    >>> manualintegrate(1 / x, x)\n    log(x)\n    >>> integrate(1/x)\n    log(x)\n    >>> manualintegrate(log(x), x)\n    x*log(x) - x\n    >>> integrate(log(x))\n    x*log(x) - x\n    >>> manualintegrate(exp(x) / (1 + exp(2 * x)), x)\n    atan(exp(x))\n    >>> integrate(exp(x) / (1 + exp(2 * x)))\n    RootSum(4*_z**2 + 1, Lambda(_i, _i*log(2*_i + exp(x))))\n    >>> manualintegrate(cos(x)**4 * sin(x), x)\n    -cos(x)**5/5\n    >>> integrate(cos(x)**4 * sin(x), x)\n    -cos(x)**5/5\n    >>> manualintegrate(cos(x)**4 * sin(x)**3, x)\n    cos(x)**7/7 - cos(x)**5/5\n    >>> integrate(cos(x)**4 * sin(x)**3, x)\n    cos(x)**7/7 - cos(x)**5/5\n    >>> manualintegrate(tan(x), x)\n    -log(cos(x))\n    >>> integrate(tan(x), x)\n    -log(cos(x))\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.integrate\n    sympy.integrals.integrals.Integral.doit\n    sympy.integrals.integrals.Integral\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "integral_steps",
    "full_id": "sympy.integrals.manualintegrate.integral_steps",
    "type": "function",
    "description": "Returns the steps needed to compute an integral.\n\n    Explanation\n    ===========\n\n    This function attempts to mirror what a student would do by hand as\n    closely as possible.\n\n    SymPy Gamma uses this to provide a step-by-step explanation of an\n    integral. The code it uses to format the results of this function can be\n    found at\n    https://github.com/sympy/sympy_gamma/blob/master/app/logic/intsteps.py.\n\n    Examples\n    ========\n\n    >>> from sympy import exp, sin\n    >>> from sympy.integrals.manualintegrate import integral_steps\n    >>> from sympy.abc import x\n    >>> print(repr(integral_steps(exp(x) / (1 + exp(2 * x)), x)))     # doctest: +NORMALIZE_WHITESPACE\n    URule(integrand=exp(x)/(exp(2*x) + 1), variable=x, u_var=_u, u_func=exp(x),\n    substep=ArctanRule(integrand=1/(_u**2 + 1), variable=_u, a=1, b=1, c=1))\n    >>> print(repr(integral_steps(sin(x), x)))     # doctest: +NORMALIZE_WHITESPACE\n    SinRule(integrand=sin(x), variable=x)\n    >>> print(repr(integral_steps((x**2 + 3)**2, x)))     # doctest: +NORMALIZE_WHITESPACE\n    RewriteRule(integrand=(x**2 + 3)**2, variable=x, rewritten=x**4 + 6*x**2 + 9,\n    substep=AddRule(integrand=x**4 + 6*x**2 + 9, variable=x,\n    substeps=[PowerRule(integrand=x**4, variable=x, base=x, exp=4),\n    ConstantTimesRule(integrand=6*x**2, variable=x, constant=6, other=x**2,\n    substep=PowerRule(integrand=x**2, variable=x, base=x, exp=2)),\n    ConstantRule(integrand=9, variable=x)]))\n\n    Returns\n    =======\n\n    rule : Rule\n        The first step; most rules have substeps that must also be\n        considered. These substeps can be evaluated using ``manualintegrate``\n        to obtain a result.\n\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "heurisch",
    "full_id": "sympy.integrals.heurisch.heurisch",
    "type": "function",
    "description": "\n    Compute indefinite integral using heuristic Risch algorithm.\n\n    Explanation\n    ===========\n\n    This is a heuristic approach to indefinite integration in finite\n    terms using the extended heuristic (parallel) Risch algorithm, based\n    on Manuel Bronstein's \"Poor Man's Integrator\".\n\n    The algorithm supports various classes of functions including\n    transcendental elementary or special functions like Airy,\n    Bessel, Whittaker and Lambert.\n\n    Note that this algorithm is not a decision procedure. If it isn't\n    able to compute the antiderivative for a given function, then this is\n    not a proof that such a functions does not exist.  One should use\n    recursive Risch algorithm in such case.  It's an open question if\n    this algorithm can be made a full decision procedure.\n\n    This is an internal integrator procedure. You should use top level\n    'integrate' function in most cases, as this procedure needs some\n    preprocessing steps and otherwise may fail.\n\n    Specification\n    =============\n\n     heurisch(f, x, rewrite=False, hints=None)\n\n       where\n         f : expression\n         x : symbol\n\n         rewrite -> force rewrite 'f' in terms of 'tan' and 'tanh'\n         hints   -> a list of functions that may appear in anti-derivate\n\n          - hints = None          --> no suggestions at all\n          - hints = [ ]           --> try to figure out\n          - hints = [f1, ..., fn] --> we know better\n\n    Examples\n    ========\n\n    >>> from sympy import tan\n    >>> from sympy.integrals.heurisch import heurisch\n    >>> from sympy.abc import x, y\n\n    >>> heurisch(y*tan(x), x)\n    y*log(tan(x)**2 + 1)/2\n\n    See Manuel Bronstein's \"Poor Man's Integrator\":\n\n    References\n    ==========\n\n    .. [1] https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html\n\n    For more information on the implemented algorithm refer to:\n\n    .. [2] K. Geddes, L. Stefanus, On the Risch-Norman Integration\n       Method and its Implementation in Maple, Proceedings of\n       ISSAC'89, ACM Press, 212-217.\n\n    .. [3] J. H. Davenport, On the Parallel Risch Algorithm (I),\n       Proceedings of EUROCAM'82, LNCS 144, Springer, 144-157.\n\n    .. [4] J. H. Davenport, On the Parallel Risch Algorithm (III):\n       Use of Tangents, SIGSAM Bulletin 16 (1982), 3-6.\n\n    .. [5] J. H. Davenport, B. M. Trager, On the Parallel Risch\n       Algorithm (II), ACM Transactions on Mathematical\n       Software 11 (1985), 356-362.\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.Integral.doit\n    sympy.integrals.integrals.Integral\n    sympy.integrals.heurisch.components\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "components",
    "full_id": "sympy.integrals.heurisch.components",
    "type": "function",
    "description": "\n    Returns a set of all functional components of the given expression\n    which includes symbols, function applications and compositions and\n    non-integer powers. Fractional powers are collected with\n    minimal, positive exponents.\n\n    Examples\n    ========\n\n    >>> from sympy import cos, sin\n    >>> from sympy.abc import x\n    >>> from sympy.integrals.heurisch import components\n\n    >>> components(sin(x)*cos(x)**2, x)\n    {x, sin(x), cos(x)}\n\n    See Also\n    ========\n\n    heurisch\n    ",
    "section": "Internals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "integrate",
    "full_id": "sympy.integrals.integrals.integrate",
    "type": "function",
    "description": "integrate(f, var, ...)\n\n    .. deprecated:: 1.6\n\n       Using ``integrate()`` with :class:`~.Poly` is deprecated. Use\n       :meth:`.Poly.integrate` instead. See :ref:`deprecated-integrate-poly`.\n\n    Explanation\n    ===========\n\n    Compute definite or indefinite integral of one or more variables\n    using Risch-Norman algorithm and table lookup. This procedure is\n    able to handle elementary algebraic and transcendental functions\n    and also a huge class of special functions, including Airy,\n    Bessel, Whittaker and Lambert.\n\n    var can be:\n\n    - a symbol                   -- indefinite integration\n    - a tuple (symbol, a)        -- indefinite integration with result\n                                    given with ``a`` replacing ``symbol``\n    - a tuple (symbol, a, b)     -- definite integration\n\n    Several variables can be specified, in which case the result is\n    multiple integration. (If var is omitted and the integrand is\n    univariate, the indefinite integral in that variable will be performed.)\n\n    Indefinite integrals are returned without terms that are independent\n    of the integration variables. (see examples)\n\n    Definite improper integrals often entail delicate convergence\n    conditions. Pass conds='piecewise', 'separate' or 'none' to have\n    these returned, respectively, as a Piecewise function, as a separate\n    result (i.e. result will be a tuple), or not at all (default is\n    'piecewise').\n\n    **Strategy**\n\n    SymPy uses various approaches to definite integration. One method is to\n    find an antiderivative for the integrand, and then use the fundamental\n    theorem of calculus. Various functions are implemented to integrate\n    polynomial, rational and trigonometric functions, and integrands\n    containing DiracDelta terms.\n\n    SymPy also implements the part of the Risch algorithm, which is a decision\n    procedure for integrating elementary functions, i.e., the algorithm can\n    either find an elementary antiderivative, or prove that one does not\n    exist.  There is also a (very successful, albeit somewhat slow) general\n    implementation of the heuristic Risch algorithm.  This algorithm will\n    eventually be phased out as more of the full Risch algorithm is\n    implemented. See the docstring of Integral._eval_integral() for more\n    details on computing the antiderivative using algebraic methods.\n\n    The option risch=True can be used to use only the (full) Risch algorithm.\n    This is useful if you want to know if an elementary function has an\n    elementary antiderivative.  If the indefinite Integral returned by this\n    function is an instance of NonElementaryIntegral, that means that the\n    Risch algorithm has proven that integral to be non-elementary.  Note that\n    by default, additional methods (such as the Meijer G method outlined\n    below) are tried on these integrals, as they may be expressible in terms\n    of special functions, so if you only care about elementary answers, use\n    risch=True.  Also note that an unevaluated Integral returned by this\n    function is not necessarily a NonElementaryIntegral, even with risch=True,\n    as it may just be an indication that the particular part of the Risch\n    algorithm needed to integrate that function is not yet implemented.\n\n    Another family of strategies comes from re-writing the integrand in\n    terms of so-called Meijer G-functions. Indefinite integrals of a\n    single G-function can always be computed, and the definite integral\n    of a product of two G-functions can be computed from zero to\n    infinity. Various strategies are implemented to rewrite integrands\n    as G-functions, and use this information to compute integrals (see\n    the ``meijerint`` module).\n\n    The option manual=True can be used to use only an algorithm that tries\n    to mimic integration by hand. This algorithm does not handle as many\n    integrands as the other algorithms implemented but may return results in\n    a more familiar form. The ``manualintegrate`` module has functions that\n    return the steps used (see the module docstring for more information).\n\n    In general, the algebraic methods work best for computing\n    antiderivatives of (possibly complicated) combinations of elementary\n    functions. The G-function methods work best for computing definite\n    integrals from zero to infinity of moderately complicated\n    combinations of special functions, or indefinite integrals of very\n    simple combinations of special functions.\n\n    The strategy employed by the integration code is as follows:\n\n    - If computing a definite integral, and both limits are real,\n      and at least one limit is +- oo, try the G-function method of\n      definite integration first.\n\n    - Try to find an antiderivative, using all available methods, ordered\n      by performance (that is try fastest method first, slowest last; in\n      particular polynomial integration is tried first, Meijer\n      G-functions second to last, and heuristic Risch last).\n\n    - If still not successful, try G-functions irrespective of the\n      limits.\n\n    The option meijerg=True, False, None can be used to, respectively:\n    always use G-function methods and no others, never use G-function\n    methods, or use all available methods (in order as described above).\n    It defaults to None.\n\n    Examples\n    ========\n\n    >>> from sympy import integrate, log, exp, oo\n    >>> from sympy.abc import a, x, y\n\n    >>> integrate(x*y, x)\n    x**2*y/2\n\n    >>> integrate(log(x), x)\n    x*log(x) - x\n\n    >>> integrate(log(x), (x, 1, a))\n    a*log(a) - a + 1\n\n    >>> integrate(x)\n    x**2/2\n\n    Terms that are independent of x are dropped by indefinite integration:\n\n    >>> from sympy import sqrt\n    >>> integrate(sqrt(1 + x), (x, 0, x))\n    2*(x + 1)**(3/2)/3 - 2/3\n    >>> integrate(sqrt(1 + x), x)\n    2*(x + 1)**(3/2)/3\n\n    >>> integrate(x*y)\n    Traceback (most recent call last):\n    ...\n    ValueError: specify integration variables to integrate x*y\n\n    Note that ``integrate(x)`` syntax is meant only for convenience\n    in interactive sessions and should be avoided in library code.\n\n    >>> integrate(x**a*exp(-x), (x, 0, oo)) # same as conds='piecewise'\n    Piecewise((gamma(a + 1), re(a) > -1),\n        (Integral(x**a*exp(-x), (x, 0, oo)), True))\n\n    >>> integrate(x**a*exp(-x), (x, 0, oo), conds='none')\n    gamma(a + 1)\n\n    >>> integrate(x**a*exp(-x), (x, 0, oo), conds='separate')\n    (gamma(a + 1), re(a) > -1)\n\n    See Also\n    ========\n\n    Integral, Integral.doit\n\n    ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "line_integrate",
    "full_id": "sympy.integrals.integrals.line_integrate",
    "type": "function",
    "description": "line_integrate(field, Curve, variables)\n\n    Compute the line integral.\n\n    Examples\n    ========\n\n    >>> from sympy import Curve, line_integrate, E, ln\n    >>> from sympy.abc import x, y, t\n    >>> C = Curve([E**t + 1, E**t - 1], (t, 0, ln(2)))\n    >>> line_integrate(x + y, C, [x, y])\n    3*sqrt(2)\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.integrate, Integral\n    ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "as_sum",
    "full_id": "sympy.integrals.integrals.Integral.as_sum",
    "type": "method",
    "description": "\n        Approximates a definite integral by a sum.\n\n        Parameters\n        ==========\n\n        n :\n            The number of subintervals to use, optional.\n        method :\n            One of: 'left', 'right', 'midpoint', 'trapezoid'.\n        evaluate : bool\n            If False, returns an unevaluated Sum expression. The default\n            is True, evaluate the sum.\n\n        Notes\n        =====\n\n        These methods of approximate integration are described in [1].\n\n        Examples\n        ========\n\n        >>> from sympy import Integral, sin, sqrt\n        >>> from sympy.abc import x, n\n        >>> e = Integral(sin(x), (x, 3, 7))\n        >>> e\n        Integral(sin(x), (x, 3, 7))\n\n        For demonstration purposes, this interval will only be split into 2\n        regions, bounded by [3, 5] and [5, 7].\n\n        The left-hand rule uses function evaluations at the left of each\n        interval:\n\n        >>> e.as_sum(2, 'left')\n        2*sin(5) + 2*sin(3)\n\n        The midpoint rule uses evaluations at the center of each interval:\n\n        >>> e.as_sum(2, 'midpoint')\n        2*sin(4) + 2*sin(6)\n\n        The right-hand rule uses function evaluations at the right of each\n        interval:\n\n        >>> e.as_sum(2, 'right')\n        2*sin(5) + 2*sin(7)\n\n        The trapezoid rule uses function evaluations on both sides of the\n        intervals. This is equivalent to taking the average of the left and\n        right hand rule results:\n\n        >>> s = e.as_sum(2, 'trapezoid')\n        >>> s\n        2*sin(5) + sin(3) + sin(7)\n        >>> (e.as_sum(2, 'left') + e.as_sum(2, 'right'))/2 == s\n        True\n\n        Here, the discontinuity at x = 0 can be avoided by using the\n        midpoint or right-hand method:\n\n        >>> e = Integral(1/sqrt(x), (x, 0, 1))\n        >>> e.as_sum(5).n(4)\n        1.730\n        >>> e.as_sum(10).n(4)\n        1.809\n        >>> e.doit().n(4)  # the actual value is 2\n        2.000\n\n        The left- or trapezoid method will encounter the discontinuity and\n        return infinity:\n\n        >>> e.as_sum(5, 'left')\n        zoo\n\n        The number of intervals can be symbolic. If omitted, a dummy symbol\n        will be used for it.\n\n        >>> e = Integral(x**2, (x, 0, 2))\n        >>> e.as_sum(n, 'right').expand()\n        8/3 + 4/n + 4/(3*n**2)\n\n        This shows that the midpoint rule is more accurate, as its error\n        term decays as the square of n:\n\n        >>> e.as_sum(method='midpoint').expand()\n        8/3 - 2/(3*_n**2)\n\n        A symbolic sum is returned with evaluate=False:\n\n        >>> e.as_sum(n, 'midpoint', evaluate=False)\n        2*Sum((2*_k/n - 1/n)**2, (_k, 1, n))/n\n\n        See Also\n        ========\n\n        Integral.doit : Perform the integration using any hints\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Riemann_sum#Riemann_summation_methods\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.integrals.integrals.Integral.doit",
    "type": "method",
    "description": "\n        Perform the integration using any hints given.\n\n        Examples\n        ========\n\n        >>> from sympy import Piecewise, S\n        >>> from sympy.abc import x, t\n        >>> p = x**2 + Piecewise((0, x/t < 0), (1, True))\n        >>> p.integrate((t, S(4)/5, 1), (x, -1, 1))\n        1/3\n\n        See Also\n        ========\n\n        sympy.integrals.trigonometry.trigintegrate\n        sympy.integrals.heurisch.heurisch\n        sympy.integrals.rationaltools.ratint\n        as_sum : Approximate the integral using a sum\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.integrals.integrals.Integral.free_symbols",
    "type": "property",
    "description": "\n        This method returns the symbols that will exist when the\n        integral is evaluated. This is useful if one is trying to\n        determine whether an integral depends on a certain\n        symbol or not.\n\n        Examples\n        ========\n\n        >>> from sympy import Integral\n        >>> from sympy.abc import x, y\n        >>> Integral(x, (x, y, 1)).free_symbols\n        {y}\n\n        See Also\n        ========\n\n        sympy.concrete.expr_with_limits.ExprWithLimits.function\n        sympy.concrete.expr_with_limits.ExprWithLimits.limits\n        sympy.concrete.expr_with_limits.ExprWithLimits.variables\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "principal_value",
    "full_id": "sympy.integrals.integrals.Integral.principal_value",
    "type": "method",
    "description": "\n        Compute the Cauchy Principal Value of the definite integral of a real function in the given interval\n        on the real axis.\n\n        Explanation\n        ===========\n\n        In mathematics, the Cauchy principal value, is a method for assigning values to certain improper\n        integrals which would otherwise be undefined.\n\n        Examples\n        ========\n\n        >>> from sympy import Integral, oo\n        >>> from sympy.abc import x\n        >>> Integral(x+1, (x, -oo, oo)).principal_value()\n        oo\n        >>> f = 1 / (x**3)\n        >>> Integral(f, (x, -oo, oo)).principal_value()\n        0\n        >>> Integral(f, (x, -10, 10)).principal_value()\n        0\n        >>> Integral(f, (x, -10, oo)).principal_value() + Integral(f, (x, -oo, 10)).principal_value()\n        0\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Cauchy_principal_value\n        .. [2] https://mathworld.wolfram.com/CauchyPrincipalValue.html\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "transform",
    "full_id": "sympy.integrals.integrals.Integral.transform",
    "type": "method",
    "description": "\n        Performs a change of variables from `x` to `u` using the relationship\n        given by `x` and `u` which will define the transformations `f` and `F`\n        (which are inverses of each other) as follows:\n\n        1) If `x` is a Symbol (which is a variable of integration) then `u`\n           will be interpreted as some function, f(u), with inverse F(u).\n           This, in effect, just makes the substitution of x with f(x).\n\n        2) If `u` is a Symbol then `x` will be interpreted as some function,\n           F(x), with inverse f(u). This is commonly referred to as\n           u-substitution.\n\n        Once f and F have been identified, the transformation is made as\n        follows:\n\n        .. math:: \\int_a^b x \\mathrm{d}x \\rightarrow \\int_{F(a)}^{F(b)} f(x)\n                  \\frac{\\mathrm{d}}{\\mathrm{d}x}\n\n        where `F(x)` is the inverse of `f(x)` and the limits and integrand have\n        been corrected so as to retain the same value after integration.\n\n        Notes\n        =====\n\n        The mappings, F(x) or f(u), must lead to a unique integral. Linear\n        or rational linear expression, ``2*x``, ``1/x`` and ``sqrt(x)``, will\n        always work; quadratic expressions like ``x**2 - 1`` are acceptable\n        as long as the resulting integrand does not depend on the sign of\n        the solutions (see examples).\n\n        The integral will be returned unchanged if ``x`` is not a variable of\n        integration.\n\n        ``x`` must be (or contain) only one of of the integration variables. If\n        ``u`` has more than one free symbol then it should be sent as a tuple\n        (``u``, ``uvar``) where ``uvar`` identifies which variable is replacing\n        the integration variable.\n        XXX can it contain another integration variable?\n\n        Examples\n        ========\n\n        >>> from sympy.abc import a, x, u\n        >>> from sympy import Integral, cos, sqrt\n\n        >>> i = Integral(x*cos(x**2 - 1), (x, 0, 1))\n\n        transform can change the variable of integration\n\n        >>> i.transform(x, u)\n        Integral(u*cos(u**2 - 1), (u, 0, 1))\n\n        transform can perform u-substitution as long as a unique\n        integrand is obtained:\n\n        >>> ui = i.transform(x**2 - 1, u)\n        >>> ui\n        Integral(cos(u)/2, (u, -1, 0))\n\n        This attempt fails because x = +/-sqrt(u + 1) and the\n        sign does not cancel out of the integrand:\n\n        >>> Integral(cos(x**2 - 1), (x, 0, 1)).transform(x**2 - 1, u)\n        Traceback (most recent call last):\n        ...\n        ValueError:\n        The mapping between F(x) and f(u) did not give a unique integrand.\n\n        transform can do a substitution. Here, the previous\n        result is transformed back into the original expression\n        using \"u-substitution\":\n\n        >>> ui.transform(sqrt(u + 1), x) == i\n        True\n\n        We can accomplish the same with a regular substitution:\n\n        >>> ui.transform(u, x**2 - 1) == i\n        True\n\n        If the `x` does not contain a symbol of integration then\n        the integral will be returned unchanged. Integral `i` does\n        not have an integration variable `a` so no change is made:\n\n        >>> i.transform(a, x) == i\n        True\n\n        When `u` has more than one free symbol the symbol that is\n        replacing `x` must be identified by passing `u` as a tuple:\n\n        >>> Integral(x, (x, 0, 1)).transform(x, (u + a, u))\n        Integral(a + u, (u, -a, 1 - a))\n        >>> Integral(x, (x, 0, 1)).transform(x, (u + a, a))\n        Integral(a + u, (a, -u, 1 - u))\n\n        See Also\n        ========\n\n        sympy.concrete.expr_with_limits.ExprWithLimits.variables : Lists the integration variables\n        as_dummy : Replace integration variables with dummy ones\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "bound_symbols",
    "full_id": "sympy.concrete.expr_with_limits.ExprWithLimits.bound_symbols",
    "type": "property",
    "description": "Return only variables that are dummy variables.\n\n        Examples\n        ========\n\n        >>> from sympy import Integral\n        >>> from sympy.abc import x, i, j, k\n        >>> Integral(x**i, (i, 1, 3), (j, 2), k).bound_symbols\n        [i, j]\n\n        See Also\n        ========\n\n        function, limits, free_symbols\n        as_dummy : Rename dummy variables\n        sympy.integrals.integrals.Integral.transform : Perform mapping on the dummy variable\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.concrete.expr_with_limits.ExprWithLimits.free_symbols",
    "type": "property",
    "description": "\n        This method returns the symbols in the object, excluding those\n        that take on a specific value (i.e. the dummy symbols).\n\n        Examples\n        ========\n\n        >>> from sympy import Sum\n        >>> from sympy.abc import x, y\n        >>> Sum(x, (x, y, 1)).free_symbols\n        {y}\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "function",
    "full_id": "sympy.concrete.expr_with_limits.ExprWithLimits.function",
    "type": "property",
    "description": "Return the function applied across limits.\n\n        Examples\n        ========\n\n        >>> from sympy import Integral\n        >>> from sympy.abc import x\n        >>> Integral(x**2, (x,)).function\n        x**2\n\n        See Also\n        ========\n\n        limits, variables, free_symbols\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "has_finite_limits",
    "full_id": "sympy.concrete.expr_with_limits.ExprWithLimits.has_finite_limits",
    "type": "property",
    "description": "\n        Returns True if the limits are known to be finite, either by the\n        explicit bounds, assumptions on the bounds, or assumptions on the\n        variables.  False if known to be infinite, based on the bounds.\n        None if not enough information is available to determine.\n\n        Examples\n        ========\n\n        >>> from sympy import Sum, Integral, Product, oo, Symbol\n        >>> x = Symbol('x')\n        >>> Sum(x, (x, 1, 8)).has_finite_limits\n        True\n\n        >>> Integral(x, (x, 1, oo)).has_finite_limits\n        False\n\n        >>> M = Symbol('M')\n        >>> Sum(x, (x, 1, M)).has_finite_limits\n\n        >>> N = Symbol('N', integer=True)\n        >>> Product(x, (x, 1, N)).has_finite_limits\n        True\n\n        See Also\n        ========\n\n        has_reversed_limits\n\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "has_reversed_limits",
    "full_id": "sympy.concrete.expr_with_limits.ExprWithLimits.has_reversed_limits",
    "type": "property",
    "description": "\n        Returns True if the limits are known to be in reversed order, either\n        by the explicit bounds, assumptions on the bounds, or assumptions on the\n        variables.  False if known to be in normal order, based on the bounds.\n        None if not enough information is available to determine.\n\n        Examples\n        ========\n\n        >>> from sympy import Sum, Integral, Product, oo, Symbol\n        >>> x = Symbol('x')\n        >>> Sum(x, (x, 8, 1)).has_reversed_limits\n        True\n\n        >>> Sum(x, (x, 1, oo)).has_reversed_limits\n        False\n\n        >>> M = Symbol('M')\n        >>> Integral(x, (x, 1, M)).has_reversed_limits\n\n        >>> N = Symbol('N', integer=True, positive=True)\n        >>> Sum(x, (x, 1, N)).has_reversed_limits\n        False\n\n        >>> Product(x, (x, 2, N)).has_reversed_limits\n\n        >>> Product(x, (x, 2, N)).subs(N, N + 2).has_reversed_limits\n        False\n\n        See Also\n        ========\n\n        sympy.concrete.expr_with_intlimits.ExprWithIntLimits.has_empty_sequence\n\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "is_number",
    "full_id": "sympy.concrete.expr_with_limits.ExprWithLimits.is_number",
    "type": "property",
    "description": "Return True if the Sum has no free symbols, else False.",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "limits",
    "full_id": "sympy.concrete.expr_with_limits.ExprWithLimits.limits",
    "type": "property",
    "description": "Return the limits of expression.\n\n        Examples\n        ========\n\n        >>> from sympy import Integral\n        >>> from sympy.abc import x, i\n        >>> Integral(x**i, (i, 1, 3)).limits\n        ((i, 1, 3),)\n\n        See Also\n        ========\n\n        function, variables, free_symbols\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "variables",
    "full_id": "sympy.concrete.expr_with_limits.ExprWithLimits.variables",
    "type": "property",
    "description": "Return a list of the limit variables.\n\n        >>> from sympy import Sum\n        >>> from sympy.abc import x, i\n        >>> Sum(x**i, (i, 1, 3)).variables\n        [i]\n\n        See Also\n        ========\n\n        function, limits, free_symbols\n        as_dummy : Rename dummy variables\n        sympy.integrals.integrals.Integral.transform : Perform mapping on the dummy variable\n        ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "gauss_legendre",
    "full_id": "sympy.integrals.quadrature.gauss_legendre",
    "type": "function",
    "description": "\n    Computes the Gauss-Legendre quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Legendre quadrature approximates the integral:\n\n    .. math::\n        \\int_{-1}^1 f(x)\\,dx \\approx \\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\frac{2}{\\left(1-x_i^2\\right) \\left(P'_n(x_i)\\right)^2}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_legendre\n    >>> x, w = gauss_legendre(3, 5)\n    >>> x\n    [-0.7746, 0, 0.7746]\n    >>> w\n    [0.55556, 0.88889, 0.55556]\n    >>> x, w = gauss_legendre(4, 5)\n    >>> x\n    [-0.86114, -0.33998, 0.33998, 0.86114]\n    >>> w\n    [0.34785, 0.65215, 0.65215, 0.34785]\n\n    See Also\n    ========\n\n    gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html\n    ",
    "section": "Numeric Integrals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "gauss_laguerre",
    "full_id": "sympy.integrals.quadrature.gauss_laguerre",
    "type": "function",
    "description": "\n    Computes the Gauss-Laguerre quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Laguerre quadrature approximates the integral:\n\n    .. math::\n        \\int_0^{\\infty} e^{-x} f(x)\\,dx \\approx \\sum_{i=1}^n w_i f(x_i)\n\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `L_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\frac{x_i}{(n+1)^2 \\left(L_{n+1}(x_i)\\right)^2}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_laguerre\n    >>> x, w = gauss_laguerre(3, 5)\n    >>> x\n    [0.41577, 2.2943, 6.2899]\n    >>> w\n    [0.71109, 0.27852, 0.010389]\n    >>> x, w = gauss_laguerre(6, 5)\n    >>> x\n    [0.22285, 1.1889, 2.9927, 5.7751, 9.8375, 15.983]\n    >>> w\n    [0.45896, 0.417, 0.11337, 0.010399, 0.00026102, 8.9855e-7]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html\n    ",
    "section": "Numeric Integrals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "gauss_hermite",
    "full_id": "sympy.integrals.quadrature.gauss_hermite",
    "type": "function",
    "description": "\n    Computes the Gauss-Hermite quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Hermite quadrature approximates the integral:\n\n    .. math::\n        \\int_{-\\infty}^{\\infty} e^{-x^2} f(x)\\,dx \\approx\n            \\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `H_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\frac{2^{n-1} n! \\sqrt{\\pi}}{n^2 \\left(H_{n-1}(x_i)\\right)^2}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : The ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_hermite\n    >>> x, w = gauss_hermite(3, 5)\n    >>> x\n    [-1.2247, 0, 1.2247]\n    >>> w\n    [0.29541, 1.1816, 0.29541]\n\n    >>> x, w = gauss_hermite(6, 5)\n    >>> x\n    [-2.3506, -1.3358, -0.43608, 0.43608, 1.3358, 2.3506]\n    >>> w\n    [0.00453, 0.15707, 0.72463, 0.72463, 0.15707, 0.00453]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_gen_laguerre, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html\n    ",
    "section": "Numeric Integrals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "gauss_gen_laguerre",
    "full_id": "sympy.integrals.quadrature.gauss_gen_laguerre",
    "type": "function",
    "description": "\n    Computes the generalized Gauss-Laguerre quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The generalized Gauss-Laguerre quadrature approximates the integral:\n\n    .. math::\n        \\int_{0}^\\infty x^{\\alpha} e^{-x} f(x)\\,dx \\approx\n            \\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\n    `L^{\\alpha}_n` and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\frac{\\Gamma(\\alpha+n)}\n                {n \\Gamma(n) L^{\\alpha}_{n-1}(x_i) L^{\\alpha+1}_{n-1}(x_i)}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n\n    alpha :\n        The exponent of the singularity, `\\alpha > -1`.\n\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> from sympy.integrals.quadrature import gauss_gen_laguerre\n    >>> x, w = gauss_gen_laguerre(3, -S.Half, 5)\n    >>> x\n    [0.19016, 1.7845, 5.5253]\n    >>> w\n    [1.4493, 0.31413, 0.00906]\n\n    >>> x, w = gauss_gen_laguerre(4, 3*S.Half, 5)\n    >>> x\n    [0.97851, 2.9904, 6.3193, 11.712]\n    >>> w\n    [0.53087, 0.67721, 0.11895, 0.0023152]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html\n    ",
    "section": "Numeric Integrals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "gauss_chebyshev_t",
    "full_id": "sympy.integrals.quadrature.gauss_chebyshev_t",
    "type": "function",
    "description": "\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\n    the first kind.\n\n    Explanation\n    ===========\n\n    The Gauss-Chebyshev quadrature of the first kind approximates the integral:\n\n    .. math::\n        \\int_{-1}^{1} \\frac{1}{\\sqrt{1-x^2}} f(x)\\,dx \\approx\n            \\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `T_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\frac{\\pi}{n}\n\n    Parameters\n    ==========\n\n    n :\n        The order of quadrature.\n\n    n_digits :\n        Number of significant digits of the points and weights to return.\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_t\n    >>> x, w = gauss_chebyshev_t(3, 5)\n    >>> x\n    [0.86602, 0, -0.86602]\n    >>> w\n    [1.0472, 1.0472, 1.0472]\n\n    >>> x, w = gauss_chebyshev_t(6, 5)\n    >>> x\n    [0.96593, 0.70711, 0.25882, -0.25882, -0.70711, -0.96593]\n    >>> w\n    [0.5236, 0.5236, 0.5236, 0.5236, 0.5236, 0.5236]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_u, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html\n    ",
    "section": "Numeric Integrals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "gauss_chebyshev_u",
    "full_id": "sympy.integrals.quadrature.gauss_chebyshev_u",
    "type": "function",
    "description": "\n    Computes the Gauss-Chebyshev quadrature [1]_ points and weights of\n    the second kind.\n\n    Explanation\n    ===========\n\n    The Gauss-Chebyshev quadrature of the second kind approximates the\n    integral:\n\n    .. math::\n        \\int_{-1}^{1} \\sqrt{1-x^2} f(x)\\,dx \\approx \\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `U_n`\n    and the weights `w_i` are given by:\n\n    .. math::\n        w_i = \\frac{\\pi}{n+1} \\sin^2 \\left(\\frac{i}{n+1}\\pi\\right)\n\n    Parameters\n    ==========\n\n    n : the order of quadrature\n\n    n_digits : number of significant digits of the points and weights to return\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_chebyshev_u\n    >>> x, w = gauss_chebyshev_u(3, 5)\n    >>> x\n    [0.70711, 0, -0.70711]\n    >>> w\n    [0.3927, 0.7854, 0.3927]\n\n    >>> x, w = gauss_chebyshev_u(6, 5)\n    >>> x\n    [0.90097, 0.62349, 0.22252, -0.22252, -0.62349, -0.90097]\n    >>> w\n    [0.084489, 0.27433, 0.42658, 0.42658, 0.27433, 0.084489]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre, gauss_chebyshev_t, gauss_jacobi, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html\n    ",
    "section": "Numeric Integrals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "gauss_jacobi",
    "full_id": "sympy.integrals.quadrature.gauss_jacobi",
    "type": "function",
    "description": "\n    Computes the Gauss-Jacobi quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Jacobi quadrature of the first kind approximates the integral:\n\n    .. math::\n        \\int_{-1}^1 (1-x)^\\alpha (1+x)^\\beta f(x)\\,dx \\approx\n            \\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of\n    `P^{(\\alpha,\\beta)}_n` and the weights `w_i` are given by:\n\n    .. math::\n        w_i = -\\frac{2n+\\alpha+\\beta+2}{n+\\alpha+\\beta+1}\n              \\frac{\\Gamma(n+\\alpha+1)\\Gamma(n+\\beta+1)}\n              {\\Gamma(n+\\alpha+\\beta+1)(n+1)!}\n              \\frac{2^{\\alpha+\\beta}}{P'_n(x_i)\n              P^{(\\alpha,\\beta)}_{n+1}(x_i)}\n\n    Parameters\n    ==========\n\n    n : the order of quadrature\n\n    alpha : the first parameter of the Jacobi Polynomial, `\\alpha > -1`\n\n    beta : the second parameter of the Jacobi Polynomial, `\\beta > -1`\n\n    n_digits : number of significant digits of the points and weights to return\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> from sympy.integrals.quadrature import gauss_jacobi\n    >>> x, w = gauss_jacobi(3, S.Half, -S.Half, 5)\n    >>> x\n    [-0.90097, -0.22252, 0.62349]\n    >>> w\n    [1.7063, 1.0973, 0.33795]\n\n    >>> x, w = gauss_jacobi(6, 1, 1, 5)\n    >>> x\n    [-0.87174, -0.5917, -0.2093, 0.2093, 0.5917, 0.87174]\n    >>> w\n    [0.050584, 0.22169, 0.39439, 0.39439, 0.22169, 0.050584]\n\n    See Also\n    ========\n\n    gauss_legendre, gauss_laguerre, gauss_hermite, gauss_gen_laguerre,\n    gauss_chebyshev_t, gauss_chebyshev_u, gauss_lobatto\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature\n    .. [2] https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html\n    .. [3] https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html\n    ",
    "section": "Numeric Integrals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "gauss_lobatto",
    "full_id": "sympy.integrals.quadrature.gauss_lobatto",
    "type": "function",
    "description": "\n    Computes the Gauss-Lobatto quadrature [1]_ points and weights.\n\n    Explanation\n    ===========\n\n    The Gauss-Lobatto quadrature approximates the integral:\n\n    .. math::\n        \\int_{-1}^1 f(x)\\,dx \\approx \\sum_{i=1}^n w_i f(x_i)\n\n    The nodes `x_i` of an order `n` quadrature rule are the roots of `P'_(n-1)`\n    and the weights `w_i` are given by:\n\n    .. math::\n        &w_i = \\frac{2}{n(n-1) \\left[P_{n-1}(x_i)\\right]^2},\\quad x\\neq\\pm 1\\\\\n        &w_i = \\frac{2}{n(n-1)},\\quad x=\\pm 1\n\n    Parameters\n    ==========\n\n    n : the order of quadrature\n\n    n_digits : number of significant digits of the points and weights to return\n\n    Returns\n    =======\n\n    (x, w) : the ``x`` and ``w`` are lists of points and weights as Floats.\n             The points `x_i` and weights `w_i` are returned as ``(x, w)``\n             tuple of lists.\n\n    Examples\n    ========\n\n    >>> from sympy.integrals.quadrature import gauss_lobatto\n    >>> x, w = gauss_lobatto(3, 5)\n    >>> x\n    [-1, 0, 1]\n    >>> w\n    [0.33333, 1.3333, 0.33333]\n    >>> x, w = gauss_lobatto(4, 5)\n    >>> x\n    [-1, -0.44721, 0.44721, 1]\n    >>> w\n    [0.16667, 0.83333, 0.83333, 0.16667]\n\n    See Also\n    ========\n\n    gauss_legendre,gauss_laguerre, gauss_gen_laguerre, gauss_hermite, gauss_chebyshev_t, gauss_chebyshev_u, gauss_jacobi\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules\n    .. [2] https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm\n    ",
    "section": "Numeric Integrals",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "polytope_integrate",
    "full_id": "sympy.integrals.intpoly.polytope_integrate",
    "type": "function",
    "description": "Integrates polynomials over 2/3-Polytopes.\n\n    Explanation\n    ===========\n\n    This function accepts the polytope in ``poly`` and the function in ``expr``\n    (uni/bi/trivariate polynomials are implemented) and returns\n    the exact integral of ``expr`` over ``poly``.\n\n    Parameters\n    ==========\n\n    poly : The input Polygon.\n\n    expr : The input polynomial.\n\n    clockwise : Binary value to sort input points of 2-Polytope clockwise.(Optional)\n\n    max_degree : The maximum degree of any monomial of the input polynomial.(Optional)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import Point, Polygon\n    >>> from sympy.integrals.intpoly import polytope_integrate\n    >>> polygon = Polygon(Point(0, 0), Point(0, 1), Point(1, 1), Point(1, 0))\n    >>> polys = [1, x, y, x*y, x**2*y, x*y**2]\n    >>> expr = x*y\n    >>> polytope_integrate(polygon, expr)\n    1/4\n    >>> polytope_integrate(polygon, polys, max_degree=3)\n    {1: 1, x: 1/2, y: 1/2, x*y: 1/4, x*y**2: 1/6, x**2*y: 1/6}\n    ",
    "section": "API reference",
    "url": "https://docs.sympy.org/latest/modules/integrals/integrals.html"
  },
  {
    "name": "limit",
    "full_id": "sympy.series.limits.limit",
    "type": "function",
    "description": "Computes the limit of ``e(z)`` at the point ``z0``.\n\n    Parameters\n    ==========\n\n    e : expression, the limit of which is to be taken\n\n    z : symbol representing the variable in the limit.\n        Other symbols are treated as constants. Multivariate limits\n        are not supported.\n\n    z0 : the value toward which ``z`` tends. Can be any expression,\n        including ``oo`` and ``-oo``.\n\n    dir : string, optional (default: \"+\")\n        The limit is bi-directional if ``dir=\"+-\"``, from the right\n        (z->z0+) if ``dir=\"+\"``, and from the left (z->z0-) if\n        ``dir=\"-\"``. For infinite ``z0`` (``oo`` or ``-oo``), the ``dir``\n        argument is determined from the direction of the infinity\n        (i.e., ``dir=\"-\"`` for ``oo``).\n\n    Examples\n    ========\n\n    >>> from sympy import limit, sin, oo\n    >>> from sympy.abc import x\n    >>> limit(sin(x)/x, x, 0)\n    1\n    >>> limit(1/x, x, 0) # default dir='+'\n    oo\n    >>> limit(1/x, x, 0, dir=\"-\")\n    -oo\n    >>> limit(1/x, x, 0, dir='+-')\n    zoo\n    >>> limit(1/x, x, oo)\n    0\n\n    Notes\n    =====\n\n    First we try some heuristics for easy and frequent cases like \"x\", \"1/x\",\n    \"x**2\" and similar, so that it's fast. For all other cases, we use the\n    Gruntz algorithm (see the gruntz() function).\n\n    See Also\n    ========\n\n     limit_seq : returns the limit of a sequence.\n    ",
    "section": "Limits",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.series.limits.Limit.doit",
    "type": "method",
    "description": "Evaluates the limit.\n\n        Parameters\n        ==========\n\n        deep : bool, optional (default: True)\n            Invoke the ``doit`` method of the expressions involved before\n            taking the limit.\n\n        hints : optional keyword arguments\n            To be passed to ``doit`` methods; only used if deep is True.\n        ",
    "section": "Limits",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "gruntz",
    "full_id": "sympy.series.gruntz.gruntz",
    "type": "function",
    "description": "\n    Compute the limit of e(z) at the point z0 using the Gruntz algorithm.\n\n    Explanation\n    ===========\n\n    ``z0`` can be any expression, including oo and -oo.\n\n    For ``dir=\"+\"`` (default) it calculates the limit from the right\n    (z->z0+) and for ``dir=\"-\"`` the limit from the left (z->z0-). For infinite z0\n    (oo or -oo), the dir argument does not matter.\n\n    This algorithm is fully described in the module docstring in the gruntz.py\n    file. It relies heavily on the series expansion. Most frequently, gruntz()\n    is only used if the faster limit() function (which uses heuristics) fails.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "compare",
    "full_id": "sympy.series.gruntz.compare",
    "type": "function",
    "description": "Returns \"<\" if a<b, \"=\" for a == b, \">\" for a>b",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "rewrite",
    "full_id": "sympy.series.gruntz.rewrite",
    "type": "function",
    "description": "e(x) ... the function\n    Omega ... the mrv set\n    wsym ... the symbol which is going to be used for w\n\n    Returns the rewritten e in terms of w and log(w). See test_rewrite1()\n    for examples and correct results.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "build_expression_tree",
    "full_id": "sympy.series.gruntz.build_expression_tree",
    "type": "function",
    "description": " Helper function for rewrite.\n\n    We need to sort Omega (mrv set) so that we replace an expression before\n    we replace any expression in terms of which it has to be rewritten::\n\n        e1 ---> e2 ---> e3\n                 \\\n                  -> e4\n\n    Here we can do e1, e2, e3, e4 or e1, e2, e4, e3.\n    To do this we assemble the nodes into a tree, and sort them by height.\n\n    This function builds the tree, rewrites then sorts the nodes.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "mrv_leadterm",
    "full_id": "sympy.series.gruntz.mrv_leadterm",
    "type": "function",
    "description": "Returns (c0, e0) for e.",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "calculate_series",
    "full_id": "sympy.series.gruntz.calculate_series",
    "type": "function",
    "description": "Calculates at least one term of the series of ``e`` in ``x``.\n\n    This is a place that fails most often, so it is in its own function.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "limitinf",
    "full_id": "sympy.series.gruntz.limitinf",
    "type": "function",
    "description": "Limit e(x) for x-> oo.",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "sign",
    "full_id": "sympy.series.gruntz.sign",
    "type": "function",
    "description": "\n    Returns a sign of an expression e(x) for x->oo.\n\n    ::\n\n        e >  0 for x sufficiently large ...  1\n        e == 0 for x sufficiently large ...  0\n        e <  0 for x sufficiently large ... -1\n\n    The result of this function is currently undefined if e changes sign\n    arbitrarily often for arbitrarily large x (e.g. sin(x)).\n\n    Note that this returns zero only if e is *constantly* zero\n    for x sufficiently large. [If e is constant, of course, this is just\n    the same thing as the sign of e.]\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "mrv",
    "full_id": "sympy.series.gruntz.mrv",
    "type": "function",
    "description": "Returns a SubsSet of most rapidly varying (mrv) subexpressions of 'e',\n    and e rewritten in terms of these",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "mrv_max1",
    "full_id": "sympy.series.gruntz.mrv_max1",
    "type": "function",
    "description": "Computes the maximum of two sets of expressions f and g, which\n    are in the same comparability class, i.e. mrv_max1() compares (two elements of)\n    f and g and returns the set, which is in the higher comparability class\n    of the union of both, if they have the same order of variation.\n    Also returns exps, with the appropriate substitutions made.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "mrv_max3",
    "full_id": "sympy.series.gruntz.mrv_max3",
    "type": "function",
    "description": "\n    Computes the maximum of two sets of expressions f and g, which\n    are in the same comparability class, i.e. max() compares (two elements of)\n    f and g and returns either (f, expsf) [if f is larger], (g, expsg)\n    [if g is larger] or (union, expsboth) [if f, g are of the same class].\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "copy",
    "full_id": "sympy.series.gruntz.SubsSet.copy",
    "type": "method",
    "description": "Create a shallow copy of SubsSet",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "do_subs",
    "full_id": "sympy.series.gruntz.SubsSet.do_subs",
    "type": "method",
    "description": "Substitute the variables with expressions",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "meets",
    "full_id": "sympy.series.gruntz.SubsSet.meets",
    "type": "method",
    "description": "Tell whether or not self and s2 have non-empty intersection",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "union",
    "full_id": "sympy.series.gruntz.SubsSet.union",
    "type": "method",
    "description": "Compute the union of self and s2, adjusting exps",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "series",
    "full_id": "sympy.series.series.series",
    "type": "function",
    "description": "Series expansion of expr around point `x = x0`.\n\n    Parameters\n    ==========\n\n    expr : Expression\n           The expression whose series is to be expanded.\n\n    x : Symbol\n        It is the variable of the expression to be calculated.\n\n    x0 : Value\n         The value around which ``x`` is calculated. Can be any value\n         from ``-oo`` to ``oo``.\n\n    n : Value\n        The number of terms upto which the series is to be expanded.\n\n    dir : String, optional\n          The series-expansion can be bi-directional. If ``dir=\"+\"``,\n          then (x->x0+). If ``dir=\"-\"``, then (x->x0-). For infinite\n          ``x0`` (``oo`` or ``-oo``), the ``dir`` argument is determined\n          from the direction of the infinity (i.e., ``dir=\"-\"`` for\n          ``oo``).\n\n    Examples\n    ========\n\n    >>> from sympy import series, tan, oo\n    >>> from sympy.abc import x\n    >>> f = tan(x)\n    >>> series(f, x, 2, 6, \"+\")\n    tan(2) + (1 + tan(2)**2)*(x - 2) + (x - 2)**2*(tan(2)**3 + tan(2)) +\n    (x - 2)**3*(1/3 + 4*tan(2)**2/3 + tan(2)**4) + (x - 2)**4*(tan(2)**5 +\n    5*tan(2)**3/3 + 2*tan(2)/3) + (x - 2)**5*(2/15 + 17*tan(2)**2/15 +\n    2*tan(2)**4 + tan(2)**6) + O((x - 2)**6, (x, 2))\n\n    >>> series(f, x, 2, 3, \"-\")\n    tan(2) + (2 - x)*(-tan(2)**2 - 1) + (2 - x)**2*(tan(2)**3 + tan(2))\n    + O((x - 2)**3, (x, 2))\n\n    >>> series(f, x, 2, oo, \"+\")\n    Traceback (most recent call last):\n    ...\n    TypeError: 'Infinity' object cannot be interpreted as an integer\n\n    Returns\n    =======\n\n    Expr\n        Series expansion of the expression about x0\n\n    See Also\n    ========\n\n    sympy.core.expr.Expr.series: See the docstring of Expr.series() for complete details of this wrapper.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.series.order.Order.contains",
    "type": "method",
    "description": "\n        Return True if expr belongs to Order(self.expr, \\*self.variables).\n        Return False if self belongs to expr.\n        Return None if the inclusion relation cannot be determined\n        (e.g. when self and expr have different symbols).\n        ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "richardson",
    "full_id": "sympy.series.acceleration.richardson",
    "type": "function",
    "description": "\n    Calculate an approximation for lim k->oo A(k) using Richardson\n    extrapolation with the terms A(n), A(n+1), ..., A(n+N+1).\n    Choosing N ~= 2*n often gives good results.\n\n    Examples\n    ========\n\n    A simple example is to calculate exp(1) using the limit definition.\n    This limit converges slowly; n = 100 only produces two accurate\n    digits:\n\n        >>> from sympy.abc import n\n        >>> e = (1 + 1/n)**n\n        >>> print(round(e.subs(n, 100).evalf(), 10))\n        2.7048138294\n\n    Richardson extrapolation with 11 appropriately chosen terms gives\n    a value that is accurate to the indicated precision:\n\n        >>> from sympy import E\n        >>> from sympy.series.acceleration import richardson\n        >>> print(round(richardson(e, n, 10, 20).evalf(), 10))\n        2.7182818285\n        >>> print(round(E.evalf(), 10))\n        2.7182818285\n\n    Another useful application is to speed up convergence of series.\n    Computing 100 terms of the zeta(2) series 1/k**2 yields only\n    two accurate digits:\n\n        >>> from sympy.abc import k, n\n        >>> from sympy import Sum\n        >>> A = Sum(k**-2, (k, 1, n))\n        >>> print(round(A.subs(n, 100).evalf(), 10))\n        1.6349839002\n\n    Richardson extrapolation performs much better:\n\n        >>> from sympy import pi\n        >>> print(round(richardson(A, n, 10, 20).evalf(), 10))\n        1.6449340668\n        >>> print(round(((pi**2)/6).evalf(), 10))     # Exact value\n        1.6449340668\n\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "shanks",
    "full_id": "sympy.series.acceleration.shanks",
    "type": "function",
    "description": "\n    Calculate an approximation for lim k->oo A(k) using the n-term Shanks\n    transformation S(A)(n). With m > 1, calculate the m-fold recursive\n    Shanks transformation S(S(...S(A)...))(n).\n\n    The Shanks transformation is useful for summing Taylor series that\n    converge slowly near a pole or singularity, e.g. for log(2):\n\n        >>> from sympy.abc import k, n\n        >>> from sympy import Sum, Integer\n        >>> from sympy.series.acceleration import shanks\n        >>> A = Sum(Integer(-1)**(k+1) / k, (k, 1, n))\n        >>> print(round(A.subs(n, 100).doit().evalf(), 10))\n        0.6881721793\n        >>> print(round(shanks(A, n, 25).evalf(), 10))\n        0.6931396564\n        >>> print(round(shanks(A, n, 25, 5).evalf(), 10))\n        0.6931471806\n\n    The correct value is 0.6931471805599453094172321215.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "residue",
    "full_id": "sympy.series.residues.residue",
    "type": "function",
    "description": "\n    Finds the residue of ``expr`` at the point x=x0.\n\n    The residue is defined as the coefficient of ``1/(x-x0)`` in the power series\n    expansion about ``x=x0``.\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, residue, sin\n    >>> x = Symbol(\"x\")\n    >>> residue(1/x, x, 0)\n    1\n    >>> residue(1/x**2, x, 0)\n    0\n    >>> residue(2/sin(x), x, 0)\n    2\n\n    This function is essential for the Residue Theorem [1].\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Residue_theorem\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/series/series.html"
  },
  {
    "name": "sequence",
    "full_id": "sympy.series.sequences.sequence",
    "type": "function",
    "description": "\n    Returns appropriate sequence object.\n\n    Explanation\n    ===========\n\n    If ``seq`` is a SymPy sequence, returns :class:`SeqPer` object\n    otherwise returns :class:`SeqFormula` object.\n\n    Examples\n    ========\n\n    >>> from sympy import sequence\n    >>> from sympy.abc import n\n    >>> sequence(n**2, (n, 0, 5))\n    SeqFormula(n**2, (n, 0, 5))\n    >>> sequence((1, 2, 3), (n, 0, 5))\n    SeqPer((1, 2, 3), (n, 0, 5))\n\n    See Also\n    ========\n\n    sympy.series.sequences.SeqPer\n    sympy.series.sequences.SeqFormula\n    ",
    "section": "Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "coeff",
    "full_id": "sympy.series.sequences.SeqBase.coeff",
    "type": "method",
    "description": "Returns the coefficient at point pt",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "coeff_mul",
    "full_id": "sympy.series.sequences.SeqBase.coeff_mul",
    "type": "method",
    "description": "\n        Should be used when ``other`` is not a sequence. Should be\n        defined to define custom behaviour.\n\n        Examples\n        ========\n\n        >>> from sympy import SeqFormula\n        >>> from sympy.abc import n\n        >>> SeqFormula(n**2).coeff_mul(2)\n        SeqFormula(2*n**2, (n, 0, oo))\n\n        Notes\n        =====\n\n        '*' defines multiplication of sequences with sequences only.\n        ",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "find_linear_recurrence",
    "full_id": "sympy.series.sequences.SeqBase.find_linear_recurrence",
    "type": "method",
    "description": "\n        Finds the shortest linear recurrence that satisfies the first n\n        terms of sequence of order `\\leq` ``n/2`` if possible.\n        If ``d`` is specified, find shortest linear recurrence of order\n        `\\leq` min(d, n/2) if possible.\n        Returns list of coefficients ``[b(1), b(2), ...]`` corresponding to the\n        recurrence relation ``x(n) = b(1)*x(n-1) + b(2)*x(n-2) + ...``\n        Returns ``[]`` if no recurrence is found.\n        If gfvar is specified, also returns ordinary generating function as a\n        function of gfvar.\n\n        Examples\n        ========\n\n        >>> from sympy import sequence, sqrt, oo, lucas\n        >>> from sympy.abc import n, x, y\n        >>> sequence(n**2).find_linear_recurrence(10, 2)\n        []\n        >>> sequence(n**2).find_linear_recurrence(10)\n        [3, -3, 1]\n        >>> sequence(2**n).find_linear_recurrence(10)\n        [2]\n        >>> sequence(23*n**4+91*n**2).find_linear_recurrence(10)\n        [5, -10, 10, -5, 1]\n        >>> sequence(sqrt(5)*(((1 + sqrt(5))/2)**n - (-(1 + sqrt(5))/2)**(-n))/5).find_linear_recurrence(10)\n        [1, 1]\n        >>> sequence(x+y*(-2)**(-n), (n, 0, oo)).find_linear_recurrence(30)\n        [1/2, 1/2]\n        >>> sequence(3*5**n + 12).find_linear_recurrence(20,gfvar=x)\n        ([6, -5], 3*(5 - 21*x)/((x - 1)*(5*x - 1)))\n        >>> sequence(lucas(n)).find_linear_recurrence(15,gfvar=x)\n        ([1, 1], (x - 2)/(x**2 + x - 1))\n        ",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.series.sequences.SeqBase.free_symbols",
    "type": "property",
    "description": "\n        This method returns the symbols in the object, excluding those\n        that take on a specific value (i.e. the dummy symbols).\n\n        Examples\n        ========\n\n        >>> from sympy import SeqFormula\n        >>> from sympy.abc import n, m\n        >>> SeqFormula(m*n**2, (n, 0, 5)).free_symbols\n        {m}\n        ",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "gen",
    "full_id": "sympy.series.sequences.SeqBase.gen",
    "type": "property",
    "description": "Returns the generator for the sequence",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "interval",
    "full_id": "sympy.series.sequences.SeqBase.interval",
    "type": "property",
    "description": "The interval on which the sequence is defined",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "length",
    "full_id": "sympy.series.sequences.SeqBase.length",
    "type": "property",
    "description": "Length of the sequence",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "start",
    "full_id": "sympy.series.sequences.SeqBase.start",
    "type": "property",
    "description": "The starting point of the sequence. This point is included",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "stop",
    "full_id": "sympy.series.sequences.SeqBase.stop",
    "type": "property",
    "description": "The ending point of the sequence. This point is included",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "variables",
    "full_id": "sympy.series.sequences.SeqBase.variables",
    "type": "property",
    "description": "Returns a tuple of variables that are bounded",
    "section": "Sequences Base",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "coeff_mul",
    "full_id": "sympy.series.sequences.SeqFormula.coeff_mul",
    "type": "method",
    "description": "See docstring of SeqBase.coeff_mul",
    "section": "Elementary Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "reduce",
    "full_id": "sympy.series.sequences.SeqAdd.reduce",
    "type": "method",
    "description": "Simplify :class:`SeqAdd` using known rules.\n\n        Iterates through all pairs and ask the constituent\n        sequences if they can simplify themselves with any other constituent.\n\n        Notes\n        =====\n\n        adapted from ``Union.reduce``\n\n        ",
    "section": "Compound Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "reduce",
    "full_id": "sympy.series.sequences.SeqMul.reduce",
    "type": "method",
    "description": "Simplify a :class:`SeqMul` using known rules.\n\n        Explanation\n        ===========\n\n        Iterates through all pairs and ask the constituent\n        sequences if they can simplify themselves with any other constituent.\n\n        Notes\n        =====\n\n        adapted from ``Union.reduce``\n\n        ",
    "section": "Compound Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "initial",
    "full_id": "sympy.series.sequences.RecursiveSeq.initial",
    "type": "property",
    "description": "The initial values of the sequence",
    "section": "Recursive Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "interval",
    "full_id": "sympy.series.sequences.RecursiveSeq.interval",
    "type": "property",
    "description": "Interval on which sequence is defined.",
    "section": "Recursive Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "n",
    "full_id": "sympy.series.sequences.RecursiveSeq.n",
    "type": "property",
    "description": "Sequence index symbol",
    "section": "Recursive Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "recurrence",
    "full_id": "sympy.series.sequences.RecursiveSeq.recurrence",
    "type": "property",
    "description": "Equation defining recurrence.",
    "section": "Recursive Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "stop",
    "full_id": "sympy.series.sequences.RecursiveSeq.stop",
    "type": "property",
    "description": "The ending point of the sequence. (oo)",
    "section": "Recursive Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "y",
    "full_id": "sympy.series.sequences.RecursiveSeq.y",
    "type": "property",
    "description": "Undefined function for the nth term of the sequence",
    "section": "Recursive Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "yn",
    "full_id": "sympy.series.sequences.RecursiveSeq.yn",
    "type": "property",
    "description": "Applied function representing the nth term",
    "section": "Recursive Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/sequences.html"
  },
  {
    "name": "scale",
    "full_id": "sympy.series.fourier.FourierSeries.scale",
    "type": "method",
    "description": "\n        Scale the function by a term independent of x.\n\n        Explanation\n        ===========\n\n        f(x) -> s * f(x)\n\n        This is fast, if Fourier series of f(x) is already\n        computed.\n\n        Examples\n        ========\n\n        >>> from sympy import fourier_series, pi\n        >>> from sympy.abc import x\n        >>> s = fourier_series(x**2, (x, -pi, pi))\n        >>> s.scale(2).truncate()\n        -8*cos(x) + 2*cos(2*x) + 2*pi**2/3\n        ",
    "section": "Fourier Series",
    "url": "https://docs.sympy.org/latest/modules/series/fourier.html"
  },
  {
    "name": "scalex",
    "full_id": "sympy.series.fourier.FourierSeries.scalex",
    "type": "method",
    "description": "\n        Scale x by a term independent of x.\n\n        Explanation\n        ===========\n\n        f(x) -> f(s*x)\n\n        This is fast, if Fourier series of f(x) is already\n        computed.\n\n        Examples\n        ========\n\n        >>> from sympy import fourier_series, pi\n        >>> from sympy.abc import x\n        >>> s = fourier_series(x**2, (x, -pi, pi))\n        >>> s.scalex(2).truncate()\n        -4*cos(2*x) + cos(4*x) + pi**2/3\n        ",
    "section": "Fourier Series",
    "url": "https://docs.sympy.org/latest/modules/series/fourier.html"
  },
  {
    "name": "shift",
    "full_id": "sympy.series.fourier.FourierSeries.shift",
    "type": "method",
    "description": "\n        Shift the function by a term independent of x.\n\n        Explanation\n        ===========\n\n        f(x) -> f(x) + s\n\n        This is fast, if Fourier series of f(x) is already\n        computed.\n\n        Examples\n        ========\n\n        >>> from sympy import fourier_series, pi\n        >>> from sympy.abc import x\n        >>> s = fourier_series(x**2, (x, -pi, pi))\n        >>> s.shift(1).truncate()\n        -4*cos(x) + cos(2*x) + 1 + pi**2/3\n        ",
    "section": "Fourier Series",
    "url": "https://docs.sympy.org/latest/modules/series/fourier.html"
  },
  {
    "name": "shiftx",
    "full_id": "sympy.series.fourier.FourierSeries.shiftx",
    "type": "method",
    "description": "\n        Shift x by a term independent of x.\n\n        Explanation\n        ===========\n\n        f(x) -> f(x + s)\n\n        This is fast, if Fourier series of f(x) is already\n        computed.\n\n        Examples\n        ========\n\n        >>> from sympy import fourier_series, pi\n        >>> from sympy.abc import x\n        >>> s = fourier_series(x**2, (x, -pi, pi))\n        >>> s.shiftx(1).truncate()\n        -4*cos(x + 1) + cos(2*x + 2) + pi**2/3\n        ",
    "section": "Fourier Series",
    "url": "https://docs.sympy.org/latest/modules/series/fourier.html"
  },
  {
    "name": "sigma_approximation",
    "full_id": "sympy.series.fourier.FourierSeries.sigma_approximation",
    "type": "method",
    "description": "\n        Return :math:`\\sigma`-approximation of Fourier series with respect\n        to order n.\n\n        Explanation\n        ===========\n\n        Sigma approximation adjusts a Fourier summation to eliminate the Gibbs\n        phenomenon which would otherwise occur at discontinuities.\n        A sigma-approximated summation for a Fourier series of a T-periodical\n        function can be written as\n\n        .. math::\n            s(\\theta) = \\frac{1}{2} a_0 + \\sum _{k=1}^{m-1}\n            \\operatorname{sinc} \\Bigl( \\frac{k}{m} \\Bigr) \\cdot\n            \\left[ a_k \\cos \\Bigl( \\frac{2\\pi k}{T} \\theta \\Bigr)\n            + b_k \\sin \\Bigl( \\frac{2\\pi k}{T} \\theta \\Bigr) \\right],\n\n        where :math:`a_0, a_k, b_k, k=1,\\ldots,{m-1}` are standard Fourier\n        series coefficients and\n        :math:`\\operatorname{sinc} \\Bigl( \\frac{k}{m} \\Bigr)` is a Lanczos\n        :math:`\\sigma` factor (expressed in terms of normalized\n        :math:`\\operatorname{sinc}` function).\n\n        Parameters\n        ==========\n\n        n : int\n            Highest order of the terms taken into account in approximation.\n\n        Returns\n        =======\n\n        Expr :\n            Sigma approximation of function expanded into Fourier series.\n\n        Examples\n        ========\n\n        >>> from sympy import fourier_series, pi\n        >>> from sympy.abc import x\n        >>> s = fourier_series(x, (x, -pi, pi))\n        >>> s.sigma_approximation(4)\n        2*sin(x)*sinc(pi/4) - 2*sin(2*x)/pi + 2*sin(3*x)*sinc(3*pi/4)/3\n\n        See Also\n        ========\n\n        sympy.series.fourier.FourierSeries.truncate\n\n        Notes\n        =====\n\n        The behaviour of\n        :meth:`~sympy.series.fourier.FourierSeries.sigma_approximation`\n        is different from :meth:`~sympy.series.fourier.FourierSeries.truncate`\n        - it takes all nonzero terms of degree smaller than n, rather than\n        first n nonzero ones.\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Gibbs_phenomenon\n        .. [2] https://en.wikipedia.org/wiki/Sigma_approximation\n        ",
    "section": "Fourier Series",
    "url": "https://docs.sympy.org/latest/modules/series/fourier.html"
  },
  {
    "name": "truncate",
    "full_id": "sympy.series.fourier.FourierSeries.truncate",
    "type": "method",
    "description": "\n        Return the first n nonzero terms of the series.\n\n        If ``n`` is None return an iterator.\n\n        Parameters\n        ==========\n\n        n : int or None\n            Amount of non-zero terms in approximation or None.\n\n        Returns\n        =======\n\n        Expr or iterator :\n            Approximation of function expanded into Fourier series.\n\n        Examples\n        ========\n\n        >>> from sympy import fourier_series, pi\n        >>> from sympy.abc import x\n        >>> s = fourier_series(x, (x, -pi, pi))\n        >>> s.truncate(4)\n        2*sin(x) - sin(2*x) + 2*sin(3*x)/3 - sin(4*x)/2\n\n        See Also\n        ========\n\n        sympy.series.fourier.FourierSeries.sigma_approximation\n        ",
    "section": "Fourier Series",
    "url": "https://docs.sympy.org/latest/modules/series/fourier.html"
  },
  {
    "name": "fourier_series",
    "full_id": "sympy.series.fourier.fourier_series",
    "type": "function",
    "description": "Computes the Fourier trigonometric series expansion.\n\n    Explanation\n    ===========\n\n    Fourier trigonometric series of $f(x)$ over the interval $(a, b)$\n    is defined as:\n\n    .. math::\n        \\frac{a_0}{2} + \\sum_{n=1}^{\\infty}\n        (a_n \\cos(\\frac{2n \\pi x}{L}) + b_n \\sin(\\frac{2n \\pi x}{L}))\n\n    where the coefficients are:\n\n    .. math::\n        L = b - a\n\n    .. math::\n        a_0 = \\frac{2}{L} \\int_{a}^{b}{f(x) dx}\n\n    .. math::\n        a_n = \\frac{2}{L} \\int_{a}^{b}{f(x) \\cos(\\frac{2n \\pi x}{L}) dx}\n\n    .. math::\n        b_n = \\frac{2}{L} \\int_{a}^{b}{f(x) \\sin(\\frac{2n \\pi x}{L}) dx}\n\n    The condition whether the function $f(x)$ given should be periodic\n    or not is more than necessary, because it is sufficient to consider\n    the series to be converging to $f(x)$ only in the given interval,\n    not throughout the whole real line.\n\n    This also brings a lot of ease for the computation because\n    you do not have to make $f(x)$ artificially periodic by\n    wrapping it with piecewise, modulo operations,\n    but you can shape the function to look like the desired periodic\n    function only in the interval $(a, b)$, and the computed series will\n    automatically become the series of the periodic version of $f(x)$.\n\n    This property is illustrated in the examples section below.\n\n    Parameters\n    ==========\n\n    limits : (sym, start, end), optional\n        *sym* denotes the symbol the series is computed with respect to.\n\n        *start* and *end* denotes the start and the end of the interval\n        where the fourier series converges to the given function.\n\n        Default range is specified as $-\\pi$ and $\\pi$.\n\n    Returns\n    =======\n\n    FourierSeries\n        A symbolic object representing the Fourier trigonometric series.\n\n    Examples\n    ========\n\n    Computing the Fourier series of $f(x) = x^2$:\n\n    >>> from sympy import fourier_series, pi\n    >>> from sympy.abc import x\n    >>> f = x**2\n    >>> s = fourier_series(f, (x, -pi, pi))\n    >>> s1 = s.truncate(n=3)\n    >>> s1\n    -4*cos(x) + cos(2*x) + pi**2/3\n\n    Shifting of the Fourier series:\n\n    >>> s.shift(1).truncate()\n    -4*cos(x) + cos(2*x) + 1 + pi**2/3\n    >>> s.shiftx(1).truncate()\n    -4*cos(x + 1) + cos(2*x + 2) + pi**2/3\n\n    Scaling of the Fourier series:\n\n    >>> s.scale(2).truncate()\n    -8*cos(x) + 2*cos(2*x) + 2*pi**2/3\n    >>> s.scalex(2).truncate()\n    -4*cos(2*x) + cos(4*x) + pi**2/3\n\n    Computing the Fourier series of $f(x) = x$:\n\n    This illustrates how truncating to the higher order gives better\n    convergence.\n\n    .. plot::\n        :context: reset\n        :format: doctest\n        :include-source: True\n\n        >>> from sympy import fourier_series, pi, plot\n        >>> from sympy.abc import x\n        >>> f = x\n        >>> s = fourier_series(f, (x, -pi, pi))\n        >>> s1 = s.truncate(n = 3)\n        >>> s2 = s.truncate(n = 5)\n        >>> s3 = s.truncate(n = 7)\n        >>> p = plot(f, s1, s2, s3, (x, -pi, pi), show=False, legend=True)\n\n        >>> p[0].line_color = (0, 0, 0)\n        >>> p[0].label = 'x'\n        >>> p[1].line_color = (0.7, 0.7, 0.7)\n        >>> p[1].label = 'n=3'\n        >>> p[2].line_color = (0.5, 0.5, 0.5)\n        >>> p[2].label = 'n=5'\n        >>> p[3].line_color = (0.3, 0.3, 0.3)\n        >>> p[3].label = 'n=7'\n\n        >>> p.show()\n\n    This illustrates how the series converges to different sawtooth\n    waves if the different ranges are specified.\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> s1 = fourier_series(x, (x, -1, 1)).truncate(10)\n        >>> s2 = fourier_series(x, (x, -pi, pi)).truncate(10)\n        >>> s3 = fourier_series(x, (x, 0, 1)).truncate(10)\n        >>> p = plot(x, s1, s2, s3, (x, -5, 5), show=False, legend=True)\n\n        >>> p[0].line_color = (0, 0, 0)\n        >>> p[0].label = 'x'\n        >>> p[1].line_color = (0.7, 0.7, 0.7)\n        >>> p[1].label = '[-1, 1]'\n        >>> p[2].line_color = (0.5, 0.5, 0.5)\n        >>> p[2].label = '[-pi, pi]'\n        >>> p[3].line_color = (0.3, 0.3, 0.3)\n        >>> p[3].label = '[0, 1]'\n\n        >>> p.show()\n\n    Notes\n    =====\n\n    Computing Fourier series can be slow\n    due to the integration required in computing\n    an, bn.\n\n    It is faster to compute Fourier series of a function\n    by using shifting and scaling on an already\n    computed Fourier series rather than computing\n    again.\n\n    e.g. If the Fourier series of ``x**2`` is known\n    the Fourier series of ``x**2 - 1`` can be found by shifting by ``-1``.\n\n    See Also\n    ========\n\n    sympy.series.fourier.FourierSeries\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/FourierSeries.html\n    ",
    "section": "Fourier Series",
    "url": "https://docs.sympy.org/latest/modules/series/fourier.html"
  },
  {
    "name": "coeff_bell",
    "full_id": "sympy.series.formal.FormalPowerSeries.coeff_bell",
    "type": "method",
    "description": "\n        self.coeff_bell(n) returns a sequence of Bell polynomials of the second kind.\n        Note that ``n`` should be a integer.\n\n        The second kind of Bell polynomials (are sometimes called \"partial\" Bell\n        polynomials or incomplete Bell polynomials) are defined as\n\n        .. math::\n            B_{n,k}(x_1, x_2,\\dotsc x_{n-k+1}) =\n                \\sum_{j_1+j_2+j_2+\\dotsb=k \\atop j_1+2j_2+3j_2+\\dotsb=n}\n                \\frac{n!}{j_1!j_2!\\dotsb j_{n-k+1}!}\n                \\left(\\frac{x_1}{1!} \\right)^{j_1}\n                \\left(\\frac{x_2}{2!} \\right)^{j_2} \\dotsb\n                \\left(\\frac{x_{n-k+1}}{(n-k+1)!} \\right) ^{j_{n-k+1}}.\n\n        * ``bell(n, k, (x1, x2, ...))`` gives Bell polynomials of the second kind,\n          `B_{n,k}(x_1, x_2, \\dotsc, x_{n-k+1})`.\n\n        See Also\n        ========\n\n        sympy.functions.combinatorial.numbers.bell\n\n        ",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "compose",
    "full_id": "sympy.series.formal.FormalPowerSeries.compose",
    "type": "method",
    "description": "\n        Returns the truncated terms of the formal power series of the composed function,\n        up to specified ``n``.\n\n        Explanation\n        ===========\n\n        If ``f`` and ``g`` are two formal power series of two different functions,\n        then the coefficient sequence ``ak`` of the composed formal power series `fp`\n        will be as follows.\n\n        .. math::\n            \\sum\\limits_{k=0}^{n} b_k B_{n,k}(x_1, x_2, \\dotsc, x_{n-k+1})\n\n        Parameters\n        ==========\n\n        n : Number, optional\n            Specifies the order of the term up to which the polynomial should\n            be truncated.\n\n        Examples\n        ========\n\n        >>> from sympy import fps, sin, exp\n        >>> from sympy.abc import x\n        >>> f1 = fps(exp(x))\n        >>> f2 = fps(sin(x))\n\n        >>> f1.compose(f2, x).truncate()\n        1 + x + x**2/2 - x**4/8 - x**5/15 + O(x**6)\n\n        >>> f1.compose(f2, x).truncate(8)\n        1 + x + x**2/2 - x**4/8 - x**5/15 - x**6/240 + x**7/90 + O(x**8)\n\n        See Also\n        ========\n\n        sympy.functions.combinatorial.numbers.bell\n        sympy.series.formal.FormalPowerSeriesCompose\n\n        References\n        ==========\n\n        .. [1] Comtet, Louis: Advanced combinatorics; the art of finite and infinite expansions. Reidel, 1974.\n\n        ",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "infinite",
    "full_id": "sympy.series.formal.FormalPowerSeries.infinite",
    "type": "property",
    "description": "Returns an infinite representation of the series",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "integrate",
    "full_id": "sympy.series.formal.FormalPowerSeries.integrate",
    "type": "method",
    "description": "\n        Integrate Formal Power Series.\n\n        Examples\n        ========\n\n        >>> from sympy import fps, sin, integrate\n        >>> from sympy.abc import x\n        >>> f = fps(sin(x))\n        >>> f.integrate(x).truncate()\n        -1 + x**2/2 - x**4/24 + O(x**6)\n        >>> integrate(f, (x, 0, 1))\n        1 - cos(1)\n        ",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "inverse",
    "full_id": "sympy.series.formal.FormalPowerSeries.inverse",
    "type": "method",
    "description": "\n        Returns the truncated terms of the inverse of the formal power series,\n        up to specified ``n``.\n\n        Explanation\n        ===========\n\n        If ``f`` and ``g`` are two formal power series of two different functions,\n        then the coefficient sequence ``ak`` of the composed formal power series ``fp``\n        will be as follows.\n\n        .. math::\n            \\sum\\limits_{k=0}^{n} (-1)^{k} x_0^{-k-1} B_{n,k}(x_1, x_2, \\dotsc, x_{n-k+1})\n\n        Parameters\n        ==========\n\n        n : Number, optional\n            Specifies the order of the term up to which the polynomial should\n            be truncated.\n\n        Examples\n        ========\n\n        >>> from sympy import fps, exp, cos\n        >>> from sympy.abc import x\n        >>> f1 = fps(exp(x))\n        >>> f2 = fps(cos(x))\n\n        >>> f1.inverse(x).truncate()\n        1 - x + x**2/2 - x**3/6 + x**4/24 - x**5/120 + O(x**6)\n\n        >>> f2.inverse(x).truncate(8)\n        1 + x**2/2 + 5*x**4/24 + 61*x**6/720 + O(x**8)\n\n        See Also\n        ========\n\n        sympy.functions.combinatorial.numbers.bell\n        sympy.series.formal.FormalPowerSeriesInverse\n\n        References\n        ==========\n\n        .. [1] Comtet, Louis: Advanced combinatorics; the art of finite and infinite expansions. Reidel, 1974.\n\n        ",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "polynomial",
    "full_id": "sympy.series.formal.FormalPowerSeries.polynomial",
    "type": "method",
    "description": "\n        Truncated series as polynomial.\n\n        Explanation\n        ===========\n\n        Returns series expansion of ``f`` upto order ``O(x**n)``\n        as a polynomial(without ``O`` term).\n        ",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "product",
    "full_id": "sympy.series.formal.FormalPowerSeries.product",
    "type": "method",
    "description": "\n        Multiplies two Formal Power Series, using discrete convolution and\n        return the truncated terms upto specified order.\n\n        Parameters\n        ==========\n\n        n : Number, optional\n            Specifies the order of the term up to which the polynomial should\n            be truncated.\n\n        Examples\n        ========\n\n        >>> from sympy import fps, sin, exp\n        >>> from sympy.abc import x\n        >>> f1 = fps(sin(x))\n        >>> f2 = fps(exp(x))\n\n        >>> f1.product(f2, x).truncate(4)\n        x + x**2 + x**3/3 + O(x**4)\n\n        See Also\n        ========\n\n        sympy.discrete.convolutions\n        sympy.series.formal.FormalPowerSeriesProduct\n\n        ",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "truncate",
    "full_id": "sympy.series.formal.FormalPowerSeries.truncate",
    "type": "method",
    "description": "\n        Truncated series.\n\n        Explanation\n        ===========\n\n        Returns truncated series expansion of f upto\n        order ``O(x**n)``.\n\n        If n is ``None``, returns an infinite iterator.\n        ",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "fps",
    "full_id": "sympy.series.formal.fps",
    "type": "function",
    "description": "\n    Generates Formal Power Series of ``f``.\n\n    Explanation\n    ===========\n\n    Returns the formal series expansion of ``f`` around ``x = x0``\n    with respect to ``x`` in the form of a ``FormalPowerSeries`` object.\n\n    Formal Power Series is represented using an explicit formula\n    computed using different algorithms.\n\n    See :func:`compute_fps` for the more details regarding the computation\n    of formula.\n\n    Parameters\n    ==========\n\n    x : Symbol, optional\n        If x is None and ``f`` is univariate, the univariate symbols will be\n        supplied, otherwise an error will be raised.\n    x0 : number, optional\n        Point to perform series expansion about. Default is 0.\n    dir : {1, -1, '+', '-'}, optional\n        If dir is 1 or '+' the series is calculated from the right and\n        for -1 or '-' the series is calculated from the left. For smooth\n        functions this flag will not alter the results. Default is 1.\n    hyper : {True, False}, optional\n        Set hyper to False to skip the hypergeometric algorithm.\n        By default it is set to False.\n    order : int, optional\n        Order of the derivative of ``f``, Default is 4.\n    rational : {True, False}, optional\n        Set rational to False to skip rational algorithm. By default it is set\n        to True.\n    full : {True, False}, optional\n        Set full to True to increase the range of rational algorithm.\n        See :func:`rational_algorithm` for details. By default it is set to\n        False.\n\n    Examples\n    ========\n\n    >>> from sympy import fps, ln, atan, sin\n    >>> from sympy.abc import x, n\n\n    Rational Functions\n\n    >>> fps(ln(1 + x)).truncate()\n    x - x**2/2 + x**3/3 - x**4/4 + x**5/5 + O(x**6)\n\n    >>> fps(atan(x), full=True).truncate()\n    x - x**3/3 + x**5/5 + O(x**6)\n\n    Symbolic Functions\n\n    >>> fps(x**n*sin(x**2), x).truncate(8)\n    -x**(n + 6)/6 + x**(n + 2) + O(x**(n + 8))\n\n    See Also\n    ========\n\n    sympy.series.formal.FormalPowerSeries\n    sympy.series.formal.compute_fps\n    ",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "compute_fps",
    "full_id": "sympy.series.formal.compute_fps",
    "type": "function",
    "description": "\n    Computes the formula for Formal Power Series of a function.\n\n    Explanation\n    ===========\n\n    Tries to compute the formula by applying the following techniques\n    (in order):\n\n    * rational_algorithm\n    * Hypergeometric algorithm\n\n    Parameters\n    ==========\n\n    x : Symbol\n    x0 : number, optional\n        Point to perform series expansion about. Default is 0.\n    dir : {1, -1, '+', '-'}, optional\n        If dir is 1 or '+' the series is calculated from the right and\n        for -1 or '-' the series is calculated from the left. For smooth\n        functions this flag will not alter the results. Default is 1.\n    hyper : {True, False}, optional\n        Set hyper to False to skip the hypergeometric algorithm.\n        By default it is set to False.\n    order : int, optional\n        Order of the derivative of ``f``, Default is 4.\n    rational : {True, False}, optional\n        Set rational to False to skip rational algorithm. By default it is set\n        to True.\n    full : {True, False}, optional\n        Set full to True to increase the range of rational algorithm.\n        See :func:`rational_algorithm` for details. By default it is set to\n        False.\n\n    Returns\n    =======\n\n    ak : sequence\n        Sequence of coefficients.\n    xk : sequence\n        Sequence of powers of x.\n    ind : Expr\n        Independent terms.\n    mul : Pow\n        Common terms.\n\n    See Also\n    ========\n\n    sympy.series.formal.rational_algorithm\n    sympy.series.formal.hyper_algorithm\n    ",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "function",
    "full_id": "sympy.series.formal.FormalPowerSeriesCompose.function",
    "type": "property",
    "description": "Function for the composed formal power series.",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "function",
    "full_id": "sympy.series.formal.FormalPowerSeriesInverse.function",
    "type": "property",
    "description": "Function for the inverse of a formal power series.",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "function",
    "full_id": "sympy.series.formal.FormalPowerSeriesProduct.function",
    "type": "property",
    "description": "Function of the product of two formal power series.",
    "section": "Formal Power Series",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "rational_independent",
    "full_id": "sympy.series.formal.rational_independent",
    "type": "function",
    "description": "\n    Returns a list of all the rationally independent terms.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, cos\n    >>> from sympy.series.formal import rational_independent\n    >>> from sympy.abc import x\n\n    >>> rational_independent([cos(x), sin(x)], x)\n    [cos(x), sin(x)]\n    >>> rational_independent([x**2, sin(x), x*sin(x), x**3], x)\n    [x**3 + x**2, x*sin(x) + sin(x)]\n    ",
    "section": "Rational Algorithm",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "rational_algorithm",
    "full_id": "sympy.series.formal.rational_algorithm",
    "type": "function",
    "description": "\n    Rational algorithm for computing\n    formula of coefficients of Formal Power Series\n    of a function.\n\n    Explanation\n    ===========\n\n    Applicable when f(x) or some derivative of f(x)\n    is a rational function in x.\n\n    :func:`rational_algorithm` uses :func:`~.apart` function for partial fraction\n    decomposition. :func:`~.apart` by default uses 'undetermined coefficients\n    method'. By setting ``full=True``, 'Bronstein's algorithm' can be used\n    instead.\n\n    Looks for derivative of a function up to 4'th order (by default).\n    This can be overridden using order option.\n\n    Parameters\n    ==========\n\n    x : Symbol\n    order : int, optional\n        Order of the derivative of ``f``, Default is 4.\n    full : bool\n\n    Returns\n    =======\n\n    formula : Expr\n    ind : Expr\n        Independent terms.\n    order : int\n    full : bool\n\n    Examples\n    ========\n\n    >>> from sympy import log, atan\n    >>> from sympy.series.formal import rational_algorithm as ra\n    >>> from sympy.abc import x, k\n\n    >>> ra(1 / (1 - x), x, k)\n    (1, 0, 0)\n    >>> ra(log(1 + x), x, k)\n    (-1/((-1)**k*k), 0, 1)\n\n    >>> ra(atan(x), x, k, full=True)\n    ((-I/(2*(-I)**k) + I/(2*I**k))/k, 0, 1)\n\n    Notes\n    =====\n\n    By setting ``full=True``, range of admissible functions to be solved using\n    ``rational_algorithm`` can be increased. This option should be used\n    carefully as it can significantly slow down the computation as ``doit`` is\n    performed on the :class:`~.RootSum` object returned by the :func:`~.apart`\n    function. Use ``full=False`` whenever possible.\n\n    See Also\n    ========\n\n    sympy.polys.partfrac.apart\n\n    References\n    ==========\n\n    .. [1] Formal Power Series - Dominik Gruntz, Wolfram Koepf\n    .. [2] Power Series in Computer Algebra - Wolfram Koepf\n\n    ",
    "section": "Rational Algorithm",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "simpleDE",
    "full_id": "sympy.series.formal.simpleDE",
    "type": "function",
    "description": "\n    Generates simple DE.\n\n    Explanation\n    ===========\n\n    DE is of the form\n\n    .. math::\n        f^k(x) + \\sum\\limits_{j=0}^{k-1} A_j f^j(x) = 0\n\n    where :math:`A_j` should be rational function in x.\n\n    Generates DE's upto order 4 (default). DE's can also have free parameters.\n\n    By increasing order, higher order DE's can be found.\n\n    Yields a tuple of (DE, order).\n    ",
    "section": "Hypergeometric Algorithm",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "exp_re",
    "full_id": "sympy.series.formal.exp_re",
    "type": "function",
    "description": "Converts a DE with constant coefficients (explike) into a RE.\n\n    Explanation\n    ===========\n\n    Performs the substitution:\n\n    .. math::\n        f^j(x) \\to r(k + j)\n\n    Normalises the terms so that lowest order of a term is always r(k).\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Derivative\n    >>> from sympy.series.formal import exp_re\n    >>> from sympy.abc import x, k\n    >>> f, r = Function('f'), Function('r')\n\n    >>> exp_re(-f(x) + Derivative(f(x)), r, k)\n    -r(k) + r(k + 1)\n    >>> exp_re(Derivative(f(x), x) + Derivative(f(x), (x, 2)), r, k)\n    r(k) + r(k + 1)\n\n    See Also\n    ========\n\n    sympy.series.formal.hyper_re\n    ",
    "section": "Hypergeometric Algorithm",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "hyper_re",
    "full_id": "sympy.series.formal.hyper_re",
    "type": "function",
    "description": "\n    Converts a DE into a RE.\n\n    Explanation\n    ===========\n\n    Performs the substitution:\n\n    .. math::\n        x^l f^j(x) \\to (k + 1 - l)_j . a_{k + j - l}\n\n    Normalises the terms so that lowest order of a term is always r(k).\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Derivative\n    >>> from sympy.series.formal import hyper_re\n    >>> from sympy.abc import x, k\n    >>> f, r = Function('f'), Function('r')\n\n    >>> hyper_re(-f(x) + Derivative(f(x)), r, k)\n    (k + 1)*r(k + 1) - r(k)\n    >>> hyper_re(-x*f(x) + Derivative(f(x), (x, 2)), r, k)\n    (k + 2)*(k + 3)*r(k + 3) - r(k)\n\n    See Also\n    ========\n\n    sympy.series.formal.exp_re\n    ",
    "section": "Hypergeometric Algorithm",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "rsolve_hypergeometric",
    "full_id": "sympy.series.formal.rsolve_hypergeometric",
    "type": "function",
    "description": "\n    Solves RE of hypergeometric type.\n\n    Explanation\n    ===========\n\n    Attempts to solve RE of the form\n\n    Q(k)*a(k + m) - P(k)*a(k)\n\n    Transformations that preserve Hypergeometric type:\n\n        a. x**n*f(x): b(k + m) = R(k - n)*b(k)\n        b. f(A*x): b(k + m) = A**m*R(k)*b(k)\n        c. f(x**n): b(k + n*m) = R(k/n)*b(k)\n        d. f(x**(1/m)): b(k + 1) = R(k*m)*b(k)\n        e. f'(x): b(k + m) = ((k + m + 1)/(k + 1))*R(k + 1)*b(k)\n\n    Some of these transformations have been used to solve the RE.\n\n    Returns\n    =======\n\n    formula : Expr\n    ind : Expr\n        Independent terms.\n    order : int\n\n    Examples\n    ========\n\n    >>> from sympy import exp, ln, S\n    >>> from sympy.series.formal import rsolve_hypergeometric as rh\n    >>> from sympy.abc import x, k\n\n    >>> rh(exp(x), x, -S.One, (k + 1), k, 1)\n    (Piecewise((1/factorial(k), Eq(Mod(k, 1), 0)), (0, True)), 1, 1)\n\n    >>> rh(ln(1 + x), x, k**2, k*(k + 1), k, 1)\n    (Piecewise(((-1)**(k - 1)*factorial(k - 1)/RisingFactorial(2, k - 1),\n     Eq(Mod(k, 1), 0)), (0, True)), x, 2)\n\n    References\n    ==========\n\n    .. [1] Formal Power Series - Dominik Gruntz, Wolfram Koepf\n    .. [2] Power Series in Computer Algebra - Wolfram Koepf\n    ",
    "section": "Hypergeometric Algorithm",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "solve_de",
    "full_id": "sympy.series.formal.solve_de",
    "type": "function",
    "description": "\n    Solves the DE.\n\n    Explanation\n    ===========\n\n    Tries to solve DE by either converting into a RE containing two terms or\n    converting into a DE having constant coefficients.\n\n    Returns\n    =======\n\n    formula : Expr\n    ind : Expr\n        Independent terms.\n    order : int\n\n    Examples\n    ========\n\n    >>> from sympy import Derivative as D, Function\n    >>> from sympy import exp, ln\n    >>> from sympy.series.formal import solve_de\n    >>> from sympy.abc import x, k\n    >>> f = Function('f')\n\n    >>> solve_de(exp(x), x, D(f(x), x) - f(x), 1, f, k)\n    (Piecewise((1/factorial(k), Eq(Mod(k, 1), 0)), (0, True)), 1, 1)\n\n    >>> solve_de(ln(1 + x), x, (x + 1)*D(f(x), x, 2) + D(f(x)), 2, f, k)\n    (Piecewise(((-1)**(k - 1)*factorial(k - 1)/RisingFactorial(2, k - 1),\n     Eq(Mod(k, 1), 0)), (0, True)), x, 2)\n    ",
    "section": "Hypergeometric Algorithm",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "hyper_algorithm",
    "full_id": "sympy.series.formal.hyper_algorithm",
    "type": "function",
    "description": "\n    Hypergeometric algorithm for computing Formal Power Series.\n\n    Explanation\n    ===========\n\n    Steps:\n        * Generates DE\n        * Convert the DE into RE\n        * Solves the RE\n\n    Examples\n    ========\n\n    >>> from sympy import exp, ln\n    >>> from sympy.series.formal import hyper_algorithm\n\n    >>> from sympy.abc import x, k\n\n    >>> hyper_algorithm(exp(x), x, k)\n    (Piecewise((1/factorial(k), Eq(Mod(k, 1), 0)), (0, True)), 1, 1)\n\n    >>> hyper_algorithm(ln(1 + x), x, k)\n    (Piecewise(((-1)**(k - 1)*factorial(k - 1)/RisingFactorial(2, k - 1),\n     Eq(Mod(k, 1), 0)), (0, True)), x, 2)\n\n    See Also\n    ========\n\n    sympy.series.formal.simpleDE\n    sympy.series.formal.solve_de\n    ",
    "section": "Hypergeometric Algorithm",
    "url": "https://docs.sympy.org/latest/modules/series/formal.html"
  },
  {
    "name": "difference_delta",
    "full_id": "sympy.series.limitseq.difference_delta",
    "type": "function",
    "description": "Difference Operator.\n\n    Explanation\n    ===========\n\n    Discrete analog of differential operator. Given a sequence x[n],\n    returns the sequence x[n + step] - x[n].\n\n    Examples\n    ========\n\n    >>> from sympy import difference_delta as dd\n    >>> from sympy.abc import n\n    >>> dd(n*(n + 1), n)\n    2*n + 2\n    >>> dd(n*(n + 1), n, 2)\n    4*n + 6\n\n    References\n    ==========\n\n    .. [1] https://reference.wolfram.com/language/ref/DifferenceDelta.html\n    ",
    "section": "Limits of Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/limitseq.html"
  },
  {
    "name": "dominant",
    "full_id": "sympy.series.limitseq.dominant",
    "type": "function",
    "description": "Finds the dominant term in a sum, that is a term that dominates\n    every other term.\n\n    Explanation\n    ===========\n\n    If limit(a/b, n, oo) is oo then a dominates b.\n    If limit(a/b, n, oo) is 0 then b dominates a.\n    Otherwise, a and b are comparable.\n\n    If there is no unique dominant term, then returns ``None``.\n\n    Examples\n    ========\n\n    >>> from sympy import Sum\n    >>> from sympy.series.limitseq import dominant\n    >>> from sympy.abc import n, k\n    >>> dominant(5*n**3 + 4*n**2 + n + 1, n)\n    5*n**3\n    >>> dominant(2**n + Sum(k, (k, 0, n)), n)\n    2**n\n\n    See Also\n    ========\n\n    sympy.series.limitseq.dominant\n    ",
    "section": "Limits of Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/limitseq.html"
  },
  {
    "name": "limit_seq",
    "full_id": "sympy.series.limitseq.limit_seq",
    "type": "function",
    "description": "Finds the limit of a sequence as index ``n`` tends to infinity.\n\n    Parameters\n    ==========\n\n    expr : Expr\n        SymPy expression for the ``n-th`` term of the sequence\n    n : Symbol, optional\n        The index of the sequence, an integer that tends to positive\n        infinity. If None, inferred from the expression unless it has\n        multiple symbols.\n    trials: int, optional\n        The algorithm is highly recursive. ``trials`` is a safeguard from\n        infinite recursion in case the limit is not easily computed by the\n        algorithm. Try increasing ``trials`` if the algorithm returns ``None``.\n\n    Admissible Terms\n    ================\n\n    The algorithm is designed for sequences built from rational functions,\n    indefinite sums, and indefinite products over an indeterminate n. Terms of\n    alternating sign are also allowed, but more complex oscillatory behavior is\n    not supported.\n\n    Examples\n    ========\n\n    >>> from sympy import limit_seq, Sum, binomial\n    >>> from sympy.abc import n, k, m\n    >>> limit_seq((5*n**3 + 3*n**2 + 4) / (3*n**3 + 4*n - 5), n)\n    5/3\n    >>> limit_seq(binomial(2*n, n) / Sum(binomial(2*k, k), (k, 1, n)), n)\n    3/4\n    >>> limit_seq(Sum(k**2 * Sum(2**m/m, (m, 1, k)), (k, 1, n)) / (2**n*n), n)\n    4\n\n    See Also\n    ========\n\n    sympy.series.limitseq.dominant\n\n    References\n    ==========\n\n    .. [1] Computing Limits of Sequences - Manuel Kauers\n    ",
    "section": "Limits of Sequences",
    "url": "https://docs.sympy.org/latest/modules/series/limitseq.html"
  },
  {
    "name": "simplify",
    "full_id": "sympy.simplify.simplify.simplify",
    "type": "function",
    "description": "Simplifies the given expression.\n\n    Explanation\n    ===========\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you do not know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`~.count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output cannot be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you do not\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(1 - log(a)))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If ``rational=True``, Floats will be recast as Rationals before simplification.\n    If ``rational=None``, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n\n    If ``inverse=True``, it will be assumed that a composition of inverse\n    functions, such as sin and asin, can be cancelled in any order.\n    For example, ``asin(sin(x))`` will yield ``x`` without checking whether\n    x belongs to the set where this relation is true. The default is\n    False.\n\n    Note that ``simplify()`` automatically calls ``doit()`` on the final\n    expression. You can avoid this behavior by passing ``doit=False`` as\n    an argument.\n\n    Also, it should be noted that simplifying a boolean expression is not\n    well defined. If the expression prefers automatic evaluation (such as\n    :obj:`~.Eq()` or :obj:`~.Or()`), simplification will return ``True`` or\n    ``False`` if truth value can be determined. If the expression is not\n    evaluated by default (such as :obj:`~.Predicate()`), simplification will\n    not reduce it and you should use :func:`~.refine` or :func:`~.ask`\n    function. This inconsistency will be resolved in future version.\n\n    See Also\n    ========\n\n    sympy.assumptions.refine.refine : Simplification using assumptions.\n    sympy.assumptions.ask.ask : Query for boolean expressions using assumptions.\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "separatevars",
    "full_id": "sympy.simplify.simplify.separatevars",
    "type": "function",
    "description": "\n    Separates variables in an expression, if possible.  By\n    default, it separates with respect to all symbols in an\n    expression and collects constant coefficients that are\n    independent of symbols.\n\n    Explanation\n    ===========\n\n    If ``dict=True`` then the separated terms will be returned\n    in a dictionary keyed to their corresponding symbols.\n    By default, all symbols in the expression will appear as\n    keys; if symbols are provided, then all those symbols will\n    be used as keys, and any terms in the expression containing\n    other symbols or non-symbols will be returned keyed to the\n    string 'coeff'. (Passing None for symbols will return the\n    expression in a dictionary keyed to 'coeff'.)\n\n    If ``force=True``, then bases of powers will be separated regardless\n    of assumptions on the symbols involved.\n\n    Notes\n    =====\n\n    The order of the factors is determined by Mul, so that the\n    separated expressions may not necessarily be grouped together.\n\n    Although factoring is necessary to separate variables in some\n    expressions, it is not necessary in all cases, so one should not\n    count on the returned factors being factored.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z, alpha\n    >>> from sympy import separatevars, sin\n    >>> separatevars((x*y)**y)\n    (x*y)**y\n    >>> separatevars((x*y)**y, force=True)\n    x**y*y**y\n\n    >>> e = 2*x**2*z*sin(y)+2*z*x**2\n    >>> separatevars(e)\n    2*x**2*z*(sin(y) + 1)\n    >>> separatevars(e, symbols=(x, y), dict=True)\n    {'coeff': 2*z, x: x**2, y: sin(y) + 1}\n    >>> separatevars(e, [x, y, alpha], dict=True)\n    {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}\n\n    If the expression is not really separable, or is only partially\n    separable, separatevars will do the best it can to separate it\n    by using factoring.\n\n    >>> separatevars(x + x*y - 3*x**2)\n    -x*(3*x - y - 1)\n\n    If the expression is not separable then expr is returned unchanged\n    or (if dict=True) then None is returned.\n\n    >>> eq = 2*x + y*sin(x)\n    >>> separatevars(eq) == eq\n    True\n    >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) is None\n    True\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "nthroot",
    "full_id": "sympy.simplify.simplify.nthroot",
    "type": "function",
    "description": "\n    Compute a real nth-root of a sum of surds.\n\n    Parameters\n    ==========\n\n    expr : sum of surds\n    n : integer\n    max_len : maximum number of surds passed as constants to ``nsimplify``\n\n    Algorithm\n    =========\n\n    First ``nsimplify`` is used to get a candidate root; if it is not a\n    root the minimal polynomial is computed; the answer is one of its\n    roots.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.simplify import nthroot\n    >>> from sympy import sqrt\n    >>> nthroot(90 + 34*sqrt(7), 3)\n    sqrt(7) + 3\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "kroneckersimp",
    "full_id": "sympy.simplify.simplify.kroneckersimp",
    "type": "function",
    "description": "\n    Simplify expressions with KroneckerDelta.\n\n    The only simplification currently attempted is to identify multiplicative cancellation:\n\n    Examples\n    ========\n\n    >>> from sympy import KroneckerDelta, kroneckersimp\n    >>> from sympy.abc import i\n    >>> kroneckersimp(1 + KroneckerDelta(0, i) * KroneckerDelta(1, i))\n    1\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "besselsimp",
    "full_id": "sympy.simplify.simplify.besselsimp",
    "type": "function",
    "description": "\n    Simplify bessel-type functions.\n\n    Explanation\n    ===========\n\n    This routine tries to simplify bessel-type functions. Currently it only\n    works on the Bessel J and I functions, however. It works by looking at all\n    such functions in turn, and eliminating factors of \"I\" and \"-1\" (actually\n    their polar equivalents) in front of the argument. Then, functions of\n    half-integer order are rewritten using trigonometric functions and\n    functions of integer order (> 1) are rewritten using functions\n    of low order.  Finally, if the expression was changed, compute\n    factorization of the result with factor().\n\n    >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S\n    >>> from sympy.abc import z, nu\n    >>> besselsimp(besselj(nu, z*polar_lift(-1)))\n    exp(I*pi*nu)*besselj(nu, z)\n    >>> besselsimp(besseli(nu, z*polar_lift(-I)))\n    exp(-I*pi*nu/2)*besselj(nu, z)\n    >>> besselsimp(besseli(S(-1)/2, z))\n    sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))\n    >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))\n    3*z*besseli(0, z)/2\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "hypersimp",
    "full_id": "sympy.simplify.simplify.hypersimp",
    "type": "function",
    "description": "Given combinatorial term f(k) simplify its consecutive term ratio\n    i.e. f(k+1)/f(k).  The input term can be composed of functions and\n    integer sequences which have equivalent representation in terms\n    of gamma special function.\n\n    Explanation\n    ===========\n\n    The algorithm performs three basic steps:\n\n    1. Rewrite all functions in terms of gamma, if possible.\n\n    2. Rewrite all occurrences of gamma in terms of products\n       of gamma and rising factorial with integer,  absolute\n       constant exponent.\n\n    3. Perform simplification of nested fractions, powers\n       and if the resulting expression is a quotient of\n       polynomials, reduce their total degree.\n\n    If f(k) is hypergeometric then as result we arrive with a\n    quotient of polynomials of minimal degree. Otherwise None\n    is returned.\n\n    For more information on the implemented algorithm refer to:\n\n    1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,\n       Journal of Symbolic Computation (1995) 20, 399-417\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "hypersimilar",
    "full_id": "sympy.simplify.simplify.hypersimilar",
    "type": "function",
    "description": "\n    Returns True if ``f`` and ``g`` are hyper-similar.\n\n    Explanation\n    ===========\n\n    Similarity in hypergeometric sense means that a quotient of\n    f(k) and g(k) is a rational function in ``k``. This procedure\n    is useful in solving recurrence relations.\n\n    For more information see hypersimp().\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "nsimplify",
    "full_id": "sympy.simplify.simplify.nsimplify",
    "type": "function",
    "description": "\n    Find a simple representation for a number or, if there are free symbols or\n    if ``rational=True``, then replace Floats with their Rational equivalents. If\n    no change is made and rational is not False then Floats will at least be\n    converted to Rationals.\n\n    Explanation\n    ===========\n\n    For numerical expressions, a simple formula that numerically matches the\n    given numerical expression is sought (and the input should be possible\n    to evalf to a precision of at least 30 digits).\n\n    Optionally, a list of (rationally independent) constants to\n    include in the formula may be given.\n\n    A lower tolerance may be set to find less exact matches. If no tolerance\n    is given then the least precise value will set the tolerance (e.g. Floats\n    default to 15 digits of precision, so would be tolerance=10**-15).\n\n    With ``full=True``, a more extensive search is performed\n    (this is useful to find simpler numbers when the tolerance\n    is set low).\n\n    When converting to rational, if rational_conversion='base10' (the default), then\n    convert floats to rationals using their base-10 (string) representation.\n    When rational_conversion='exact' it uses the exact, base-2 representation.\n\n    Examples\n    ========\n\n    >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, pi\n    >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])\n    -2 + 2*GoldenRatio\n    >>> nsimplify((1/(exp(3*pi*I/5)+1)))\n    1/2 - I*sqrt(sqrt(5)/10 + 1/4)\n    >>> nsimplify(I**I, [pi])\n    exp(-pi/2)\n    >>> nsimplify(pi, tolerance=0.01)\n    22/7\n\n    >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact')\n    6004799503160655/18014398509481984\n    >>> nsimplify(0.333333333333333, rational=True)\n    1/3\n\n    See Also\n    ========\n\n    sympy.core.function.nfloat\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "posify",
    "full_id": "sympy.simplify.simplify.posify",
    "type": "function",
    "description": "Return ``eq`` (with generic symbols made positive) and a\n    dictionary containing the mapping between the old and new\n    symbols.\n\n    Explanation\n    ===========\n\n    Any symbol that has positive=None will be replaced with a positive dummy\n    symbol having the same name. This replacement will allow more symbolic\n    processing of expressions, especially those involving powers and\n    logarithms.\n\n    A dictionary that can be sent to subs to restore ``eq`` to its original\n    symbols is also returned.\n\n    >>> from sympy import posify, Symbol, log, solve\n    >>> from sympy.abc import x\n    >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))\n    (_x + n + p, {_x: x})\n\n    >>> eq = 1/x\n    >>> log(eq).expand()\n    log(1/x)\n    >>> log(posify(eq)[0]).expand()\n    -log(_x)\n    >>> p, rep = posify(eq)\n    >>> log(p).expand().subs(rep)\n    -log(x)\n\n    It is possible to apply the same transformations to an iterable\n    of expressions:\n\n    >>> eq = x**2 - 4\n    >>> solve(eq, x)\n    [-2, 2]\n    >>> eq_x, reps = posify([eq, x]); eq_x\n    [_x**2 - 4, _x]\n    >>> solve(*eq_x)\n    [2]\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "logcombine",
    "full_id": "sympy.simplify.simplify.logcombine",
    "type": "function",
    "description": "\n    Takes logarithms and combines them using the following rules:\n\n    - log(x) + log(y) == log(x*y) if both are positive\n    - a*log(x) == log(x**a) if x is positive and a is real\n\n    If ``force`` is ``True`` then the assumptions above will be assumed to hold if\n    there is no assumption already in place on a quantity. For example, if\n    ``a`` is imaginary or the argument negative, force will not perform a\n    combination but if ``a`` is a symbol with no assumptions the change will\n    take place.\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, symbols, log, logcombine, I\n    >>> from sympy.abc import a, x, y, z\n    >>> logcombine(a*log(x) + log(y) - log(z))\n    a*log(x) + log(y) - log(z)\n    >>> logcombine(a*log(x) + log(y) - log(z), force=True)\n    log(x**a*y/z)\n    >>> x,y,z = symbols('x,y,z', positive=True)\n    >>> a = Symbol('a', real=True)\n    >>> logcombine(a*log(x) + log(y) - log(z))\n    log(x**a*y/z)\n\n    The transformation is limited to factors and/or terms that\n    contain logs, so the result depends on the initial state of\n    expansion:\n\n    >>> eq = (2 + 3*I)*log(x)\n    >>> logcombine(eq, force=True) == eq\n    True\n    >>> logcombine(eq.expand(), force=True)\n    log(x**2) + I*log(x**3)\n\n    See Also\n    ========\n\n    posify: replace all symbols with symbols having positive assumptions\n    sympy.core.function.expand_log: expand the logarithms of products\n        and powers; the opposite of logcombine\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "radsimp",
    "full_id": "sympy.simplify.radsimp.radsimp",
    "type": "function",
    "description": "\n    Rationalize the denominator by removing square roots.\n\n    Explanation\n    ===========\n\n    The expression returned from radsimp must be used with caution\n    since if the denominator contains symbols, it will be possible to make\n    substitutions that violate the assumptions of the simplification process:\n    that for a denominator matching a + b*sqrt(c), a != +/-b*sqrt(c). (If\n    there are no symbols, this assumptions is made valid by collecting terms\n    of sqrt(c) so the match variable ``a`` does not contain ``sqrt(c)``.) If\n    you do not want the simplification to occur for symbolic denominators, set\n    ``symbolic`` to False.\n\n    If there are more than ``max_terms`` radical terms then the expression is\n    returned unchanged.\n\n    Examples\n    ========\n\n    >>> from sympy import radsimp, sqrt, Symbol, pprint\n    >>> from sympy import factor_terms, fraction, signsimp\n    >>> from sympy.simplify.radsimp import collect_sqrt\n    >>> from sympy.abc import a, b, c\n\n    >>> radsimp(1/(2 + sqrt(2)))\n    (2 - sqrt(2))/2\n    >>> x,y = map(Symbol, 'xy')\n    >>> e = ((2 + 2*sqrt(2))*x + (2 + sqrt(8))*y)/(2 + sqrt(2))\n    >>> radsimp(e)\n    sqrt(2)*(x + y)\n\n    No simplification beyond removal of the gcd is done. One might\n    want to polish the result a little, however, by collecting\n    square root terms:\n\n    >>> r2 = sqrt(2)\n    >>> r5 = sqrt(5)\n    >>> ans = radsimp(1/(y*r2 + x*r2 + a*r5 + b*r5)); pprint(ans)\n        ___       ___       ___       ___\n      \\/ 5 *a + \\/ 5 *b - \\/ 2 *x - \\/ 2 *y\n    ------------------------------------------\n       2               2      2              2\n    5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y\n\n    >>> n, d = fraction(ans)\n    >>> pprint(factor_terms(signsimp(collect_sqrt(n))/d, radical=True))\n            ___             ___\n          \\/ 5 *(a + b) - \\/ 2 *(x + y)\n    ------------------------------------------\n       2               2      2              2\n    5*a  + 10*a*b + 5*b  - 2*x  - 4*x*y - 2*y\n\n    If radicals in the denominator cannot be removed or there is no denominator,\n    the original expression will be returned.\n\n    >>> radsimp(sqrt(2)*x + sqrt(2))\n    sqrt(2)*x + sqrt(2)\n\n    Results with symbols will not always be valid for all substitutions:\n\n    >>> eq = 1/(a + b*sqrt(c))\n    >>> eq.subs(a, b*sqrt(c))\n    1/(2*b*sqrt(c))\n    >>> radsimp(eq).subs(a, b*sqrt(c))\n    nan\n\n    If ``symbolic=False``, symbolic denominators will not be transformed (but\n    numeric denominators will still be processed):\n\n    >>> radsimp(eq, symbolic=False)\n    1/(a + b*sqrt(c))\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "rad_rationalize",
    "full_id": "sympy.simplify.radsimp.rad_rationalize",
    "type": "function",
    "description": "\n    Rationalize ``num/den`` by removing square roots in the denominator;\n    num and den are sum of terms whose squares are positive rationals.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> from sympy.simplify.radsimp import rad_rationalize\n    >>> rad_rationalize(sqrt(3), 1 + sqrt(2)/3)\n    (-sqrt(3) + sqrt(6)/3, -7/9)\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "collect",
    "full_id": "sympy.simplify.radsimp.collect",
    "type": "function",
    "description": "\n    Collect additive terms of an expression.\n\n    Explanation\n    ===========\n\n    This function collects additive terms of an expression with respect\n    to a list of expression up to powers with rational exponents. By the\n    term symbol here are meant arbitrary expressions, which can contain\n    powers, products, sums etc. In other words symbol is a pattern which\n    will be searched for in the expression's terms.\n\n    The input expression is not expanded by :func:`collect`, so user is\n    expected to provide an expression in an appropriate form. This makes\n    :func:`collect` more predictable as there is no magic happening behind the\n    scenes. However, it is important to note, that powers of products are\n    converted to products of powers using the :func:`~.expand_power_base`\n    function.\n\n    There are two possible types of output. First, if ``evaluate`` flag is\n    set, this function will return an expression with collected terms or\n    else it will return a dictionary with expressions up to rational powers\n    as keys and collected coefficients as values.\n\n    Examples\n    ========\n\n    >>> from sympy import S, collect, expand, factor, Wild\n    >>> from sympy.abc import a, b, c, x, y\n\n    This function can collect symbolic coefficients in polynomials or\n    rational expressions. It will manage to find all integer or rational\n    powers of collection variable::\n\n        >>> collect(a*x**2 + b*x**2 + a*x - b*x + c, x)\n        c + x**2*(a + b) + x*(a - b)\n\n    The same result can be achieved in dictionary form::\n\n        >>> d = collect(a*x**2 + b*x**2 + a*x - b*x + c, x, evaluate=False)\n        >>> d[x**2]\n        a + b\n        >>> d[x]\n        a - b\n        >>> d[S.One]\n        c\n\n    You can also work with multivariate polynomials. However, remember that\n    this function is greedy so it will care only about a single symbol at time,\n    in specification order::\n\n        >>> collect(x**2 + y*x**2 + x*y + y + a*y, [x, y])\n        x**2*(y + 1) + x*y + y*(a + 1)\n\n    Also more complicated expressions can be used as patterns::\n\n        >>> from sympy import sin, log\n        >>> collect(a*sin(2*x) + b*sin(2*x), sin(2*x))\n        (a + b)*sin(2*x)\n\n        >>> collect(a*x*log(x) + b*(x*log(x)), x*log(x))\n        x*(a + b)*log(x)\n\n    You can use wildcards in the pattern::\n\n        >>> w = Wild('w1')\n        >>> collect(a*x**y - b*x**y, w**y)\n        x**y*(a - b)\n\n    It is also possible to work with symbolic powers, although it has more\n    complicated behavior, because in this case power's base and symbolic part\n    of the exponent are treated as a single symbol::\n\n        >>> collect(a*x**c + b*x**c, x)\n        a*x**c + b*x**c\n        >>> collect(a*x**c + b*x**c, x**c)\n        x**c*(a + b)\n\n    However if you incorporate rationals to the exponents, then you will get\n    well known behavior::\n\n        >>> collect(a*x**(2*c) + b*x**(2*c), x**c)\n        x**(2*c)*(a + b)\n\n    Note also that all previously stated facts about :func:`collect` function\n    apply to the exponential function, so you can get::\n\n        >>> from sympy import exp\n        >>> collect(a*exp(2*x) + b*exp(2*x), exp(x))\n        (a + b)*exp(2*x)\n\n    If you are interested only in collecting specific powers of some symbols\n    then set ``exact`` flag to True::\n\n        >>> collect(a*x**7 + b*x**7, x, exact=True)\n        a*x**7 + b*x**7\n        >>> collect(a*x**7 + b*x**7, x**7, exact=True)\n        x**7*(a + b)\n\n    If you want to collect on any object containing symbols, set\n    ``exact`` to None:\n\n        >>> collect(x*exp(x) + sin(x)*y + sin(x)*2 + 3*x, x, exact=None)\n        x*exp(x) + 3*x + (y + 2)*sin(x)\n        >>> collect(a*x*y + x*y + b*x + x, [x, y], exact=None)\n        x*y*(a + 1) + x*(b + 1)\n\n    You can also apply this function to differential equations, where\n    derivatives of arbitrary order can be collected. Note that if you\n    collect with respect to a function or a derivative of a function, all\n    derivatives of that function will also be collected. Use\n    ``exact=True`` to prevent this from happening::\n\n        >>> from sympy import Derivative as D, collect, Function\n        >>> f = Function('f') (x)\n\n        >>> collect(a*D(f,x) + b*D(f,x), D(f,x))\n        (a + b)*Derivative(f(x), x)\n\n        >>> collect(a*D(D(f,x),x) + b*D(D(f,x),x), f)\n        (a + b)*Derivative(f(x), (x, 2))\n\n        >>> collect(a*D(D(f,x),x) + b*D(D(f,x),x), D(f,x), exact=True)\n        a*Derivative(f(x), (x, 2)) + b*Derivative(f(x), (x, 2))\n\n        >>> collect(a*D(f,x) + b*D(f,x) + a*f + b*f, f)\n        (a + b)*f(x) + (a + b)*Derivative(f(x), x)\n\n    Or you can even match both derivative order and exponent at the same time::\n\n        >>> collect(a*D(D(f,x),x)**2 + b*D(D(f,x),x)**2, D(f,x))\n        (a + b)*Derivative(f(x), (x, 2))**2\n\n    Finally, you can apply a function to each of the collected coefficients.\n    For example you can factorize symbolic coefficients of polynomial::\n\n        >>> f = expand((x + a + 1)**3)\n\n        >>> collect(f, x, factor)\n        x**3 + 3*x**2*(a + 1) + 3*x*(a + 1)**2 + (a + 1)**3\n\n    .. note:: Arguments are expected to be in expanded form, so you might have\n              to call :func:`~.expand` prior to calling this function.\n\n    See Also\n    ========\n\n    collect_const, collect_sqrt, rcollect\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "rcollect",
    "full_id": "sympy.simplify.radsimp.rcollect",
    "type": "function",
    "description": "\n    Recursively collect sums in an expression.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify import rcollect\n    >>> from sympy.abc import x, y\n\n    >>> expr = (x**2*y + x*y + x + y)/(x + y)\n\n    >>> rcollect(expr, y)\n    (x + y*(x**2 + x + 1))/(x + y)\n\n    See Also\n    ========\n\n    collect, collect_const, collect_sqrt\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "collect_sqrt",
    "full_id": "sympy.simplify.radsimp.collect_sqrt",
    "type": "function",
    "description": "Return expr with terms having common square roots collected together.\n    If ``evaluate`` is False a count indicating the number of sqrt-containing\n    terms will be returned and, if non-zero, the terms of the Add will be\n    returned, else the expression itself will be returned as a single term.\n    If ``evaluate`` is True, the expression with any collected terms will be\n    returned.\n\n    Note: since I = sqrt(-1), it is collected, too.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> from sympy.simplify.radsimp import collect_sqrt\n    >>> from sympy.abc import a, b\n\n    >>> r2, r3, r5 = [sqrt(i) for i in [2, 3, 5]]\n    >>> collect_sqrt(a*r2 + b*r2)\n    sqrt(2)*(a + b)\n    >>> collect_sqrt(a*r2 + b*r2 + a*r3 + b*r3)\n    sqrt(2)*(a + b) + sqrt(3)*(a + b)\n    >>> collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5)\n    sqrt(3)*a + sqrt(5)*b + sqrt(2)*(a + b)\n\n    If evaluate is False then the arguments will be sorted and\n    returned as a list and a count of the number of sqrt-containing\n    terms will be returned:\n\n    >>> collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5, evaluate=False)\n    ((sqrt(3)*a, sqrt(5)*b, sqrt(2)*(a + b)), 3)\n    >>> collect_sqrt(a*sqrt(2) + b, evaluate=False)\n    ((b, sqrt(2)*a), 1)\n    >>> collect_sqrt(a + b, evaluate=False)\n    ((a + b,), 0)\n\n    See Also\n    ========\n\n    collect, collect_const, rcollect\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "collect_const",
    "full_id": "sympy.simplify.radsimp.collect_const",
    "type": "function",
    "description": "A non-greedy collection of terms with similar number coefficients in\n    an Add expr. If ``vars`` is given then only those constants will be\n    targeted. Although any Number can also be targeted, if this is not\n    desired set ``Numbers=False`` and no Float or Rational will be collected.\n\n    Parameters\n    ==========\n\n    expr : SymPy expression\n        This parameter defines the expression the expression from which\n        terms with similar coefficients are to be collected. A non-Add\n        expression is returned as it is.\n\n    vars : variable length collection of Numbers, optional\n        Specifies the constants to target for collection. Can be multiple in\n        number.\n\n    Numbers : bool\n        Specifies to target all instance of\n        :class:`sympy.core.numbers.Number` class. If ``Numbers=False``, then\n        no Float or Rational will be collected.\n\n    Returns\n    =======\n\n    expr : Expr\n        Returns an expression with similar coefficient terms collected.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt\n    >>> from sympy.abc import s, x, y, z\n    >>> from sympy.simplify.radsimp import collect_const\n    >>> collect_const(sqrt(3) + sqrt(3)*(1 + sqrt(2)))\n    sqrt(3)*(sqrt(2) + 2)\n    >>> collect_const(sqrt(3)*s + sqrt(7)*s + sqrt(3) + sqrt(7))\n    (sqrt(3) + sqrt(7))*(s + 1)\n    >>> s = sqrt(2) + 2\n    >>> collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7))\n    (sqrt(2) + 3)*(sqrt(3) + sqrt(7))\n    >>> collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7), sqrt(3))\n    sqrt(7) + sqrt(3)*(sqrt(2) + 3) + sqrt(7)*(sqrt(2) + 2)\n\n    The collection is sign-sensitive, giving higher precedence to the\n    unsigned values:\n\n    >>> collect_const(x - y - z)\n    x - (y + z)\n    >>> collect_const(-y - z)\n    -(y + z)\n    >>> collect_const(2*x - 2*y - 2*z, 2)\n    2*(x - y - z)\n    >>> collect_const(2*x - 2*y - 2*z, -2)\n    2*x - 2*(y + z)\n\n    See Also\n    ========\n\n    collect, collect_sqrt, rcollect\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "fraction",
    "full_id": "sympy.simplify.radsimp.fraction",
    "type": "function",
    "description": "Returns a pair with expression's numerator and denominator.\n    If the given expression is not a fraction then this function\n    will return the tuple (expr, 1).\n\n    This function will not make any attempt to simplify nested\n    fractions or to do any term rewriting at all.\n\n    If only one of the numerator/denominator pair is needed then\n    use numer(expr) or denom(expr) functions respectively.\n\n    >>> from sympy import fraction, Rational, Symbol\n    >>> from sympy.abc import x, y\n\n    >>> fraction(x/y)\n    (x, y)\n    >>> fraction(x)\n    (x, 1)\n\n    >>> fraction(1/y**2)\n    (1, y**2)\n\n    >>> fraction(x*y/2)\n    (x*y, 2)\n    >>> fraction(Rational(1, 2))\n    (1, 2)\n\n    This function will also work fine with assumptions:\n\n    >>> k = Symbol('k', negative=True)\n    >>> fraction(x * y**k)\n    (x, y**(-k))\n\n    If we know nothing about sign of some exponent and ``exact``\n    flag is unset, then the exponent's structure will\n    be analyzed and pretty fraction will be returned:\n\n    >>> from sympy import exp, Mul\n    >>> fraction(2*x**(-y))\n    (2, x**y)\n\n    >>> fraction(exp(-x))\n    (1, exp(x))\n\n    >>> fraction(exp(-x), exact=True)\n    (exp(-x), 1)\n\n    The ``exact`` flag will also keep any unevaluated Muls from\n    being evaluated:\n\n    >>> u = Mul(2, x + 1, evaluate=False)\n    >>> fraction(u)\n    (2*x + 2, 1)\n    >>> fraction(u, exact=True)\n    (2*(x  + 1), 1)\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "ratsimp",
    "full_id": "sympy.simplify.ratsimp.ratsimp",
    "type": "function",
    "description": "\n    Put an expression over a common denominator, cancel and reduce.\n\n    Examples\n    ========\n\n    >>> from sympy import ratsimp\n    >>> from sympy.abc import x, y\n    >>> ratsimp(1/x + 1/y)\n    (x + y)/(x*y)\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "ratsimpmodprime",
    "full_id": "sympy.simplify.ratsimp.ratsimpmodprime",
    "type": "function",
    "description": "\n    Simplifies a rational expression ``expr`` modulo the prime ideal\n    generated by ``G``.  ``G`` should be a Groebner basis of the\n    ideal.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.ratsimp import ratsimpmodprime\n    >>> from sympy.abc import x, y\n    >>> eq = (x + y**5 + y)/(x - y)\n    >>> ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order='lex')\n    (-x**2 - x*y - x - y)/(-x**2 + x*y)\n\n    If ``polynomial`` is ``False``, the algorithm computes a rational\n    simplification which minimizes the sum of the total degrees of\n    the numerator and the denominator.\n\n    If ``polynomial`` is ``True``, this function just brings numerator and\n    denominator into a canonical form. This is much faster, but has\n    potentially worse results.\n\n    References\n    ==========\n\n    .. [1] M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial\n        Ideal, https://dl.acm.org/doi/pdf/10.1145/1145768.1145809\n        (specifically, the second algorithm)\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "trigsimp",
    "full_id": "sympy.simplify.trigsimp.trigsimp",
    "type": "function",
    "description": "Returns a reduced expression by using known trig identities.\n\n    Parameters\n    ==========\n\n    inverse : bool, optional\n        If ``inverse=True``, it will be assumed that a composition of inverse\n        functions, such as sin and asin, can be cancelled in any order.\n        For example, ``asin(sin(x))`` will yield ``x`` without checking whether\n        x belongs to the set where this relation is true. The default is False.\n        Default : True\n\n    method : string, optional\n        Specifies the method to use. Valid choices are:\n\n        - ``'matching'``, default\n        - ``'groebner'``\n        - ``'combined'``\n        - ``'fu'``\n        - ``'old'``\n\n        If ``'matching'``, simplify the expression recursively by targeting\n        common patterns. If ``'groebner'``, apply an experimental groebner\n        basis algorithm. In this case further options are forwarded to\n        ``trigsimp_groebner``, please refer to\n        its docstring. If ``'combined'``, it first runs the groebner basis\n        algorithm with small default parameters, then runs the ``'matching'``\n        algorithm. If ``'fu'``, run the collection of trigonometric\n        transformations described by Fu, et al. (see the\n        :py:func:`~sympy.simplify.fu.fu` docstring). If ``'old'``, the original\n        SymPy trig simplification function is run.\n    opts :\n        Optional keyword arguments passed to the method. See each method's\n        function docstring for details.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using ``method='groebner'`` (or ``method='combined'``) might lead to\n    greater simplification.\n\n    The old trigsimp routine can be accessed as with method ``method='old'``.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "powsimp",
    "full_id": "sympy.simplify.powsimp.powsimp",
    "type": "function",
    "description": "\n    Reduce expression by combining powers with similar bases and exponents.\n\n    Explanation\n    ===========\n\n    If ``deep`` is ``True`` then powsimp() will also simplify arguments of\n    functions. By default ``deep`` is set to ``False``.\n\n    If ``force`` is ``True`` then bases will be combined without checking for\n    assumptions, e.g. sqrt(x)*sqrt(y) -> sqrt(x*y) which is not true\n    if x and y are both negative.\n\n    You can make powsimp() only combine bases or only combine exponents by\n    changing combine='base' or combine='exp'.  By default, combine='all',\n    which does both.  combine='base' will only combine::\n\n         a   a          a                          2x      x\n        x * y  =>  (x*y)   as well as things like 2   =>  4\n\n    and combine='exp' will only combine\n    ::\n\n         a   b      (a + b)\n        x * x  =>  x\n\n    combine='exp' will strictly only combine exponents in the way that used\n    to be automatic.  Also use deep=True if you need the old behavior.\n\n    When combine='all', 'exp' is evaluated first.  Consider the first\n    example below for when there could be an ambiguity relating to this.\n    This is done so things like the second example can be completely\n    combined.  If you want 'base' combined first, do something like\n    powsimp(powsimp(expr, combine='base'), combine='exp').\n\n    Examples\n    ========\n\n    >>> from sympy import powsimp, exp, log, symbols\n    >>> from sympy.abc import x, y, z, n\n    >>> powsimp(x**y*x**z*y**z, combine='all')\n    x**(y + z)*y**z\n    >>> powsimp(x**y*x**z*y**z, combine='exp')\n    x**(y + z)*y**z\n    >>> powsimp(x**y*x**z*y**z, combine='base', force=True)\n    x**y*(x*y)**z\n\n    >>> powsimp(x**z*x**y*n**z*n**y, combine='all', force=True)\n    (n*x)**(y + z)\n    >>> powsimp(x**z*x**y*n**z*n**y, combine='exp')\n    n**(y + z)*x**(y + z)\n    >>> powsimp(x**z*x**y*n**z*n**y, combine='base', force=True)\n    (n*x)**y*(n*x)**z\n\n    >>> x, y = symbols('x y', positive=True)\n    >>> powsimp(log(exp(x)*exp(y)))\n    log(exp(x)*exp(y))\n    >>> powsimp(log(exp(x)*exp(y)), deep=True)\n    x + y\n\n    Radicals with Mul bases will be combined if combine='exp'\n\n    >>> from sympy import sqrt\n    >>> x, y = symbols('x y')\n\n    Two radicals are automatically joined through Mul:\n\n    >>> a=sqrt(x*sqrt(y))\n    >>> a*a**3 == a**4\n    True\n\n    But if an integer power of that radical has been\n    autoexpanded then Mul does not join the resulting factors:\n\n    >>> a**4 # auto expands to a Mul, no longer a Pow\n    x**2*y\n    >>> _*a # so Mul doesn't combine them\n    x**2*y*sqrt(x*sqrt(y))\n    >>> powsimp(_) # but powsimp will\n    (x*sqrt(y))**(5/2)\n    >>> powsimp(x*y*a) # but won't when doing so would violate assumptions\n    x*y*sqrt(x*sqrt(y))\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "powdenest",
    "full_id": "sympy.simplify.powsimp.powdenest",
    "type": "function",
    "description": "\n    Collect exponents on powers as assumptions allow.\n\n    Explanation\n    ===========\n\n    Given ``(bb**be)**e``, this can be simplified as follows:\n        * if ``bb`` is positive, or\n        * ``e`` is an integer, or\n        * ``|be| < 1`` then this simplifies to ``bb**(be*e)``\n\n    Given a product of powers raised to a power, ``(bb1**be1 *\n    bb2**be2...)**e``, simplification can be done as follows:\n\n    - if e is positive, the gcd of all bei can be joined with e;\n    - all non-negative bb can be separated from those that are negative\n      and their gcd can be joined with e; autosimplification already\n      handles this separation.\n    - integer factors from powers that have integers in the denominator\n      of the exponent can be removed from any term and the gcd of such\n      integers can be joined with e\n\n    Setting ``force`` to ``True`` will make symbols that are not explicitly\n    negative behave as though they are positive, resulting in more\n    denesting.\n\n    Setting ``polar`` to ``True`` will do simplifications on the Riemann surface of\n    the logarithm, also resulting in more denestings.\n\n    When there are sums of logs in exp() then a product of powers may be\n    obtained e.g. ``exp(3*(log(a) + 2*log(b)))`` - > ``a**3*b**6``.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import a, b, x, y, z\n    >>> from sympy import Symbol, exp, log, sqrt, symbols, powdenest\n\n    >>> powdenest((x**(2*a/3))**(3*x))\n    (x**(2*a/3))**(3*x)\n    >>> powdenest(exp(3*x*log(2)))\n    2**(3*x)\n\n    Assumptions may prevent expansion:\n\n    >>> powdenest(sqrt(x**2))\n    sqrt(x**2)\n\n    >>> p = symbols('p', positive=True)\n    >>> powdenest(sqrt(p**2))\n    p\n\n    No other expansion is done.\n\n    >>> i, j = symbols('i,j', integer=True)\n    >>> powdenest((x**x)**(i + j)) # -X-> (x**x)**i*(x**x)**j\n    x**(x*(i + j))\n\n    But exp() will be denested by moving all non-log terms outside of\n    the function; this may result in the collapsing of the exp to a power\n    with a different base:\n\n    >>> powdenest(exp(3*y*log(x)))\n    x**(3*y)\n    >>> powdenest(exp(y*(log(a) + log(b))))\n    (a*b)**y\n    >>> powdenest(exp(3*(log(a) + log(b))))\n    a**3*b**3\n\n    If assumptions allow, symbols can also be moved to the outermost exponent:\n\n    >>> i = Symbol('i', integer=True)\n    >>> powdenest(((x**(2*i))**(3*y))**x)\n    ((x**(2*i))**(3*y))**x\n    >>> powdenest(((x**(2*i))**(3*y))**x, force=True)\n    x**(6*i*x*y)\n\n    >>> powdenest(((x**(2*a/3))**(3*y/i))**x)\n    ((x**(2*a/3))**(3*y/i))**x\n    >>> powdenest((x**(2*i)*y**(4*i))**z, force=True)\n    (x*y**2)**(2*i*z)\n\n    >>> n = Symbol('n', negative=True)\n\n    >>> powdenest((x**i)**y, force=True)\n    x**(i*y)\n    >>> powdenest((n**i)**x, force=True)\n    (n**i)**x\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "combsimp",
    "full_id": "sympy.simplify.combsimp.combsimp",
    "type": "function",
    "description": "\n    Simplify combinatorial expressions.\n\n    Explanation\n    ===========\n\n    This function takes as input an expression containing factorials,\n    binomials, Pochhammer symbol and other \"combinatorial\" functions,\n    and tries to minimize the number of those functions and reduce\n    the size of their arguments.\n\n    The algorithm works by rewriting all combinatorial functions as\n    gamma functions and applying gammasimp() except simplification\n    steps that may make an integer argument non-integer. See docstring\n    of gammasimp for more information.\n\n    Then it rewrites expression in terms of factorials and binomials by\n    rewriting gammas as factorials and converting (a+b)!/a!b! into\n    binomials.\n\n    If expression has gamma functions or combinatorial functions\n    with non-integer argument, it is automatically passed to gammasimp.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify import combsimp\n    >>> from sympy import factorial, binomial, symbols\n    >>> n, k = symbols('n k', integer = True)\n\n    >>> combsimp(factorial(n)/factorial(n - 3))\n    n*(n - 2)*(n - 1)\n    >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\n    (n + 1)/(k + 1)\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "sqrtdenest",
    "full_id": "sympy.simplify.sqrtdenest.sqrtdenest",
    "type": "function",
    "description": "Denests sqrts in an expression that contain other square roots\n    if possible, otherwise returns the expr unchanged. This is based on the\n    algorithms of [1].\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.sqrtdenest import sqrtdenest\n    >>> from sympy import sqrt\n    >>> sqrtdenest(sqrt(5 + 2 * sqrt(6)))\n    sqrt(2) + sqrt(3)\n\n    See Also\n    ========\n\n    sympy.solvers.solvers.unrad\n\n    References\n    ==========\n\n    .. [1] https://web.archive.org/web/20210806201615/https://researcher.watson.ibm.com/researcher/files/us-fagin/symb85.pdf\n\n    .. [2] D. J. Jeffrey and A. D. Rich, 'Symplifying Square Roots of Square Roots\n           by Denesting' (available at https://www.cybertester.com/data/denest.pdf)\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "cse",
    "full_id": "sympy.simplify.cse_main.cse",
    "type": "function",
    "description": "Perform common subexpression elimination on an expression.\n\n    Parameters\n    ==========\n\n    exprs : list of SymPy expressions, or a single SymPy expression\n        The expressions to reduce.\n    symbols : infinite iterator yielding unique Symbols\n        The symbols used to label the common subexpressions which are pulled\n        out. The ``numbered_symbols`` generator is useful. The default is a\n        stream of symbols of the form \"x0\", \"x1\", etc. This must be an\n        infinite iterator.\n    optimizations : list of (callable, callable) pairs\n        The (preprocessor, postprocessor) pairs of external optimization\n        functions. Optionally 'basic' can be passed for a set of predefined\n        basic optimizations. Such 'basic' optimizations were used by default\n        in old implementation, however they can be really slow on larger\n        expressions. Now, no pre or post optimizations are made by default.\n    postprocess : a function which accepts the two return values of cse and\n        returns the desired form of output from cse, e.g. if you want the\n        replacements reversed the function might be the following lambda:\n        lambda r, e: return reversed(r), e\n    order : string, 'none' or 'canonical'\n        The order by which Mul and Add arguments are processed. If set to\n        'canonical', arguments will be canonically ordered. If set to 'none',\n        ordering will be faster but dependent on expressions hashes, thus\n        machine dependent and variable. For large expressions where speed is a\n        concern, use the setting order='none'.\n    ignore : iterable of Symbols\n        Substitutions containing any Symbol from ``ignore`` will be ignored.\n    list : bool, (default True)\n        Returns expression in list or else with same type as input (when False).\n\n    Returns\n    =======\n\n    replacements : list of (Symbol, expression) pairs\n        All of the common subexpressions that were replaced. Subexpressions\n        earlier in this list might show up in subexpressions later in this\n        list.\n    reduced_exprs : list of SymPy expressions\n        The reduced expressions with all of the replacements above.\n\n    Examples\n    ========\n\n    >>> from sympy import cse, SparseMatrix\n    >>> from sympy.abc import x, y, z, w\n    >>> cse(((w + x + y + z)*(w + y + z))/(w + x)**3)\n    ([(x0, y + z), (x1, w + x)], [(w + x0)*(x0 + x1)/x1**3])\n\n\n    List of expressions with recursive substitutions:\n\n    >>> m = SparseMatrix([x + y, x + y + z])\n    >>> cse([(x+y)**2, x + y + z, y + z, x + z + y, m])\n    ([(x0, x + y), (x1, x0 + z)], [x0**2, x1, y + z, x1, Matrix([\n    [x0],\n    [x1]])])\n\n    Note: the type and mutability of input matrices is retained.\n\n    >>> isinstance(_[1][-1], SparseMatrix)\n    True\n\n    The user may disallow substitutions containing certain symbols:\n\n    >>> cse([y**2*(x + 1), 3*y**2*(x + 1)], ignore=(y,))\n    ([(x0, x + 1)], [x0*y**2, 3*x0*y**2])\n\n    The default return value for the reduced expression(s) is a list, even if there is only\n    one expression. The `list` flag preserves the type of the input in the output:\n\n    >>> cse(x)\n    ([], [x])\n    >>> cse(x, list=False)\n    ([], x)\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "opt_cse",
    "full_id": "sympy.simplify.cse_main.opt_cse",
    "type": "function",
    "description": "Find optimization opportunities in Adds, Muls, Pows and negative\n    coefficient Muls.\n\n    Parameters\n    ==========\n\n    exprs : list of SymPy expressions\n        The expressions to optimize.\n    order : string, 'none' or 'canonical'\n        The order by which Mul and Add arguments are processed. For large\n        expressions where speed is a concern, use the setting order='none'.\n\n    Returns\n    =======\n\n    opt_subs : dictionary of expression substitutions\n        The expression substitutions which can be useful to optimize CSE.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.cse_main import opt_cse\n    >>> from sympy.abc import x\n    >>> opt_subs = opt_cse([x**-2])\n    >>> k, v = list(opt_subs.keys())[0], list(opt_subs.values())[0]\n    >>> print((k, v.as_unevaluated_basic()))\n    (x**(-2), 1/(x**2))\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "tree_cse",
    "full_id": "sympy.simplify.cse_main.tree_cse",
    "type": "function",
    "description": "Perform raw CSE on expression tree, taking opt_subs into account.\n\n    Parameters\n    ==========\n\n    exprs : list of SymPy expressions\n        The expressions to reduce.\n    symbols : infinite iterator yielding unique Symbols\n        The symbols used to label the common subexpressions which are pulled\n        out.\n    opt_subs : dictionary of expression substitutions\n        The expressions to be substituted before any CSE action is performed.\n    order : string, 'none' or 'canonical'\n        The order by which Mul and Add arguments are processed. For large\n        expressions where speed is a concern, use the setting order='none'.\n    ignore : iterable of Symbols\n        Substitutions containing any Symbol from ``ignore`` will be ignored.\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "hyperexpand",
    "full_id": "sympy.simplify.hyperexpand.hyperexpand",
    "type": "function",
    "description": "\n    Expand hypergeometric functions. If allow_hyper is True, allow partial\n    simplification (that is a result different from input,\n    but still containing hypergeometric functions).\n\n    If a G-function has expansions both at zero and at infinity,\n    ``place`` can be set to ``0`` or ``zoo`` to indicate the\n    preferred choice.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.hyperexpand import hyperexpand\n    >>> from sympy.functions import hyper\n    >>> from sympy.abc import z\n    >>> hyperexpand(hyper([], [], z))\n    exp(z)\n\n    Non-hyperegeometric parts of the expression and hypergeometric expressions\n    that are not recognised are left unchanged:\n\n    >>> hyperexpand(1 + hyper([1, 1, 1], [], z))\n    hyper((1, 1, 1), (), z) + 1\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "apply",
    "full_id": "sympy.simplify.epathtools.EPath.apply",
    "type": "method",
    "description": "\n        Modify parts of an expression selected by a path.\n\n        Examples\n        ========\n\n        >>> from sympy.simplify.epathtools import EPath\n        >>> from sympy import sin, cos, E\n        >>> from sympy.abc import x, y, z, t\n\n        >>> path = EPath(\"/*/[0]/Symbol\")\n        >>> expr = [((x, 1), 2), ((3, y), z)]\n\n        >>> path.apply(expr, lambda expr: expr**2)\n        [((x**2, 1), 2), ((3, y**2), z)]\n\n        >>> path = EPath(\"/*/*/Symbol\")\n        >>> expr = t + sin(x + 1) + cos(x + y + E)\n\n        >>> path.apply(expr, lambda expr: 2*expr)\n        t + sin(2*x + 1) + cos(2*x + 2*y + E)\n\n        ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "select",
    "full_id": "sympy.simplify.epathtools.EPath.select",
    "type": "method",
    "description": "\n        Retrieve parts of an expression selected by a path.\n\n        Examples\n        ========\n\n        >>> from sympy.simplify.epathtools import EPath\n        >>> from sympy import sin, cos, E\n        >>> from sympy.abc import x, y, z, t\n\n        >>> path = EPath(\"/*/[0]/Symbol\")\n        >>> expr = [((x, 1), 2), ((3, y), z)]\n\n        >>> path.select(expr)\n        [x, y]\n\n        >>> path = EPath(\"/*/*/Symbol\")\n        >>> expr = t + sin(x + 1) + cos(x + y + E)\n\n        >>> path.select(expr)\n        [x, x, y]\n\n        ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "epath",
    "full_id": "sympy.simplify.epathtools.epath",
    "type": "function",
    "description": "\n    Manipulate parts of an expression selected by a path.\n\n    Explanation\n    ===========\n\n    This function allows to manipulate large nested expressions in single\n    line of code, utilizing techniques to those applied in XML processing\n    standards (e.g. XPath).\n\n    If ``func`` is ``None``, :func:`epath` retrieves elements selected by\n    the ``path``. Otherwise it applies ``func`` to each matching element.\n\n    Note that it is more efficient to create an EPath object and use the select\n    and apply methods of that object, since this will compile the path string\n    only once.  This function should only be used as a convenient shortcut for\n    interactive use.\n\n    This is the supported syntax:\n\n    * select all: ``/*``\n          Equivalent of ``for arg in args:``.\n    * select slice: ``/[0]`` or ``/[1:5]`` or ``/[1:5:2]``\n          Supports standard Python's slice syntax.\n    * select by type: ``/list`` or ``/list|tuple``\n          Emulates ``isinstance()``.\n    * select by attribute: ``/__iter__?``\n          Emulates ``hasattr()``.\n\n    Parameters\n    ==========\n\n    path : str | EPath\n        A path as a string or a compiled EPath.\n    expr : Basic | iterable\n        An expression or a container of expressions.\n    func : callable (optional)\n        A callable that will be applied to matching parts.\n    args : tuple (optional)\n        Additional positional arguments to ``func``.\n    kwargs : dict (optional)\n        Additional keyword arguments to ``func``.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.epathtools import epath\n    >>> from sympy import sin, cos, E\n    >>> from sympy.abc import x, y, z, t\n\n    >>> path = \"/*/[0]/Symbol\"\n    >>> expr = [((x, 1), 2), ((3, y), z)]\n\n    >>> epath(path, expr)\n    [x, y]\n    >>> epath(path, expr, lambda expr: expr**2)\n    [((x**2, 1), 2), ((3, y**2), z)]\n\n    >>> path = \"/*/*/Symbol\"\n    >>> expr = t + sin(x + 1) + cos(x + y + E)\n\n    >>> epath(path, expr)\n    [x, x, y]\n    >>> epath(path, expr, lambda expr: 2*expr)\n    t + sin(2*x + 1) + cos(2*x + 2*y + E)\n\n    ",
    "section": "Simplify",
    "url": "https://docs.sympy.org/latest/modules/simplify/simplify.html"
  },
  {
    "name": "TR0",
    "full_id": "sympy.simplify.fu.TR0",
    "type": "function",
    "description": "Simplification of rational polynomials, trying to simplify\n    the expression, e.g. combine things like 3*x + 2*x, etc....\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR1",
    "full_id": "sympy.simplify.fu.TR1",
    "type": "function",
    "description": "Replace sec, csc with 1/cos, 1/sin\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR1, sec, csc\n    >>> from sympy.abc import x\n    >>> TR1(2*csc(x) + sec(x))\n    1/cos(x) + 2/sin(x)\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR2",
    "full_id": "sympy.simplify.fu.TR2",
    "type": "function",
    "description": "Replace tan and cot with sin/cos and cos/sin\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR2\n    >>> from sympy.abc import x\n    >>> from sympy import tan, cot, sin, cos\n    >>> TR2(tan(x))\n    sin(x)/cos(x)\n    >>> TR2(cot(x))\n    cos(x)/sin(x)\n    >>> TR2(tan(tan(x) - sin(x)/cos(x)))\n    0\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR2i",
    "full_id": "sympy.simplify.fu.TR2i",
    "type": "function",
    "description": "Converts ratios involving sin and cos as follows::\n        sin(x)/cos(x) -> tan(x)\n        sin(x)/(cos(x) + 1) -> tan(x/2) if half=True\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR2i\n    >>> from sympy.abc import x, a\n    >>> from sympy import sin, cos\n    >>> TR2i(sin(x)/cos(x))\n    tan(x)\n\n    Powers of the numerator and denominator are also recognized\n\n    >>> TR2i(sin(x)**2/(cos(x) + 1)**2, half=True)\n    tan(x/2)**2\n\n    The transformation does not take place unless assumptions allow\n    (i.e. the base must be positive or the exponent must be an integer\n    for both numerator and denominator)\n\n    >>> TR2i(sin(x)**a/(cos(x) + 1)**a)\n    sin(x)**a/(cos(x) + 1)**a\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR3",
    "full_id": "sympy.simplify.fu.TR3",
    "type": "function",
    "description": "Induced formula: example sin(-a) = -sin(a)\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR3\n    >>> from sympy.abc import x, y\n    >>> from sympy import pi\n    >>> from sympy import cos\n    >>> TR3(cos(y - x*(y - x)))\n    cos(x*(x - y) + y)\n    >>> cos(pi/2 + x)\n    -sin(x)\n    >>> cos(30*pi/2 + x)\n    -cos(x)\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR4",
    "full_id": "sympy.simplify.fu.TR4",
    "type": "function",
    "description": "Identify values of special angles.\n\n        a=  0   pi/6        pi/4        pi/3        pi/2\n    ----------------------------------------------------\n    sin(a)  0   1/2         sqrt(2)/2   sqrt(3)/2   1\n    cos(a)  1   sqrt(3)/2   sqrt(2)/2   1/2         0\n    tan(a)  0   sqt(3)/3    1           sqrt(3)     --\n\n    Examples\n    ========\n\n    >>> from sympy import pi\n    >>> from sympy import cos, sin, tan, cot\n    >>> for s in (0, pi/6, pi/4, pi/3, pi/2):\n    ...    print('%s %s %s %s' % (cos(s), sin(s), tan(s), cot(s)))\n    ...\n    1 0 0 zoo\n    sqrt(3)/2 1/2 sqrt(3)/3 sqrt(3)\n    sqrt(2)/2 sqrt(2)/2 1 1\n    1/2 sqrt(3)/2 sqrt(3) sqrt(3)/3\n    0 1 zoo 0\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR5",
    "full_id": "sympy.simplify.fu.TR5",
    "type": "function",
    "description": "Replacement of sin**2 with 1 - cos(x)**2.\n\n    See _TR56 docstring for advanced use of ``max`` and ``pow``.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR5\n    >>> from sympy.abc import x\n    >>> from sympy import sin\n    >>> TR5(sin(x)**2)\n    1 - cos(x)**2\n    >>> TR5(sin(x)**-2)  # unchanged\n    sin(x)**(-2)\n    >>> TR5(sin(x)**4)\n    (1 - cos(x)**2)**2\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR6",
    "full_id": "sympy.simplify.fu.TR6",
    "type": "function",
    "description": "Replacement of cos**2 with 1 - sin(x)**2.\n\n    See _TR56 docstring for advanced use of ``max`` and ``pow``.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR6\n    >>> from sympy.abc import x\n    >>> from sympy import cos\n    >>> TR6(cos(x)**2)\n    1 - sin(x)**2\n    >>> TR6(cos(x)**-2)  #unchanged\n    cos(x)**(-2)\n    >>> TR6(cos(x)**4)\n    (1 - sin(x)**2)**2\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR7",
    "full_id": "sympy.simplify.fu.TR7",
    "type": "function",
    "description": "Lowering the degree of cos(x)**2.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR7\n    >>> from sympy.abc import x\n    >>> from sympy import cos\n    >>> TR7(cos(x)**2)\n    cos(2*x)/2 + 1/2\n    >>> TR7(cos(x)**2 + 1)\n    cos(2*x)/2 + 3/2\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR8",
    "full_id": "sympy.simplify.fu.TR8",
    "type": "function",
    "description": "Converting products of ``cos`` and/or ``sin`` to a sum or\n    difference of ``cos`` and or ``sin`` terms.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR8\n    >>> from sympy import cos, sin\n    >>> TR8(cos(2)*cos(3))\n    cos(5)/2 + cos(1)/2\n    >>> TR8(cos(2)*sin(3))\n    sin(5)/2 + sin(1)/2\n    >>> TR8(sin(2)*sin(3))\n    -cos(5)/2 + cos(1)/2\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR9",
    "full_id": "sympy.simplify.fu.TR9",
    "type": "function",
    "description": "Sum of ``cos`` or ``sin`` terms as a product of ``cos`` or ``sin``.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR9\n    >>> from sympy import cos, sin\n    >>> TR9(cos(1) + cos(2))\n    2*cos(1/2)*cos(3/2)\n    >>> TR9(cos(1) + 2*sin(1) + 2*sin(2))\n    cos(1) + 4*sin(3/2)*cos(1/2)\n\n    If no change is made by TR9, no re-arrangement of the\n    expression will be made. For example, though factoring\n    of common term is attempted, if the factored expression\n    was not changed, the original expression will be returned:\n\n    >>> TR9(cos(3) + cos(3)*cos(2))\n    cos(3) + cos(2)*cos(3)\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR10",
    "full_id": "sympy.simplify.fu.TR10",
    "type": "function",
    "description": "Separate sums in ``cos`` and ``sin``.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR10\n    >>> from sympy.abc import a, b, c\n    >>> from sympy import cos, sin\n    >>> TR10(cos(a + b))\n    -sin(a)*sin(b) + cos(a)*cos(b)\n    >>> TR10(sin(a + b))\n    sin(a)*cos(b) + sin(b)*cos(a)\n    >>> TR10(sin(a + b + c))\n    (-sin(a)*sin(b) + cos(a)*cos(b))*sin(c) +     (sin(a)*cos(b) + sin(b)*cos(a))*cos(c)\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR10i",
    "full_id": "sympy.simplify.fu.TR10i",
    "type": "function",
    "description": "Sum of products to function of sum.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR10i\n    >>> from sympy import cos, sin, sqrt\n    >>> from sympy.abc import x\n\n    >>> TR10i(cos(1)*cos(3) + sin(1)*sin(3))\n    cos(2)\n    >>> TR10i(cos(1)*sin(3) + sin(1)*cos(3) + cos(3))\n    cos(3) + sin(4)\n    >>> TR10i(sqrt(2)*cos(x)*x + sqrt(6)*sin(x)*x)\n    2*sqrt(2)*x*sin(x + pi/6)\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR11",
    "full_id": "sympy.simplify.fu.TR11",
    "type": "function",
    "description": "Function of double angle to product. The ``base`` argument can be used\n    to indicate what is the un-doubled argument, e.g. if 3*pi/7 is the base\n    then cosine and sine functions with argument 6*pi/7 will be replaced.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR11\n    >>> from sympy import cos, sin, pi\n    >>> from sympy.abc import x\n    >>> TR11(sin(2*x))\n    2*sin(x)*cos(x)\n    >>> TR11(cos(2*x))\n    -sin(x)**2 + cos(x)**2\n    >>> TR11(sin(4*x))\n    4*(-sin(x)**2 + cos(x)**2)*sin(x)*cos(x)\n    >>> TR11(sin(4*x/3))\n    4*(-sin(x/3)**2 + cos(x/3)**2)*sin(x/3)*cos(x/3)\n\n    If the arguments are simply integers, no change is made\n    unless a base is provided:\n\n    >>> TR11(cos(2))\n    cos(2)\n    >>> TR11(cos(4), 2)\n    -sin(2)**2 + cos(2)**2\n\n    There is a subtle issue here in that autosimplification will convert\n    some higher angles to lower angles\n\n    >>> cos(6*pi/7) + cos(3*pi/7)\n    -cos(pi/7) + cos(3*pi/7)\n\n    The 6*pi/7 angle is now pi/7 but can be targeted with TR11 by supplying\n    the 3*pi/7 base:\n\n    >>> TR11(_, 3*pi/7)\n    -sin(3*pi/7)**2 + cos(3*pi/7)**2 + cos(3*pi/7)\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR12",
    "full_id": "sympy.simplify.fu.TR12",
    "type": "function",
    "description": "Separate sums in ``tan``.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import tan\n    >>> from sympy.simplify.fu import TR12\n    >>> TR12(tan(x + y))\n    (tan(x) + tan(y))/(-tan(x)*tan(y) + 1)\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR12i",
    "full_id": "sympy.simplify.fu.TR12i",
    "type": "function",
    "description": "Combine tan arguments as\n    (tan(y) + tan(x))/(tan(x)*tan(y) - 1) -> -tan(x + y).\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR12i\n    >>> from sympy import tan\n    >>> from sympy.abc import a, b, c\n    >>> ta, tb, tc = [tan(i) for i in (a, b, c)]\n    >>> TR12i((ta + tb)/(-ta*tb + 1))\n    tan(a + b)\n    >>> TR12i((ta + tb)/(ta*tb - 1))\n    -tan(a + b)\n    >>> TR12i((-ta - tb)/(ta*tb - 1))\n    tan(a + b)\n    >>> eq = (ta + tb)/(-ta*tb + 1)**2*(-3*ta - 3*tc)/(2*(ta*tc - 1))\n    >>> TR12i(eq.expand())\n    -3*tan(a + b)*tan(a + c)/(2*(tan(a) + tan(b) - 1))\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR13",
    "full_id": "sympy.simplify.fu.TR13",
    "type": "function",
    "description": "Change products of ``tan`` or ``cot``.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR13\n    >>> from sympy import tan, cot\n    >>> TR13(tan(3)*tan(2))\n    -tan(2)/tan(5) - tan(3)/tan(5) + 1\n    >>> TR13(cot(3)*cot(2))\n    cot(2)*cot(5) + 1 + cot(3)*cot(5)\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TRmorrie",
    "full_id": "sympy.simplify.fu.TRmorrie",
    "type": "function",
    "description": "Returns cos(x)*cos(2*x)*...*cos(2**(k-1)*x) -> sin(2**k*x)/(2**k*sin(x))\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TRmorrie, TR8, TR3\n    >>> from sympy.abc import x\n    >>> from sympy import Mul, cos, pi\n    >>> TRmorrie(cos(x)*cos(2*x))\n    sin(4*x)/(4*sin(x))\n    >>> TRmorrie(7*Mul(*[cos(x) for x in range(10)]))\n    7*sin(12)*sin(16)*cos(5)*cos(7)*cos(9)/(64*sin(1)*sin(3))\n\n    Sometimes autosimplification will cause a power to be\n    not recognized. e.g. in the following, cos(4*pi/7) automatically\n    simplifies to -cos(3*pi/7) so only 2 of the 3 terms are\n    recognized:\n\n    >>> TRmorrie(cos(pi/7)*cos(2*pi/7)*cos(4*pi/7))\n    -sin(3*pi/7)*cos(3*pi/7)/(4*sin(pi/7))\n\n    A touch by TR8 resolves the expression to a Rational\n\n    >>> TR8(_)\n    -1/8\n\n    In this case, if eq is unsimplified, the answer is obtained\n    directly:\n\n    >>> eq = cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9)\n    >>> TRmorrie(eq)\n    1/16\n\n    But if angles are made canonical with TR3 then the answer\n    is not simplified without further work:\n\n    >>> TR3(eq)\n    sin(pi/18)*cos(pi/9)*cos(2*pi/9)/2\n    >>> TRmorrie(_)\n    sin(pi/18)*sin(4*pi/9)/(8*sin(pi/9))\n    >>> TR8(_)\n    cos(7*pi/18)/(16*sin(pi/9))\n    >>> TR3(_)\n    1/16\n\n    The original expression would have resolve to 1/16 directly with TR8,\n    however:\n\n    >>> TR8(eq)\n    1/16\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Morrie%27s_law\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR14",
    "full_id": "sympy.simplify.fu.TR14",
    "type": "function",
    "description": "Convert factored powers of sin and cos identities into simpler\n    expressions.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR14\n    >>> from sympy.abc import x, y\n    >>> from sympy import cos, sin\n    >>> TR14((cos(x) - 1)*(cos(x) + 1))\n    -sin(x)**2\n    >>> TR14((sin(x) - 1)*(sin(x) + 1))\n    -cos(x)**2\n    >>> p1 = (cos(x) + 1)*(cos(x) - 1)\n    >>> p2 = (cos(y) - 1)*2*(cos(y) + 1)\n    >>> p3 = (3*(cos(y) - 1))*(3*(cos(y) + 1))\n    >>> TR14(p1*p2*p3*(x - 1))\n    -18*(x - 1)*sin(x)**2*sin(y)**4\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR15",
    "full_id": "sympy.simplify.fu.TR15",
    "type": "function",
    "description": "Convert sin(x)**-2 to 1 + cot(x)**2.\n\n    See _TR56 docstring for advanced use of ``max`` and ``pow``.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR15\n    >>> from sympy.abc import x\n    >>> from sympy import sin\n    >>> TR15(1 - 1/sin(x)**2)\n    -cot(x)**2\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR16",
    "full_id": "sympy.simplify.fu.TR16",
    "type": "function",
    "description": "Convert cos(x)**-2 to 1 + tan(x)**2.\n\n    See _TR56 docstring for advanced use of ``max`` and ``pow``.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR16\n    >>> from sympy.abc import x\n    >>> from sympy import cos\n    >>> TR16(1 - 1/cos(x)**2)\n    -tan(x)**2\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR111",
    "full_id": "sympy.simplify.fu.TR111",
    "type": "function",
    "description": "Convert f(x)**-i to g(x)**i where either ``i`` is an integer\n    or the base is positive and f, g are: tan, cot; sin, csc; or cos, sec.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR111\n    >>> from sympy.abc import x\n    >>> from sympy import tan\n    >>> TR111(1 - 1/tan(x)**2)\n    1 - cot(x)**2\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TR22",
    "full_id": "sympy.simplify.fu.TR22",
    "type": "function",
    "description": "Convert tan(x)**2 to sec(x)**2 - 1 and cot(x)**2 to csc(x)**2 - 1.\n\n    See _TR56 docstring for advanced use of ``max`` and ``pow``.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TR22\n    >>> from sympy.abc import x\n    >>> from sympy import tan, cot\n    >>> TR22(1 + tan(x)**2)\n    sec(x)**2\n    >>> TR22(1 + cot(x)**2)\n    csc(x)**2\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "TRpower",
    "full_id": "sympy.simplify.fu.TRpower",
    "type": "function",
    "description": "Convert sin(x)**n and cos(x)**n with positive n to sums.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import TRpower\n    >>> from sympy.abc import x\n    >>> from sympy import cos, sin\n    >>> TRpower(sin(x)**6)\n    -15*cos(2*x)/32 + 3*cos(4*x)/16 - cos(6*x)/32 + 5/16\n    >>> TRpower(sin(x)**3*cos(2*x)**4)\n    (3*sin(x)/4 - sin(3*x)/4)*(cos(4*x)/2 + cos(8*x)/8 + 3/8)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Power-reduction_formulae\n\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "fu",
    "full_id": "sympy.simplify.fu.fu",
    "type": "function",
    "description": "Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n\n    .. [1] https://www.sciencedirect.com/science/article/pii/S0895717706001609\n    ",
    "section": "Rules",
    "url": "https://docs.sympy.org/latest/modules/simplify/fu.html"
  },
  {
    "name": "diophantine",
    "full_id": "sympy.solvers.diophantine.diophantine.diophantine",
    "type": "function",
    "description": "\n    Simplify the solution procedure of diophantine equation ``eq`` by\n    converting it into a product of terms which should equal zero.\n\n    Explanation\n    ===========\n\n    For example, when solving, `x^2 - y^2 = 0` this is treated as\n    `(x + y)(x - y) = 0` and `x + y = 0` and `x - y = 0` are solved\n    independently and combined. Each term is solved by calling\n    ``diop_solve()``. (Although it is possible to call ``diop_solve()``\n    directly, one must be careful to pass an equation in the correct\n    form and to interpret the output correctly; ``diophantine()`` is\n    the public-facing function to use in general.)\n\n    Output of ``diophantine()`` is a set of tuples. The elements of the\n    tuple are the solutions for each variable in the equation and\n    are arranged according to the alphabetic ordering of the variables.\n    e.g. For an equation with two variables, `a` and `b`, the first\n    element of the tuple is the solution for `a` and the second for `b`.\n\n    Usage\n    =====\n\n    ``diophantine(eq, t, syms)``: Solve the diophantine\n    equation ``eq``.\n    ``t`` is the optional parameter to be used by ``diop_solve()``.\n    ``syms`` is an optional list of symbols which determines the\n    order of the elements in the returned tuple.\n\n    By default, only the base solution is returned. If ``permute`` is set to\n    True then permutations of the base solution and/or permutations of the\n    signs of the values will be returned when applicable.\n\n    Details\n    =======\n\n    ``eq`` should be an expression which is assumed to be zero.\n    ``t`` is the parameter to be used in the solution.\n\n    Examples\n    ========\n\n    >>> from sympy import diophantine\n    >>> from sympy.abc import a, b\n    >>> eq = a**4 + b**4 - (2**4 + 3**4)\n    >>> diophantine(eq)\n    {(2, 3)}\n    >>> diophantine(eq, permute=True)\n    {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n\n    >>> from sympy.abc import x, y, z\n    >>> diophantine(x**2 - y**2)\n    {(t_0, -t_0), (t_0, t_0)}\n\n    >>> diophantine(x*(2*x + 3*y - z))\n    {(0, n1, n2), (t_0, t_1, 2*t_0 + 3*t_1)}\n    >>> diophantine(x**2 + 3*x*y + 4*x)\n    {(0, n1), (-3*t_0 - 4, t_0)}\n\n    See Also\n    ========\n\n    diop_solve\n    sympy.utilities.iterables.permute_signs\n    sympy.utilities.iterables.signed_permutations\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_solve",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_solve",
    "type": "function",
    "description": "\n    Solves the diophantine equation ``eq``.\n\n    Explanation\n    ===========\n\n    Unlike ``diophantine()``, factoring of ``eq`` is not attempted. Uses\n    ``classify_diop()`` to determine the type of the equation and calls\n    the appropriate solver function.\n\n    Use of ``diophantine()`` is recommended over other helper functions.\n    ``diop_solve()`` can return either a set or a tuple depending on the\n    nature of the equation.\n\n    Usage\n    =====\n\n    ``diop_solve(eq, t)``: Solve diophantine equation, ``eq`` using ``t``\n    as a parameter if needed.\n\n    Details\n    =======\n\n    ``eq`` should be an expression which is assumed to be zero.\n    ``t`` is a parameter to be used in the solution.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine import diop_solve\n    >>> from sympy.abc import x, y, z, w\n    >>> diop_solve(2*x + 3*y - 5)\n    (3*t_0 - 5, 5 - 2*t_0)\n    >>> diop_solve(4*x + 3*y - 4*z + 5)\n    (t_0, 8*t_0 + 4*t_1 + 5, 7*t_0 + 3*t_1 + 5)\n    >>> diop_solve(x + 3*y - 4*z + w - 6)\n    (t_0, t_0 + t_1, 6*t_0 + 5*t_1 + 4*t_2 - 6, 5*t_0 + 4*t_1 + 3*t_2 - 6)\n    >>> diop_solve(x**2 + y**2 - 5)\n    {(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)}\n\n\n    See Also\n    ========\n\n    diophantine()\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_linear",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_linear",
    "type": "function",
    "description": "\n    Solves linear diophantine equations.\n\n    A linear diophantine equation is an equation of the form `a_{1}x_{1} +\n    a_{2}x_{2} + .. + a_{n}x_{n} = 0` where `a_{1}, a_{2}, ..a_{n}` are\n    integer constants and `x_{1}, x_{2}, ..x_{n}` are integer variables.\n\n    Usage\n    =====\n\n    ``diop_linear(eq)``: Returns a tuple containing solutions to the\n    diophantine equation ``eq``. Values in the tuple is arranged in the same\n    order as the sorted variables.\n\n    Details\n    =======\n\n    ``eq`` is a linear diophantine equation which is assumed to be zero.\n    ``param`` is the parameter to be used in the solution.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import diop_linear\n    >>> from sympy.abc import x, y, z\n    >>> diop_linear(2*x - 3*y - 5) # solves equation 2*x - 3*y - 5 == 0\n    (3*t_0 - 5, 2*t_0 - 5)\n\n    Here x = -3*t_0 - 5 and y = -2*t_0 - 5\n\n    >>> diop_linear(2*x - 3*y - 4*z -3)\n    (t_0, 2*t_0 + 4*t_1 + 3, -t_0 - 3*t_1 - 3)\n\n    See Also\n    ========\n\n    diop_quadratic(), diop_ternary_quadratic(), diop_general_pythagorean(),\n    diop_general_sum_of_squares()\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "base_solution_linear",
    "full_id": "sympy.solvers.diophantine.diophantine.base_solution_linear",
    "type": "function",
    "description": "\n    Return the base solution for the linear equation, `ax + by = c`.\n\n    Explanation\n    ===========\n\n    Used by ``diop_linear()`` to find the base solution of a linear\n    Diophantine equation. If ``t`` is given then the parametrized solution is\n    returned.\n\n    Usage\n    =====\n\n    ``base_solution_linear(c, a, b, t)``: ``a``, ``b``, ``c`` are coefficients\n    in `ax + by = c` and ``t`` is the parameter to be used in the solution.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import base_solution_linear\n    >>> from sympy.abc import t\n    >>> base_solution_linear(5, 2, 3) # equation 2*x + 3*y = 5\n    (-5, 5)\n    >>> base_solution_linear(0, 5, 7) # equation 5*x + 7*y = 0\n    (0, 0)\n    >>> base_solution_linear(5, 2, 3, t) # equation 2*x + 3*y = 5\n    (3*t - 5, 5 - 2*t)\n    >>> base_solution_linear(0, 5, 7, t) # equation 5*x + 7*y = 0\n    (7*t, -5*t)\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_quadratic",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_quadratic",
    "type": "function",
    "description": "\n    Solves quadratic diophantine equations.\n\n    i.e. equations of the form `Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0`. Returns a\n    set containing the tuples `(x, y)` which contains the solutions. If there\n    are no solutions then `(None, None)` is returned.\n\n    Usage\n    =====\n\n    ``diop_quadratic(eq, param)``: ``eq`` is a quadratic binary diophantine\n    equation. ``param`` is used to indicate the parameter to be used in the\n    solution.\n\n    Details\n    =======\n\n    ``eq`` should be an expression which is assumed to be zero.\n    ``param`` is a parameter to be used in the solution.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, t\n    >>> from sympy.solvers.diophantine.diophantine import diop_quadratic\n    >>> diop_quadratic(x**2 + y**2 + 2*x + 2*y + 2, t)\n    {(-1, -1)}\n\n    References\n    ==========\n\n    .. [1] Methods to solve Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0, [online],\n          Available: https://www.alpertron.com.ar/METHODS.HTM\n    .. [2] Solving the equation ax^2+ bxy + cy^2 + dx + ey + f= 0, [online],\n          Available: https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf\n\n    See Also\n    ========\n\n    diop_linear(), diop_ternary_quadratic(), diop_general_sum_of_squares(),\n    diop_general_pythagorean()\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_DN",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_DN",
    "type": "function",
    "description": "\n    Solves the equation `x^2 - Dy^2 = N`.\n\n    Explanation\n    ===========\n\n    Mainly concerned with the case `D > 0, D` is not a perfect square,\n    which is the same as the generalized Pell equation. The LMM\n    algorithm [1]_ is used to solve this equation.\n\n    Returns one solution tuple, (`x, y)` for each class of the solutions.\n    Other solutions of the class can be constructed according to the\n    values of ``D`` and ``N``.\n\n    Usage\n    =====\n\n    ``diop_DN(D, N, t)``: D and N are integers as in `x^2 - Dy^2 = N` and\n    ``t`` is the parameter to be used in the solutions.\n\n    Details\n    =======\n\n    ``D`` and ``N`` correspond to D and N in the equation.\n    ``t`` is the parameter to be used in the solutions.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import diop_DN\n    >>> diop_DN(13, -4) # Solves equation x**2 - 13*y**2 = -4\n    [(3, 1), (393, 109), (36, 10)]\n\n    The output can be interpreted as follows: There are three fundamental\n    solutions to the equation `x^2 - 13y^2 = -4` given by (3, 1), (393, 109)\n    and (36, 10). Each tuple is in the form (x, y), i.e. solution (3, 1) means\n    that `x = 3` and `y = 1`.\n\n    >>> diop_DN(986, 1) # Solves equation x**2 - 986*y**2 = 1\n    [(49299, 1570)]\n\n    See Also\n    ========\n\n    find_DN(), diop_bf_DN()\n\n    References\n    ==========\n\n    .. [1] Solving the generalized Pell equation x**2 - D*y**2 = N, John P.\n        Robertson, July 31, 2004, Pages 16 - 17. [online], Available:\n        https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "cornacchia",
    "full_id": "sympy.solvers.diophantine.diophantine.cornacchia",
    "type": "function",
    "description": "\n    Solves `ax^2 + by^2 = m` where `\\gcd(a, b) = 1 = gcd(a, m)` and `a, b > 0`.\n\n    Explanation\n    ===========\n\n    Uses the algorithm due to Cornacchia. The method only finds primitive\n    solutions, i.e. ones with `\\gcd(x, y) = 1`. So this method cannot be used to\n    find the solutions of `x^2 + y^2 = 20` since the only solution to former is\n    `(x, y) = (4, 2)` and it is not primitive. When `a = b`, only the\n    solutions with `x \\leq y` are found. For more details, see the References.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import cornacchia\n    >>> cornacchia(2, 3, 35) # equation 2x**2 + 3y**2 = 35\n    {(2, 3), (4, 1)}\n    >>> cornacchia(1, 1, 25) # equation x**2 + y**2 = 25\n    {(4, 3)}\n\n    References\n    ===========\n\n    .. [1] A. Nitaj, \"L'algorithme de Cornacchia\"\n    .. [2] Solving the diophantine equation ax**2 + by**2 = m by Cornacchia's\n        method, [online], Available:\n        http://www.numbertheory.org/php/cornacchia.html\n\n    See Also\n    ========\n\n    sympy.utilities.iterables.signed_permutations\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_bf_DN",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_bf_DN",
    "type": "function",
    "description": "\n    Uses brute force to solve the equation, `x^2 - Dy^2 = N`.\n\n    Explanation\n    ===========\n\n    Mainly concerned with the generalized Pell equation which is the case when\n    `D > 0, D` is not a perfect square. For more information on the case refer\n    [1]_. Let `(t, u)` be the minimal positive solution of the equation\n    `x^2 - Dy^2 = 1`. Then this method requires\n    `\\sqrt{\\\\frac{\\mid N \\mid (t \\pm 1)}{2D}}` to be small.\n\n    Usage\n    =====\n\n    ``diop_bf_DN(D, N, t)``: ``D`` and ``N`` are coefficients in\n    `x^2 - Dy^2 = N` and ``t`` is the parameter to be used in the solutions.\n\n    Details\n    =======\n\n    ``D`` and ``N`` correspond to D and N in the equation.\n    ``t`` is the parameter to be used in the solutions.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import diop_bf_DN\n    >>> diop_bf_DN(13, -4)\n    [(3, 1), (-3, 1), (36, 10)]\n    >>> diop_bf_DN(986, 1)\n    [(49299, 1570)]\n\n    See Also\n    ========\n\n    diop_DN()\n\n    References\n    ==========\n\n    .. [1] Solving the generalized Pell equation x**2 - D*y**2 = N, John P.\n        Robertson, July 31, 2004, Page 15. https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "transformation_to_DN",
    "full_id": "sympy.solvers.diophantine.diophantine.transformation_to_DN",
    "type": "function",
    "description": "\n    This function transforms general quadratic,\n    `ax^2 + bxy + cy^2 + dx + ey + f = 0`\n    to more easy to deal with `X^2 - DY^2 = N` form.\n\n    Explanation\n    ===========\n\n    This is used to solve the general quadratic equation by transforming it to\n    the latter form. Refer to [1]_ for more detailed information on the\n    transformation. This function returns a tuple (A, B) where A is a 2 X 2\n    matrix and B is a 2 X 1 matrix such that,\n\n    Transpose([x y]) =  A * Transpose([X Y]) + B\n\n    Usage\n    =====\n\n    ``transformation_to_DN(eq)``: where ``eq`` is the quadratic to be\n    transformed.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy.solvers.diophantine.diophantine import transformation_to_DN\n    >>> A, B = transformation_to_DN(x**2 - 3*x*y - y**2 - 2*y + 1)\n    >>> A\n    Matrix([\n    [1/26, 3/26],\n    [   0, 1/13]])\n    >>> B\n    Matrix([\n    [-6/13],\n    [-4/13]])\n\n    A, B  returned are such that Transpose((x y)) =  A * Transpose((X Y)) + B.\n    Substituting these values for `x` and `y` and a bit of simplifying work\n    will give an equation of the form `x^2 - Dy^2 = N`.\n\n    >>> from sympy.abc import X, Y\n    >>> from sympy import Matrix, simplify\n    >>> u = (A*Matrix([X, Y]) + B)[0] # Transformation for x\n    >>> u\n    X/26 + 3*Y/26 - 6/13\n    >>> v = (A*Matrix([X, Y]) + B)[1] # Transformation for y\n    >>> v\n    Y/13 - 4/13\n\n    Next we will substitute these formulas for `x` and `y` and do\n    ``simplify()``.\n\n    >>> eq = simplify((x**2 - 3*x*y - y**2 - 2*y + 1).subs(zip((x, y), (u, v))))\n    >>> eq\n    X**2/676 - Y**2/52 + 17/13\n\n    By multiplying the denominator appropriately, we can get a Pell equation\n    in the standard form.\n\n    >>> eq * 676\n    X**2 - 13*Y**2 + 884\n\n    If only the final equation is needed, ``find_DN()`` can be used.\n\n    See Also\n    ========\n\n    find_DN()\n\n    References\n    ==========\n\n    .. [1] Solving the equation ax^2 + bxy + cy^2 + dx + ey + f = 0,\n           John P.Robertson, May 8, 2003, Page 7 - 11.\n           https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "transformation_to_normal",
    "full_id": "sympy.solvers.diophantine.diophantine.transformation_to_normal",
    "type": "function",
    "description": "\n    Returns the transformation Matrix that converts a general ternary\n    quadratic equation ``eq`` (`ax^2 + by^2 + cz^2 + dxy + eyz + fxz`)\n    to a form without cross terms: `ax^2 + by^2 + cz^2 = 0`. This is\n    not used in solving ternary quadratics; it is only implemented for\n    the sake of completeness.\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "find_DN",
    "full_id": "sympy.solvers.diophantine.diophantine.find_DN",
    "type": "function",
    "description": "\n    This function returns a tuple, `(D, N)` of the simplified form,\n    `x^2 - Dy^2 = N`, corresponding to the general quadratic,\n    `ax^2 + bxy + cy^2 + dx + ey + f = 0`.\n\n    Solving the general quadratic is then equivalent to solving the equation\n    `X^2 - DY^2 = N` and transforming the solutions by using the transformation\n    matrices returned by ``transformation_to_DN()``.\n\n    Usage\n    =====\n\n    ``find_DN(eq)``: where ``eq`` is the quadratic to be transformed.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy.solvers.diophantine.diophantine import find_DN\n    >>> find_DN(x**2 - 3*x*y - y**2 - 2*y + 1)\n    (13, -884)\n\n    Interpretation of the output is that we get `X^2 -13Y^2 = -884` after\n    transforming `x^2 - 3xy - y^2 - 2y + 1` using the transformation returned\n    by ``transformation_to_DN()``.\n\n    See Also\n    ========\n\n    transformation_to_DN()\n\n    References\n    ==========\n\n    .. [1] Solving the equation ax^2 + bxy + cy^2 + dx + ey + f = 0,\n           John P.Robertson, May 8, 2003, Page 7 - 11.\n           https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_ternary_quadratic",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_ternary_quadratic",
    "type": "function",
    "description": "\n    Solves the general quadratic ternary form,\n    `ax^2 + by^2 + cz^2 + fxy + gyz + hxz = 0`.\n\n    Returns a tuple `(x, y, z)` which is a base solution for the above\n    equation. If there are no solutions, `(None, None, None)` is returned.\n\n    Usage\n    =====\n\n    ``diop_ternary_quadratic(eq)``: Return a tuple containing a basic solution\n    to ``eq``.\n\n    Details\n    =======\n\n    ``eq`` should be an homogeneous expression of degree two in three variables\n    and it is assumed to be zero.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> from sympy.solvers.diophantine.diophantine import diop_ternary_quadratic\n    >>> diop_ternary_quadratic(x**2 + 3*y**2 - z**2)\n    (1, 0, 1)\n    >>> diop_ternary_quadratic(4*x**2 + 5*y**2 - z**2)\n    (1, 0, 2)\n    >>> diop_ternary_quadratic(45*x**2 - 7*y**2 - 8*x*y - z**2)\n    (28, 45, 105)\n    >>> diop_ternary_quadratic(x**2 - 49*y**2 - z**2 + 13*z*y -8*x*y)\n    (9, 1, 5)\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "square_factor",
    "full_id": "sympy.solvers.diophantine.diophantine.square_factor",
    "type": "function",
    "description": "\n    Returns an integer `c` s.t. `a = c^2k, \\ c,k \\in Z`. Here `k` is square\n    free. `a` can be given as an integer or a dictionary of factors.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import square_factor\n    >>> square_factor(24)\n    2\n    >>> square_factor(-36*3)\n    6\n    >>> square_factor(1)\n    1\n    >>> square_factor({3: 2, 2: 1, -1: 1})  # -18\n    3\n\n    See Also\n    ========\n    sympy.ntheory.factor_.core\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "descent",
    "full_id": "sympy.solvers.diophantine.diophantine.descent",
    "type": "function",
    "description": "\n    Returns a non-trivial solution, (x, y, z), to `x^2 = Ay^2 + Bz^2`\n    using Lagrange's descent method with lattice-reduction. `A` and `B`\n    are assumed to be valid for such a solution to exist.\n\n    This is faster than the normal Lagrange's descent algorithm because\n    the Gaussian reduction is used.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import descent\n    >>> descent(3, 1) # x**2 = 3*y**2 + z**2\n    (1, 0, 1)\n\n    `(x, y, z) = (1, 0, 1)` is a solution to the above equation.\n\n    >>> descent(41, -113)\n    (-16, -3, 1)\n\n    References\n    ==========\n\n    .. [1] Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics.\n           Mathematics of Computation, 72(243), 1417-1441.\n           https://doi.org/10.1090/S0025-5718-02-01480-1\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_general_pythagorean",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_general_pythagorean",
    "type": "function",
    "description": "\n    Solves the general pythagorean equation,\n    `a_{1}^2x_{1}^2 + a_{2}^2x_{2}^2 + . . . + a_{n}^2x_{n}^2 - a_{n + 1}^2x_{n + 1}^2 = 0`.\n\n    Returns a tuple which contains a parametrized solution to the equation,\n    sorted in the same order as the input variables.\n\n    Usage\n    =====\n\n    ``diop_general_pythagorean(eq, param)``: where ``eq`` is a general\n    pythagorean equation which is assumed to be zero and ``param`` is the base\n    parameter used to construct other parameters by subscripting.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import diop_general_pythagorean\n    >>> from sympy.abc import a, b, c, d, e\n    >>> diop_general_pythagorean(a**2 + b**2 + c**2 - d**2)\n    (m1**2 + m2**2 - m3**2, 2*m1*m3, 2*m2*m3, m1**2 + m2**2 + m3**2)\n    >>> diop_general_pythagorean(9*a**2 - 4*b**2 + 16*c**2 + 25*d**2 + e**2)\n    (10*m1**2  + 10*m2**2  + 10*m3**2 - 10*m4**2, 15*m1**2  + 15*m2**2  + 15*m3**2  + 15*m4**2, 15*m1*m4, 12*m2*m4, 60*m3*m4)\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_general_sum_of_squares",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares",
    "type": "function",
    "description": "\n    Solves the equation `x_{1}^2 + x_{2}^2 + . . . + x_{n}^2 - k = 0`.\n\n    Returns at most ``limit`` number of solutions.\n\n    Usage\n    =====\n\n    ``general_sum_of_squares(eq, limit)`` : Here ``eq`` is an expression which\n    is assumed to be zero. Also, ``eq`` should be in the form,\n    `x_{1}^2 + x_{2}^2 + . . . + x_{n}^2 - k = 0`.\n\n    Details\n    =======\n\n    When `n = 3` if `k = 4^a(8m + 7)` for some `a, m \\in Z` then there will be\n    no solutions. Refer to [1]_ for more details.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import diop_general_sum_of_squares\n    >>> from sympy.abc import a, b, c, d, e\n    >>> diop_general_sum_of_squares(a**2 + b**2 + c**2 + d**2 + e**2 - 2345)\n    {(15, 22, 22, 24, 24)}\n\n    Reference\n    =========\n\n    .. [1] Representing an integer as a sum of three squares, [online],\n        Available:\n        https://www.proofwiki.org/wiki/Integer_as_Sum_of_Three_Squares\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_general_sum_of_even_powers",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_general_sum_of_even_powers",
    "type": "function",
    "description": "\n    Solves the equation `x_{1}^e + x_{2}^e + . . . + x_{n}^e - k = 0`\n    where `e` is an even, integer power.\n\n    Returns at most ``limit`` number of solutions.\n\n    Usage\n    =====\n\n    ``general_sum_of_even_powers(eq, limit)`` : Here ``eq`` is an expression which\n    is assumed to be zero. Also, ``eq`` should be in the form,\n    `x_{1}^e + x_{2}^e + . . . + x_{n}^e - k = 0`.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import diop_general_sum_of_even_powers\n    >>> from sympy.abc import a, b\n    >>> diop_general_sum_of_even_powers(a**4 + b**4 - (2**4 + 3**4))\n    {(2, 3)}\n\n    See Also\n    ========\n\n    power_representation\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "power_representation",
    "full_id": "sympy.solvers.diophantine.diophantine.power_representation",
    "type": "function",
    "description": "\n    Returns a generator for finding k-tuples of integers,\n    `(n_{1}, n_{2}, . . . n_{k})`, such that\n    `n = n_{1}^p + n_{2}^p + . . . n_{k}^p`.\n\n    Usage\n    =====\n\n    ``power_representation(n, p, k, zeros)``: Represent non-negative number\n    ``n`` as a sum of ``k`` ``p``\\ th powers. If ``zeros`` is true, then the\n    solutions is allowed to contain zeros.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import power_representation\n\n    Represent 1729 as a sum of two cubes:\n\n    >>> f = power_representation(1729, 3, 2)\n    >>> next(f)\n    (9, 10)\n    >>> next(f)\n    (1, 12)\n\n    If the flag `zeros` is True, the solution may contain tuples with\n    zeros; any such solutions will be generated after the solutions\n    without zeros:\n\n    >>> list(power_representation(125, 2, 3, zeros=True))\n    [(5, 6, 8), (3, 4, 10), (0, 5, 10), (0, 2, 11)]\n\n    For even `p` the `permute_sign` function can be used to get all\n    signed values:\n\n    >>> from sympy.utilities.iterables import permute_signs\n    >>> list(permute_signs((1, 12)))\n    [(1, 12), (-1, 12), (1, -12), (-1, -12)]\n\n    All possible signed permutations can also be obtained:\n\n    >>> from sympy.utilities.iterables import signed_permutations\n    >>> list(signed_permutations((1, 12)))\n    [(1, 12), (-1, 12), (1, -12), (-1, -12), (12, 1), (-12, 1), (12, -1), (-12, -1)]\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "partition",
    "full_id": "sympy.solvers.diophantine.diophantine.partition",
    "type": "function",
    "description": "\n    Returns a generator that can be used to generate partitions of an integer\n    `n`.\n\n    Explanation\n    ===========\n\n    A partition of `n` is a set of positive integers which add up to `n`. For\n    example, partitions of 3 are 3, 1 + 2, 1 + 1 + 1. A partition is returned\n    as a tuple. If ``k`` equals None, then all possible partitions are returned\n    irrespective of their size, otherwise only the partitions of size ``k`` are\n    returned. If the ``zero`` parameter is set to True then a suitable\n    number of zeros are added at the end of every partition of size less than\n    ``k``.\n\n    ``zero`` parameter is considered only if ``k`` is not None. When the\n    partitions are over, the last `next()` call throws the ``StopIteration``\n    exception, so this function should always be used inside a try - except\n    block.\n\n    Details\n    =======\n\n    ``partition(n, k)``: Here ``n`` is a positive integer and ``k`` is the size\n    of the partition which is also positive integer.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import partition\n    >>> f = partition(5)\n    >>> next(f)\n    (1, 1, 1, 1, 1)\n    >>> next(f)\n    (1, 1, 1, 2)\n    >>> g = partition(5, 3)\n    >>> next(g)\n    (1, 1, 3)\n    >>> next(g)\n    (1, 2, 2)\n    >>> g = partition(5, 3, zeros=True)\n    >>> next(g)\n    (0, 0, 5)\n\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "sum_of_three_squares",
    "full_id": "sympy.solvers.diophantine.diophantine.sum_of_three_squares",
    "type": "function",
    "description": "\n    Returns a 3-tuple $(a, b, c)$ such that $a^2 + b^2 + c^2 = n$ and\n    $a, b, c \\geq 0$.\n\n    Returns None if $n = 4^a(8m + 7)$ for some `a, m \\in \\mathbb{Z}`. See\n    [1]_ for more details.\n\n    Parameters\n    ==========\n\n    n : Integer\n        non-negative integer\n\n    Returns\n    =======\n\n    (int, int, int) | None : 3-tuple non-negative integers ``(a, b, c)`` satisfying ``a**2 + b**2 + c**2 = n``.\n                             a,b,c are sorted in ascending order. ``None`` if no such ``(a,b,c)``.\n\n    Raises\n    ======\n\n    ValueError\n        If ``n`` is a negative integer\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import sum_of_three_squares\n    >>> sum_of_three_squares(44542)\n    (18, 37, 207)\n\n    References\n    ==========\n\n    .. [1] Representing a number as a sum of three squares, [online],\n        Available: https://schorn.ch/lagrange.html\n\n    See Also\n    ========\n\n    power_representation :\n        ``sum_of_three_squares(n)`` is one of the solutions output by ``power_representation(n, 2, 3, zeros=True)``\n\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "sum_of_four_squares",
    "full_id": "sympy.solvers.diophantine.diophantine.sum_of_four_squares",
    "type": "function",
    "description": "\n    Returns a 4-tuple `(a, b, c, d)` such that `a^2 + b^2 + c^2 + d^2 = n`.\n    Here `a, b, c, d \\geq 0`.\n\n    Parameters\n    ==========\n\n    n : Integer\n        non-negative integer\n\n    Returns\n    =======\n\n    (int, int, int, int) : 4-tuple non-negative integers ``(a, b, c, d)`` satisfying ``a**2 + b**2 + c**2 + d**2 = n``.\n                           a,b,c,d are sorted in ascending order.\n\n    Raises\n    ======\n\n    ValueError\n        If ``n`` is a negative integer\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import sum_of_four_squares\n    >>> sum_of_four_squares(3456)\n    (8, 8, 32, 48)\n    >>> sum_of_four_squares(1294585930293)\n    (0, 1234, 2161, 1137796)\n\n    References\n    ==========\n\n    .. [1] Representing a number as a sum of four squares, [online],\n        Available: https://schorn.ch/lagrange.html\n\n    See Also\n    ========\n\n    power_representation :\n        ``sum_of_four_squares(n)`` is one of the solutions output by ``power_representation(n, 2, 4, zeros=True)``\n\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "sum_of_squares",
    "full_id": "sympy.solvers.diophantine.diophantine.sum_of_squares",
    "type": "function",
    "description": "Return a generator that yields the k-tuples of nonnegative\n    values, the squares of which sum to n. If zeros is False (default)\n    then the solution will not contain zeros. The nonnegative\n    elements of a tuple are sorted.\n\n    * If k == 1 and n is square, (n,) is returned.\n\n    * If k == 2 then n can only be written as a sum of squares if\n      every prime in the factorization of n that has the form\n      4*k + 3 has an even multiplicity. If n is prime then\n      it can only be written as a sum of two squares if it is\n      in the form 4*k + 1.\n\n    * if k == 3 then n can be written as a sum of squares if it does\n      not have the form 4**m*(8*k + 7).\n\n    * all integers can be written as the sum of 4 squares.\n\n    * if k > 4 then n can be partitioned and each partition can\n      be written as a sum of 4 squares; if n is not evenly divisible\n      by 4 then n can be written as a sum of squares only if the\n      an additional partition can be written as sum of squares.\n      For example, if k = 6 then n is partitioned into two parts,\n      the first being written as a sum of 4 squares and the second\n      being written as a sum of 2 squares -- which can only be\n      done if the condition above for k = 2 can be met, so this will\n      automatically reject certain partitions of n.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import sum_of_squares\n    >>> list(sum_of_squares(25, 2))\n    [(3, 4)]\n    >>> list(sum_of_squares(25, 2, True))\n    [(3, 4), (0, 5)]\n    >>> list(sum_of_squares(25, 4))\n    [(1, 2, 2, 4)]\n\n    See Also\n    ========\n\n    sympy.utilities.iterables.signed_permutations\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "merge_solution",
    "full_id": "sympy.solvers.diophantine.diophantine.merge_solution",
    "type": "function",
    "description": "\n    This is used to construct the full solution from the solutions of sub\n    equations.\n\n    Explanation\n    ===========\n\n    For example when solving the equation `(x - y)(x^2 + y^2 - z^2) = 0`,\n    solutions for each of the equations `x - y = 0` and `x^2 + y^2 - z^2` are\n    found independently. Solutions for `x - y = 0` are `(x, y) = (t, t)`. But\n    we should introduce a value for z when we output the solution for the\n    original equation. This function converts `(t, t)` into `(t, t, n_{1})`\n    where `n_{1}` is an integer parameter.\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "divisible",
    "full_id": "sympy.solvers.diophantine.diophantine.divisible",
    "type": "function",
    "description": "\n    Returns `True` if ``a`` is divisible by ``b`` and `False` otherwise.\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "PQa",
    "full_id": "sympy.solvers.diophantine.diophantine.PQa",
    "type": "function",
    "description": "\n    Returns useful information needed to solve the Pell equation.\n\n    Explanation\n    ===========\n\n    There are six sequences of integers defined related to the continued\n    fraction representation of `\\\\frac{P + \\sqrt{D}}{Q}`, namely {`P_{i}`},\n    {`Q_{i}`}, {`a_{i}`},{`A_{i}`}, {`B_{i}`}, {`G_{i}`}. ``PQa()`` Returns\n    these values as a 6-tuple in the same order as mentioned above. Refer [1]_\n    for more detailed information.\n\n    Usage\n    =====\n\n    ``PQa(P_0, Q_0, D)``: ``P_0``, ``Q_0`` and ``D`` are integers corresponding\n    to `P_{0}`, `Q_{0}` and `D` in the continued fraction\n    `\\\\frac{P_{0} + \\sqrt{D}}{Q_{0}}`.\n    Also it's assumed that `P_{0}^2 == D mod(|Q_{0}|)` and `D` is square free.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import PQa\n    >>> pqa = PQa(13, 4, 5) # (13 + sqrt(5))/4\n    >>> next(pqa) # (P_0, Q_0, a_0, A_0, B_0, G_0)\n    (13, 4, 3, 3, 1, -1)\n    >>> next(pqa) # (P_1, Q_1, a_1, A_1, B_1, G_1)\n    (-1, 1, 1, 4, 1, 3)\n\n    References\n    ==========\n\n    .. [1] Solving the generalized Pell equation x^2 - Dy^2 = N, John P.\n        Robertson, July 31, 2004, Pages 4 - 8. https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "equivalent",
    "full_id": "sympy.solvers.diophantine.diophantine.equivalent",
    "type": "function",
    "description": "\n    Returns True if two solutions `(u, v)` and `(r, s)` of `x^2 - Dy^2 = N`\n    belongs to the same equivalence class and False otherwise.\n\n    Explanation\n    ===========\n\n    Two solutions `(u, v)` and `(r, s)` to the above equation fall to the same\n    equivalence class iff both `(ur - Dvs)` and `(us - vr)` are divisible by\n    `N`. See reference [1]_. No test is performed to test whether `(u, v)` and\n    `(r, s)` are actually solutions to the equation. User should take care of\n    this.\n\n    Usage\n    =====\n\n    ``equivalent(u, v, r, s, D, N)``: `(u, v)` and `(r, s)` are two solutions\n    of the equation `x^2 - Dy^2 = N` and all parameters involved are integers.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import equivalent\n    >>> equivalent(18, 5, -18, -5, 13, -1)\n    True\n    >>> equivalent(3, 1, -18, 393, 109, -4)\n    False\n\n    References\n    ==========\n\n    .. [1] Solving the generalized Pell equation x**2 - D*y**2 = N, John P.\n        Robertson, July 31, 2004, Page 12. https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf\n\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "parametrize_ternary_quadratic",
    "full_id": "sympy.solvers.diophantine.diophantine.parametrize_ternary_quadratic",
    "type": "function",
    "description": "\n    Returns the parametrized general solution for the ternary quadratic\n    equation ``eq`` which has the form\n    `ax^2 + by^2 + cz^2 + fxy + gyz + hxz = 0`.\n\n    Examples\n    ========\n\n    >>> from sympy import Tuple, ordered\n    >>> from sympy.abc import x, y, z\n    >>> from sympy.solvers.diophantine.diophantine import parametrize_ternary_quadratic\n\n    The parametrized solution may be returned with three parameters:\n\n    >>> parametrize_ternary_quadratic(2*x**2 + y**2 - 2*z**2)\n    (p**2 - 2*q**2, -2*p**2 + 4*p*q - 4*p*r - 4*q**2, p**2 - 4*p*q + 2*q**2 - 4*q*r)\n\n    There might also be only two parameters:\n\n    >>> parametrize_ternary_quadratic(4*x**2 + 2*y**2 - 3*z**2)\n    (2*p**2 - 3*q**2, -4*p**2 + 12*p*q - 6*q**2, 4*p**2 - 8*p*q + 6*q**2)\n\n    Notes\n    =====\n\n    Consider ``p`` and ``q`` in the previous 2-parameter\n    solution and observe that more than one solution can be represented\n    by a given pair of parameters. If `p` and ``q`` are not coprime, this is\n    trivially true since the common factor will also be a common factor of the\n    solution values. But it may also be true even when ``p`` and\n    ``q`` are coprime:\n\n    >>> sol = Tuple(*_)\n    >>> p, q = ordered(sol.free_symbols)\n    >>> sol.subs([(p, 3), (q, 2)])\n    (6, 12, 12)\n    >>> sol.subs([(q, 1), (p, 1)])\n    (-1, 2, 2)\n    >>> sol.subs([(q, 0), (p, 1)])\n    (2, -4, 4)\n    >>> sol.subs([(q, 1), (p, 0)])\n    (-3, -6, 6)\n\n    Except for sign and a common factor, these are equivalent to\n    the solution of (1, 2, 2).\n\n    References\n    ==========\n\n    .. [1] The algorithmic resolution of Diophantine equations, Nigel P. Smart,\n           London Mathematical Society Student Texts 41, Cambridge University\n           Press, Cambridge, 1998.\n\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "diop_ternary_quadratic_normal",
    "full_id": "sympy.solvers.diophantine.diophantine.diop_ternary_quadratic_normal",
    "type": "function",
    "description": "\n    Solves the quadratic ternary diophantine equation,\n    `ax^2 + by^2 + cz^2 = 0`.\n\n    Explanation\n    ===========\n\n    Here the coefficients `a`, `b`, and `c` should be non zero. Otherwise the\n    equation will be a quadratic binary or univariate equation. If solvable,\n    returns a tuple `(x, y, z)` that satisfies the given equation. If the\n    equation does not have integer solutions, `(None, None, None)` is returned.\n\n    Usage\n    =====\n\n    ``diop_ternary_quadratic_normal(eq)``: where ``eq`` is an equation of the form\n    `ax^2 + by^2 + cz^2 = 0`.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> from sympy.solvers.diophantine.diophantine import diop_ternary_quadratic_normal\n    >>> diop_ternary_quadratic_normal(x**2 + 3*y**2 - z**2)\n    (1, 0, 1)\n    >>> diop_ternary_quadratic_normal(4*x**2 + 5*y**2 - z**2)\n    (1, 0, 2)\n    >>> diop_ternary_quadratic_normal(34*x**2 - 3*y**2 - 301*z**2)\n    (4, 9, 1)\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "ldescent",
    "full_id": "sympy.solvers.diophantine.diophantine.ldescent",
    "type": "function",
    "description": "\n    Return a non-trivial solution to `w^2 = Ax^2 + By^2` using\n    Lagrange's method; return None if there is no such solution.\n\n    Parameters\n    ==========\n\n    A : Integer\n    B : Integer\n        non-zero integer\n\n    Returns\n    =======\n\n    (int, int, int) | None : a tuple `(w_0, x_0, y_0)` which is a solution to the above equation.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import ldescent\n    >>> ldescent(1, 1) # w^2 = x^2 + y^2\n    (1, 1, 0)\n    >>> ldescent(4, -7) # w^2 = 4x^2 - 7y^2\n    (2, -1, 0)\n\n    This means that `x = -1, y = 0` and `w = 2` is a solution to the equation\n    `w^2 = 4x^2 - 7y^2`\n\n    >>> ldescent(5, -1) # w^2 = 5x^2 - y^2\n    (2, 1, -1)\n\n    References\n    ==========\n\n    .. [1] The algorithmic resolution of Diophantine equations, Nigel P. Smart,\n           London Mathematical Society Student Texts 41, Cambridge University\n           Press, Cambridge, 1998.\n    .. [2] Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics.\n           Mathematics of Computation, 72(243), 1417-1441.\n           https://doi.org/10.1090/S0025-5718-02-01480-1\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "gaussian_reduce",
    "full_id": "sympy.solvers.diophantine.diophantine.gaussian_reduce",
    "type": "function",
    "description": "\n    Returns a reduced solution `(x, z)` to the congruence\n    `X^2 - aZ^2 \\equiv 0 \\pmod{b}` so that `x^2 + |a|z^2` is as small as possible.\n    Here ``w`` is a solution of the congruence `x^2 \\equiv a \\pmod{b}`.\n\n    This function is intended to be used only for ``descent()``.\n\n    Explanation\n    ===========\n\n    The Gaussian reduction can find the shortest vector for any norm.\n    So we define the special norm for the vectors `u = (u_1, u_2)` and `v = (v_1, v_2)` as follows.\n\n    .. math ::\n        u \\cdot v := (wu_1 + bu_2)(wv_1 + bv_2) + |a|u_1v_1\n\n    Note that, given the mapping `f: (u_1, u_2) \\to (wu_1 + bu_2, u_1)`,\n    `f((u_1,u_2))` is the solution to `X^2 - aZ^2 \\equiv 0 \\pmod{b}`.\n    In other words, finding the shortest vector in this norm will yield a solution with smaller `X^2 + |a|Z^2`.\n    The algorithm starts from basis vectors `(0, 1)` and `(1, 0)`\n    (corresponding to solutions `(b, 0)` and `(w, 1)`, respectively) and finds the shortest vector.\n    The shortest vector does not necessarily correspond to the smallest solution,\n    but since ``descent()`` only wants the smallest possible solution, it is sufficient.\n\n    Parameters\n    ==========\n\n    w : int\n        ``w`` s.t. `w^2 \\equiv a \\pmod{b}`\n    a : int\n        square-free nonzero integer\n    b : int\n        square-free nonzero integer\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import gaussian_reduce\n    >>> from sympy.ntheory.residue_ntheory import sqrt_mod\n    >>> a, b = 19, 101\n    >>> gaussian_reduce(sqrt_mod(a, b), a, b) # 1**2 - 19*(-4)**2 = -303\n    (1, -4)\n    >>> a, b = 11, 14\n    >>> x, z = gaussian_reduce(sqrt_mod(a, b), a, b)\n    >>> (x**2 - a*z**2) % b == 0\n    True\n\n    It does not always return the smallest solution.\n\n    >>> a, b = 6, 95\n    >>> min_x, min_z = 1, 4\n    >>> x, z = gaussian_reduce(sqrt_mod(a, b), a, b)\n    >>> (x**2 - a*z**2) % b == 0 and (min_x**2 - a*min_z**2) % b == 0\n    True\n    >>> min_x**2 + abs(a)*min_z**2 < x**2 + abs(a)*z**2\n    True\n\n    References\n    ==========\n\n    .. [1] Gaussian lattice Reduction [online]. Available:\n           https://web.archive.org/web/20201021115213/http://home.ie.cuhk.edu.hk/~wkshum/wordpress/?p=404\n    .. [2] Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics.\n           Mathematics of Computation, 72(243), 1417-1441.\n           https://doi.org/10.1090/S0025-5718-02-01480-1\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "holzer",
    "full_id": "sympy.solvers.diophantine.diophantine.holzer",
    "type": "function",
    "description": "\n    Simplify the solution `(x, y, z)` of the equation\n    `ax^2 + by^2 = cz^2` with `a, b, c > 0` and `z^2 \\geq \\mid ab \\mid` to\n    a new reduced solution `(x', y', z')` such that `z'^2 \\leq \\mid ab \\mid`.\n\n    The algorithm is an interpretation of Mordell's reduction as described\n    on page 8 of Cremona and Rusin's paper [1]_ and the work of Mordell in\n    reference [2]_.\n\n    References\n    ==========\n\n    .. [1] Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics.\n           Mathematics of Computation, 72(243), 1417-1441.\n           https://doi.org/10.1090/S0025-5718-02-01480-1\n    .. [2] Diophantine Equations, L. J. Mordell, page 48.\n\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "prime_as_sum_of_two_squares",
    "full_id": "sympy.solvers.diophantine.diophantine.prime_as_sum_of_two_squares",
    "type": "function",
    "description": "\n    Represent a prime `p` as a unique sum of two squares; this can\n    only be done if the prime is congruent to 1 mod 4.\n\n    Parameters\n    ==========\n\n    p : Integer\n        A prime that is congruent to 1 mod 4\n\n    Returns\n    =======\n\n    (int, int) | None : Pair of positive integers ``(x, y)`` satisfying ``x**2 + y**2 = p``.\n                        None if ``p`` is not congruent to 1 mod 4.\n\n    Raises\n    ======\n\n    ValueError\n        If ``p`` is not prime number\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import prime_as_sum_of_two_squares\n    >>> prime_as_sum_of_two_squares(7)  # can't be done\n    >>> prime_as_sum_of_two_squares(5)\n    (1, 2)\n\n    Reference\n    =========\n\n    .. [1] Representing a number as a sum of four squares, [online],\n           Available: https://schorn.ch/lagrange.html\n\n    See Also\n    ========\n\n    sum_of_squares\n\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "sqf_normal",
    "full_id": "sympy.solvers.diophantine.diophantine.sqf_normal",
    "type": "function",
    "description": "\n    Return `a', b', c'`, the coefficients of the square-free normal\n    form of `ax^2 + by^2 + cz^2 = 0`, where `a', b', c'` are pairwise\n    prime.  If `steps` is True then also return three tuples:\n    `sq`, `sqf`, and `(a', b', c')` where `sq` contains the square\n    factors of `a`, `b` and `c` after removing the `gcd(a, b, c)`;\n    `sqf` contains the values of `a`, `b` and `c` after removing\n    both the `gcd(a, b, c)` and the square factors.\n\n    The solutions for `ax^2 + by^2 + cz^2 = 0` can be\n    recovered from the solutions of `a'x^2 + b'y^2 + c'z^2 = 0`.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine.diophantine import sqf_normal\n    >>> sqf_normal(2 * 3**2 * 5, 2 * 5 * 11, 2 * 7**2 * 11)\n    (11, 1, 5)\n    >>> sqf_normal(2 * 3**2 * 5, 2 * 5 * 11, 2 * 7**2 * 11, True)\n    ((3, 1, 7), (5, 55, 11), (11, 1, 5))\n\n    References\n    ==========\n\n    .. [1] Legendre's Theorem, Legrange's Descent,\n           https://public.csusm.edu/aitken_html/notes/legendre.pdf\n\n\n    See Also\n    ========\n\n    reconstruct()\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "reconstruct",
    "full_id": "sympy.solvers.diophantine.diophantine.reconstruct",
    "type": "function",
    "description": "\n    Reconstruct the `z` value of an equivalent solution of `ax^2 + by^2 + cz^2`\n    from the `z` value of a solution of the square-free normal form of the\n    equation, `a'*x^2 + b'*y^2 + c'*z^2`, where `a'`, `b'` and `c'` are square\n    free and `gcd(a', b', c') == 1`.\n    ",
    "section": "Internal Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "matches",
    "full_id": "sympy.solvers.diophantine.diophantine.DiophantineEquationType.matches",
    "type": "method",
    "description": "\n        Determine whether the given equation can be matched to the particular equation type.\n        ",
    "section": "Internal Classes",
    "url": "https://docs.sympy.org/latest/modules/solvers/diophantine.html"
  },
  {
    "name": "solve_rational_inequalities",
    "full_id": "sympy.solvers.inequalities.solve_rational_inequalities",
    "type": "function",
    "description": "Solve a system of rational inequalities with rational coefficients.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy import solve_rational_inequalities, Poly\n\n    >>> solve_rational_inequalities([[\n    ... ((Poly(-x + 1), Poly(1, x)), '>='),\n    ... ((Poly(-x + 1), Poly(1, x)), '<=')]])\n    {1}\n\n    >>> solve_rational_inequalities([[\n    ... ((Poly(x), Poly(1, x)), '!='),\n    ... ((Poly(-x + 1), Poly(1, x)), '>=')]])\n    Union(Interval.open(-oo, 0), Interval.Lopen(0, 1))\n\n    See Also\n    ========\n    solve_poly_inequality\n    ",
    "section": "Inequality Solvers",
    "url": "https://docs.sympy.org/latest/modules/solvers/inequalities.html"
  },
  {
    "name": "solve_poly_inequality",
    "full_id": "sympy.solvers.inequalities.solve_poly_inequality",
    "type": "function",
    "description": "Solve a polynomial inequality with rational coefficients.\n\n    Examples\n    ========\n\n    >>> from sympy import solve_poly_inequality, Poly\n    >>> from sympy.abc import x\n\n    >>> solve_poly_inequality(Poly(x, x, domain='ZZ'), '==')\n    [{0}]\n\n    >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '!=')\n    [Interval.open(-oo, -1), Interval.open(-1, 1), Interval.open(1, oo)]\n\n    >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '==')\n    [{-1}, {1}]\n\n    See Also\n    ========\n    solve_poly_inequalities\n    ",
    "section": "Inequality Solvers",
    "url": "https://docs.sympy.org/latest/modules/solvers/inequalities.html"
  },
  {
    "name": "solve_poly_inequalities",
    "full_id": "sympy.solvers.inequalities.solve_poly_inequalities",
    "type": "function",
    "description": "Solve polynomial inequalities with rational coefficients.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly\n    >>> from sympy.solvers.inequalities import solve_poly_inequalities\n    >>> from sympy.abc import x\n    >>> solve_poly_inequalities(((\n    ... Poly(x**2 - 3), \">\"), (\n    ... Poly(-x**2 + 1), \">\")))\n    Union(Interval.open(-oo, -sqrt(3)), Interval.open(-1, 1), Interval.open(sqrt(3), oo))\n    ",
    "section": "Inequality Solvers",
    "url": "https://docs.sympy.org/latest/modules/solvers/inequalities.html"
  },
  {
    "name": "reduce_rational_inequalities",
    "full_id": "sympy.solvers.inequalities.reduce_rational_inequalities",
    "type": "function",
    "description": "Reduce a system of rational inequalities with rational coefficients.\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol\n    >>> from sympy.solvers.inequalities import reduce_rational_inequalities\n\n    >>> x = Symbol('x', real=True)\n\n    >>> reduce_rational_inequalities([[x**2 <= 0]], x)\n    Eq(x, 0)\n\n    >>> reduce_rational_inequalities([[x + 2 > 0]], x)\n    -2 < x\n    >>> reduce_rational_inequalities([[(x + 2, \">\")]], x)\n    -2 < x\n    >>> reduce_rational_inequalities([[x + 2]], x)\n    Eq(x, -2)\n\n    This function find the non-infinite solution set so if the unknown symbol\n    is declared as extended real rather than real then the result may include\n    finiteness conditions:\n\n    >>> y = Symbol('y', extended_real=True)\n    >>> reduce_rational_inequalities([[y + 2 > 0]], y)\n    (-2 < y) & (y < oo)\n    ",
    "section": "Inequality Solvers",
    "url": "https://docs.sympy.org/latest/modules/solvers/inequalities.html"
  },
  {
    "name": "reduce_abs_inequality",
    "full_id": "sympy.solvers.inequalities.reduce_abs_inequality",
    "type": "function",
    "description": "Reduce an inequality with nested absolute values.\n\n    Examples\n    ========\n\n    >>> from sympy import reduce_abs_inequality, Abs, Symbol\n    >>> x = Symbol('x', real=True)\n\n    >>> reduce_abs_inequality(Abs(x - 5) - 3, '<', x)\n    (2 < x) & (x < 8)\n\n    >>> reduce_abs_inequality(Abs(x + 2)*3 - 13, '<', x)\n    (-19/3 < x) & (x < 7/3)\n\n    See Also\n    ========\n\n    reduce_abs_inequalities\n    ",
    "section": "Inequality Solvers",
    "url": "https://docs.sympy.org/latest/modules/solvers/inequalities.html"
  },
  {
    "name": "reduce_abs_inequalities",
    "full_id": "sympy.solvers.inequalities.reduce_abs_inequalities",
    "type": "function",
    "description": "Reduce a system of inequalities with nested absolute values.\n\n    Examples\n    ========\n\n    >>> from sympy import reduce_abs_inequalities, Abs, Symbol\n    >>> x = Symbol('x', extended_real=True)\n\n    >>> reduce_abs_inequalities([(Abs(3*x - 5) - 7, '<'),\n    ... (Abs(x + 25) - 13, '>')], x)\n    (-2/3 < x) & (x < 4) & (((-oo < x) & (x < -38)) | ((-12 < x) & (x < oo)))\n\n    >>> reduce_abs_inequalities([(Abs(x - 4) + Abs(3*x - 5) - 7, '<')], x)\n    (1/2 < x) & (x < 4)\n\n    See Also\n    ========\n\n    reduce_abs_inequality\n    ",
    "section": "Inequality Solvers",
    "url": "https://docs.sympy.org/latest/modules/solvers/inequalities.html"
  },
  {
    "name": "reduce_inequalities",
    "full_id": "sympy.solvers.inequalities.reduce_inequalities",
    "type": "function",
    "description": "Reduce a system of inequalities with rational coefficients.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import reduce_inequalities\n\n    >>> reduce_inequalities(0 <= x + 3, [])\n    (-3 <= x) & (x < oo)\n\n    >>> reduce_inequalities(0 <= x + y*2 - 1, [x])\n    (x < oo) & (x >= 1 - 2*y)\n    ",
    "section": "Inequality Solvers",
    "url": "https://docs.sympy.org/latest/modules/solvers/inequalities.html"
  },
  {
    "name": "solve_univariate_inequality",
    "full_id": "sympy.solvers.inequalities.solve_univariate_inequality",
    "type": "function",
    "description": "Solves a real univariate inequality.\n\n    Parameters\n    ==========\n\n    expr : Relational\n        The target inequality\n    gen : Symbol\n        The variable for which the inequality is solved\n    relational : bool\n        A Relational type output is expected or not\n    domain : Set\n        The domain over which the equation is solved\n    continuous: bool\n        True if expr is known to be continuous over the given domain\n        (and so continuous_domain() does not need to be called on it)\n\n    Raises\n    ======\n\n    NotImplementedError\n        The solution of the inequality cannot be determined due to limitation\n        in :func:`sympy.solvers.solveset.solvify`.\n\n    Notes\n    =====\n\n    Currently, we cannot solve all the inequalities due to limitations in\n    :func:`sympy.solvers.solveset.solvify`. Also, the solution returned for trigonometric inequalities\n    are restricted in its periodic interval.\n\n    See Also\n    ========\n\n    sympy.solvers.solveset.solvify: solver returning solveset solutions with solve's output API\n\n    Examples\n    ========\n\n    >>> from sympy import solve_univariate_inequality, Symbol, sin, Interval, S\n    >>> x = Symbol('x')\n\n    >>> solve_univariate_inequality(x**2 >= 4, x)\n    ((2 <= x) & (x < oo)) | ((-oo < x) & (x <= -2))\n\n    >>> solve_univariate_inequality(x**2 >= 4, x, relational=False)\n    Union(Interval(-oo, -2), Interval(2, oo))\n\n    >>> domain = Interval(0, S.Infinity)\n    >>> solve_univariate_inequality(x**2 >= 4, x, False, domain)\n    Interval(2, oo)\n\n    >>> solve_univariate_inequality(sin(x) > 0, x, relational=False)\n    Interval.open(0, pi)\n\n    ",
    "section": "Inequality Solvers",
    "url": "https://docs.sympy.org/latest/modules/solvers/inequalities.html"
  },
  {
    "name": "dsolve",
    "full_id": "sympy.solvers.ode.dsolve",
    "type": "function",
    "description": "\n    Solves any (supported) kind of ordinary differential equation and\n    system of ordinary differential equations.\n\n    For single ordinary differential equation\n    =========================================\n\n    It is classified under this when number of equation in ``eq`` is one.\n    **Usage**\n\n        ``dsolve(eq, f(x), hint)`` -> Solve ordinary differential equation\n        ``eq`` for function ``f(x)``, using method ``hint``.\n\n    **Details**\n\n        ``eq`` can be any supported ordinary differential equation (see the\n            :py:mod:`~sympy.solvers.ode` docstring for supported methods).\n            This can either be an :py:class:`~sympy.core.relational.Equality`,\n            or an expression, which is assumed to be equal to ``0``.\n\n        ``f(x)`` is a function of one variable whose derivatives in that\n            variable make up the ordinary differential equation ``eq``.  In\n            many cases it is not necessary to provide this; it will be\n            autodetected (and an error raised if it could not be detected).\n\n        ``hint`` is the solving method that you want dsolve to use.  Use\n            ``classify_ode(eq, f(x))`` to get all of the possible hints for an\n            ODE.  The default hint, ``default``, will use whatever hint is\n            returned first by :py:meth:`~sympy.solvers.ode.classify_ode`.  See\n            Hints below for more options that you can use for hint.\n\n        ``simplify`` enables simplification by\n            :py:meth:`~sympy.solvers.ode.ode.odesimp`.  See its docstring for more\n            information.  Turn this off, for example, to disable solving of\n            solutions for ``func`` or simplification of arbitrary constants.\n            It will still integrate with this hint. Note that the solution may\n            contain more arbitrary constants than the order of the ODE with\n            this option enabled.\n\n        ``xi`` and ``eta`` are the infinitesimal functions of an ordinary\n            differential equation. They are the infinitesimals of the Lie group\n            of point transformations for which the differential equation is\n            invariant. The user can specify values for the infinitesimals. If\n            nothing is specified, ``xi`` and ``eta`` are calculated using\n            :py:meth:`~sympy.solvers.ode.infinitesimals` with the help of various\n            heuristics.\n\n        ``ics`` is the set of initial/boundary conditions for the differential equation.\n          It should be given in the form of ``{f(x0): x1, f(x).diff(x).subs(x, x2):\n          x3}`` and so on.  For power series solutions, if no initial\n          conditions are specified ``f(0)`` is assumed to be ``C0`` and the power\n          series solution is calculated about 0.\n\n        ``x0`` is the point about which the power series solution of a differential\n          equation is to be evaluated.\n\n        ``n`` gives the exponent of the dependent variable up to which the power series\n          solution of a differential equation is to be evaluated.\n\n    **Hints**\n\n        Aside from the various solving methods, there are also some meta-hints\n        that you can pass to :py:meth:`~sympy.solvers.ode.dsolve`:\n\n        ``default``:\n                This uses whatever hint is returned first by\n                :py:meth:`~sympy.solvers.ode.classify_ode`. This is the\n                default argument to :py:meth:`~sympy.solvers.ode.dsolve`.\n\n        ``all``:\n                To make :py:meth:`~sympy.solvers.ode.dsolve` apply all\n                relevant classification hints, use ``dsolve(ODE, func,\n                hint=\"all\")``.  This will return a dictionary of\n                ``hint:solution`` terms.  If a hint causes dsolve to raise the\n                ``NotImplementedError``, value of that hint's key will be the\n                exception object raised.  The dictionary will also include\n                some special keys:\n\n                - ``order``: The order of the ODE.  See also\n                  :py:meth:`~sympy.solvers.deutils.ode_order` in\n                  ``deutils.py``.\n                - ``best``: The simplest hint; what would be returned by\n                  ``best`` below.\n                - ``best_hint``: The hint that would produce the solution\n                  given by ``best``.  If more than one hint produces the best\n                  solution, the first one in the tuple returned by\n                  :py:meth:`~sympy.solvers.ode.classify_ode` is chosen.\n                - ``default``: The solution that would be returned by default.\n                  This is the one produced by the hint that appears first in\n                  the tuple returned by\n                  :py:meth:`~sympy.solvers.ode.classify_ode`.\n\n        ``all_Integral``:\n                This is the same as ``all``, except if a hint also has a\n                corresponding ``_Integral`` hint, it only returns the\n                ``_Integral`` hint.  This is useful if ``all`` causes\n                :py:meth:`~sympy.solvers.ode.dsolve` to hang because of a\n                difficult or impossible integral.  This meta-hint will also be\n                much faster than ``all``, because\n                :py:meth:`~sympy.core.expr.Expr.integrate` is an expensive\n                routine.\n\n        ``best``:\n                To have :py:meth:`~sympy.solvers.ode.dsolve` try all methods\n                and return the simplest one.  This takes into account whether\n                the solution is solvable in the function, whether it contains\n                any Integral classes (i.e.  unevaluatable integrals), and\n                which one is the shortest in size.\n\n        See also the :py:meth:`~sympy.solvers.ode.classify_ode` docstring for\n        more info on hints, and the :py:mod:`~sympy.solvers.ode` docstring for\n        a list of all supported hints.\n\n    **Tips**\n\n        - You can declare the derivative of an unknown function this way:\n\n            >>> from sympy import Function, Derivative\n            >>> from sympy.abc import x # x is the independent variable\n            >>> f = Function(\"f\")(x) # f is a function of x\n            >>> # f_ will be the derivative of f with respect to x\n            >>> f_ = Derivative(f, x)\n\n        - See ``test_ode.py`` for many tests, which serves also as a set of\n          examples for how to use :py:meth:`~sympy.solvers.ode.dsolve`.\n        - :py:meth:`~sympy.solvers.ode.dsolve` always returns an\n          :py:class:`~sympy.core.relational.Equality` class (except for the\n          case when the hint is ``all`` or ``all_Integral``).  If possible, it\n          solves the solution explicitly for the function being solved for.\n          Otherwise, it returns an implicit solution.\n        - Arbitrary constants are symbols named ``C1``, ``C2``, and so on.\n        - Because all solutions should be mathematically equivalent, some\n          hints may return the exact same result for an ODE. Often, though,\n          two different hints will return the same solution formatted\n          differently.  The two should be equivalent. Also note that sometimes\n          the values of the arbitrary constants in two different solutions may\n          not be the same, because one constant may have \"absorbed\" other\n          constants into it.\n        - Do ``help(ode.ode_<hintname>)`` to get help more information on a\n          specific hint, where ``<hintname>`` is the name of a hint without\n          ``_Integral``.\n\n    For system of ordinary differential equations\n    =============================================\n\n    **Usage**\n        ``dsolve(eq, func)`` -> Solve a system of ordinary differential\n        equations ``eq`` for ``func`` being list of functions including\n        `x(t)`, `y(t)`, `z(t)` where number of functions in the list depends\n        upon the number of equations provided in ``eq``.\n\n    **Details**\n\n        ``eq`` can be any supported system of ordinary differential equations\n        This can either be an :py:class:`~sympy.core.relational.Equality`,\n        or an expression, which is assumed to be equal to ``0``.\n\n        ``func`` holds ``x(t)`` and ``y(t)`` being functions of one variable which\n        together with some of their derivatives make up the system of ordinary\n        differential equation ``eq``. It is not necessary to provide this; it\n        will be autodetected (and an error raised if it could not be detected).\n\n    **Hints**\n\n        The hints are formed by parameters returned by classify_sysode, combining\n        them give hints name used later for forming method name.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, dsolve, Eq, Derivative, sin, cos, symbols\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n    >>> dsolve(Derivative(f(x), x, x) + 9*f(x), f(x))\n    Eq(f(x), C1*sin(3*x) + C2*cos(3*x))\n\n    >>> eq = sin(x)*cos(f(x)) + cos(x)*sin(f(x))*f(x).diff(x)\n    >>> dsolve(eq, hint='1st_exact')\n    [Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]\n    >>> dsolve(eq, hint='almost_linear')\n    [Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]\n    >>> t = symbols('t')\n    >>> x, y = symbols('x, y', cls=Function)\n    >>> eq = (Eq(Derivative(x(t),t), 12*t*x(t) + 8*y(t)), Eq(Derivative(y(t),t), 21*x(t) + 7*t*y(t)))\n    >>> dsolve(eq)\n    [Eq(x(t), C1*x0(t) + C2*x0(t)*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)**2, t)),\n    Eq(y(t), C1*y0(t) + C2*(y0(t)*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)**2, t) +\n    exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)))]\n    >>> eq = (Eq(Derivative(x(t),t),x(t)*y(t)*sin(t)), Eq(Derivative(y(t),t),y(t)**2*sin(t)))\n    >>> dsolve(eq)\n    {Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t))), Eq(y(t), -1/(C1 - cos(t)))}\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "dsolve_system",
    "full_id": "sympy.solvers.ode.systems.dsolve_system",
    "type": "function",
    "description": "\n    Solves any(supported) system of Ordinary Differential Equations\n\n    Explanation\n    ===========\n\n    This function takes a system of ODEs as an input, determines if the\n    it is solvable by this function, and returns the solution if found any.\n\n    This function can handle:\n    1. Linear, First Order, Constant coefficient homogeneous system of ODEs\n    2. Linear, First Order, Constant coefficient non-homogeneous system of ODEs\n    3. Linear, First Order, non-constant coefficient homogeneous system of ODEs\n    4. Linear, First Order, non-constant coefficient non-homogeneous system of ODEs\n    5. Any implicit system which can be divided into system of ODEs which is of the above 4 forms\n    6. Any higher order linear system of ODEs that can be reduced to one of the 5 forms of systems described above.\n\n    The types of systems described above are not limited by the number of equations, i.e. this\n    function can solve the above types irrespective of the number of equations in the system passed.\n    But, the bigger the system, the more time it will take to solve the system.\n\n    This function returns a list of solutions. Each solution is a list of equations where LHS is\n    the dependent variable and RHS is an expression in terms of the independent variable.\n\n    Among the non constant coefficient types, not all the systems are solvable by this function. Only\n    those which have either a coefficient matrix with a commutative antiderivative or those systems which\n    may be divided further so that the divided systems may have coefficient matrix with commutative antiderivative.\n\n    Parameters\n    ==========\n\n    eqs : List\n        system of ODEs to be solved\n    funcs : List or None\n        List of dependent variables that make up the system of ODEs\n    t : Symbol or None\n        Independent variable in the system of ODEs\n    ics : Dict or None\n        Set of initial boundary/conditions for the system of ODEs\n    doit : Boolean\n        Evaluate the solutions if True. Default value is True. Can be\n        set to false if the integral evaluation takes too much time and/or\n        is not required.\n    simplify: Boolean\n        Simplify the solutions for the systems. Default value is True.\n        Can be set to false if simplification takes too much time and/or\n        is not required.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, Eq, Function\n    >>> from sympy.solvers.ode.systems import dsolve_system\n    >>> f, g = symbols(\"f g\", cls=Function)\n    >>> x = symbols(\"x\")\n\n    >>> eqs = [Eq(f(x).diff(x), g(x)), Eq(g(x).diff(x), f(x))]\n    >>> dsolve_system(eqs)\n    [[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]]\n\n    You can also pass the initial conditions for the system of ODEs:\n\n    >>> dsolve_system(eqs, ics={f(0): 1, g(0): 0})\n    [[Eq(f(x), exp(x)/2 + exp(-x)/2), Eq(g(x), exp(x)/2 - exp(-x)/2)]]\n\n    Optionally, you can pass the dependent variables and the independent\n    variable for which the system is to be solved:\n\n    >>> funcs = [f(x), g(x)]\n    >>> dsolve_system(eqs, funcs=funcs, t=x)\n    [[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]]\n\n    Lets look at an implicit system of ODEs:\n\n    >>> eqs = [Eq(f(x).diff(x)**2, g(x)**2), Eq(g(x).diff(x), g(x))]\n    >>> dsolve_system(eqs)\n    [[Eq(f(x), C1 - C2*exp(x)), Eq(g(x), C2*exp(x))], [Eq(f(x), C1 + C2*exp(x)), Eq(g(x), C2*exp(x))]]\n\n    Returns\n    =======\n\n    List of List of Equations\n\n    Raises\n    ======\n\n    NotImplementedError\n        When the system of ODEs is not solvable by this function.\n    ValueError\n        When the parameters passed are not in the required form.\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "classify_ode",
    "full_id": "sympy.solvers.ode.classify_ode",
    "type": "function",
    "description": "\n    Returns a tuple of possible :py:meth:`~sympy.solvers.ode.dsolve`\n    classifications for an ODE.\n\n    The tuple is ordered so that first item is the classification that\n    :py:meth:`~sympy.solvers.ode.dsolve` uses to solve the ODE by default.  In\n    general, classifications at the near the beginning of the list will\n    produce better solutions faster than those near the end, thought there are\n    always exceptions.  To make :py:meth:`~sympy.solvers.ode.dsolve` use a\n    different classification, use ``dsolve(ODE, func,\n    hint=<classification>)``.  See also the\n    :py:meth:`~sympy.solvers.ode.dsolve` docstring for different meta-hints\n    you can use.\n\n    If ``dict`` is true, :py:meth:`~sympy.solvers.ode.classify_ode` will\n    return a dictionary of ``hint:match`` expression terms. This is intended\n    for internal use by :py:meth:`~sympy.solvers.ode.dsolve`.  Note that\n    because dictionaries are ordered arbitrarily, this will most likely not be\n    in the same order as the tuple.\n\n    You can get help on different hints by executing\n    ``help(ode.ode_hintname)``, where ``hintname`` is the name of the hint\n    without ``_Integral``.\n\n    See :py:data:`~sympy.solvers.ode.allhints` or the\n    :py:mod:`~sympy.solvers.ode` docstring for a list of all supported hints\n    that can be returned from :py:meth:`~sympy.solvers.ode.classify_ode`.\n\n    Notes\n    =====\n\n    These are remarks on hint names.\n\n    ``_Integral``\n\n        If a classification has ``_Integral`` at the end, it will return the\n        expression with an unevaluated :py:class:`~.Integral`\n        class in it.  Note that a hint may do this anyway if\n        :py:meth:`~sympy.core.expr.Expr.integrate` cannot do the integral,\n        though just using an ``_Integral`` will do so much faster.  Indeed, an\n        ``_Integral`` hint will always be faster than its corresponding hint\n        without ``_Integral`` because\n        :py:meth:`~sympy.core.expr.Expr.integrate` is an expensive routine.\n        If :py:meth:`~sympy.solvers.ode.dsolve` hangs, it is probably because\n        :py:meth:`~sympy.core.expr.Expr.integrate` is hanging on a tough or\n        impossible integral.  Try using an ``_Integral`` hint or\n        ``all_Integral`` to get it return something.\n\n        Note that some hints do not have ``_Integral`` counterparts. This is\n        because :py:func:`~sympy.integrals.integrals.integrate` is not used in\n        solving the ODE for those method. For example, `n`\\th order linear\n        homogeneous ODEs with constant coefficients do not require integration\n        to solve, so there is no\n        ``nth_linear_homogeneous_constant_coeff_Integrate`` hint. You can\n        easily evaluate any unevaluated\n        :py:class:`~sympy.integrals.integrals.Integral`\\s in an expression by\n        doing ``expr.doit()``.\n\n    Ordinals\n\n        Some hints contain an ordinal such as ``1st_linear``.  This is to help\n        differentiate them from other hints, as well as from other methods\n        that may not be implemented yet. If a hint has ``nth`` in it, such as\n        the ``nth_linear`` hints, this means that the method used to applies\n        to ODEs of any order.\n\n    ``indep`` and ``dep``\n\n        Some hints contain the words ``indep`` or ``dep``.  These reference\n        the independent variable and the dependent function, respectively. For\n        example, if an ODE is in terms of `f(x)`, then ``indep`` will refer to\n        `x` and ``dep`` will refer to `f`.\n\n    ``subs``\n\n        If a hints has the word ``subs`` in it, it means that the ODE is solved\n        by substituting the expression given after the word ``subs`` for a\n        single dummy variable.  This is usually in terms of ``indep`` and\n        ``dep`` as above.  The substituted expression will be written only in\n        characters allowed for names of Python objects, meaning operators will\n        be spelled out.  For example, ``indep``/``dep`` will be written as\n        ``indep_div_dep``.\n\n    ``coeff``\n\n        The word ``coeff`` in a hint refers to the coefficients of something\n        in the ODE, usually of the derivative terms.  See the docstring for\n        the individual methods for more info (``help(ode)``).  This is\n        contrast to ``coefficients``, as in ``undetermined_coefficients``,\n        which refers to the common name of a method.\n\n    ``_best``\n\n        Methods that have more than one fundamental way to solve will have a\n        hint for each sub-method and a ``_best`` meta-classification. This\n        will evaluate all hints and return the best, using the same\n        considerations as the normal ``best`` meta-hint.\n\n\n    Examples\n    ========\n\n    >>> from sympy import Function, classify_ode, Eq\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n    >>> classify_ode(Eq(f(x).diff(x), 0), f(x))\n    ('nth_algebraic',\n    'separable',\n    '1st_exact',\n    '1st_linear',\n    'Bernoulli',\n    '1st_homogeneous_coeff_best',\n    '1st_homogeneous_coeff_subs_indep_div_dep',\n    '1st_homogeneous_coeff_subs_dep_div_indep',\n    '1st_power_series', 'lie_group', 'nth_linear_constant_coeff_homogeneous',\n    'nth_linear_euler_eq_homogeneous',\n    'nth_algebraic_Integral', 'separable_Integral', '1st_exact_Integral',\n    '1st_linear_Integral', 'Bernoulli_Integral',\n    '1st_homogeneous_coeff_subs_indep_div_dep_Integral',\n    '1st_homogeneous_coeff_subs_dep_div_indep_Integral')\n    >>> classify_ode(f(x).diff(x, 2) + 3*f(x).diff(x) + 2*f(x) - 4)\n    ('factorable', 'nth_linear_constant_coeff_undetermined_coefficients',\n    'nth_linear_constant_coeff_variation_of_parameters',\n    'nth_linear_constant_coeff_variation_of_parameters_Integral')\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "checkodesol",
    "full_id": "sympy.solvers.ode.checkodesol",
    "type": "function",
    "description": "\n    Substitutes ``sol`` into ``ode`` and checks that the result is ``0``.\n\n    This works when ``func`` is one function, like `f(x)` or a list of\n    functions like `[f(x), g(x)]` when `ode` is a system of ODEs.  ``sol`` can\n    be a single solution or a list of solutions.  Each solution may be an\n    :py:class:`~sympy.core.relational.Equality` that the solution satisfies,\n    e.g. ``Eq(f(x), C1), Eq(f(x) + C1, 0)``; or simply an\n    :py:class:`~sympy.core.expr.Expr`, e.g. ``f(x) - C1``. In most cases it\n    will not be necessary to explicitly identify the function, but if the\n    function cannot be inferred from the original equation it can be supplied\n    through the ``func`` argument.\n\n    If a sequence of solutions is passed, the same sort of container will be\n    used to return the result for each solution.\n\n    It tries the following methods, in order, until it finds zero equivalence:\n\n    1. Substitute the solution for `f` in the original equation.  This only\n       works if ``ode`` is solved for `f`.  It will attempt to solve it first\n       unless ``solve_for_func == False``.\n    2. Take `n` derivatives of the solution, where `n` is the order of\n       ``ode``, and check to see if that is equal to the solution.  This only\n       works on exact ODEs.\n    3. Take the 1st, 2nd, ..., `n`\\th derivatives of the solution, each time\n       solving for the derivative of `f` of that order (this will always be\n       possible because `f` is a linear operator). Then back substitute each\n       derivative into ``ode`` in reverse order.\n\n    This function returns a tuple.  The first item in the tuple is ``True`` if\n    the substitution results in ``0``, and ``False`` otherwise. The second\n    item in the tuple is what the substitution results in.  It should always\n    be ``0`` if the first item is ``True``. Sometimes this function will\n    return ``False`` even when an expression is identically equal to ``0``.\n    This happens when :py:meth:`~sympy.simplify.simplify.simplify` does not\n    reduce the expression to ``0``.  If an expression returned by this\n    function vanishes identically, then ``sol`` really is a solution to\n    the ``ode``.\n\n    If this function seems to hang, it is probably because of a hard\n    simplification.\n\n    To use this function to test, test the first item of the tuple.\n\n    Examples\n    ========\n\n    >>> from sympy import (Eq, Function, checkodesol, symbols,\n    ...     Derivative, exp)\n    >>> x, C1, C2 = symbols('x,C1,C2')\n    >>> f, g = symbols('f g', cls=Function)\n    >>> checkodesol(f(x).diff(x), Eq(f(x), C1))\n    (True, 0)\n    >>> assert checkodesol(f(x).diff(x), C1)[0]\n    >>> assert not checkodesol(f(x).diff(x), x)[0]\n    >>> checkodesol(f(x).diff(x, 2), x**2)\n    (False, 2)\n\n    >>> eqs = [Eq(Derivative(f(x), x), f(x)), Eq(Derivative(g(x), x), g(x))]\n    >>> sol = [Eq(f(x), C1*exp(x)), Eq(g(x), C2*exp(x))]\n    >>> checkodesol(eqs, sol)\n    (True, [0, 0])\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "homogeneous_order",
    "full_id": "sympy.solvers.ode.homogeneous_order",
    "type": "function",
    "description": "\n    Returns the order `n` if `g` is homogeneous and ``None`` if it is not\n    homogeneous.\n\n    Determines if a function is homogeneous and if so of what order.  A\n    function `f(x, y, \\cdots)` is homogeneous of order `n` if `f(t x, t y,\n    \\cdots) = t^n f(x, y, \\cdots)`.\n\n    If the function is of two variables, `F(x, y)`, then `f` being homogeneous\n    of any order is equivalent to being able to rewrite `F(x, y)` as `G(x/y)`\n    or `H(y/x)`.  This fact is used to solve 1st order ordinary differential\n    equations whose coefficients are homogeneous of the same order (see the\n    docstrings of\n    :obj:`~sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep` and\n    :obj:`~sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep`).\n\n    Symbols can be functions, but every argument of the function must be a\n    symbol, and the arguments of the function that appear in the expression\n    must match those given in the list of symbols.  If a declared function\n    appears with different arguments than given in the list of symbols,\n    ``None`` is returned.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, homogeneous_order, sqrt\n    >>> from sympy.abc import x, y\n    >>> f = Function('f')\n    >>> homogeneous_order(f(x), f(x)) is None\n    True\n    >>> homogeneous_order(f(x,y), f(y, x), x, y) is None\n    True\n    >>> homogeneous_order(f(x), f(x), x)\n    1\n    >>> homogeneous_order(x**2*f(x)/sqrt(x**2+f(x)**2), x, f(x))\n    2\n    >>> homogeneous_order(x**2+f(x), x, f(x)) is None\n    True\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "infinitesimals",
    "full_id": "sympy.solvers.ode.infinitesimals",
    "type": "function",
    "description": "\n    The infinitesimal functions of an ordinary differential equation, `\\xi(x,y)`\n    and `\\eta(x,y)`, are the infinitesimals of the Lie group of point transformations\n    for which the differential equation is invariant. So, the ODE `y'=f(x,y)`\n    would admit a Lie group `x^*=X(x,y;\\varepsilon)=x+\\varepsilon\\xi(x,y)`,\n    `y^*=Y(x,y;\\varepsilon)=y+\\varepsilon\\eta(x,y)` such that `(y^*)'=f(x^*, y^*)`.\n    A change of coordinates, to `r(x,y)` and `s(x,y)`, can be performed so this Lie group\n    becomes the translation group, `r^*=r` and `s^*=s+\\varepsilon`.\n    They are tangents to the coordinate curves of the new system.\n\n    Consider the transformation `(x, y) \\to (X, Y)` such that the\n    differential equation remains invariant. `\\xi` and `\\eta` are the tangents to\n    the transformed coordinates `X` and `Y`, at `\\varepsilon=0`.\n\n    .. math:: \\left(\\frac{\\partial X(x,y;\\varepsilon)}{\\partial\\varepsilon\n                }\\right)|_{\\varepsilon=0} = \\xi,\n              \\left(\\frac{\\partial Y(x,y;\\varepsilon)}{\\partial\\varepsilon\n                }\\right)|_{\\varepsilon=0} = \\eta,\n\n    The infinitesimals can be found by solving the following PDE:\n\n        >>> from sympy import Function, Eq, pprint\n        >>> from sympy.abc import x, y\n        >>> xi, eta, h = map(Function, ['xi', 'eta', 'h'])\n        >>> h = h(x, y)  # dy/dx = h\n        >>> eta = eta(x, y)\n        >>> xi = xi(x, y)\n        >>> genform = Eq(eta.diff(x) + (eta.diff(y) - xi.diff(x))*h\n        ... - (xi.diff(y))*h**2 - xi*(h.diff(x)) - eta*(h.diff(y)), 0)\n        >>> pprint(genform)\n        /d               d           \\                     d              2       d                       d             d\n        |--(eta(x, y)) - --(xi(x, y))|*h(x, y) - eta(x, y)*--(h(x, y)) - h (x, y)*--(xi(x, y)) - xi(x, y)*--(h(x, y)) + --(eta(x, y)) = 0\n        \\dy              dx          /                     dy                     dy                      dx            dx\n\n    Solving the above mentioned PDE is not trivial, and can be solved only by\n    making intelligent assumptions for `\\xi` and `\\eta` (heuristics). Once an\n    infinitesimal is found, the attempt to find more heuristics stops. This is done to\n    optimise the speed of solving the differential equation. If a list of all the\n    infinitesimals is needed, ``hint`` should be flagged as ``all``, which gives\n    the complete list of infinitesimals. If the infinitesimals for a particular\n    heuristic needs to be found, it can be passed as a flag to ``hint``.\n\n    Examples\n    ========\n\n    >>> from sympy import Function\n    >>> from sympy.solvers.ode.lie_group import infinitesimals\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n    >>> eq = f(x).diff(x) - x**2*f(x)\n    >>> infinitesimals(eq)\n    [{eta(x, f(x)): exp(x**3/3), xi(x, f(x)): 0}]\n\n    References\n    ==========\n\n    - Solving differential equations by Symmetry Groups,\n      John Starrett, pp. 1 - pp. 14\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "checkinfsol",
    "full_id": "sympy.solvers.ode.checkinfsol",
    "type": "function",
    "description": "\n    This function is used to check if the given infinitesimals are the\n    actual infinitesimals of the given first order differential equation.\n    This method is specific to the Lie Group Solver of ODEs.\n\n    As of now, it simply checks, by substituting the infinitesimals in the\n    partial differential equation.\n\n\n    .. math:: \\frac{\\partial \\eta}{\\partial x} + \\left(\\frac{\\partial \\eta}{\\partial y}\n                - \\frac{\\partial \\xi}{\\partial x}\\right)*h\n                - \\frac{\\partial \\xi}{\\partial y}*h^{2}\n                - \\xi\\frac{\\partial h}{\\partial x} - \\eta\\frac{\\partial h}{\\partial y} = 0\n\n\n    where `\\eta`, and `\\xi` are the infinitesimals and `h(x,y) = \\frac{dy}{dx}`\n\n    The infinitesimals should be given in the form of a list of dicts\n    ``[{xi(x, y): inf, eta(x, y): inf}]``, corresponding to the\n    output of the function infinitesimals. It returns a list\n    of values of the form ``[(True/False, sol)]`` where ``sol`` is the value\n    obtained after substituting the infinitesimals in the PDE. If it\n    is ``True``, then ``sol`` would be 0.\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "constantsimp",
    "full_id": "sympy.solvers.ode.constantsimp",
    "type": "function",
    "description": "\n    Simplifies an expression with arbitrary constants in it.\n\n    This function is written specifically to work with\n    :py:meth:`~sympy.solvers.ode.dsolve`, and is not intended for general use.\n\n    Simplification is done by \"absorbing\" the arbitrary constants into other\n    arbitrary constants, numbers, and symbols that they are not independent\n    of.\n\n    The symbols must all have the same name with numbers after it, for\n    example, ``C1``, ``C2``, ``C3``.  The ``symbolname`` here would be\n    '``C``', the ``startnumber`` would be 1, and the ``endnumber`` would be 3.\n    If the arbitrary constants are independent of the variable ``x``, then the\n    independent symbol would be ``x``.  There is no need to specify the\n    dependent function, such as ``f(x)``, because it already has the\n    independent symbol, ``x``, in it.\n\n    Because terms are \"absorbed\" into arbitrary constants and because\n    constants are renumbered after simplifying, the arbitrary constants in\n    expr are not necessarily equal to the ones of the same name in the\n    returned result.\n\n    If two or more arbitrary constants are added, multiplied, or raised to the\n    power of each other, they are first absorbed together into a single\n    arbitrary constant.  Then the new constant is combined into other terms if\n    necessary.\n\n    Absorption of constants is done with limited assistance:\n\n    1. terms of :py:class:`~sympy.core.add.Add`\\s are collected to try join\n       constants so `e^x (C_1 \\cos(x) + C_2 \\cos(x))` will simplify to `e^x\n       C_1 \\cos(x)`;\n\n    2. powers with exponents that are :py:class:`~sympy.core.add.Add`\\s are\n       expanded so `e^{C_1 + x}` will be simplified to `C_1 e^x`.\n\n    Use :py:meth:`~sympy.solvers.ode.ode.constant_renumber` to renumber constants\n    after simplification or else arbitrary numbers on constants may appear,\n    e.g. `C_1 + C_3 x`.\n\n    In rare cases, a single constant can be \"simplified\" into two constants.\n    Every differential equation solution should have as many arbitrary\n    constants as the order of the differential equation.  The result here will\n    be technically correct, but it may, for example, have `C_1` and `C_2` in\n    an expression, when `C_1` is actually equal to `C_2`.  Use your discretion\n    in such situations, and also take advantage of the ability to use hints in\n    :py:meth:`~sympy.solvers.ode.dsolve`.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.solvers.ode.ode import constantsimp\n    >>> C1, C2, C3, x, y = symbols('C1, C2, C3, x, y')\n    >>> constantsimp(2*C1*x, {C1, C2, C3})\n    C1*x\n    >>> constantsimp(C1 + 2 + x, {C1, C2, C3})\n    C1 + x\n    >>> constantsimp(C1*C2 + 2 + C2 + C3*x, {C1, C2, C3})\n    C1 + C3*x\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "odesimp",
    "full_id": "sympy.solvers.ode.ode.odesimp",
    "type": "function",
    "description": "\n    Simplifies solutions of ODEs, including trying to solve for ``func`` and\n    running :py:meth:`~sympy.solvers.ode.constantsimp`.\n\n    It may use knowledge of the type of solution that the hint returns to\n    apply additional simplifications.\n\n    It also attempts to integrate any :py:class:`~sympy.integrals.integrals.Integral`\\s\n    in the expression, if the hint is not an ``_Integral`` hint.\n\n    This function should have no effect on expressions returned by\n    :py:meth:`~sympy.solvers.ode.dsolve`, as\n    :py:meth:`~sympy.solvers.ode.dsolve` already calls\n    :py:meth:`~sympy.solvers.ode.ode.odesimp`, but the individual hint functions\n    do not call :py:meth:`~sympy.solvers.ode.ode.odesimp` (because the\n    :py:meth:`~sympy.solvers.ode.dsolve` wrapper does).  Therefore, this\n    function is designed for mainly internal use.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, symbols, dsolve, pprint, Function\n    >>> from sympy.solvers.ode.ode import odesimp\n    >>> x, u2, C1= symbols('x,u2,C1')\n    >>> f = Function('f')\n\n    >>> eq = dsolve(x*f(x).diff(x) - f(x) - x*sin(f(x)/x), f(x),\n    ... hint='1st_homogeneous_coeff_subs_indep_div_dep_Integral',\n    ... simplify=False)\n    >>> pprint(eq, wrap_line=False)\n                            x\n                           ----\n                           f(x)\n                             /\n                            |\n                            |   /        1   \\\n                            |  -|u1 + -------|\n                            |   |        /1 \\|\n                            |   |     sin|--||\n                            |   \\        \\u1//\n    log(f(x)) = log(C1) +   |  ---------------- d(u1)\n                            |          2\n                            |        u1\n                            |\n                           /\n\n    >>> pprint(odesimp(eq, f(x), 1, {C1},\n    ... hint='1st_homogeneous_coeff_subs_indep_div_dep'\n    ... )) #doctest: +SKIP\n        x\n    --------- = C1\n       /f(x)\\\n    tan|----|\n       \\2*x /\n\n    ",
    "section": "Hint Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "constant_renumber",
    "full_id": "sympy.solvers.ode.ode.constant_renumber",
    "type": "function",
    "description": "\n    Renumber arbitrary constants in ``expr`` to use the symbol names as given\n    in ``newconstants``. In the process, this reorders expression terms in a\n    standard way.\n\n    If ``newconstants`` is not provided then the new constant names will be\n    ``C1``, ``C2`` etc. Otherwise ``newconstants`` should be an iterable\n    giving the new symbols to use for the constants in order.\n\n    The ``variables`` argument is a list of non-constant symbols. All other\n    free symbols found in ``expr`` are assumed to be constants and will be\n    renumbered. If ``variables`` is not given then any numbered symbol\n    beginning with ``C`` (e.g. ``C1``) is assumed to be a constant.\n\n    Symbols are renumbered based on ``.sort_key()``, so they should be\n    numbered roughly in the order that they appear in the final, printed\n    expression.  Note that this ordering is based in part on hashes, so it can\n    produce different results on different machines.\n\n    The structure of this function is very similar to that of\n    :py:meth:`~sympy.solvers.ode.constantsimp`.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.solvers.ode.ode import constant_renumber\n    >>> x, C1, C2, C3 = symbols('x,C1:4')\n    >>> expr = C3 + C2*x + C1*x**2\n    >>> expr\n    C1*x**2  + C2*x + C3\n    >>> constant_renumber(expr)\n    C1 + C2*x + C3*x**2\n\n    The ``variables`` argument specifies which are constants so that the\n    other symbols will not be renumbered:\n\n    >>> constant_renumber(expr, [C1, x])\n    C1*x**2  + C2 + C3*x\n\n    The ``newconstants`` argument is used to specify what symbols to use when\n    replacing the constants:\n\n    >>> constant_renumber(expr, [x], newconstants=symbols('E1:4'))\n    E1 + E2*x + E3*x**2\n\n    ",
    "section": "Hint Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "ode_sol_simplicity",
    "full_id": "sympy.solvers.ode.ode.ode_sol_simplicity",
    "type": "function",
    "description": "\n    Returns an extended integer representing how simple a solution to an ODE\n    is.\n\n    The following things are considered, in order from most simple to least:\n\n    - ``sol`` is solved for ``func``.\n    - ``sol`` is not solved for ``func``, but can be if passed to solve (e.g.,\n      a solution returned by ``dsolve(ode, func, simplify=False``).\n    - If ``sol`` is not solved for ``func``, then base the result on the\n      length of ``sol``, as computed by ``len(str(sol))``.\n    - If ``sol`` has any unevaluated :py:class:`~sympy.integrals.integrals.Integral`\\s,\n      this will automatically be considered less simple than any of the above.\n\n    This function returns an integer such that if solution A is simpler than\n    solution B by above metric, then ``ode_sol_simplicity(sola, func) <\n    ode_sol_simplicity(solb, func)``.\n\n    Currently, the following are the numbers returned, but if the heuristic is\n    ever improved, this may change.  Only the ordering is guaranteed.\n\n    +----------------------------------------------+-------------------+\n    | Simplicity                                   | Return            |\n    +==============================================+===================+\n    | ``sol`` solved for ``func``                  | ``-2``            |\n    +----------------------------------------------+-------------------+\n    | ``sol`` not solved for ``func`` but can be   | ``-1``            |\n    +----------------------------------------------+-------------------+\n    | ``sol`` is not solved nor solvable for       | ``len(str(sol))`` |\n    | ``func``                                     |                   |\n    +----------------------------------------------+-------------------+\n    | ``sol`` contains an                          | ``oo``            |\n    | :obj:`~sympy.integrals.integrals.Integral`   |                   |\n    +----------------------------------------------+-------------------+\n\n    ``oo`` here means the SymPy infinity, which should compare greater than\n    any integer.\n\n    If you already know :py:meth:`~sympy.solvers.solvers.solve` cannot solve\n    ``sol``, you can use ``trysolving=False`` to skip that step, which is the\n    only potentially slow step.  For example,\n    :py:meth:`~sympy.solvers.ode.dsolve` with the ``simplify=False`` flag\n    should do this.\n\n    If ``sol`` is a list of solutions, if the worst solution in the list\n    returns ``oo`` it returns that, otherwise it returns ``len(str(sol))``,\n    that is, the length of the string representation of the whole list.\n\n    Examples\n    ========\n\n    This function is designed to be passed to ``min`` as the key argument,\n    such as ``min(listofsolutions, key=lambda i: ode_sol_simplicity(i,\n    f(x)))``.\n\n    >>> from sympy import symbols, Function, Eq, tan, Integral\n    >>> from sympy.solvers.ode.ode import ode_sol_simplicity\n    >>> x, C1, C2 = symbols('x, C1, C2')\n    >>> f = Function('f')\n\n    >>> ode_sol_simplicity(Eq(f(x), C1*x**2), f(x))\n    -2\n    >>> ode_sol_simplicity(Eq(x**2 + f(x), C1), f(x))\n    -1\n    >>> ode_sol_simplicity(Eq(f(x), C1*Integral(2*x, x)), f(x))\n    oo\n    >>> eq1 = Eq(f(x)/tan(f(x)/(2*x)), C1)\n    >>> eq2 = Eq(f(x)/tan(f(x)/(2*x) + f(x)), C2)\n    >>> [ode_sol_simplicity(eq, f(x)) for eq in [eq1, eq2]]\n    [28, 35]\n    >>> min([eq1, eq2], key=lambda i: ode_sol_simplicity(i, f(x)))\n    Eq(f(x)/tan(f(x)/(2*x)), C1)\n\n    ",
    "section": "Hint Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "ode_1st_power_series",
    "full_id": "sympy.solvers.ode.ode.ode_1st_power_series",
    "type": "function",
    "description": "\n    The power series solution is a method which gives the Taylor series expansion\n    to the solution of a differential equation.\n\n    For a first order differential equation `\\frac{dy}{dx} = h(x, y)`, a power\n    series solution exists at a point `x = x_{0}` if `h(x, y)` is analytic at `x_{0}`.\n    The solution is given by\n\n    .. math:: y(x) = y(x_{0}) + \\sum_{n = 1}^{\\infty} \\frac{F_{n}(x_{0},b)(x - x_{0})^n}{n!},\n\n    where `y(x_{0}) = b` is the value of y at the initial value of `x_{0}`.\n    To compute the values of the `F_{n}(x_{0},b)` the following algorithm is\n    followed, until the required number of terms are generated.\n\n    1. `F_1 = h(x_{0}, b)`\n    2. `F_{n+1} = \\frac{\\partial F_{n}}{\\partial x} + \\frac{\\partial F_{n}}{\\partial y}F_{1}`\n\n    Examples\n    ========\n\n    >>> from sympy import Function, pprint, exp, dsolve\n    >>> from sympy.abc import x\n    >>> f = Function('f')\n    >>> eq = exp(x)*(f(x).diff(x)) - f(x)\n    >>> pprint(dsolve(eq, hint='1st_power_series'))\n                           3       4       5\n                       C1*x    C1*x    C1*x     / 6\\\n    f(x) = C1 + C1*x - ----- + ----- + ----- + O\\x /\n                         6       24      60\n\n\n    References\n    ==========\n\n    - Travis W. Walker, Analytic power series technique for solving first-order\n      differential equations, p.p 17, 18\n\n    ",
    "section": "Hint Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "ode_2nd_power_series_ordinary",
    "full_id": "sympy.solvers.ode.ode.ode_2nd_power_series_ordinary",
    "type": "function",
    "description": "\n    Gives a power series solution to a second order homogeneous differential\n    equation with polynomial coefficients at an ordinary point. A homogeneous\n    differential equation is of the form\n\n    .. math :: P(x)\\frac{d^2y}{dx^2} + Q(x)\\frac{dy}{dx} + R(x) y(x) = 0\n\n    For simplicity it is assumed that `P(x)`, `Q(x)` and `R(x)` are polynomials,\n    it is sufficient that `\\frac{Q(x)}{P(x)}` and `\\frac{R(x)}{P(x)}` exists at\n    `x_{0}`. A recurrence relation is obtained by substituting `y` as `\\sum_{n=0}^\\infty a_{n}x^{n}`,\n    in the differential equation, and equating the nth term. Using this relation\n    various terms can be generated.\n\n\n    Examples\n    ========\n\n    >>> from sympy import dsolve, Function, pprint\n    >>> from sympy.abc import x\n    >>> f = Function(\"f\")\n    >>> eq = f(x).diff(x, 2) + f(x)\n    >>> pprint(dsolve(eq, hint='2nd_power_series_ordinary'))\n              / 4    2    \\        /     2\\\n              |x    x     |        |    x |    / 6\\\n    f(x) = C2*|-- - -- + 1| + C1*x*|1 - --| + O\\x /\n              \\24   2     /        \\    6 /\n\n\n    References\n    ==========\n    - https://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx\n    - George E. Simmons, \"Differential Equations with Applications and\n      Historical Notes\", p.p 176 - 184\n\n    ",
    "section": "Hint Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "ode_2nd_power_series_regular",
    "full_id": "sympy.solvers.ode.ode.ode_2nd_power_series_regular",
    "type": "function",
    "description": "\n    Gives a power series solution to a second order homogeneous differential\n    equation with polynomial coefficients at a regular point. A second order\n    homogeneous differential equation is of the form\n\n    .. math :: P(x)\\frac{d^2y}{dx^2} + Q(x)\\frac{dy}{dx} + R(x) y(x) = 0\n\n    A point is said to regular singular at `x0` if `x - x0\\frac{Q(x)}{P(x)}`\n    and `(x - x0)^{2}\\frac{R(x)}{P(x)}` are analytic at `x0`. For simplicity\n    `P(x)`, `Q(x)` and `R(x)` are assumed to be polynomials. The algorithm for\n    finding the power series solutions is:\n\n    1.  Try expressing `(x - x0)P(x)` and `((x - x0)^{2})Q(x)` as power series\n        solutions about x0. Find `p0` and `q0` which are the constants of the\n        power series expansions.\n    2.  Solve the indicial equation `f(m) = m(m - 1) + m*p0 + q0`, to obtain the\n        roots `m1` and `m2` of the indicial equation.\n    3.  If `m1 - m2` is a non integer there exists two series solutions. If\n        `m1 = m2`, there exists only one solution. If `m1 - m2` is an integer,\n        then the existence of one solution is confirmed. The other solution may\n        or may not exist.\n\n    The power series solution is of the form `x^{m}\\sum_{n=0}^\\infty a_{n}x^{n}`. The\n    coefficients are determined by the following recurrence relation.\n    `a_{n} = -\\frac{\\sum_{k=0}^{n-1} q_{n-k} + (m + k)p_{n-k}}{f(m + n)}`. For the case\n    in which `m1 - m2` is an integer, it can be seen from the recurrence relation\n    that for the lower root `m`, when `n` equals the difference of both the\n    roots, the denominator becomes zero. So if the numerator is not equal to zero,\n    a second series solution exists.\n\n\n    Examples\n    ========\n\n    >>> from sympy import dsolve, Function, pprint\n    >>> from sympy.abc import x\n    >>> f = Function(\"f\")\n    >>> eq = x*(f(x).diff(x, 2)) + 2*(f(x).diff(x)) + x*f(x)\n    >>> pprint(dsolve(eq, hint='2nd_power_series_regular'))\n                                  /   6     4    2    \\\n                                  |  x     x    x     |\n              / 4     2    \\   C1*|- --- + -- - -- + 1|\n              |x     x     |      \\  720   24   2     /    / 6\\\n    f(x) = C2*|--- - -- + 1| + ------------------------ + O\\x /\n              \\120   6     /              x\n\n\n    References\n    ==========\n    - George E. Simmons, \"Differential Equations with Applications and\n      Historical Notes\", p.p 176 - 184\n\n    ",
    "section": "Hint Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "lie_heuristic_abaco1_simple",
    "full_id": "sympy.solvers.ode.lie_group.lie_heuristic_abaco1_simple",
    "type": "function",
    "description": "\n    The first heuristic uses the following four sets of\n    assumptions on `\\xi` and `\\eta`\n\n    .. math:: \\xi = 0, \\eta = f(x)\n\n    .. math:: \\xi = 0, \\eta = f(y)\n\n    .. math:: \\xi = f(x), \\eta = 0\n\n    .. math:: \\xi = f(y), \\eta = 0\n\n    The success of this heuristic is determined by algebraic factorisation.\n    For the first assumption `\\xi = 0` and `\\eta` to be a function of `x`, the PDE\n\n    .. math:: \\frac{\\partial \\eta}{\\partial x} + (\\frac{\\partial \\eta}{\\partial y}\n                - \\frac{\\partial \\xi}{\\partial x})*h\n                - \\frac{\\partial \\xi}{\\partial y}*h^{2}\n                - \\xi*\\frac{\\partial h}{\\partial x} - \\eta*\\frac{\\partial h}{\\partial y} = 0\n\n    reduces to `f'(x) - f\\frac{\\partial h}{\\partial y} = 0`\n    If `\\frac{\\partial h}{\\partial y}` is a function of `x`, then this can usually\n    be integrated easily. A similar idea is applied to the other 3 assumptions as well.\n\n\n    References\n    ==========\n\n    - E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra\n      Solving of First Order ODEs Using Symmetry Methods, pp. 8\n\n\n    ",
    "section": "Lie heuristics",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "lie_heuristic_abaco1_product",
    "full_id": "sympy.solvers.ode.lie_group.lie_heuristic_abaco1_product",
    "type": "function",
    "description": "\n    The second heuristic uses the following two assumptions on `\\xi` and `\\eta`\n\n    .. math:: \\eta = 0, \\xi = f(x)*g(y)\n\n    .. math:: \\eta = f(x)*g(y), \\xi = 0\n\n    The first assumption of this heuristic holds good if\n    `\\frac{1}{h^{2}}\\frac{\\partial^2}{\\partial x \\partial y}\\log(h)` is\n    separable in `x` and `y`, then the separated factors containing `x`\n    is `f(x)`, and `g(y)` is obtained by\n\n    .. math:: e^{\\int f\\frac{\\partial}{\\partial x}\\left(\\frac{1}{f*h}\\right)\\,dy}\n\n    provided `f\\frac{\\partial}{\\partial x}\\left(\\frac{1}{f*h}\\right)` is a function\n    of `y` only.\n\n    The second assumption holds good if `\\frac{dy}{dx} = h(x, y)` is rewritten as\n    `\\frac{dy}{dx} = \\frac{1}{h(y, x)}` and the same properties of the first assumption\n    satisfies. After obtaining `f(x)` and `g(y)`, the coordinates are again\n    interchanged, to get `\\eta` as `f(x)*g(y)`\n\n\n    References\n    ==========\n    - E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order\n      ODE Patterns, pp. 7 - pp. 8\n\n    ",
    "section": "Lie heuristics",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "lie_heuristic_bivariate",
    "full_id": "sympy.solvers.ode.lie_group.lie_heuristic_bivariate",
    "type": "function",
    "description": "\n    The third heuristic assumes the infinitesimals `\\xi` and `\\eta`\n    to be bi-variate polynomials in `x` and `y`. The assumption made here\n    for the logic below is that `h` is a rational function in `x` and `y`\n    though that may not be necessary for the infinitesimals to be\n    bivariate polynomials. The coefficients of the infinitesimals\n    are found out by substituting them in the PDE and grouping similar terms\n    that are polynomials and since they form a linear system, solve and check\n    for non trivial solutions. The degree of the assumed bivariates\n    are increased till a certain maximum value.\n\n    References\n    ==========\n    - Lie Groups and Differential Equations\n      pp. 327 - pp. 329\n\n    ",
    "section": "Lie heuristics",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "lie_heuristic_chi",
    "full_id": "sympy.solvers.ode.lie_group.lie_heuristic_chi",
    "type": "function",
    "description": "\n    The aim of the fourth heuristic is to find the function `\\chi(x, y)`\n    that satisfies the PDE `\\frac{d\\chi}{dx} + h\\frac{d\\chi}{dx}\n    - \\frac{\\partial h}{\\partial y}\\chi = 0`.\n\n    This assumes `\\chi` to be a bivariate polynomial in `x` and `y`. By intuition,\n    `h` should be a rational function in `x` and `y`. The method used here is\n    to substitute a general binomial for `\\chi` up to a certain maximum degree\n    is reached. The coefficients of the polynomials, are calculated by by collecting\n    terms of the same order in `x` and `y`.\n\n    After finding `\\chi`, the next step is to use `\\eta = \\xi*h + \\chi`, to\n    determine `\\xi` and `\\eta`. This can be done by dividing `\\chi` by `h`\n    which would give `-\\xi` as the quotient and `\\eta` as the remainder.\n\n\n    References\n    ==========\n    - E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra\n      Solving of First Order ODEs Using Symmetry Methods, pp. 8\n\n    ",
    "section": "Lie heuristics",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "lie_heuristic_abaco2_similar",
    "full_id": "sympy.solvers.ode.lie_group.lie_heuristic_abaco2_similar",
    "type": "function",
    "description": "\n    This heuristic uses the following two assumptions on `\\xi` and `\\eta`\n\n    .. math:: \\eta = g(x), \\xi = f(x)\n\n    .. math:: \\eta = f(y), \\xi = g(y)\n\n    For the first assumption,\n\n    1. First `\\frac{\\frac{\\partial h}{\\partial y}}{\\frac{\\partial^{2} h}{\n       \\partial yy}}` is calculated. Let us say this value is A\n\n    2. If this is constant, then `h` is matched to the form `A(x) + B(x)e^{\n       \\frac{y}{C}}` then, `\\frac{e^{\\int \\frac{A(x)}{C} \\,dx}}{B(x)}` gives `f(x)`\n       and `A(x)*f(x)` gives `g(x)`\n\n    3. Otherwise `\\frac{\\frac{\\partial A}{\\partial X}}{\\frac{\\partial A}{\n       \\partial Y}} = \\gamma` is calculated. If\n\n       a] `\\gamma` is a function of `x` alone\n\n       b] `\\frac{\\gamma\\frac{\\partial h}{\\partial y} - \\gamma'(x) - \\frac{\n       \\partial h}{\\partial x}}{h + \\gamma} = G` is a function of `x` alone.\n       then, `e^{\\int G \\,dx}` gives `f(x)` and `-\\gamma*f(x)` gives `g(x)`\n\n    The second assumption holds good if `\\frac{dy}{dx} = h(x, y)` is rewritten as\n    `\\frac{dy}{dx} = \\frac{1}{h(y, x)}` and the same properties of the first assumption\n    satisfies. After obtaining `f(x)` and `g(x)`, the coordinates are again\n    interchanged, to get `\\xi` as `f(x^*)` and `\\eta` as `g(y^*)`\n\n    References\n    ==========\n    - E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order\n      ODE Patterns, pp. 10 - pp. 12\n\n    ",
    "section": "Lie heuristics",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "lie_heuristic_function_sum",
    "full_id": "sympy.solvers.ode.lie_group.lie_heuristic_function_sum",
    "type": "function",
    "description": "\n    This heuristic uses the following two assumptions on `\\xi` and `\\eta`\n\n    .. math:: \\eta = 0, \\xi = f(x) + g(y)\n\n    .. math:: \\eta = f(x) + g(y), \\xi = 0\n\n    The first assumption of this heuristic holds good if\n\n    .. math:: \\frac{\\partial}{\\partial y}[(h\\frac{\\partial^{2}}{\n                \\partial x^{2}}(h^{-1}))^{-1}]\n\n    is separable in `x` and `y`,\n\n    1. The separated factors containing `y` is `\\frac{\\partial g}{\\partial y}`.\n       From this `g(y)` can be determined.\n    2. The separated factors containing `x` is `f''(x)`.\n    3. `h\\frac{\\partial^{2}}{\\partial x^{2}}(h^{-1})` equals\n       `\\frac{f''(x)}{f(x) + g(y)}`. From this `f(x)` can be determined.\n\n    The second assumption holds good if `\\frac{dy}{dx} = h(x, y)` is rewritten as\n    `\\frac{dy}{dx} = \\frac{1}{h(y, x)}` and the same properties of the first\n    assumption satisfies. After obtaining `f(x)` and `g(y)`, the coordinates\n    are again interchanged, to get `\\eta` as `f(x) + g(y)`.\n\n    For both assumptions, the constant factors are separated among `g(y)`\n    and `f''(x)`, such that `f''(x)` obtained from 3] is the same as that\n    obtained from 2]. If not possible, then this heuristic fails.\n\n\n    References\n    ==========\n    - E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order\n      ODE Patterns, pp. 7 - pp. 8\n\n    ",
    "section": "Lie heuristics",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "lie_heuristic_abaco2_unique_unknown",
    "full_id": "sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_unknown",
    "type": "function",
    "description": "\n    This heuristic assumes the presence of unknown functions or known functions\n    with non-integer powers.\n\n    1. A list of all functions and non-integer powers containing x and y\n    2. Loop over each element `f` in the list, find `\\frac{\\frac{\\partial f}{\\partial x}}{\n       \\frac{\\partial f}{\\partial x}} = R`\n\n       If it is separable in `x` and `y`, let `X` be the factors containing `x`. Then\n\n       a] Check if `\\xi = X` and `\\eta = -\\frac{X}{R}` satisfy the PDE. If yes, then return\n          `\\xi` and `\\eta`\n       b] Check if `\\xi = \\frac{-R}{X}` and `\\eta = -\\frac{1}{X}` satisfy the PDE.\n           If yes, then return `\\xi` and `\\eta`\n\n       If not, then check if\n\n       a] :math:`\\xi = -R,\\eta = 1`\n\n       b] :math:`\\xi = 1, \\eta = -\\frac{1}{R}`\n\n       are solutions.\n\n    References\n    ==========\n    - E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order\n      ODE Patterns, pp. 10 - pp. 12\n\n    ",
    "section": "Lie heuristics",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "lie_heuristic_abaco2_unique_general",
    "full_id": "sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_general",
    "type": "function",
    "description": "\n    This heuristic finds if infinitesimals of the form `\\eta = f(x)`, `\\xi = g(y)`\n    without making any assumptions on `h`.\n\n    The complete sequence of steps is given in the paper mentioned below.\n\n    References\n    ==========\n    - E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order\n      ODE Patterns, pp. 10 - pp. 12\n\n    ",
    "section": "Lie heuristics",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "lie_heuristic_linear",
    "full_id": "sympy.solvers.ode.lie_group.lie_heuristic_linear",
    "type": "function",
    "description": "\n    This heuristic assumes\n\n    1. `\\xi = ax + by + c` and\n    2. `\\eta = fx + gy + h`\n\n    After substituting the following assumptions in the determining PDE, it\n    reduces to\n\n    .. math:: f + (g - a)h - bh^{2} - (ax + by + c)\\frac{\\partial h}{\\partial x}\n                 - (fx + gy + c)\\frac{\\partial h}{\\partial y}\n\n    Solving the reduced PDE obtained, using the method of characteristics, becomes\n    impractical. The method followed is grouping similar terms and solving the system\n    of linear equations obtained. The difference between the bivariate heuristic is that\n    `h` need not be a rational function in this case.\n\n    References\n    ==========\n    - E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order\n      ODE Patterns, pp. 10 - pp. 12\n\n    ",
    "section": "Lie heuristics",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "riccati_normal",
    "full_id": "sympy.solvers.ode.riccati.riccati_normal",
    "type": "function",
    "description": "\n    Given a solution `w(x)` to the equation\n\n    .. math:: w'(x) = b_0(x) + b_1(x)*w(x) + b_2(x)*w(x)^2\n\n    and rational function coefficients `b_1(x)` and\n    `b_2(x)`, this function transforms the solution to\n    give a solution `y(x)` for its corresponding normal\n    Riccati ODE\n\n    .. math:: y'(x) + y(x)^2 = a(x)\n\n    using the transformation\n\n    .. math:: y(x) = -b_2(x)*w(x) - b'_2(x)/(2*b_2(x)) - b_1(x)/2\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "riccati_inverse_normal",
    "full_id": "sympy.solvers.ode.riccati.riccati_inverse_normal",
    "type": "function",
    "description": "\n    Inverse transforming the solution to the normal\n    Riccati ODE to get the solution to the Riccati ODE.\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "riccati_reduced",
    "full_id": "sympy.solvers.ode.riccati.riccati_reduced",
    "type": "function",
    "description": "\n    Convert a Riccati ODE into its corresponding\n    normal Riccati ODE.\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "construct_c",
    "full_id": "sympy.solvers.ode.riccati.construct_c",
    "type": "function",
    "description": "\n    Helper function to calculate the coefficients\n    in the c-vector for each pole.\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "construct_d",
    "full_id": "sympy.solvers.ode.riccati.construct_d",
    "type": "function",
    "description": "\n    Helper function to calculate the coefficients\n    in the d-vector based on the valuation of the\n    function at oo.\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "rational_laurent_series",
    "full_id": "sympy.solvers.ode.riccati.rational_laurent_series",
    "type": "function",
    "description": "\n    The function computes the Laurent series coefficients\n    of a rational function.\n\n    Parameters\n    ==========\n\n    num: A Poly object that is the numerator of `f(x)`.\n    den: A Poly object that is the denominator of `f(x)`.\n    x: The variable of expansion of the series.\n    r: The point of expansion of the series.\n    m: Multiplicity of r if r is a pole of `f(x)`. Should\n    be zero otherwise.\n    n: Order of the term upto which the series is expanded.\n\n    Returns\n    =======\n\n    series: A dictionary that has power of the term as key\n    and coefficient of that term as value.\n\n    Below is a basic outline of how the Laurent series of a\n    rational function `f(x)` about `x_0` is being calculated -\n\n    1. Substitute `x + x_0` in place of `x`. If `x_0`\n    is a pole of `f(x)`, multiply the expression by `x^m`\n    where `m` is the multiplicity of `x_0`. Denote the\n    the resulting expression as g(x). We do this substitution\n    so that we can now find the Laurent series of g(x) about\n    `x = 0`.\n\n    2. We can then assume that the Laurent series of `g(x)`\n    takes the following form -\n\n    .. math:: g(x) = \\frac{num(x)}{den(x)} = \\sum_{m = 0}^{\\infty} a_m x^m\n\n    where `a_m` denotes the Laurent series coefficients.\n\n    3. Multiply the denominator to the RHS of the equation\n    and form a recurrence relation for the coefficients `a_m`.\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "compute_m_ybar",
    "full_id": "sympy.solvers.ode.riccati.compute_m_ybar",
    "type": "function",
    "description": "\n    Helper function to calculate -\n\n    1. m - The degree bound for the polynomial\n    solution that must be found for the auxiliary\n    differential equation.\n\n    2. ybar - Part of the solution which can be\n    computed using the poles, c and d vectors.\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "solve_aux_eq",
    "full_id": "sympy.solvers.ode.riccati.solve_aux_eq",
    "type": "function",
    "description": "\n    Helper function to find a polynomial solution\n    of degree m for the auxiliary differential\n    equation.\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "remove_redundant_sols",
    "full_id": "sympy.solvers.ode.riccati.remove_redundant_sols",
    "type": "function",
    "description": "\n    Helper function to remove redundant\n    solutions to the differential equation.\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "get_gen_sol_from_part_sol",
    "full_id": "sympy.solvers.ode.riccati.get_gen_sol_from_part_sol",
    "type": "function",
    "description": " \"\n    Helper function which computes the general\n    solution for a Riccati ODE from its particular\n    solutions.\n\n    There are 3 cases to find the general solution\n    from the particular solutions for a Riccati ODE\n    depending on the number of particular solution(s)\n    we have - 1, 2 or 3.\n\n    For more information, see Section 6 of\n    \"Methods of Solution of the Riccati Differential Equation\"\n    by D. R. Haaheim and F. M. Stein\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "solve_riccati",
    "full_id": "sympy.solvers.ode.riccati.solve_riccati",
    "type": "function",
    "description": "\n    The main function that gives particular/general\n    solutions to Riccati ODEs that have atleast 1\n    rational particular solution.\n    ",
    "section": "Rational Riccati Solver",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_linear_2eq_order1_type6",
    "full_id": "sympy.solvers.ode.ode._linear_2eq_order1_type6",
    "type": "function",
    "description": "\n    The equations of this type of ode are .\n\n    .. math:: x' = f(t) x + g(t) y\n\n    .. math:: y' = a [f(t) + a h(t)] x + a [g(t) - h(t)] y\n\n    This is solved by first multiplying the first equation by `-a` and adding\n    it to the second equation to obtain\n\n    .. math:: y' - a x' = -a h(t) (y - a x)\n\n    Setting `U = y - ax` and integrating the equation we arrive at\n\n    .. math:: y - ax = C_1 e^{-a \\int h(t) \\,dt}\n\n    and on substituting the value of y in first equation give rise to first order ODEs. After solving for\n    `x`, we can obtain `y` by substituting the value of `x` in second equation.\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_linear_2eq_order1_type7",
    "full_id": "sympy.solvers.ode.ode._linear_2eq_order1_type7",
    "type": "function",
    "description": "\n    The equations of this type of ode are .\n\n    .. math:: x' = f(t) x + g(t) y\n\n    .. math:: y' = h(t) x + p(t) y\n\n    Differentiating the first equation and substituting the value of `y`\n    from second equation will give a second-order linear equation\n\n    .. math:: g x'' - (fg + gp + g') x' + (fgp - g^{2} h + f g' - f' g) x = 0\n\n    This above equation can be easily integrated if following conditions are satisfied.\n\n    1. `fgp - g^{2} h + f g' - f' g = 0`\n\n    2. `fgp - g^{2} h + f g' - f' g = ag, fg + gp + g' = bg`\n\n    If first condition is satisfied then it is solved by current dsolve solver and in second case it becomes\n    a constant coefficient differential equation which is also solved by current solver.\n\n    Otherwise if the above condition fails then,\n    a particular solution is assumed as `x = x_0(t)` and `y = y_0(t)`\n    Then the general solution is expressed as\n\n    .. math:: x = C_1 x_0(t) + C_2 x_0(t) \\int \\frac{g(t) F(t) P(t)}{x_0^{2}(t)} \\,dt\n\n    .. math:: y = C_1 y_0(t) + C_2 [\\frac{F(t) P(t)}{x_0(t)} + y_0(t) \\int \\frac{g(t) F(t) P(t)}{x_0^{2}(t)} \\,dt]\n\n    where C1 and C2 are arbitrary constants and\n\n    .. math:: F(t) = e^{\\int f(t) \\,dt}, P(t) = e^{\\int p(t) \\,dt}\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "linear_ode_to_matrix",
    "full_id": "sympy.solvers.ode.systems.linear_ode_to_matrix",
    "type": "function",
    "description": "\n    Convert a linear system of ODEs to matrix form\n\n    Explanation\n    ===========\n\n    Express a system of linear ordinary differential equations as a single\n    matrix differential equation [1]. For example the system $x' = x + y + 1$\n    and $y' = x - y$ can be represented as\n\n    .. math:: A_1 X' = A_0 X + b\n\n    where $A_1$ and $A_0$ are $2 \\times 2$ matrices and $b$, $X$ and $X'$ are\n    $2 \\times 1$ matrices with $X = [x, y]^T$.\n\n    Higher-order systems are represented with additional matrices e.g. a\n    second-order system would look like\n\n    .. math:: A_2 X'' =  A_1 X' + A_0 X  + b\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Symbol, Matrix, Eq\n    >>> from sympy.solvers.ode.systems import linear_ode_to_matrix\n    >>> t = Symbol('t')\n    >>> x = Function('x')\n    >>> y = Function('y')\n\n    We can create a system of linear ODEs like\n\n    >>> eqs = [\n    ...     Eq(x(t).diff(t), x(t) + y(t) + 1),\n    ...     Eq(y(t).diff(t), x(t) - y(t)),\n    ... ]\n    >>> funcs = [x(t), y(t)]\n    >>> order = 1 # 1st order system\n\n    Now ``linear_ode_to_matrix`` can represent this as a matrix\n    differential equation.\n\n    >>> (A1, A0), b = linear_ode_to_matrix(eqs, funcs, t, order)\n    >>> A1\n    Matrix([\n    [1, 0],\n    [0, 1]])\n    >>> A0\n    Matrix([\n    [1, 1],\n    [1,  -1]])\n    >>> b\n    Matrix([\n    [1],\n    [0]])\n\n    The original equations can be recovered from these matrices:\n\n    >>> eqs_mat = Matrix([eq.lhs - eq.rhs for eq in eqs])\n    >>> X = Matrix(funcs)\n    >>> A1 * X.diff(t) - A0 * X - b == eqs_mat\n    True\n\n    If the system of equations has a maximum order greater than the\n    order of the system specified, a ODEOrderError exception is raised.\n\n    >>> eqs = [Eq(x(t).diff(t, 2), x(t).diff(t) + x(t)), Eq(y(t).diff(t), y(t) + x(t))]\n    >>> linear_ode_to_matrix(eqs, funcs, t, 1)\n    Traceback (most recent call last):\n    ...\n    ODEOrderError: Cannot represent system in 1-order form\n\n    If the system of equations is nonlinear, then ODENonlinearError is\n    raised.\n\n    >>> eqs = [Eq(x(t).diff(t), x(t) + y(t)), Eq(y(t).diff(t), y(t)**2 + x(t))]\n    >>> linear_ode_to_matrix(eqs, funcs, t, 1)\n    Traceback (most recent call last):\n    ...\n    ODENonlinearError: The system of ODEs is nonlinear.\n\n    Parameters\n    ==========\n\n    eqs : list of SymPy expressions or equalities\n        The equations as expressions (assumed equal to zero).\n    funcs : list of applied functions\n        The dependent variables of the system of ODEs.\n    t : symbol\n        The independent variable.\n    order : int\n        The order of the system of ODEs.\n\n    Returns\n    =======\n\n    The tuple ``(As, b)`` where ``As`` is a tuple of matrices and ``b`` is the\n    the matrix representing the rhs of the matrix equation.\n\n    Raises\n    ======\n\n    ODEOrderError\n        When the system of ODEs have an order greater than what was specified\n    ODENonlinearError\n        When the system of ODEs is nonlinear\n\n    See Also\n    ========\n\n    linear_eq_to_matrix: for systems of linear algebraic equations.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Matrix_differential_equation\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "canonical_odes",
    "full_id": "sympy.solvers.ode.systems.canonical_odes",
    "type": "function",
    "description": "\n    Function that solves for highest order derivatives in a system\n\n    Explanation\n    ===========\n\n    This function inputs a system of ODEs and based on the system,\n    the dependent variables and their highest order, returns the system\n    in the following form:\n\n    .. math::\n        X'(t) = A(t) X(t) + b(t)\n\n    Here, $X(t)$ is the vector of dependent variables of lower order, $A(t)$ is\n    the coefficient matrix, $b(t)$ is the non-homogeneous term and $X'(t)$ is the\n    vector of dependent variables in their respective highest order. We use the term\n    canonical form to imply the system of ODEs which is of the above form.\n\n    If the system passed has a non-linear term with multiple solutions, then a list of\n    systems is returned in its canonical form.\n\n    Parameters\n    ==========\n\n    eqs : List\n        List of the ODEs\n    funcs : List\n        List of dependent variables\n    t : Symbol\n        Independent variable\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, Function, Eq, Derivative\n    >>> from sympy.solvers.ode.systems import canonical_odes\n    >>> f, g = symbols(\"f g\", cls=Function)\n    >>> x, y = symbols(\"x y\")\n    >>> funcs = [f(x), g(x)]\n    >>> eqs = [Eq(f(x).diff(x) - 7*f(x), 12*g(x)), Eq(g(x).diff(x) + g(x), 20*f(x))]\n\n    >>> canonical_eqs = canonical_odes(eqs, funcs, x)\n    >>> canonical_eqs\n    [[Eq(Derivative(f(x), x), 7*f(x) + 12*g(x)), Eq(Derivative(g(x), x), 20*f(x) - g(x))]]\n\n    >>> system = [Eq(Derivative(f(x), x)**2 - 2*Derivative(f(x), x) + 1, 4), Eq(-y*f(x) + Derivative(g(x), x), 0)]\n\n    >>> canonical_system = canonical_odes(system, funcs, x)\n    >>> canonical_system\n    [[Eq(Derivative(f(x), x), -1), Eq(Derivative(g(x), x), y*f(x))], [Eq(Derivative(f(x), x), 3), Eq(Derivative(g(x), x), y*f(x))]]\n\n    Returns\n    =======\n\n    List\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "linodesolve_type",
    "full_id": "sympy.solvers.ode.systems.linodesolve_type",
    "type": "function",
    "description": "\n    Helper function that determines the type of the system of ODEs for solving with :obj:`sympy.solvers.ode.systems.linodesolve()`\n\n    Explanation\n    ===========\n\n    This function takes in the coefficient matrix and/or the non-homogeneous term\n    and returns the type of the equation that can be solved by :obj:`sympy.solvers.ode.systems.linodesolve()`.\n\n    If the system is constant coefficient homogeneous, then \"type1\" is returned\n\n    If the system is constant coefficient non-homogeneous, then \"type2\" is returned\n\n    If the system is non-constant coefficient homogeneous, then \"type3\" is returned\n\n    If the system is non-constant coefficient non-homogeneous, then \"type4\" is returned\n\n    If the system has a non-constant coefficient matrix which can be factorized into constant\n    coefficient matrix, then \"type5\" or \"type6\" is returned for when the system is homogeneous or\n    non-homogeneous respectively.\n\n    Note that, if the system of ODEs is of \"type3\" or \"type4\", then along with the type,\n    the commutative antiderivative of the coefficient matrix is also returned.\n\n    If the system cannot be solved by :obj:`sympy.solvers.ode.systems.linodesolve()`, then\n    NotImplementedError is raised.\n\n    Parameters\n    ==========\n\n    A : Matrix\n        Coefficient matrix of the system of ODEs\n    b : Matrix or None\n        Non-homogeneous term of the system. The default value is None.\n        If this argument is None, then the system is assumed to be homogeneous.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, Matrix\n    >>> from sympy.solvers.ode.systems import linodesolve_type\n    >>> t = symbols(\"t\")\n    >>> A = Matrix([[1, 1], [2, 3]])\n    >>> b = Matrix([t, 1])\n\n    >>> linodesolve_type(A, t)\n    {'antiderivative': None, 'type_of_equation': 'type1'}\n\n    >>> linodesolve_type(A, t, b=b)\n    {'antiderivative': None, 'type_of_equation': 'type2'}\n\n    >>> A_t = Matrix([[1, t], [-t, 1]])\n\n    >>> linodesolve_type(A_t, t)\n    {'antiderivative': Matrix([\n    [      t, t**2/2],\n    [-t**2/2,      t]]), 'type_of_equation': 'type3'}\n\n    >>> linodesolve_type(A_t, t, b=b)\n    {'antiderivative': Matrix([\n    [      t, t**2/2],\n    [-t**2/2,      t]]), 'type_of_equation': 'type4'}\n\n    >>> A_non_commutative = Matrix([[1, t], [t, -1]])\n    >>> linodesolve_type(A_non_commutative, t)\n    Traceback (most recent call last):\n    ...\n    NotImplementedError:\n    The system does not have a commutative antiderivative, it cannot be\n    solved by linodesolve.\n\n    Returns\n    =======\n\n    Dict\n\n    Raises\n    ======\n\n    NotImplementedError\n        When the coefficient matrix does not have a commutative antiderivative\n\n    See Also\n    ========\n\n    linodesolve: Function for which linodesolve_type gets the information\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "matrix_exp_jordan_form",
    "full_id": "sympy.solvers.ode.systems.matrix_exp_jordan_form",
    "type": "function",
    "description": "\n    Matrix exponential $\\exp(A*t)$ for the matrix *A* and scalar *t*.\n\n    Explanation\n    ===========\n\n    Returns the Jordan form of the $\\exp(A*t)$ along with the matrix $P$ such that:\n\n    .. math::\n        \\exp(A*t) = P * expJ * P^{-1}\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, Symbol\n    >>> from sympy.solvers.ode.systems import matrix_exp, matrix_exp_jordan_form\n    >>> t = Symbol('t')\n\n    We will consider a 2x2 defective matrix. This shows that our method\n    works even for defective matrices.\n\n    >>> A = Matrix([[1, 1], [0, 1]])\n\n    It can be observed that this function gives us the Jordan normal form\n    and the required invertible matrix P.\n\n    >>> P, expJ = matrix_exp_jordan_form(A, t)\n\n    Here, it is shown that P and expJ returned by this function is correct\n    as they satisfy the formula: P * expJ * P_inverse = exp(A*t).\n\n    >>> P * expJ * P.inv() == matrix_exp(A, t)\n    True\n\n    Parameters\n    ==========\n\n    A : Matrix\n        The matrix $A$ in the expression $\\exp(A*t)$\n    t : Symbol\n        The independent variable\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Defective_matrix\n    .. [2] https://en.wikipedia.org/wiki/Jordan_matrix\n    .. [3] https://en.wikipedia.org/wiki/Jordan_normal_form\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "matrix_exp",
    "full_id": "sympy.solvers.ode.systems.matrix_exp",
    "type": "function",
    "description": "\n    Matrix exponential $\\exp(A*t)$ for the matrix ``A`` and scalar ``t``.\n\n    Explanation\n    ===========\n\n    This functions returns the $\\exp(A*t)$ by doing a simple\n    matrix multiplication:\n\n    .. math:: \\exp(A*t) = P * expJ * P^{-1}\n\n    where $expJ$ is $\\exp(J*t)$. $J$ is the Jordan normal\n    form of $A$ and $P$ is matrix such that:\n\n    .. math:: A = P * J * P^{-1}\n\n    The matrix exponential $\\exp(A*t)$ appears in the solution of linear\n    differential equations. For example if $x$ is a vector and $A$ is a matrix\n    then the initial value problem\n\n    .. math:: \\frac{dx(t)}{dt} = A \\times x(t),   x(0) = x0\n\n    has the unique solution\n\n    .. math:: x(t) = \\exp(A t) x0\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, Matrix, pprint\n    >>> from sympy.solvers.ode.systems import matrix_exp\n    >>> t = Symbol('t')\n\n    We will consider a 2x2 matrix for comupting the exponential\n\n    >>> A = Matrix([[2, -5], [2, -4]])\n    >>> pprint(A)\n    [2  -5]\n    [     ]\n    [2  -4]\n\n    Now, exp(A*t) is given as follows:\n\n    >>> pprint(matrix_exp(A, t))\n    [   -t           -t                    -t              ]\n    [3*e  *sin(t) + e  *cos(t)         -5*e  *sin(t)       ]\n    [                                                      ]\n    [         -t                     -t           -t       ]\n    [      2*e  *sin(t)         - 3*e  *sin(t) + e  *cos(t)]\n\n    Parameters\n    ==========\n\n    A : Matrix\n        The matrix $A$ in the expression $\\exp(A*t)$\n    t : Symbol\n        The independent variable\n\n    See Also\n    ========\n\n    matrix_exp_jordan_form: For exponential of Jordan normal form\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Jordan_normal_form\n    .. [2] https://en.wikipedia.org/wiki/Matrix_exponential\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "linodesolve",
    "full_id": "sympy.solvers.ode.systems.linodesolve",
    "type": "function",
    "description": "\n    System of n equations linear first-order differential equations\n\n    Explanation\n    ===========\n\n    This solver solves the system of ODEs of the following form:\n\n    .. math::\n        X'(t) = A(t) X(t) +  b(t)\n\n    Here, $A(t)$ is the coefficient matrix, $X(t)$ is the vector of n independent variables,\n    $b(t)$ is the non-homogeneous term and $X'(t)$ is the derivative of $X(t)$\n\n    Depending on the properties of $A(t)$ and $b(t)$, this solver evaluates the solution\n    differently.\n\n    When $A(t)$ is constant coefficient matrix and $b(t)$ is zero vector i.e. system is homogeneous,\n    the system is \"type1\". The solution is:\n\n    .. math::\n        X(t) = \\exp(A t) C\n\n    Here, $C$ is a vector of constants and $A$ is the constant coefficient matrix.\n\n    When $A(t)$ is constant coefficient matrix and $b(t)$ is non-zero i.e. system is non-homogeneous,\n    the system is \"type2\". The solution is:\n\n    .. math::\n        X(t) = e^{A t} ( \\int e^{- A t} b \\,dt + C)\n\n    When $A(t)$ is coefficient matrix such that its commutative with its antiderivative $B(t)$ and\n    $b(t)$ is a zero vector i.e. system is homogeneous, the system is \"type3\". The solution is:\n\n    .. math::\n        X(t) = \\exp(B(t)) C\n\n    When $A(t)$ is commutative with its antiderivative $B(t)$ and $b(t)$ is non-zero i.e. system is\n    non-homogeneous, the system is \"type4\". The solution is:\n\n    .. math::\n        X(t) =  e^{B(t)} ( \\int e^{-B(t)} b(t) \\,dt + C)\n\n    When $A(t)$ is a coefficient matrix such that it can be factorized into a scalar and a constant\n    coefficient matrix:\n\n    .. math::\n        A(t) = f(t) * A\n\n    Where $f(t)$ is a scalar expression in the independent variable $t$ and $A$ is a constant matrix,\n    then we can do the following substitutions:\n\n    .. math::\n        tau = \\int f(t) dt, X(t) = Y(tau), b(t) = b(f^{-1}(tau))\n\n    Here, the substitution for the non-homogeneous term is done only when its non-zero.\n    Using these substitutions, our original system becomes:\n\n    .. math::\n        Y'(tau) = A * Y(tau) + b(tau)/f(tau)\n\n    The above system can be easily solved using the solution for \"type1\" or \"type2\" depending\n    on the homogeneity of the system. After we get the solution for $Y(tau)$, we substitute the\n    solution for $tau$ as $t$ to get back $X(t)$\n\n    .. math::\n        X(t) = Y(tau)\n\n    Systems of \"type5\" and \"type6\" have a commutative antiderivative but we use this solution\n    because its faster to compute.\n\n    The final solution is the general solution for all the four equations since a constant coefficient\n    matrix is always commutative with its antidervative.\n\n    An additional feature of this function is, if someone wants to substitute for value of the independent\n    variable, they can pass the substitution `tau` and the solution will have the independent variable\n    substituted with the passed expression(`tau`).\n\n    Parameters\n    ==========\n\n    A : Matrix\n        Coefficient matrix of the system of linear first order ODEs.\n    t : Symbol\n        Independent variable in the system of ODEs.\n    b : Matrix or None\n        Non-homogeneous term in the system of ODEs. If None is passed,\n        a homogeneous system of ODEs is assumed.\n    B : Matrix or None\n        Antiderivative of the coefficient matrix. If the antiderivative\n        is not passed and the solution requires the term, then the solver\n        would compute it internally.\n    type : String\n        Type of the system of ODEs passed. Depending on the type, the\n        solution is evaluated. The type values allowed and the corresponding\n        system it solves are: \"type1\" for constant coefficient homogeneous\n        \"type2\" for constant coefficient non-homogeneous, \"type3\" for non-constant\n        coefficient homogeneous, \"type4\" for non-constant coefficient non-homogeneous,\n        \"type5\" and \"type6\" for non-constant coefficient homogeneous and non-homogeneous\n        systems respectively where the coefficient matrix can be factorized to a constant\n        coefficient matrix.\n        The default value is \"auto\" which will let the solver decide the correct type of\n        the system passed.\n    doit : Boolean\n        Evaluate the solution if True, default value is False\n    tau: Expression\n        Used to substitute for the value of `t` after we get the solution of the system.\n\n    Examples\n    ========\n\n    To solve the system of ODEs using this function directly, several things must be\n    done in the right order. Wrong inputs to the function will lead to incorrect results.\n\n    >>> from sympy import symbols, Function, Eq\n    >>> from sympy.solvers.ode.systems import canonical_odes, linear_ode_to_matrix, linodesolve, linodesolve_type\n    >>> from sympy.solvers.ode.subscheck import checkodesol\n    >>> f, g = symbols(\"f, g\", cls=Function)\n    >>> x, a = symbols(\"x, a\")\n    >>> funcs = [f(x), g(x)]\n    >>> eqs = [Eq(f(x).diff(x) - f(x), a*g(x) + 1), Eq(g(x).diff(x) + g(x), a*f(x))]\n\n    Here, it is important to note that before we derive the coefficient matrix, it is\n    important to get the system of ODEs into the desired form. For that we will use\n    :obj:`sympy.solvers.ode.systems.canonical_odes()`.\n\n    >>> eqs = canonical_odes(eqs, funcs, x)\n    >>> eqs\n    [[Eq(Derivative(f(x), x), a*g(x) + f(x) + 1), Eq(Derivative(g(x), x), a*f(x) - g(x))]]\n\n    Now, we will use :obj:`sympy.solvers.ode.systems.linear_ode_to_matrix()` to get the coefficient matrix and the\n    non-homogeneous term if it is there.\n\n    >>> eqs = eqs[0]\n    >>> (A1, A0), b = linear_ode_to_matrix(eqs, funcs, x, 1)\n    >>> A = A0\n\n    We have the coefficient matrices and the non-homogeneous term ready. Now, we can use\n    :obj:`sympy.solvers.ode.systems.linodesolve_type()` to get the information for the system of ODEs\n    to finally pass it to the solver.\n\n    >>> system_info = linodesolve_type(A, x, b=b)\n    >>> sol_vector = linodesolve(A, x, b=b, B=system_info['antiderivative'], type=system_info['type_of_equation'])\n\n    Now, we can prove if the solution is correct or not by using :obj:`sympy.solvers.ode.checkodesol()`\n\n    >>> sol = [Eq(f, s) for f, s in zip(funcs, sol_vector)]\n    >>> checkodesol(eqs, sol)\n    (True, [0, 0])\n\n    We can also use the doit method to evaluate the solutions passed by the function.\n\n    >>> sol_vector_evaluated = linodesolve(A, x, b=b, type=\"type2\", doit=True)\n\n    Now, we will look at a system of ODEs which is non-constant.\n\n    >>> eqs = [Eq(f(x).diff(x), f(x) + x*g(x)), Eq(g(x).diff(x), -x*f(x) + g(x))]\n\n    The system defined above is already in the desired form, so we do not have to convert it.\n\n    >>> (A1, A0), b = linear_ode_to_matrix(eqs, funcs, x, 1)\n    >>> A = A0\n\n    A user can also pass the commutative antiderivative required for type3 and type4 system of ODEs.\n    Passing an incorrect one will lead to incorrect results. If the coefficient matrix is not commutative\n    with its antiderivative, then :obj:`sympy.solvers.ode.systems.linodesolve_type()` raises a NotImplementedError.\n    If it does have a commutative antiderivative, then the function just returns the information about the system.\n\n    >>> system_info = linodesolve_type(A, x, b=b)\n\n    Now, we can pass the antiderivative as an argument to get the solution. If the system information is not\n    passed, then the solver will compute the required arguments internally.\n\n    >>> sol_vector = linodesolve(A, x, b=b)\n\n    Once again, we can verify the solution obtained.\n\n    >>> sol = [Eq(f, s) for f, s in zip(funcs, sol_vector)]\n    >>> checkodesol(eqs, sol)\n    (True, [0, 0])\n\n    Returns\n    =======\n\n    List\n\n    Raises\n    ======\n\n    ValueError\n        This error is raised when the coefficient matrix, non-homogeneous term\n        or the antiderivative, if passed, are not a matrix or\n        do not have correct dimensions\n    NonSquareMatrixError\n        When the coefficient matrix or its antiderivative, if passed is not a\n        square matrix\n    NotImplementedError\n        If the coefficient matrix does not have a commutative antiderivative\n\n    See Also\n    ========\n\n    linear_ode_to_matrix: Coefficient matrix computation function\n    canonical_odes: System of ODEs representation change\n    linodesolve_type: Getting information about systems of ODEs to pass in this solver\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_2eq_order1_type1",
    "full_id": "sympy.solvers.ode.ode._nonlinear_2eq_order1_type1",
    "type": "function",
    "description": "\n    Equations:\n\n    .. math:: x' = x^n F(x,y)\n\n    .. math:: y' = g(y) F(x,y)\n\n    Solution:\n\n    .. math:: x = \\varphi(y), \\int \\frac{1}{g(y) F(\\varphi(y),y)} \\,dy = t + C_2\n\n    where\n\n    if `n \\neq 1`\n\n    .. math:: \\varphi = [C_1 + (1-n) \\int \\frac{1}{g(y)} \\,dy]^{\\frac{1}{1-n}}\n\n    if `n = 1`\n\n    .. math:: \\varphi = C_1 e^{\\int \\frac{1}{g(y)} \\,dy}\n\n    where `C_1` and `C_2` are arbitrary constants.\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_2eq_order1_type2",
    "full_id": "sympy.solvers.ode.ode._nonlinear_2eq_order1_type2",
    "type": "function",
    "description": "\n    Equations:\n\n    .. math:: x' = e^{\\lambda x} F(x,y)\n\n    .. math:: y' = g(y) F(x,y)\n\n    Solution:\n\n    .. math:: x = \\varphi(y), \\int \\frac{1}{g(y) F(\\varphi(y),y)} \\,dy = t + C_2\n\n    where\n\n    if `\\lambda \\neq 0`\n\n    .. math:: \\varphi = -\\frac{1}{\\lambda} log(C_1 - \\lambda \\int \\frac{1}{g(y)} \\,dy)\n\n    if `\\lambda = 0`\n\n    .. math:: \\varphi = C_1 + \\int \\frac{1}{g(y)} \\,dy\n\n    where `C_1` and `C_2` are arbitrary constants.\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_2eq_order1_type3",
    "full_id": "sympy.solvers.ode.ode._nonlinear_2eq_order1_type3",
    "type": "function",
    "description": "\n    Autonomous system of general form\n\n    .. math:: x' = F(x,y)\n\n    .. math:: y' = G(x,y)\n\n    Assuming `y = y(x, C_1)` where `C_1` is an arbitrary constant is the general\n    solution of the first-order equation\n\n    .. math:: F(x,y) y'_x = G(x,y)\n\n    Then the general solution of the original system of equations has the form\n\n    .. math:: \\int \\frac{1}{F(x,y(x,C_1))} \\,dx = t + C_1\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_2eq_order1_type4",
    "full_id": "sympy.solvers.ode.ode._nonlinear_2eq_order1_type4",
    "type": "function",
    "description": "\n    Equation:\n\n    .. math:: x' = f_1(x) g_1(y) \\phi(x,y,t)\n\n    .. math:: y' = f_2(x) g_2(y) \\phi(x,y,t)\n\n    First integral:\n\n    .. math:: \\int \\frac{f_2(x)}{f_1(x)} \\,dx - \\int \\frac{g_1(y)}{g_2(y)} \\,dy = C\n\n    where `C` is an arbitrary constant.\n\n    On solving the first integral for `x` (resp., `y` ) and on substituting the\n    resulting expression into either equation of the original solution, one\n    arrives at a first-order equation for determining `y` (resp., `x` ).\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_2eq_order1_type5",
    "full_id": "sympy.solvers.ode.ode._nonlinear_2eq_order1_type5",
    "type": "function",
    "description": "\n    Clairaut system of ODEs\n\n    .. math:: x = t x' + F(x',y')\n\n    .. math:: y = t y' + G(x',y')\n\n    The following are solutions of the system\n\n    `(i)` straight lines:\n\n    .. math:: x = C_1 t + F(C_1, C_2), y = C_2 t + G(C_1, C_2)\n\n    where `C_1` and `C_2` are arbitrary constants;\n\n    `(ii)` envelopes of the above lines;\n\n    `(iii)` continuously differentiable lines made up from segments of the lines\n    `(i)` and `(ii)`.\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_3eq_order1_type1",
    "full_id": "sympy.solvers.ode.ode._nonlinear_3eq_order1_type1",
    "type": "function",
    "description": "\n    Equations:\n\n    .. math:: a x' = (b - c) y z, \\enspace b y' = (c - a) z x, \\enspace c z' = (a - b) x y\n\n    First Integrals:\n\n    .. math:: a x^{2} + b y^{2} + c z^{2} = C_1\n\n    .. math:: a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2} = C_2\n\n    where `C_1` and `C_2` are arbitrary constants. On solving the integrals for `y` and\n    `z` and on substituting the resulting expressions into the first equation of the\n    system, we arrives at a separable first-order equation on `x`. Similarly doing that\n    for other two equations, we will arrive at first order equation on `y` and `z` too.\n\n    References\n    ==========\n    -https://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_3eq_order1_type2",
    "full_id": "sympy.solvers.ode.ode._nonlinear_3eq_order1_type2",
    "type": "function",
    "description": "\n    Equations:\n\n    .. math:: a x' = (b - c) y z f(x, y, z, t)\n\n    .. math:: b y' = (c - a) z x f(x, y, z, t)\n\n    .. math:: c z' = (a - b) x y f(x, y, z, t)\n\n    First Integrals:\n\n    .. math:: a x^{2} + b y^{2} + c z^{2} = C_1\n\n    .. math:: a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2} = C_2\n\n    where `C_1` and `C_2` are arbitrary constants. On solving the integrals for `y` and\n    `z` and on substituting the resulting expressions into the first equation of the\n    system, we arrives at a first-order differential equations on `x`. Similarly doing\n    that for other two equations we will arrive at first order equation on `y` and `z`.\n\n    References\n    ==========\n    -https://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_3eq_order1_type3",
    "full_id": "sympy.solvers.ode.ode._nonlinear_3eq_order1_type3",
    "type": "function",
    "description": "\n    Equations:\n\n    .. math:: x' = c F_2 - b F_3, \\enspace y' = a F_3 - c F_1, \\enspace z' = b F_1 - a F_2\n\n    where `F_n = F_n(x, y, z, t)`.\n\n    1. First Integral:\n\n    .. math:: a x + b y + c z = C_1,\n\n    where C is an arbitrary constant.\n\n    2. If we assume function `F_n` to be independent of `t`,i.e, `F_n` = `F_n (x, y, z)`\n    Then, on eliminating `t` and `z` from the first two equation of the system, one\n    arrives at the first-order equation\n\n    .. math:: \\frac{dy}{dx} = \\frac{a F_3 (x, y, z) - c F_1 (x, y, z)}{c F_2 (x, y, z) -\n                b F_3 (x, y, z)}\n\n    where `z = \\frac{1}{c} (C_1 - a x - b y)`\n\n    References\n    ==========\n    -https://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_3eq_order1_type4",
    "full_id": "sympy.solvers.ode.ode._nonlinear_3eq_order1_type4",
    "type": "function",
    "description": "\n    Equations:\n\n    .. math:: x' = c z F_2 - b y F_3, \\enspace y' = a x F_3 - c z F_1, \\enspace z' = b y F_1 - a x F_2\n\n    where `F_n = F_n (x, y, z, t)`\n\n    1. First integral:\n\n    .. math:: a x^{2} + b y^{2} + c z^{2} = C_1\n\n    where `C` is an arbitrary constant.\n\n    2. Assuming the function `F_n` is independent of `t`: `F_n = F_n (x, y, z)`. Then on\n    eliminating `t` and `z` from the first two equations of the system, one arrives at\n    the first-order equation\n\n    .. math:: \\frac{dy}{dx} = \\frac{a x F_3 (x, y, z) - c z F_1 (x, y, z)}\n                {c z F_2 (x, y, z) - b y F_3 (x, y, z)}\n\n    where `z = \\pm \\sqrt{\\frac{1}{c} (C_1 - a x^{2} - b y^{2})}`\n\n    References\n    ==========\n    -https://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_nonlinear_3eq_order1_type5",
    "full_id": "sympy.solvers.ode.ode._nonlinear_3eq_order1_type5",
    "type": "function",
    "description": "\n    .. math:: x' = x (c F_2 - b F_3), \\enspace y' = y (a F_3 - c F_1), \\enspace z' = z (b F_1 - a F_2)\n\n    where `F_n = F_n (x, y, z, t)` and are arbitrary functions.\n\n    First Integral:\n\n    .. math:: \\left|x\\right|^{a} \\left|y\\right|^{b} \\left|z\\right|^{c} = C_1\n\n    where `C` is an arbitrary constant. If the function `F_n` is independent of `t`,\n    then, by eliminating `t` and `z` from the first two equations of the system, one\n    arrives at a first-order equation.\n\n    References\n    ==========\n    -https://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf\n\n    ",
    "section": "System of ODEs",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "_handle_Integral",
    "full_id": "sympy.solvers.ode.ode._handle_Integral",
    "type": "function",
    "description": "\n    Converts a solution with Integrals in it into an actual solution.\n\n    For most hints, this simply runs ``expr.doit()``.\n\n    ",
    "section": "Information on the ode module",
    "url": "https://docs.sympy.org/latest/modules/solvers/ode.html"
  },
  {
    "name": "pde_separate",
    "full_id": "sympy.solvers.pde.pde_separate",
    "type": "function",
    "description": "Separate variables in partial differential equation either by additive\n    or multiplicative separation approach. It tries to rewrite an equation so\n    that one of the specified variables occurs on a different side of the\n    equation than the others.\n\n    :param eq: Partial differential equation\n\n    :param fun: Original function F(x, y, z)\n\n    :param sep: List of separated functions [X(x), u(y, z)]\n\n    :param strategy: Separation strategy. You can choose between additive\n        separation ('add') and multiplicative separation ('mul') which is\n        default.\n\n    Examples\n    ========\n\n    >>> from sympy import E, Eq, Function, pde_separate, Derivative as D\n    >>> from sympy.abc import x, t\n    >>> u, X, T = map(Function, 'uXT')\n\n    >>> eq = Eq(D(u(x, t), x), E**(u(x, t))*D(u(x, t), t))\n    >>> pde_separate(eq, u(x, t), [X(x), T(t)], strategy='add')\n    [exp(-X(x))*Derivative(X(x), x), exp(T(t))*Derivative(T(t), t)]\n\n    >>> eq = Eq(D(u(x, t), x, 2), D(u(x, t), t, 2))\n    >>> pde_separate(eq, u(x, t), [X(x), T(t)], strategy='mul')\n    [Derivative(X(x), (x, 2))/X(x), Derivative(T(t), (t, 2))/T(t)]\n\n    See Also\n    ========\n    pde_separate_add, pde_separate_mul\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/pde.html"
  },
  {
    "name": "pde_separate_add",
    "full_id": "sympy.solvers.pde.pde_separate_add",
    "type": "function",
    "description": "\n    Helper function for searching additive separable solutions.\n\n    Consider an equation of two independent variables x, y and a dependent\n    variable w, we look for the product of two functions depending on different\n    arguments:\n\n    `w(x, y, z) = X(x) + y(y, z)`\n\n    Examples\n    ========\n\n    >>> from sympy import E, Eq, Function, pde_separate_add, Derivative as D\n    >>> from sympy.abc import x, t\n    >>> u, X, T = map(Function, 'uXT')\n\n    >>> eq = Eq(D(u(x, t), x), E**(u(x, t))*D(u(x, t), t))\n    >>> pde_separate_add(eq, u(x, t), [X(x), T(t)])\n    [exp(-X(x))*Derivative(X(x), x), exp(T(t))*Derivative(T(t), t)]\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/pde.html"
  },
  {
    "name": "pde_separate_mul",
    "full_id": "sympy.solvers.pde.pde_separate_mul",
    "type": "function",
    "description": "\n    Helper function for searching multiplicative separable solutions.\n\n    Consider an equation of two independent variables x, y and a dependent\n    variable w, we look for the product of two functions depending on different\n    arguments:\n\n    `w(x, y, z) = X(x)*u(y, z)`\n\n    Examples\n    ========\n\n    >>> from sympy import Function, Eq, pde_separate_mul, Derivative as D\n    >>> from sympy.abc import x, y\n    >>> u, X, Y = map(Function, 'uXY')\n\n    >>> eq = Eq(D(u(x, y), x, 2), D(u(x, y), y, 2))\n    >>> pde_separate_mul(eq, u(x, y), [X(x), Y(y)])\n    [Derivative(X(x), (x, 2))/X(x), Derivative(Y(y), (y, 2))/Y(y)]\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/pde.html"
  },
  {
    "name": "pdsolve",
    "full_id": "sympy.solvers.pde.pdsolve",
    "type": "function",
    "description": "\n    Solves any (supported) kind of partial differential equation.\n\n    **Usage**\n\n        pdsolve(eq, f(x,y), hint) -> Solve partial differential equation\n        eq for function f(x,y), using method hint.\n\n    **Details**\n\n        ``eq`` can be any supported partial differential equation (see\n            the pde docstring for supported methods).  This can either\n            be an Equality, or an expression, which is assumed to be\n            equal to 0.\n\n        ``f(x,y)`` is a function of two variables whose derivatives in that\n            variable make up the partial differential equation. In many\n            cases it is not necessary to provide this; it will be autodetected\n            (and an error raised if it could not be detected).\n\n        ``hint`` is the solving method that you want pdsolve to use.  Use\n            classify_pde(eq, f(x,y)) to get all of the possible hints for\n            a PDE.  The default hint, 'default', will use whatever hint\n            is returned first by classify_pde().  See Hints below for\n            more options that you can use for hint.\n\n        ``solvefun`` is the convention used for arbitrary functions returned\n            by the PDE solver. If not set by the user, it is set by default\n            to be F.\n\n    **Hints**\n\n        Aside from the various solving methods, there are also some\n        meta-hints that you can pass to pdsolve():\n\n        \"default\":\n                This uses whatever hint is returned first by\n                classify_pde(). This is the default argument to\n                pdsolve().\n\n        \"all\":\n                To make pdsolve apply all relevant classification hints,\n                use pdsolve(PDE, func, hint=\"all\").  This will return a\n                dictionary of hint:solution terms.  If a hint causes\n                pdsolve to raise the NotImplementedError, value of that\n                hint's key will be the exception object raised.  The\n                dictionary will also include some special keys:\n\n                - order: The order of the PDE.  See also ode_order() in\n                  deutils.py\n                - default: The solution that would be returned by\n                  default.  This is the one produced by the hint that\n                  appears first in the tuple returned by classify_pde().\n\n        \"all_Integral\":\n                This is the same as \"all\", except if a hint also has a\n                corresponding \"_Integral\" hint, it only returns the\n                \"_Integral\" hint.  This is useful if \"all\" causes\n                pdsolve() to hang because of a difficult or impossible\n                integral.  This meta-hint will also be much faster than\n                \"all\", because integrate() is an expensive routine.\n\n        See also the classify_pde() docstring for more info on hints,\n        and the pde docstring for a list of all supported hints.\n\n    **Tips**\n        - You can declare the derivative of an unknown function this way:\n\n            >>> from sympy import Function, Derivative\n            >>> from sympy.abc import x, y # x and y are the independent variables\n            >>> f = Function(\"f\")(x, y) # f is a function of x and y\n            >>> # fx will be the partial derivative of f with respect to x\n            >>> fx = Derivative(f, x)\n            >>> # fy will be the partial derivative of f with respect to y\n            >>> fy = Derivative(f, y)\n\n        - See test_pde.py for many tests, which serves also as a set of\n          examples for how to use pdsolve().\n        - pdsolve always returns an Equality class (except for the case\n          when the hint is \"all\" or \"all_Integral\"). Note that it is not possible\n          to get an explicit solution for f(x, y) as in the case of ODE's\n        - Do help(pde.pde_hintname) to get help more information on a\n          specific hint\n\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.pde import pdsolve\n    >>> from sympy import Function, Eq\n    >>> from sympy.abc import x, y\n    >>> f = Function('f')\n    >>> u = f(x, y)\n    >>> ux = u.diff(x)\n    >>> uy = u.diff(y)\n    >>> eq = Eq(1 + (2*(ux/u)) + (3*(uy/u)), 0)\n    >>> pdsolve(eq)\n    Eq(f(x, y), F(3*x - 2*y)*exp(-2*x/13 - 3*y/13))\n\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/pde.html"
  },
  {
    "name": "classify_pde",
    "full_id": "sympy.solvers.pde.classify_pde",
    "type": "function",
    "description": "\n    Returns a tuple of possible pdsolve() classifications for a PDE.\n\n    The tuple is ordered so that first item is the classification that\n    pdsolve() uses to solve the PDE by default.  In general,\n    classifications near the beginning of the list will produce\n    better solutions faster than those near the end, though there are\n    always exceptions.  To make pdsolve use a different classification,\n    use pdsolve(PDE, func, hint=<classification>).  See also the pdsolve()\n    docstring for different meta-hints you can use.\n\n    If ``dict`` is true, classify_pde() will return a dictionary of\n    hint:match expression terms. This is intended for internal use by\n    pdsolve().  Note that because dictionaries are ordered arbitrarily,\n    this will most likely not be in the same order as the tuple.\n\n    You can get help on different hints by doing help(pde.pde_hintname),\n    where hintname is the name of the hint without \"_Integral\".\n\n    See sympy.pde.allhints or the sympy.pde docstring for a list of all\n    supported hints that can be returned from classify_pde.\n\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.pde import classify_pde\n    >>> from sympy import Function, Eq\n    >>> from sympy.abc import x, y\n    >>> f = Function('f')\n    >>> u = f(x, y)\n    >>> ux = u.diff(x)\n    >>> uy = u.diff(y)\n    >>> eq = Eq(1 + (2*(ux/u)) + (3*(uy/u)), 0)\n    >>> classify_pde(eq)\n    ('1st_linear_constant_coeff_homogeneous',)\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/pde.html"
  },
  {
    "name": "checkpdesol",
    "full_id": "sympy.solvers.pde.checkpdesol",
    "type": "function",
    "description": "\n    Checks if the given solution satisfies the partial differential\n    equation.\n\n    pde is the partial differential equation which can be given in the\n    form of an equation or an expression. sol is the solution for which\n    the pde is to be checked. This can also be given in an equation or\n    an expression form. If the function is not provided, the helper\n    function _preprocess from deutils is used to identify the function.\n\n    If a sequence of solutions is passed, the same sort of container will be\n    used to return the result for each solution.\n\n    The following methods are currently being implemented to check if the\n    solution satisfies the PDE:\n\n        1. Directly substitute the solution in the PDE and check. If the\n           solution has not been solved for f, then it will solve for f\n           provided solve_for_func has not been set to False.\n\n    If the solution satisfies the PDE, then a tuple (True, 0) is returned.\n    Otherwise a tuple (False, expr) where expr is the value obtained\n    after substituting the solution in the PDE. However if a known solution\n    returns False, it may be due to the inability of doit() to simplify it to zero.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, symbols\n    >>> from sympy.solvers.pde import checkpdesol, pdsolve\n    >>> x, y = symbols('x y')\n    >>> f = Function('f')\n    >>> eq = 2*f(x,y) + 3*f(x,y).diff(x) + 4*f(x,y).diff(y)\n    >>> sol = pdsolve(eq)\n    >>> assert checkpdesol(eq, sol)[0]\n    >>> eq = x*f(x,y) + f(x,y).diff(x)\n    >>> checkpdesol(eq, sol)\n    (False, (x*F(4*x - 3*y) - 6*F(4*x - 3*y)/25 + 4*Subs(Derivative(F(_xi_1), _xi_1), _xi_1, 4*x - 3*y))*exp(-6*x/25 - 8*y/25))\n    ",
    "section": "User Functions",
    "url": "https://docs.sympy.org/latest/modules/solvers/pde.html"
  },
  {
    "name": "pde_1st_linear_constant_coeff_homogeneous",
    "full_id": "sympy.solvers.pde.pde_1st_linear_constant_coeff_homogeneous",
    "type": "function",
    "description": "\n    Solves a first order linear homogeneous\n    partial differential equation with constant coefficients.\n\n    The general form of this partial differential equation is\n\n    .. math:: a \\frac{\\partial f(x,y)}{\\partial x}\n              + b \\frac{\\partial f(x,y)}{\\partial y} + c f(x,y) = 0\n\n    where `a`, `b` and `c` are constants.\n\n    The general solution is of the form:\n\n    .. math::\n        f(x, y) = F(- a y + b x ) e^{- \\frac{c (a x + b y)}{a^2 + b^2}}\n\n    and can be found in SymPy with ``pdsolve``::\n\n        >>> from sympy.solvers import pdsolve\n        >>> from sympy.abc import x, y, a, b, c\n        >>> from sympy import Function, pprint\n        >>> f = Function('f')\n        >>> u = f(x,y)\n        >>> ux = u.diff(x)\n        >>> uy = u.diff(y)\n        >>> genform = a*ux + b*uy + c*u\n        >>> pprint(genform)\n          d               d\n        a*--(f(x, y)) + b*--(f(x, y)) + c*f(x, y)\n          dx              dy\n\n        >>> pprint(pdsolve(genform))\n                                 -c*(a*x + b*y)\n                                 ---------------\n                                      2    2\n                                     a  + b\n        f(x, y) = F(-a*y + b*x)*e\n\n    Examples\n    ========\n\n    >>> from sympy import pdsolve\n    >>> from sympy import Function, pprint\n    >>> from sympy.abc import x,y\n    >>> f = Function('f')\n    >>> pdsolve(f(x,y) + f(x,y).diff(x) + f(x,y).diff(y))\n    Eq(f(x, y), F(x - y)*exp(-x/2 - y/2))\n    >>> pprint(pdsolve(f(x,y) + f(x,y).diff(x) + f(x,y).diff(y)))\n                          x   y\n                        - - - -\n                          2   2\n    f(x, y) = F(x - y)*e\n\n    References\n    ==========\n\n    - Viktor Grigoryan, \"Partial Differential Equations\"\n      Math 124A - Fall 2010, pp.7\n\n    ",
    "section": "Hint Methods",
    "url": "https://docs.sympy.org/latest/modules/solvers/pde.html"
  },
  {
    "name": "pde_1st_linear_constant_coeff",
    "full_id": "sympy.solvers.pde.pde_1st_linear_constant_coeff",
    "type": "function",
    "description": "\n    Solves a first order linear partial differential equation\n    with constant coefficients.\n\n    The general form of this partial differential equation is\n\n    .. math:: a \\frac{\\partial f(x,y)}{\\partial x}\n              + b \\frac{\\partial f(x,y)}{\\partial y}\n              + c f(x,y) = G(x,y)\n\n    where `a`, `b` and `c` are constants and `G(x, y)` can be an arbitrary\n    function in `x` and `y`.\n\n    The general solution of the PDE is:\n\n    .. math::\n        f(x, y) = \\left. \\left[F(\\eta) + \\frac{1}{a^2 + b^2}\n        \\int\\limits^{a x + b y} G\\left(\\frac{a \\xi + b \\eta}{a^2 + b^2},\n        \\frac{- a \\eta + b \\xi}{a^2 + b^2} \\right)\n        e^{\\frac{c \\xi}{a^2 + b^2}}\\, d\\xi\\right]\n        e^{- \\frac{c \\xi}{a^2 + b^2}}\n        \\right|_{\\substack{\\eta=- a y + b x\\\\ \\xi=a x + b y }}\\, ,\n\n    where `F(\\eta)` is an arbitrary single-valued function. The solution\n    can be found in SymPy with ``pdsolve``::\n\n        >>> from sympy.solvers import pdsolve\n        >>> from sympy.abc import x, y, a, b, c\n        >>> from sympy import Function, pprint\n        >>> f = Function('f')\n        >>> G = Function('G')\n        >>> u = f(x, y)\n        >>> ux = u.diff(x)\n        >>> uy = u.diff(y)\n        >>> genform = a*ux + b*uy + c*u - G(x,y)\n        >>> pprint(genform)\n          d               d\n        a*--(f(x, y)) + b*--(f(x, y)) + c*f(x, y) - G(x, y)\n          dx              dy\n        >>> pprint(pdsolve(genform, hint='1st_linear_constant_coeff_Integral'))\n                  //          a*x + b*y                                             \\         \\|\n                  ||              /                                                 |         ||\n                  ||             |                                                  |         ||\n                  ||             |                                      c*xi        |         ||\n                  ||             |                                     -------      |         ||\n                  ||             |                                      2    2      |         ||\n                  ||             |      /a*xi + b*eta  -a*eta + b*xi\\  a  + b       |         ||\n                  ||             |     G|------------, -------------|*e        d(xi)|         ||\n                  ||             |      |   2    2         2    2   |               |         ||\n                  ||             |      \\  a  + b         a  + b    /               |  -c*xi  ||\n                  ||             |                                                  |  -------||\n                  ||            /                                                   |   2    2||\n                  ||                                                                |  a  + b ||\n        f(x, y) = ||F(eta) + -------------------------------------------------------|*e       ||\n                  ||                                  2    2                        |         ||\n                  \\\\                                 a  + b                         /         /|eta=-a*y + b*x, xi=a*x + b*y\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.pde import pdsolve\n    >>> from sympy import Function, pprint, exp\n    >>> from sympy.abc import x,y\n    >>> f = Function('f')\n    >>> eq = -2*f(x,y).diff(x) + 4*f(x,y).diff(y) + 5*f(x,y) - exp(x + 3*y)\n    >>> pdsolve(eq)\n    Eq(f(x, y), (F(4*x + 2*y)*exp(x/2) + exp(x + 4*y)/15)*exp(-y))\n\n    References\n    ==========\n\n    - Viktor Grigoryan, \"Partial Differential Equations\"\n      Math 124A - Fall 2010, pp.7\n\n    ",
    "section": "Hint Methods",
    "url": "https://docs.sympy.org/latest/modules/solvers/pde.html"
  },
  {
    "name": "pde_1st_linear_variable_coeff",
    "full_id": "sympy.solvers.pde.pde_1st_linear_variable_coeff",
    "type": "function",
    "description": "\n    Solves a first order linear partial differential equation\n    with variable coefficients. The general form of this partial\n    differential equation is\n\n    .. math:: a(x, y) \\frac{\\partial f(x, y)}{\\partial x}\n                + b(x, y) \\frac{\\partial f(x, y)}{\\partial y}\n                + c(x, y) f(x, y) = G(x, y)\n\n    where `a(x, y)`, `b(x, y)`, `c(x, y)` and `G(x, y)` are arbitrary\n    functions in `x` and `y`. This PDE is converted into an ODE by\n    making the following transformation:\n\n    1. `\\xi` as `x`\n\n    2. `\\eta` as the constant in the solution to the differential\n       equation `\\frac{dy}{dx} = -\\frac{b}{a}`\n\n    Making the previous substitutions reduces it to the linear ODE\n\n    .. math:: a(\\xi, \\eta)\\frac{du}{d\\xi} + c(\\xi, \\eta)u - G(\\xi, \\eta) = 0\n\n    which can be solved using ``dsolve``.\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import Function, pprint\n    >>> a, b, c, G, f= [Function(i) for i in ['a', 'b', 'c', 'G', 'f']]\n    >>> u = f(x,y)\n    >>> ux = u.diff(x)\n    >>> uy = u.diff(y)\n    >>> genform = a(x, y)*u + b(x, y)*ux + c(x, y)*uy - G(x,y)\n    >>> pprint(genform)\n                                         d                     d\n    -G(x, y) + a(x, y)*f(x, y) + b(x, y)*--(f(x, y)) + c(x, y)*--(f(x, y))\n                                         dx                    dy\n\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.pde import pdsolve\n    >>> from sympy import Function, pprint\n    >>> from sympy.abc import x,y\n    >>> f = Function('f')\n    >>> eq =  x*(u.diff(x)) - y*(u.diff(y)) + y**2*u - y**2\n    >>> pdsolve(eq)\n    Eq(f(x, y), F(x*y)*exp(y**2/2) + 1)\n\n    References\n    ==========\n\n    - Viktor Grigoryan, \"Partial Differential Equations\"\n      Math 124A - Fall 2010, pp.7\n\n    ",
    "section": "Hint Methods",
    "url": "https://docs.sympy.org/latest/modules/solvers/pde.html"
  },
  {
    "name": "solve",
    "full_id": "sympy.solvers.solvers.solve",
    "type": "function",
    "description": "\n    Algebraically solves equations and systems of equations.\n\n    Explanation\n    ===========\n\n    Currently supported:\n        - polynomial\n        - transcendental\n        - piecewise combinations of the above\n        - systems of linear and polynomial equations\n        - systems containing relational expressions\n        - systems implied by undetermined coefficients\n\n    Examples\n    ========\n\n    The default output varies according to the input and might\n    be a list (possibly empty), a dictionary, a list of\n    dictionaries or tuples, or an expression involving relationals.\n    For specifics regarding different forms of output that may appear, see :ref:`solve_output`.\n    Let it suffice here to say that to obtain a uniform output from\n    `solve` use ``dict=True`` or ``set=True`` (see below).\n\n        >>> from sympy import solve, Poly, Eq, Matrix, Symbol\n        >>> from sympy.abc import x, y, z, a, b\n\n    The expressions that are passed can be Expr, Equality, or Poly\n    classes (or lists of the same); a Matrix is considered to be a\n    list of all the elements of the matrix:\n\n        >>> solve(x - 3, x)\n        [3]\n        >>> solve(Eq(x, 3), x)\n        [3]\n        >>> solve(Poly(x - 3), x)\n        [3]\n        >>> solve(Matrix([[x, x + y]]), x, y) == solve([x, x + y], x, y)\n        True\n\n    If no symbols are indicated to be of interest and the equation is\n    univariate, a list of values is returned; otherwise, the keys in\n    a dictionary will indicate which (of all the variables used in\n    the expression(s)) variables and solutions were found:\n\n        >>> solve(x**2 - 4)\n        [-2, 2]\n        >>> solve((x - a)*(y - b))\n        [{a: x}, {b: y}]\n        >>> solve([x - 3, y - 1])\n        {x: 3, y: 1}\n        >>> solve([x - 3, y**2 - 1])\n        [{x: 3, y: -1}, {x: 3, y: 1}]\n\n    If you pass symbols for which solutions are sought, the output will vary\n    depending on the number of symbols you passed, whether you are passing\n    a list of expressions or not, and whether a linear system was solved.\n    Uniform output is attained by using ``dict=True`` or ``set=True``.\n\n        >>> #### *** feel free to skip to the stars below *** ####\n        >>> from sympy import TableForm\n        >>> h = [None, ';|;'.join(['e', 's', 'solve(e, s)', 'solve(e, s, dict=True)',\n        ... 'solve(e, s, set=True)']).split(';')]\n        >>> t = []\n        >>> for e, s in [\n        ...         (x - y, y),\n        ...         (x - y, [x, y]),\n        ...         (x**2 - y, [x, y]),\n        ...         ([x - 3, y -1], [x, y]),\n        ...         ]:\n        ...     how = [{}, dict(dict=True), dict(set=True)]\n        ...     res = [solve(e, s, **f) for f in how]\n        ...     t.append([e, '|', s, '|'] + [res[0], '|', res[1], '|', res[2]])\n        ...\n        >>> # ******************************************************* #\n        >>> TableForm(t, headings=h, alignments=\"<\")\n        e              | s      | solve(e, s)  | solve(e, s, dict=True) | solve(e, s, set=True)\n        ---------------------------------------------------------------------------------------\n        x - y          | y      | [x]          | [{y: x}]               | ([y], {(x,)})\n        x - y          | [x, y] | [(y, y)]     | [{x: y}]               | ([x, y], {(y, y)})\n        x**2 - y       | [x, y] | [(x, x**2)]  | [{y: x**2}]            | ([x, y], {(x, x**2)})\n        [x - 3, y - 1] | [x, y] | {x: 3, y: 1} | [{x: 3, y: 1}]         | ([x, y], {(3, 1)})\n\n        * If any equation does not depend on the symbol(s) given, it will be\n          eliminated from the equation set and an answer may be given\n          implicitly in terms of variables that were not of interest:\n\n            >>> solve([x - y, y - 3], x)\n            {x: y}\n\n    When you pass all but one of the free symbols, an attempt\n    is made to find a single solution based on the method of\n    undetermined coefficients. If it succeeds, a dictionary of values\n    is returned. If you want an algebraic solutions for one\n    or more of the symbols, pass the expression to be solved in a list:\n\n        >>> e = a*x + b - 2*x - 3\n        >>> solve(e, [a, b])\n        {a: 2, b: 3}\n        >>> solve([e], [a, b])\n        {a: -b/x + (2*x + 3)/x}\n\n    When there is no solution for any given symbol which will make all\n    expressions zero, the empty list is returned (or an empty set in\n    the tuple when ``set=True``):\n\n        >>> from sympy import sqrt\n        >>> solve(3, x)\n        []\n        >>> solve(x - 3, y)\n        []\n        >>> solve(sqrt(x) + 1, x, set=True)\n        ([x], set())\n\n    When an object other than a Symbol is given as a symbol, it is\n    isolated algebraically and an implicit solution may be obtained.\n    This is mostly provided as a convenience to save you from replacing\n    the object with a Symbol and solving for that Symbol. It will only\n    work if the specified object can be replaced with a Symbol using the\n    subs method:\n\n        >>> from sympy import exp, Function\n        >>> f = Function('f')\n\n        >>> solve(f(x) - x, f(x))\n        [x]\n        >>> solve(f(x).diff(x) - f(x) - x, f(x).diff(x))\n        [x + f(x)]\n        >>> solve(f(x).diff(x) - f(x) - x, f(x))\n        [-x + Derivative(f(x), x)]\n        >>> solve(x + exp(x)**2, exp(x), set=True)\n        ([exp(x)], {(-sqrt(-x),), (sqrt(-x),)})\n\n        >>> from sympy import Indexed, IndexedBase, Tuple\n        >>> A = IndexedBase('A')\n        >>> eqs = Tuple(A[1] + A[2] - 3, A[1] - A[2] + 1)\n        >>> solve(eqs, eqs.atoms(Indexed))\n        {A[1]: 1, A[2]: 2}\n\n        * To solve for a function within a derivative, use :func:`~.dsolve`.\n\n    To solve for a symbol implicitly, use implicit=True:\n\n        >>> solve(x + exp(x), x)\n        [-LambertW(1)]\n        >>> solve(x + exp(x), x, implicit=True)\n        [-exp(x)]\n\n    It is possible to solve for anything in an expression that can be\n    replaced with a symbol using :obj:`~sympy.core.basic.Basic.subs`:\n\n        >>> solve(x + 2 + sqrt(3), x + 2)\n        [-sqrt(3)]\n        >>> solve((x + 2 + sqrt(3), x + 4 + y), y, x + 2)\n        {y: -2 + sqrt(3), x + 2: -sqrt(3)}\n\n        * Nothing heroic is done in this implicit solving so you may end up\n          with a symbol still in the solution:\n\n            >>> eqs = (x*y + 3*y + sqrt(3), x + 4 + y)\n            >>> solve(eqs, y, x + 2)\n            {y: -sqrt(3)/(x + 3), x + 2: -2*x/(x + 3) - 6/(x + 3) + sqrt(3)/(x + 3)}\n            >>> solve(eqs, y*x, x)\n            {x: -y - 4, x*y: -3*y - sqrt(3)}\n\n        * If you attempt to solve for a number, remember that the number\n          you have obtained does not necessarily mean that the value is\n          equivalent to the expression obtained:\n\n            >>> solve(sqrt(2) - 1, 1)\n            [sqrt(2)]\n            >>> solve(x - y + 1, 1)  # /!\\ -1 is targeted, too\n            [x/(y - 1)]\n            >>> [_.subs(z, -1) for _ in solve((x - y + 1).subs(-1, z), 1)]\n            [-x + y]\n\n    **Additional Examples**\n\n    ``solve()`` with check=True (default) will run through the symbol tags to\n    eliminate unwanted solutions. If no assumptions are included, all possible\n    solutions will be returned:\n\n        >>> x = Symbol(\"x\")\n        >>> solve(x**2 - 1)\n        [-1, 1]\n\n    By setting the ``positive`` flag, only one solution will be returned:\n\n        >>> pos = Symbol(\"pos\", positive=True)\n        >>> solve(pos**2 - 1)\n        [1]\n\n    When the solutions are checked, those that make any denominator zero\n    are automatically excluded. If you do not want to exclude such solutions,\n    then use the check=False option:\n\n        >>> from sympy import sin, limit\n        >>> solve(sin(x)/x)  # 0 is excluded\n        [pi]\n\n    If ``check=False``, then a solution to the numerator being zero is found\n    but the value of $x = 0$ is a spurious solution since $\\sin(x)/x$ has the well\n    known limit (without discontinuity) of 1 at $x = 0$:\n\n        >>> solve(sin(x)/x, check=False)\n        [0, pi]\n\n    In the following case, however, the limit exists and is equal to the\n    value of $x = 0$ that is excluded when check=True:\n\n        >>> eq = x**2*(1/x - z**2/x)\n        >>> solve(eq, x)\n        []\n        >>> solve(eq, x, check=False)\n        [0]\n        >>> limit(eq, x, 0, '-')\n        0\n        >>> limit(eq, x, 0, '+')\n        0\n\n    **Solving Relationships**\n\n    When one or more expressions passed to ``solve`` is a relational,\n    a relational result is returned (and the ``dict`` and ``set`` flags\n    are ignored):\n\n        >>> solve(x < 3)\n        (-oo < x) & (x < 3)\n        >>> solve([x < 3, x**2 > 4], x)\n        ((-oo < x) & (x < -2)) | ((2 < x) & (x < 3))\n        >>> solve([x + y - 3, x > 3], x)\n        (3 < x) & (x < oo) & Eq(x, 3 - y)\n\n    Although checking of assumptions on symbols in relationals\n    is not done, setting assumptions will affect how certain\n    relationals might automatically simplify:\n\n        >>> solve(x**2 > 4)\n        ((-oo < x) & (x < -2)) | ((2 < x) & (x < oo))\n\n        >>> r = Symbol('r', real=True)\n        >>> solve(r**2 > 4)\n        (2 < r) | (r < -2)\n\n    There is currently no algorithm in SymPy that allows you to use\n    relationships to resolve more than one variable. So the following\n    does not determine that ``q < 0`` (and trying to solve for ``r``\n    and ``q`` will raise an error):\n\n        >>> from sympy import symbols\n        >>> r, q = symbols('r, q', real=True)\n        >>> solve([r + q - 3, r > 3], r)\n        (3 < r) & Eq(r, 3 - q)\n\n    You can directly call the routine that ``solve`` calls\n    when it encounters a relational: :func:`~.reduce_inequalities`.\n    It treats Expr like Equality.\n\n        >>> from sympy import reduce_inequalities\n        >>> reduce_inequalities([x**2 - 4])\n        Eq(x, -2) | Eq(x, 2)\n\n    If each relationship contains only one symbol of interest,\n    the expressions can be processed for multiple symbols:\n\n        >>> reduce_inequalities([0 <= x  - 1, y < 3], [x, y])\n        (-oo < y) & (1 <= x) & (x < oo) & (y < 3)\n\n    But an error is raised if any relationship has more than one\n    symbol of interest:\n\n        >>> reduce_inequalities([0 <= x*y  - 1, y < 3], [x, y])\n        Traceback (most recent call last):\n        ...\n        NotImplementedError:\n        inequality has more than one symbol of interest.\n\n    **Disabling High-Order Explicit Solutions**\n\n    When solving polynomial expressions, you might not want explicit solutions\n    (which can be quite long). If the expression is univariate, ``CRootOf``\n    instances will be returned instead:\n\n        >>> solve(x**3 - x + 1)\n        [-1/((-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)) -\n        (-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3,\n        -(-1/2 + sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3 -\n        1/((-1/2 + sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)),\n        -(3*sqrt(69)/2 + 27/2)**(1/3)/3 -\n        1/(3*sqrt(69)/2 + 27/2)**(1/3)]\n        >>> solve(x**3 - x + 1, cubics=False)\n        [CRootOf(x**3 - x + 1, 0),\n         CRootOf(x**3 - x + 1, 1),\n         CRootOf(x**3 - x + 1, 2)]\n\n    If the expression is multivariate, no solution might be returned:\n\n        >>> solve(x**3 - x + a, x, cubics=False)\n        []\n\n    Sometimes solutions will be obtained even when a flag is False because the\n    expression could be factored. In the following example, the equation can\n    be factored as the product of a linear and a quadratic factor so explicit\n    solutions (which did not require solving a cubic expression) are obtained:\n\n        >>> eq = x**3 + 3*x**2 + x - 1\n        >>> solve(eq, cubics=False)\n        [-1, -1 + sqrt(2), -sqrt(2) - 1]\n\n    **Solving Equations Involving Radicals**\n\n    Because of SymPy's use of the principle root, some solutions\n    to radical equations will be missed unless check=False:\n\n        >>> from sympy import root\n        >>> eq = root(x**3 - 3*x**2, 3) + 1 - x\n        >>> solve(eq)\n        []\n        >>> solve(eq, check=False)\n        [1/3]\n\n    In the above example, there is only a single solution to the\n    equation. Other expressions will yield spurious roots which\n    must be checked manually; roots which give a negative argument\n    to odd-powered radicals will also need special checking:\n\n        >>> from sympy import real_root, S\n        >>> eq = root(x, 3) - root(x, 5) + S(1)/7\n        >>> solve(eq)  # this gives 2 solutions but misses a 3rd\n        [CRootOf(7*x**5 - 7*x**3 + 1, 1)**15,\n        CRootOf(7*x**5 - 7*x**3 + 1, 2)**15]\n        >>> sol = solve(eq, check=False)\n        >>> [abs(eq.subs(x,i).n(2)) for i in sol]\n        [0.48, 0.e-110, 0.e-110, 0.052, 0.052]\n\n    The first solution is negative so ``real_root`` must be used to see that it\n    satisfies the expression:\n\n        >>> abs(real_root(eq.subs(x, sol[0])).n(2))\n        0.e-110\n\n    If the roots of the equation are not real then more care will be\n    necessary to find the roots, especially for higher order equations.\n    Consider the following expression:\n\n        >>> expr = root(x, 3) - root(x, 5)\n\n    We will construct a known value for this expression at x = 3 by selecting\n    the 1-th root for each radical:\n\n        >>> expr1 = root(x, 3, 1) - root(x, 5, 1)\n        >>> v = expr1.subs(x, -3)\n\n    The ``solve`` function is unable to find any exact roots to this equation:\n\n        >>> eq = Eq(expr, v); eq1 = Eq(expr1, v)\n        >>> solve(eq, check=False), solve(eq1, check=False)\n        ([], [])\n\n    The function ``unrad``, however, can be used to get a form of the equation\n    for which numerical roots can be found:\n\n        >>> from sympy.solvers.solvers import unrad\n        >>> from sympy import nroots\n        >>> e, (p, cov) = unrad(eq)\n        >>> pvals = nroots(e)\n        >>> inversion = solve(cov, x)[0]\n        >>> xvals = [inversion.subs(p, i) for i in pvals]\n\n    Although ``eq`` or ``eq1`` could have been used to find ``xvals``, the\n    solution can only be verified with ``expr1``:\n\n        >>> z = expr - v\n        >>> [xi.n(chop=1e-9) for xi in xvals if abs(z.subs(x, xi).n()) < 1e-9]\n        []\n        >>> z1 = expr1 - v\n        >>> [xi.n(chop=1e-9) for xi in xvals if abs(z1.subs(x, xi).n()) < 1e-9]\n        [-3.0]\n\n    Parameters\n    ==========\n\n    f :\n        - a single Expr or Poly that must be zero\n        - an Equality\n        - a Relational expression\n        - a Boolean\n        - iterable of one or more of the above\n\n    symbols : (object(s) to solve for) specified as\n        - none given (other non-numeric objects will be used)\n        - single symbol\n        - denested list of symbols\n          (e.g., ``solve(f, x, y)``)\n        - ordered iterable of symbols\n          (e.g., ``solve(f, [x, y])``)\n\n    flags :\n        dict=True (default is False)\n            Return list (perhaps empty) of solution mappings.\n        set=True (default is False)\n            Return list of symbols and set of tuple(s) of solution(s).\n        exclude=[] (default)\n            Do not try to solve for any of the free symbols in exclude;\n            if expressions are given, the free symbols in them will\n            be extracted automatically.\n        check=True (default)\n            If False, do not do any testing of solutions. This can be\n            useful if you want to include solutions that make any\n            denominator zero.\n        numerical=True (default)\n            Do a fast numerical check if *f* has only one symbol.\n        minimal=True (default is False)\n            A very fast, minimal testing.\n        warn=True (default is False)\n            Show a warning if ``checksol()`` could not conclude.\n        simplify=True (default)\n            Simplify all but polynomials of order 3 or greater before\n            returning them and (if check is not False) use the\n            general simplify function on the solutions and the\n            expression obtained when they are substituted into the\n            function which should be zero.\n        force=True (default is False)\n            Make positive all symbols without assumptions regarding sign.\n        rational=True (default)\n            Recast Floats as Rational; if this option is not used, the\n            system containing Floats may fail to solve because of issues\n            with polys. If rational=None, Floats will be recast as\n            rationals but the answer will be recast as Floats. If the\n            flag is False then nothing will be done to the Floats.\n        manual=True (default is False)\n            Do not use the polys/matrix method to solve a system of\n            equations, solve them one at a time as you might \"manually.\"\n        implicit=True (default is False)\n            Allows ``solve`` to return a solution for a pattern in terms of\n            other functions that contain that pattern; this is only\n            needed if the pattern is inside of some invertible function\n            like cos, exp, ect.\n        particular=True (default is False)\n            Instructs ``solve`` to try to find a particular solution to\n            a linear system with as many zeros as possible; this is very\n            expensive.\n        quick=True (default is False; ``particular`` must be True)\n            Selects a fast heuristic to find a solution with many zeros\n            whereas a value of False uses the very slow method guaranteed\n            to find the largest number of zeros possible.\n        cubics=True (default)\n            Return explicit solutions when cubic expressions are encountered.\n            When False, quartics and quintics are disabled, too.\n        quartics=True (default)\n            Return explicit solutions when quartic expressions are encountered.\n            When False, quintics are disabled, too.\n        quintics=True (default)\n            Return explicit solutions (if possible) when quintic expressions\n            are encountered.\n\n    See Also\n    ========\n\n    rsolve: For solving recurrence relationships\n    dsolve: For solving differential equations\n\n    ",
    "section": "Algebraic equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "solve_linear",
    "full_id": "sympy.solvers.solvers.solve_linear",
    "type": "function",
    "description": "\n    Return a tuple derived from ``f = lhs - rhs`` that is one of\n    the following: ``(0, 1)``, ``(0, 0)``, ``(symbol, solution)``, ``(n, d)``.\n\n    Explanation\n    ===========\n\n    ``(0, 1)`` meaning that ``f`` is independent of the symbols in *symbols*\n    that are not in *exclude*.\n\n    ``(0, 0)`` meaning that there is no solution to the equation amongst the\n    symbols given. If the first element of the tuple is not zero, then the\n    function is guaranteed to be dependent on a symbol in *symbols*.\n\n    ``(symbol, solution)`` where symbol appears linearly in the numerator of\n    ``f``, is in *symbols* (if given), and is not in *exclude* (if given). No\n    simplification is done to ``f`` other than a ``mul=True`` expansion, so the\n    solution will correspond strictly to a unique solution.\n\n    ``(n, d)`` where ``n`` and ``d`` are the numerator and denominator of ``f``\n    when the numerator was not linear in any symbol of interest; ``n`` will\n    never be a symbol unless a solution for that symbol was found (in which case\n    the second element is the solution, not the denominator).\n\n    Examples\n    ========\n\n    >>> from sympy import cancel, Pow\n\n    ``f`` is independent of the symbols in *symbols* that are not in\n    *exclude*:\n\n    >>> from sympy import cos, sin, solve_linear\n    >>> from sympy.abc import x, y, z\n    >>> eq = y*cos(x)**2 + y*sin(x)**2 - y  # = y*(1 - 1) = 0\n    >>> solve_linear(eq)\n    (0, 1)\n    >>> eq = cos(x)**2 + sin(x)**2  # = 1\n    >>> solve_linear(eq)\n    (0, 1)\n    >>> solve_linear(x, exclude=[x])\n    (0, 1)\n\n    The variable ``x`` appears as a linear variable in each of the\n    following:\n\n    >>> solve_linear(x + y**2)\n    (x, -y**2)\n    >>> solve_linear(1/x - y**2)\n    (x, y**(-2))\n\n    When not linear in ``x`` or ``y`` then the numerator and denominator are\n    returned:\n\n    >>> solve_linear(x**2/y**2 - 3)\n    (x**2 - 3*y**2, y**2)\n\n    If the numerator of the expression is a symbol, then ``(0, 0)`` is\n    returned if the solution for that symbol would have set any\n    denominator to 0:\n\n    >>> eq = 1/(1/x - 2)\n    >>> eq.as_numer_denom()\n    (x, 1 - 2*x)\n    >>> solve_linear(eq)\n    (0, 0)\n\n    But automatic rewriting may cause a symbol in the denominator to\n    appear in the numerator so a solution will be returned:\n\n    >>> (1/x)**-1\n    x\n    >>> solve_linear((1/x)**-1)\n    (x, 0)\n\n    Use an unevaluated expression to avoid this:\n\n    >>> solve_linear(Pow(1/x, -1, evaluate=False))\n    (0, 0)\n\n    If ``x`` is allowed to cancel in the following expression, then it\n    appears to be linear in ``x``, but this sort of cancellation is not\n    done by ``solve_linear`` so the solution will always satisfy the\n    original expression without causing a division by zero error.\n\n    >>> eq = x**2*(1/x - z**2/x)\n    >>> solve_linear(cancel(eq))\n    (x, 0)\n    >>> solve_linear(eq)\n    (x**2*(1 - z**2), x)\n\n    A list of symbols for which a solution is desired may be given:\n\n    >>> solve_linear(x + y + z, symbols=[y])\n    (y, -x - z)\n\n    A list of symbols to ignore may also be given:\n\n    >>> solve_linear(x + y + z, exclude=[x])\n    (y, -x - z)\n\n    (A solution for ``y`` is obtained because it is the first variable\n    from the canonically sorted list of symbols that had a linear\n    solution.)\n\n    ",
    "section": "Algebraic equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "solve_linear_system",
    "full_id": "sympy.solvers.solvers.solve_linear_system",
    "type": "function",
    "description": "\n    Solve system of $N$ linear equations with $M$ variables, which means\n    both under- and overdetermined systems are supported.\n\n    Explanation\n    ===========\n\n    The possible number of solutions is zero, one, or infinite. Respectively,\n    this procedure will return None or a dictionary with solutions. In the\n    case of underdetermined systems, all arbitrary parameters are skipped.\n    This may cause a situation in which an empty dictionary is returned.\n    In that case, all symbols can be assigned arbitrary values.\n\n    Input to this function is a $N\\times M + 1$ matrix, which means it has\n    to be in augmented form. If you prefer to enter $N$ equations and $M$\n    unknowns then use ``solve(Neqs, *Msymbols)`` instead. Note: a local\n    copy of the matrix is made by this routine so the matrix that is\n    passed will not be modified.\n\n    The algorithm used here is fraction-free Gaussian elimination,\n    which results, after elimination, in an upper-triangular matrix.\n    Then solutions are found using back-substitution. This approach\n    is more efficient and compact than the Gauss-Jordan method.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, solve_linear_system\n    >>> from sympy.abc import x, y\n\n    Solve the following system::\n\n           x + 4 y ==  2\n        -2 x +   y == 14\n\n    >>> system = Matrix(( (1, 4, 2), (-2, 1, 14)))\n    >>> solve_linear_system(system, x, y)\n    {x: -6, y: 2}\n\n    A degenerate system returns an empty dictionary:\n\n    >>> system = Matrix(( (0,0,0), (0,0,0) ))\n    >>> solve_linear_system(system, x, y)\n    {}\n\n    ",
    "section": "Algebraic equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "solve_linear_system_LU",
    "full_id": "sympy.solvers.solvers.solve_linear_system_LU",
    "type": "function",
    "description": "\n    Solves the augmented matrix system using ``LUsolve`` and returns a\n    dictionary in which solutions are keyed to the symbols of *syms* as ordered.\n\n    Explanation\n    ===========\n\n    The matrix must be invertible.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, solve_linear_system_LU\n    >>> from sympy.abc import x, y, z\n\n    >>> solve_linear_system_LU(Matrix([\n    ... [1, 2, 0, 1],\n    ... [3, 2, 2, 1],\n    ... [2, 0, 0, 1]]), [x, y, z])\n    {x: 1/2, y: 1/4, z: -1/2}\n\n    See Also\n    ========\n\n    LUsolve\n\n    ",
    "section": "Algebraic equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "solve_undetermined_coeffs",
    "full_id": "sympy.solvers.solvers.solve_undetermined_coeffs",
    "type": "function",
    "description": "\n    Solve a system of equations in $k$ parameters that is formed by\n    matching coefficients in variables ``coeffs`` that are on\n    factors dependent on the remaining variables (or those given\n    explicitly by ``syms``.\n\n    Explanation\n    ===========\n\n    The result of this function is a dictionary with symbolic values of those\n    parameters with respect to coefficients in $q$ -- empty if there\n    is no solution or coefficients do not appear in the equation -- else\n    None (if the system was not recognized). If there is more than one\n    solution, the solutions are passed as a list. The output can be modified using\n    the same semantics as for `solve` since the flags that are passed are sent\n    directly to `solve` so, for example the flag ``dict=True`` will always return a list\n    of solutions as dictionaries.\n\n    This function accepts both Equality and Expr class instances.\n    The solving process is most efficient when symbols are specified\n    in addition to parameters to be determined,  but an attempt to\n    determine them (if absent) will be made. If an expected solution is not\n    obtained (and symbols were not specified) try specifying them.\n\n    Examples\n    ========\n\n    >>> from sympy import Eq, solve_undetermined_coeffs\n    >>> from sympy.abc import a, b, c, h, p, k, x, y\n\n    >>> solve_undetermined_coeffs(Eq(a*x + a + b, x/2), [a, b], x)\n    {a: 1/2, b: -1/2}\n    >>> solve_undetermined_coeffs(a - 2, [a])\n    {a: 2}\n\n    The equation can be nonlinear in the symbols:\n\n    >>> X, Y, Z = y, x**y, y*x**y\n    >>> eq = a*X + b*Y + c*Z - X - 2*Y - 3*Z\n    >>> coeffs = a, b, c\n    >>> syms = x, y\n    >>> solve_undetermined_coeffs(eq, coeffs, syms)\n    {a: 1, b: 2, c: 3}\n\n    And the system can be nonlinear in coefficients, too, but if\n    there is only a single solution, it will be returned as a\n    dictionary:\n\n    >>> eq = a*x**2 + b*x + c - ((x - h)**2 + 4*p*k)/4/p\n    >>> solve_undetermined_coeffs(eq, (h, p, k), x)\n    {h: -b/(2*a), k: (4*a*c - b**2)/(4*a), p: 1/(4*a)}\n\n    Multiple solutions are always returned in a list:\n\n    >>> solve_undetermined_coeffs(a**2*x + b - x, [a, b], x)\n    [{a: -1, b: 0}, {a: 1, b: 0}]\n\n    Using flag ``dict=True`` (in keeping with semantics in :func:`~.solve`)\n    will force the result to always be a list with any solutions\n    as elements in that list.\n\n    >>> solve_undetermined_coeffs(a*x - 2*x, [a], dict=True)\n    [{a: 2}]\n    ",
    "section": "Algebraic equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "nsolve",
    "full_id": "sympy.solvers.solvers.nsolve",
    "type": "function",
    "description": "\n    Solve a nonlinear equation system numerically: ``nsolve(f, [args,] x0,\n    modules=['mpmath'], **kwargs)``.\n\n    Explanation\n    ===========\n\n    ``f`` is a vector function of symbolic expressions representing the system.\n    *args* are the variables. If there is only one variable, this argument can\n    be omitted. ``x0`` is a starting vector close to a solution.\n\n    Use the modules keyword to specify which modules should be used to\n    evaluate the function and the Jacobian matrix. Make sure to use a module\n    that supports matrices. For more information on the syntax, please see the\n    docstring of ``lambdify``.\n\n    If the keyword arguments contain ``dict=True`` (default is False) ``nsolve``\n    will return a list (perhaps empty) of solution mappings. This might be\n    especially useful if you want to use ``nsolve`` as a fallback to solve since\n    using the dict argument for both methods produces return values of\n    consistent type structure. Please note: to keep this consistent with\n    ``solve``, the solution will be returned in a list even though ``nsolve``\n    (currently at least) only finds one solution at a time.\n\n    Overdetermined systems are supported.\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, nsolve\n    >>> import mpmath\n    >>> mpmath.mp.dps = 15\n    >>> x1 = Symbol('x1')\n    >>> x2 = Symbol('x2')\n    >>> f1 = 3 * x1**2 - 2 * x2**2 - 1\n    >>> f2 = x1**2 - 2 * x1 + x2**2 + 2 * x2 - 8\n    >>> print(nsolve((f1, f2), (x1, x2), (-1, 1)))\n    Matrix([[-1.19287309935246], [1.27844411169911]])\n\n    For one-dimensional functions the syntax is simplified:\n\n    >>> from sympy import sin, nsolve\n    >>> from sympy.abc import x\n    >>> nsolve(sin(x), x, 2)\n    3.14159265358979\n    >>> nsolve(sin(x), 2)\n    3.14159265358979\n\n    To solve with higher precision than the default, use the prec argument:\n\n    >>> from sympy import cos\n    >>> nsolve(cos(x) - x, 1)\n    0.739085133215161\n    >>> nsolve(cos(x) - x, 1, prec=50)\n    0.73908513321516064165531208767387340401341175890076\n    >>> cos(_)\n    0.73908513321516064165531208767387340401341175890076\n\n    To solve for complex roots of real functions, a nonreal initial point\n    must be specified:\n\n    >>> from sympy import I\n    >>> nsolve(x**2 + 2, I)\n    1.4142135623731*I\n\n    ``mpmath.findroot`` is used and you can find their more extensive\n    documentation, especially concerning keyword parameters and\n    available solvers. Note, however, that functions which are very\n    steep near the root, the verification of the solution may fail. In\n    this case you should use the flag ``verify=False`` and\n    independently verify the solution.\n\n    >>> from sympy import cos, cosh\n    >>> f = cos(x)*cosh(x) - 1\n    >>> nsolve(f, 3.14*100)\n    Traceback (most recent call last):\n    ...\n    ValueError: Could not find root within given tolerance. (1.39267e+230 > 2.1684e-19)\n    >>> ans = nsolve(f, 3.14*100, verify=False); ans\n    312.588469032184\n    >>> f.subs(x, ans).n(2)\n    2.1e+121\n    >>> (f/f.diff(x)).subs(x, ans).n(2)\n    7.4e-15\n\n    One might safely skip the verification if bounds of the root are known\n    and a bisection method is used:\n\n    >>> bounds = lambda i: (3.14*i, 3.14*(i + 1))\n    >>> nsolve(f, bounds(100), solver='bisect', verify=False)\n    315.730061685774\n\n    Alternatively, a function may be better behaved when the\n    denominator is ignored. Since this is not always the case, however,\n    the decision of what function to use is left to the discretion of\n    the user.\n\n    >>> eq = x**2/(1 - x)/(1 - 2*x)**2 - 100\n    >>> nsolve(eq, 0.46)\n    Traceback (most recent call last):\n    ...\n    ValueError: Could not find root within given tolerance. (10000 > 2.1684e-19)\n    Try another starting point or tweak arguments.\n    >>> nsolve(eq.as_numer_denom()[0], 0.46)\n    0.46792545969349058\n\n    ",
    "section": "Algebraic equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "checksol",
    "full_id": "sympy.solvers.solvers.checksol",
    "type": "function",
    "description": "\n    Checks whether sol is a solution of equation f == 0.\n\n    Explanation\n    ===========\n\n    Input can be either a single symbol and corresponding value\n    or a dictionary of symbols and values. When given as a dictionary\n    and flag ``simplify=True``, the values in the dictionary will be\n    simplified. *f* can be a single equation or an iterable of equations.\n    A solution must satisfy all equations in *f* to be considered valid;\n    if a solution does not satisfy any equation, False is returned; if one or\n    more checks are inconclusive (and none are False) then None is returned.\n\n    Examples\n    ========\n\n    >>> from sympy import checksol, symbols\n    >>> x, y = symbols('x,y')\n    >>> checksol(x**4 - 1, x, 1)\n    True\n    >>> checksol(x**4 - 1, x, 0)\n    False\n    >>> checksol(x**2 + y**2 - 5**2, {x: 3, y: 4})\n    True\n\n    To check if an expression is zero using ``checksol()``, pass it\n    as *f* and send an empty dictionary for *symbol*:\n\n    >>> checksol(x**2 + x - x*(x + 1), {})\n    True\n\n    None is returned if ``checksol()`` could not conclude.\n\n    flags:\n        'numerical=True (default)'\n           do a fast numerical check if ``f`` has only one symbol.\n        'minimal=True (default is False)'\n           a very fast, minimal testing.\n        'warn=True (default is False)'\n           show a warning if checksol() could not conclude.\n        'simplify=True (default)'\n           simplify solution before substituting into function and\n           simplify the function before trying specific simplifications\n        'force=True (default is False)'\n           make positive all symbols without assumptions regarding sign.\n\n    ",
    "section": "Algebraic equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "unrad",
    "full_id": "sympy.solvers.solvers.unrad",
    "type": "function",
    "description": "\n    Remove radicals with symbolic arguments and return (eq, cov),\n    None, or raise an error.\n\n    Explanation\n    ===========\n\n    None is returned if there are no radicals to remove.\n\n    NotImplementedError is raised if there are radicals and they cannot be\n    removed or if the relationship between the original symbols and the\n    change of variable needed to rewrite the system as a polynomial cannot\n    be solved.\n\n    Otherwise the tuple, ``(eq, cov)``, is returned where:\n\n    *eq*, ``cov``\n        *eq* is an equation without radicals (in the symbol(s) of\n        interest) whose solutions are a superset of the solutions to the\n        original expression. *eq* might be rewritten in terms of a new\n        variable; the relationship to the original variables is given by\n        ``cov`` which is a list containing ``v`` and ``v**p - b`` where\n        ``p`` is the power needed to clear the radical and ``b`` is the\n        radical now expressed as a polynomial in the symbols of interest.\n        For example, for sqrt(2 - x) the tuple would be\n        ``(c, c**2 - 2 + x)``. The solutions of *eq* will contain\n        solutions to the original equation (if there are any).\n\n    *syms*\n        An iterable of symbols which, if provided, will limit the focus of\n        radical removal: only radicals with one or more of the symbols of\n        interest will be cleared. All free symbols are used if *syms* is not\n        set.\n\n    *flags* are used internally for communication during recursive calls.\n    Two options are also recognized:\n\n        ``take``, when defined, is interpreted as a single-argument function\n        that returns True if a given Pow should be handled.\n\n    Radicals can be removed from an expression if:\n\n        *   All bases of the radicals are the same; a change of variables is\n            done in this case.\n        *   If all radicals appear in one term of the expression.\n        *   There are only four terms with sqrt() factors or there are less than\n            four terms having sqrt() factors.\n        *   There are only two terms with radicals.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.solvers import unrad\n    >>> from sympy.abc import x\n    >>> from sympy import sqrt, Rational, root\n\n    >>> unrad(sqrt(x)*x**Rational(1, 3) + 2)\n    (x**5 - 64, [])\n    >>> unrad(sqrt(x) + root(x + 1, 3))\n    (-x**3 + x**2 + 2*x + 1, [])\n    >>> eq = sqrt(x) + root(x, 3) - 2\n    >>> unrad(eq)\n    (_p**3 + _p**2 - 2, [_p, _p**6 - x])\n\n    ",
    "section": "Algebraic equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "ode_order",
    "full_id": "sympy.solvers.deutils.ode_order",
    "type": "function",
    "description": "\n    Returns the order of a given differential\n    equation with respect to func.\n\n    This function is implemented recursively.\n\n    Examples\n    ========\n\n    >>> from sympy import Function\n    >>> from sympy.solvers.deutils import ode_order\n    >>> from sympy.abc import x\n    >>> f, g = map(Function, ['f', 'g'])\n    >>> ode_order(f(x).diff(x, 2) + f(x).diff(x)**2 +\n    ... f(x).diff(x), f(x))\n    2\n    >>> ode_order(f(x).diff(x, 2) + g(x).diff(x, 3), f(x))\n    2\n    >>> ode_order(f(x).diff(x, 2) + g(x).diff(x, 3), g(x))\n    3\n\n    ",
    "section": "Deutils (Utilities for solving ODE\u2019s and PDE\u2019s)",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "rsolve",
    "full_id": "sympy.solvers.recurr.rsolve",
    "type": "function",
    "description": "\n    Solve univariate recurrence with rational coefficients.\n\n    Given `k`-th order linear recurrence `\\operatorname{L} y = f`,\n    or equivalently:\n\n    .. math:: a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +\n              \\cdots + a_{0}(n) y(n) = f(n)\n\n    where `a_{i}(n)`, for `i=0, \\ldots, k`, are polynomials or rational\n    functions in `n`, and `f` is a hypergeometric function or a sum\n    of a fixed number of pairwise dissimilar hypergeometric terms in\n    `n`, finds all solutions or returns ``None``, if none were found.\n\n    Initial conditions can be given as a dictionary in two forms:\n\n        (1) ``{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}``\n        (2) ``{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}``\n\n    or as a list ``L`` of values:\n\n        ``L = [v_0, v_1, ..., v_m]``\n\n    where ``L[i] = v_i``, for `i=0, \\ldots, m`, maps to `y(n_i)`.\n\n    Examples\n    ========\n\n    Lets consider the following recurrence:\n\n    .. math:: (n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +\n              2 n (n + 1) y(n) = 0\n\n    >>> from sympy import Function, rsolve\n    >>> from sympy.abc import n\n    >>> y = Function('y')\n\n    >>> f = (n - 1)*y(n + 2) - (n**2 + 3*n - 2)*y(n + 1) + 2*n*(n + 1)*y(n)\n\n    >>> rsolve(f, y(n))\n    2**n*C0 + C1*factorial(n)\n\n    >>> rsolve(f, y(n), {y(0):0, y(1):3})\n    3*2**n - 3*factorial(n)\n\n    See Also\n    ========\n\n    rsolve_poly, rsolve_ratio, rsolve_hyper\n\n    ",
    "section": "Recurrence Equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "rsolve_poly",
    "full_id": "sympy.solvers.recurr.rsolve_poly",
    "type": "function",
    "description": "\n    Given linear recurrence operator `\\operatorname{L}` of order\n    `k` with polynomial coefficients and inhomogeneous equation\n    `\\operatorname{L} y = f`, where `f` is a polynomial, we seek for\n    all polynomial solutions over field `K` of characteristic zero.\n\n    The algorithm performs two basic steps:\n\n        (1) Compute degree `N` of the general polynomial solution.\n        (2) Find all polynomials of degree `N` or less\n            of `\\operatorname{L} y = f`.\n\n    There are two methods for computing the polynomial solutions.\n    If the degree bound is relatively small, i.e. it's smaller than\n    or equal to the order of the recurrence, then naive method of\n    undetermined coefficients is being used. This gives a system\n    of algebraic equations with `N+1` unknowns.\n\n    In the other case, the algorithm performs transformation of the\n    initial equation to an equivalent one for which the system of\n    algebraic equations has only `r` indeterminates. This method is\n    quite sophisticated (in comparison with the naive one) and was\n    invented together by Abramov, Bronstein and Petkovsek.\n\n    It is possible to generalize the algorithm implemented here to\n    the case of linear q-difference and differential equations.\n\n    Lets say that we would like to compute `m`-th Bernoulli polynomial\n    up to a constant. For this we can use `b(n+1) - b(n) = m n^{m-1}`\n    recurrence, which has solution `b(n) = B_m + C`. For example:\n\n    >>> from sympy import Symbol, rsolve_poly\n    >>> n = Symbol('n', integer=True)\n\n    >>> rsolve_poly([-1, 1], 4*n**3, n)\n    C0 + n**4 - 2*n**3 + n**2\n\n    References\n    ==========\n\n    .. [1] S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial\n           solutions of linear operator equations, in: T. Levelt, ed.,\n           Proc. ISSAC '95, ACM Press, New York, 1995, 290-296.\n\n    .. [2] M. Petkovsek, Hypergeometric solutions of linear recurrences\n           with polynomial coefficients, J. Symbolic Computation,\n           14 (1992), 243-264.\n\n    .. [3] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\n\n    ",
    "section": "Recurrence Equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "rsolve_ratio",
    "full_id": "sympy.solvers.recurr.rsolve_ratio",
    "type": "function",
    "description": "\n    Given linear recurrence operator `\\operatorname{L}` of order `k`\n    with polynomial coefficients and inhomogeneous equation\n    `\\operatorname{L} y = f`, where `f` is a polynomial, we seek\n    for all rational solutions over field `K` of characteristic zero.\n\n    This procedure accepts only polynomials, however if you are\n    interested in solving recurrence with rational coefficients\n    then use ``rsolve`` which will pre-process the given equation\n    and run this procedure with polynomial arguments.\n\n    The algorithm performs two basic steps:\n\n        (1) Compute polynomial `v(n)` which can be used as universal\n            denominator of any rational solution of equation\n            `\\operatorname{L} y = f`.\n\n        (2) Construct new linear difference equation by substitution\n            `y(n) = u(n)/v(n)` and solve it for `u(n)` finding all its\n            polynomial solutions. Return ``None`` if none were found.\n\n    The algorithm implemented here is a revised version of the original\n    Abramov's algorithm, developed in 1989. The new approach is much\n    simpler to implement and has better overall efficiency. This\n    method can be easily adapted to the q-difference equations case.\n\n    Besides finding rational solutions alone, this functions is\n    an important part of Hyper algorithm where it is used to find\n    a particular solution for the inhomogeneous part of a recurrence.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy.solvers.recurr import rsolve_ratio\n    >>> rsolve_ratio([-2*x**3 + x**2 + 2*x - 1, 2*x**3 + x**2 - 6*x,\n    ... - 2*x**3 - 11*x**2 - 18*x - 9, 2*x**3 + 13*x**2 + 22*x + 8], 0, x)\n    C0*(2*x - 3)/(2*(x**2 - 1))\n\n    References\n    ==========\n\n    .. [1] S. A. Abramov, Rational solutions of linear difference\n           and q-difference equations with polynomial coefficients,\n           in: T. Levelt, ed., Proc. ISSAC '95, ACM Press, New York,\n           1995, 285-289\n\n    See Also\n    ========\n\n    rsolve_hyper\n    ",
    "section": "Recurrence Equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "rsolve_hyper",
    "full_id": "sympy.solvers.recurr.rsolve_hyper",
    "type": "function",
    "description": "\n    Given linear recurrence operator `\\operatorname{L}` of order `k`\n    with polynomial coefficients and inhomogeneous equation\n    `\\operatorname{L} y = f` we seek for all hypergeometric solutions\n    over field `K` of characteristic zero.\n\n    The inhomogeneous part can be either hypergeometric or a sum\n    of a fixed number of pairwise dissimilar hypergeometric terms.\n\n    The algorithm performs three basic steps:\n\n        (1) Group together similar hypergeometric terms in the\n            inhomogeneous part of `\\operatorname{L} y = f`, and find\n            particular solution using Abramov's algorithm.\n\n        (2) Compute generating set of `\\operatorname{L}` and find basis\n            in it, so that all solutions are linearly independent.\n\n        (3) Form final solution with the number of arbitrary\n            constants equal to dimension of basis of `\\operatorname{L}`.\n\n    Term `a(n)` is hypergeometric if it is annihilated by first order\n    linear difference equations with polynomial coefficients or, in\n    simpler words, if consecutive term ratio is a rational function.\n\n    The output of this procedure is a linear combination of fixed\n    number of hypergeometric terms. However the underlying method\n    can generate larger class of solutions - D'Alembertian terms.\n\n    Note also that this method not only computes the kernel of the\n    inhomogeneous equation, but also reduces in to a basis so that\n    solutions generated by this procedure are linearly independent\n\n    Examples\n    ========\n\n    >>> from sympy.solvers import rsolve_hyper\n    >>> from sympy.abc import x\n\n    >>> rsolve_hyper([-1, -1, 1], 0, x)\n    C0*(1/2 - sqrt(5)/2)**x + C1*(1/2 + sqrt(5)/2)**x\n\n    >>> rsolve_hyper([-1, 1], 1 + x, x)\n    C0 + x*(x + 1)/2\n\n    References\n    ==========\n\n    .. [1] M. Petkovsek, Hypergeometric solutions of linear recurrences\n           with polynomial coefficients, J. Symbolic Computation,\n           14 (1992), 243-264.\n\n    .. [2] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.\n    ",
    "section": "Recurrence Equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "solve_poly_system",
    "full_id": "sympy.solvers.polysys.solve_poly_system",
    "type": "function",
    "description": "\n    Return a list of solutions for the system of polynomial equations\n    or else None.\n\n    Parameters\n    ==========\n\n    seq: a list/tuple/set\n        Listing all the equations that are needed to be solved\n    gens: generators\n        generators of the equations in seq for which we want the\n        solutions\n    strict: a boolean (default is False)\n        if strict is True, NotImplementedError will be raised if\n        the solution is known to be incomplete (which can occur if\n        not all solutions are expressible in radicals)\n    args: Keyword arguments\n        Special options for solving the equations.\n\n\n    Returns\n    =======\n\n    List[Tuple]\n        a list of tuples with elements being solutions for the\n        symbols in the order they were passed as gens\n    None\n        None is returned when the computed basis contains only the ground.\n\n    Examples\n    ========\n\n    >>> from sympy import solve_poly_system\n    >>> from sympy.abc import x, y\n\n    >>> solve_poly_system([x*y - 2*y, 2*y**2 - x**2], x, y)\n    [(0, 0), (2, -sqrt(2)), (2, sqrt(2))]\n\n    >>> solve_poly_system([x**5 - x + y**3, y**2 - 1], x, y, strict=True)\n    Traceback (most recent call last):\n    ...\n    UnsolvableFactorError\n\n    ",
    "section": "Systems of Polynomial Equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "solve_triangulated",
    "full_id": "sympy.solvers.polysys.solve_triangulated",
    "type": "function",
    "description": "\n    Solve a polynomial system using Gianni-Kalkbrenner algorithm.\n\n    The algorithm proceeds by computing one Groebner basis in the ground\n    domain and then by iteratively computing polynomial factorizations in\n    appropriately constructed algebraic extensions of the ground domain.\n\n    Parameters\n    ==========\n\n    polys: a list/tuple/set\n        Listing all the equations that are needed to be solved\n    gens: generators\n        generators of the equations in polys for which we want the\n        solutions\n    args: Keyword arguments\n        Special options for solving the equations\n\n    Returns\n    =======\n\n    List[Tuple]\n        A List of tuples. Solutions for symbols that satisfy the\n        equations listed in polys\n\n    Examples\n    ========\n\n    >>> from sympy import solve_triangulated\n    >>> from sympy.abc import x, y, z\n\n    >>> F = [x**2 + y + z - 1, x + y**2 + z - 1, x + y + z**2 - 1]\n\n    >>> solve_triangulated(F, x, y, z)\n    [(0, 0, 1), (0, 1, 0), (1, 0, 0)]\n\n    References\n    ==========\n\n    1. Patrizia Gianni, Teo Mora, Algebraic Solution of System of\n    Polynomial Equations using Groebner Bases, AAECC-5 on Applied Algebra,\n    Algebraic Algorithms and Error-Correcting Codes, LNCS 356 247--257, 1989\n\n    ",
    "section": "Systems of Polynomial Equations",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "lpmax",
    "full_id": "sympy.solvers.simplex.lpmax",
    "type": "function",
    "description": "return maximum of linear equation ``f`` under\n    linear constraints expressed using Ge, Le or Eq.\n\n    All variables are unbounded unless constrained.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.simplex import lpmax\n    >>> from sympy import Eq\n    >>> from sympy.abc import x, y\n    >>> lpmax(x, [2*x - 3*y >= -1, Eq(x+ 3*y,2), x <= 2*y])\n    (4/5, {x: 4/5, y: 2/5})\n\n    Negative values for variables are permitted unless explicitly\n    exluding:\n\n    >>> lpmax(x, [x <= -1])\n    (-1, {x: -1})\n\n    If a non-negative constraint is added for x, there is no\n    possible solution:\n\n    >>> lpmax(x, [x <= -1, x >= 0])\n    Traceback (most recent call last):\n    ...\n    sympy.solvers.simplex.InfeasibleLPError: inconsistent/False constraint\n\n    See Also\n    ========\n    linprog, lpmin\n    ",
    "section": "Linear Programming (Optimization)",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "lpmin",
    "full_id": "sympy.solvers.simplex.lpmin",
    "type": "function",
    "description": "return minimum of linear equation ``f`` under\n    linear constraints expressed using Ge, Le or Eq.\n\n    All variables are unbounded unless constrained.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.simplex import lpmin\n    >>> from sympy import Eq\n    >>> from sympy.abc import x, y\n    >>> lpmin(x, [2*x - 3*y >= -1, Eq(x + 3*y, 2), x <= 2*y])\n    (1/3, {x: 1/3, y: 5/9})\n\n    Negative values for variables are permitted unless explicitly\n    exluding, so minimizing ``x`` for ``x <= 3`` is an\n    unbounded problem while the following has a bounded solution:\n\n    >>> lpmin(x, [x >= 0, x <= 3])\n    (0, {x: 0})\n\n    Without indicating that ``x`` is nonnegative, there\n    is no minimum for this objective:\n\n    >>> lpmin(x, [x <= 3])\n    Traceback (most recent call last):\n    ...\n    sympy.solvers.simplex.UnboundedLPError:\n    Objective function can assume arbitrarily large values!\n\n    See Also\n    ========\n    linprog, lpmax\n    ",
    "section": "Linear Programming (Optimization)",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "linprog",
    "full_id": "sympy.solvers.simplex.linprog",
    "type": "function",
    "description": "Return the minimization of ``c*x`` with the given\n    constraints ``A*x <= b`` and ``A_eq*x = b_eq``. Unless bounds\n    are given, variables will have nonnegative values in the solution.\n\n    If ``A`` is not given, then the dimension of the system will\n    be determined by the length of ``C``.\n\n    By default, all variables will be nonnegative. If ``bounds``\n    is given as a single tuple, ``(lo, hi)``, then all variables\n    will be constrained to be between ``lo`` and ``hi``. Use\n    None for a ``lo`` or ``hi`` if it is unconstrained in the\n    negative or positive direction, respectively, e.g.\n    ``(None, 0)`` indicates nonpositive values. To set\n    individual ranges, pass a list with length equal to the\n    number of columns in ``A``, each element being a tuple; if\n    only a few variables take on non-default values they can be\n    passed as a dictionary with keys giving the corresponding\n    column to which the variable is assigned, e.g. ``bounds={2:\n    (1, 4)}`` would limit the 3rd variable to have a value in\n    range ``[1, 4]``.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.simplex import linprog\n    >>> from sympy import symbols, Eq, linear_eq_to_matrix as M, Matrix\n    >>> x = x1, x2, x3, x4 = symbols('x1:5')\n    >>> X = Matrix(x)\n    >>> c, d = M(5*x2 + x3 + 4*x4 - x1, x)\n    >>> a, b = M([5*x2 + 2*x3 + 5*x4 - (x1 + 5)], x)\n    >>> aeq, beq = M([Eq(3*x2 + x4, 2), Eq(-x1 + x3 + 2*x4, 1)], x)\n    >>> constr = [i <= j for i,j in zip(a*X, b)]\n    >>> constr += [Eq(i, j) for i,j in zip(aeq*X, beq)]\n    >>> linprog(c, a, b, aeq, beq)\n    (9/2, [0, 1/2, 0, 1/2])\n    >>> assert all(i.subs(dict(zip(x, _[1]))) for i in constr)\n\n    See Also\n    ========\n    lpmin, lpmax\n    ",
    "section": "Linear Programming (Optimization)",
    "url": "https://docs.sympy.org/latest/modules/solvers/solvers.html"
  },
  {
    "name": "solveset",
    "full_id": "sympy.solvers.solveset.solveset",
    "type": "function",
    "description": "Solves a given inequality or equation with set as output\n\n    Parameters\n    ==========\n\n    f : Expr or a relational.\n        The target equation or inequality\n    symbol : Symbol\n        The variable for which the equation is solved\n    domain : Set\n        The domain over which the equation is solved\n\n    Returns\n    =======\n\n    Set\n        A set of values for `symbol` for which `f` is True or is equal to\n        zero. An :class:`~.EmptySet` is returned if `f` is False or nonzero.\n        A :class:`~.ConditionSet` is returned as unsolved object if algorithms\n        to evaluate complete solution are not yet implemented.\n\n    ``solveset`` claims to be complete in the solution set that it returns.\n\n    Raises\n    ======\n\n    NotImplementedError\n        The algorithms to solve inequalities in complex domain  are\n        not yet implemented.\n    ValueError\n        The input is not valid.\n    RuntimeError\n        It is a bug, please report to the github issue tracker.\n\n\n    Notes\n    =====\n\n    Python interprets 0 and 1 as False and True, respectively, but\n    in this function they refer to solutions of an expression. So 0 and 1\n    return the domain and EmptySet, respectively, while True and False\n    return the opposite (as they are assumed to be solutions of relational\n    expressions).\n\n\n    See Also\n    ========\n\n    solveset_real: solver for real domain\n    solveset_complex: solver for complex domain\n\n    Examples\n    ========\n\n    >>> from sympy import exp, sin, Symbol, pprint, S, Eq\n    >>> from sympy.solvers.solveset import solveset, solveset_real\n\n    * The default domain is complex. Not specifying a domain will lead\n      to the solving of the equation in the complex domain (and this\n      is not affected by the assumptions on the symbol):\n\n    >>> x = Symbol('x')\n    >>> pprint(solveset(exp(x) - 1, x), use_unicode=False)\n    {2*n*I*pi | n in Integers}\n\n    >>> x = Symbol('x', real=True)\n    >>> pprint(solveset(exp(x) - 1, x), use_unicode=False)\n    {2*n*I*pi | n in Integers}\n\n    * If you want to use ``solveset`` to solve the equation in the\n      real domain, provide a real domain. (Using ``solveset_real``\n      does this automatically.)\n\n    >>> R = S.Reals\n    >>> x = Symbol('x')\n    >>> solveset(exp(x) - 1, x, R)\n    {0}\n    >>> solveset_real(exp(x) - 1, x)\n    {0}\n\n    The solution is unaffected by assumptions on the symbol:\n\n    >>> p = Symbol('p', positive=True)\n    >>> pprint(solveset(p**2 - 4))\n    {-2, 2}\n\n    When a :class:`~.ConditionSet` is returned, symbols with assumptions that\n    would alter the set are replaced with more generic symbols:\n\n    >>> i = Symbol('i', imaginary=True)\n    >>> solveset(Eq(i**2 + i*sin(i), 1), i, domain=S.Reals)\n    ConditionSet(_R, Eq(_R**2 + _R*sin(_R) - 1, 0), Reals)\n\n    * Inequalities can be solved over the real domain only. Use of a complex\n      domain leads to a NotImplementedError.\n\n    >>> solveset(exp(x) > 1, x, R)\n    Interval.open(0, oo)\n\n    ",
    "section": "Solveset Module Reference",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "invert_real",
    "full_id": "sympy.solvers.solveset.invert_real",
    "type": "function",
    "description": "\n    Inverts a real-valued function. Same as :func:`invert_complex`, but sets\n    the domain to ``S.Reals`` before inverting.\n    ",
    "section": "Solveset Module Reference",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "invert_complex",
    "full_id": "sympy.solvers.solveset.invert_complex",
    "type": "function",
    "description": "\n    Reduce the complex valued equation $f(x) = y$ to a set of equations\n\n    $$\\left\\{g(x) = h_1(y),\\  g(x) = h_2(y),\\ \\dots,\\  g(x) = h_n(y) \\right\\}$$\n\n    where $g(x)$ is a simpler function than $f(x)$.  The return value is a tuple\n    $(g(x), \\mathrm{set}_h)$, where $g(x)$ is a function of $x$ and $\\mathrm{set}_h$ is\n    the set of function $\\left\\{h_1(y), h_2(y), \\dots, h_n(y)\\right\\}$.\n    Here, $y$ is not necessarily a symbol.\n\n    $\\mathrm{set}_h$ contains the functions, along with the information\n    about the domain in which they are valid, through set\n    operations. For instance, if :math:`y = |x| - n` is inverted\n    in the real domain, then $\\mathrm{set}_h$ is not simply\n    $\\{-n, n\\}$ as the nature of `n` is unknown; rather, it is:\n\n    $$ \\left(\\left[0, \\infty\\right) \\cap \\left\\{n\\right\\}\\right) \\cup\n                       \\left(\\left(-\\infty, 0\\right] \\cap \\left\\{- n\\right\\}\\right)$$\n\n    By default, the complex domain is used which means that inverting even\n    seemingly simple functions like $\\exp(x)$ will give very different\n    results from those obtained in the real domain.\n    (In the case of $\\exp(x)$, the inversion via $\\log$ is multi-valued\n    in the complex domain, having infinitely many branches.)\n\n    If you are working with real values only (or you are not sure which\n    function to use) you should probably set the domain to\n    ``S.Reals`` (or use ``invert_real`` which does that automatically).\n\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.solveset import invert_complex, invert_real\n    >>> from sympy.abc import x, y\n    >>> from sympy import exp\n\n    When does exp(x) == y?\n\n    >>> invert_complex(exp(x), y, x)\n    (x, ImageSet(Lambda(_n, I*(2*_n*pi + arg(y)) + log(Abs(y))), Integers))\n    >>> invert_real(exp(x), y, x)\n    (x, Intersection({log(y)}, Reals))\n\n    When does exp(x) == 1?\n\n    >>> invert_complex(exp(x), 1, x)\n    (x, ImageSet(Lambda(_n, 2*_n*I*pi), Integers))\n    >>> invert_real(exp(x), 1, x)\n    (x, {0})\n\n    See Also\n    ========\n    invert_real, invert_complex\n    ",
    "section": "Solveset Module Reference",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "domain_check",
    "full_id": "sympy.solvers.solveset.domain_check",
    "type": "function",
    "description": "Returns False if point p is infinite or any subexpression of f\n    is infinite or becomes so after replacing symbol with p. If none of\n    these conditions is met then True will be returned.\n\n    Examples\n    ========\n\n    >>> from sympy import Mul, oo\n    >>> from sympy.abc import x\n    >>> from sympy.solvers.solveset import domain_check\n    >>> g = 1/(1 + (1/(x + 1))**2)\n    >>> domain_check(g, x, -1)\n    False\n    >>> domain_check(x**2, x, 0)\n    True\n    >>> domain_check(1/x, x, oo)\n    False\n\n    * The function relies on the assumption that the original form\n      of the equation has not been changed by automatic simplification.\n\n    >>> domain_check(x/x, x, 0) # x/x is automatically simplified to 1\n    True\n\n    * To deal with automatic evaluations use evaluate=False:\n\n    >>> domain_check(Mul(x, 1/x, evaluate=False), x, 0)\n    False\n    ",
    "section": "Solveset Module Reference",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "solvify",
    "full_id": "sympy.solvers.solveset.solvify",
    "type": "function",
    "description": "Solves an equation using solveset and returns the solution in accordance\n    with the `solve` output API.\n\n    Returns\n    =======\n\n    We classify the output based on the type of solution returned by `solveset`.\n\n    Solution    |    Output\n    ----------------------------------------\n    FiniteSet   | list\n\n    ImageSet,   | list (if `f` is periodic)\n    Union       |\n\n    Union       | list (with FiniteSet)\n\n    EmptySet    | empty list\n\n    Others      | None\n\n\n    Raises\n    ======\n\n    NotImplementedError\n        A ConditionSet is the input.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.solveset import solvify\n    >>> from sympy.abc import x\n    >>> from sympy import S, tan, sin, exp\n    >>> solvify(x**2 - 9, x, S.Reals)\n    [-3, 3]\n    >>> solvify(sin(x) - 1, x, S.Reals)\n    [pi/2]\n    >>> solvify(tan(x), x, S.Reals)\n    [0]\n    >>> solvify(exp(x) - 1, x, S.Complexes)\n\n    >>> solvify(exp(x) - 1, x, S.Reals)\n    [0]\n\n    ",
    "section": "Solveset Module Reference",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "linear_eq_to_matrix",
    "full_id": "sympy.solvers.solveset.linear_eq_to_matrix",
    "type": "function",
    "description": "\n    Converts a given System of Equations into Matrix form.\n    Here `equations` must be a linear system of equations in\n    `symbols`. Element ``M[i, j]`` corresponds to the coefficient\n    of the jth symbol in the ith equation.\n\n    The Matrix form corresponds to the augmented matrix form.\n    For example:\n\n    .. math:: 4x + 2y + 3z  = 1\n    .. math:: 3x +  y +  z  = -6\n    .. math:: 2x + 4y + 9z  = 2\n\n    This system will return $A$ and $b$ as:\n\n    $$ A = \\left[\\begin{array}{ccc}\n        4 & 2 & 3 \\\\\n        3 & 1 & 1 \\\\\n        2 & 4 & 9\n        \\end{array}\\right] \\ \\  b = \\left[\\begin{array}{c}\n        1 \\\\ -6 \\\\ 2\n        \\end{array}\\right] $$\n\n    The only simplification performed is to convert\n    ``Eq(a, b)`` $\\Rightarrow a - b$.\n\n    Raises\n    ======\n\n    NonlinearError\n        The equations contain a nonlinear term.\n    ValueError\n        The symbols are not given or are not unique.\n\n    Examples\n    ========\n\n    >>> from sympy import linear_eq_to_matrix, symbols\n    >>> c, x, y, z = symbols('c, x, y, z')\n\n    The coefficients (numerical or symbolic) of the symbols will\n    be returned as matrices:\n\n        >>> eqns = [c*x + z - 1 - c, y + z, x - y]\n        >>> A, b = linear_eq_to_matrix(eqns, [x, y, z])\n        >>> A\n        Matrix([\n        [c,  0, 1],\n        [0,  1, 1],\n        [1, -1, 0]])\n        >>> b\n        Matrix([\n        [c + 1],\n        [    0],\n        [    0]])\n\n    This routine does not simplify expressions and will raise an error\n    if nonlinearity is encountered:\n\n            >>> eqns = [\n            ...     (x**2 - 3*x)/(x - 3) - 3,\n            ...     y**2 - 3*y - y*(y - 4) + x - 4]\n            >>> linear_eq_to_matrix(eqns, [x, y])\n            Traceback (most recent call last):\n            ...\n            NonlinearError:\n            symbol-dependent term can be ignored using `strict=False`\n\n        Simplifying these equations will discard the removable singularity\n        in the first and reveal the linear structure of the second:\n\n            >>> [e.simplify() for e in eqns]\n            [x - 3, x + y - 4]\n\n        Any such simplification needed to eliminate nonlinear terms must\n        be done *before* calling this routine.\n    ",
    "section": "Solveset Module Reference",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "linsolve",
    "full_id": "sympy.solvers.solveset.linsolve",
    "type": "function",
    "description": "\n    Solve system of $N$ linear equations with $M$ variables; both\n    underdetermined and overdetermined systems are supported.\n    The possible number of solutions is zero, one or infinite.\n    Zero solutions throws a ValueError, whereas infinite\n    solutions are represented parametrically in terms of the given\n    symbols. For unique solution a :class:`~.FiniteSet` of ordered tuples\n    is returned.\n\n    All standard input formats are supported:\n    For the given set of equations, the respective input types\n    are given below:\n\n    .. math:: 3x + 2y -   z = 1\n    .. math:: 2x - 2y + 4z = -2\n    .. math:: 2x -   y + 2z = 0\n\n    * Augmented matrix form, ``system`` given below:\n\n    $$ \\text{system} = \\left[{array}{cccc}\n        3 &  2 & -1 &  1\\\\\n        2 & -2 &  4 & -2\\\\\n        2 & -1 &  2 &  0\n        \\end{array}\\right] $$\n\n    ::\n\n        system = Matrix([[3, 2, -1, 1], [2, -2, 4, -2], [2, -1, 2, 0]])\n\n    * List of equations form\n\n    ::\n\n        system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]\n\n    * Input $A$ and $b$ in matrix form (from $Ax = b$) are given as:\n\n    $$ A = \\left[\\begin{array}{ccc}\n        3 &  2 & -1 \\\\\n        2 & -2 &  4 \\\\\n        2 & -1 &  2\n        \\end{array}\\right] \\ \\  b = \\left[\\begin{array}{c}\n        1 \\\\ -2 \\\\ 0\n        \\end{array}\\right] $$\n\n    ::\n\n        A = Matrix([[3, 2, -1], [2, -2, 4], [2, -1, 2]])\n        b = Matrix([[1], [-2], [0]])\n        system = (A, b)\n\n    Symbols can always be passed but are actually only needed\n    when 1) a system of equations is being passed and 2) the\n    system is passed as an underdetermined matrix and one wants\n    to control the name of the free variables in the result.\n    An error is raised if no symbols are used for case 1, but if\n    no symbols are provided for case 2, internally generated symbols\n    will be provided. When providing symbols for case 2, there should\n    be at least as many symbols are there are columns in matrix A.\n\n    The algorithm used here is Gauss-Jordan elimination, which\n    results, after elimination, in a row echelon form matrix.\n\n    Returns\n    =======\n\n    A FiniteSet containing an ordered tuple of values for the\n    unknowns for which the `system` has a solution. (Wrapping\n    the tuple in FiniteSet is used to maintain a consistent\n    output format throughout solveset.)\n\n    Returns EmptySet, if the linear system is inconsistent.\n\n    Raises\n    ======\n\n    ValueError\n        The input is not valid.\n        The symbols are not given.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, linsolve, symbols\n    >>> x, y, z = symbols(\"x, y, z\")\n    >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\n    >>> b = Matrix([3, 6, 9])\n    >>> A\n    Matrix([\n    [1, 2,  3],\n    [4, 5,  6],\n    [7, 8, 10]])\n    >>> b\n    Matrix([\n    [3],\n    [6],\n    [9]])\n    >>> linsolve((A, b), [x, y, z])\n    {(-1, 2, 0)}\n\n    * Parametric Solution: In case the system is underdetermined, the\n      function will return a parametric solution in terms of the given\n      symbols. Those that are free will be returned unchanged. e.g. in\n      the system below, `z` is returned as the solution for variable z;\n      it can take on any value.\n\n    >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> b = Matrix([3, 6, 9])\n    >>> linsolve((A, b), x, y, z)\n    {(z - 1, 2 - 2*z, z)}\n\n    If no symbols are given, internally generated symbols will be used.\n    The ``tau0`` in the third position indicates (as before) that the third\n    variable -- whatever it is named -- can take on any value:\n\n    >>> linsolve((A, b))\n    {(tau0 - 1, 2 - 2*tau0, tau0)}\n\n    * List of equations as input\n\n    >>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]\n    >>> linsolve(Eqns, x, y, z)\n    {(1, -2, -2)}\n\n    * Augmented matrix as input\n\n    >>> aug = Matrix([[2, 1, 3, 1], [2, 6, 8, 3], [6, 8, 18, 5]])\n    >>> aug\n    Matrix([\n    [2, 1,  3, 1],\n    [2, 6,  8, 3],\n    [6, 8, 18, 5]])\n    >>> linsolve(aug, x, y, z)\n    {(3/10, 2/5, 0)}\n\n    * Solve for symbolic coefficients\n\n    >>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')\n    >>> eqns = [a*x + b*y - c, d*x + e*y - f]\n    >>> linsolve(eqns, x, y)\n    {((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))}\n\n    * A degenerate system returns solution as set of given\n      symbols.\n\n    >>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))\n    >>> linsolve(system, x, y)\n    {(x, y)}\n\n    * For an empty system linsolve returns empty set\n\n    >>> linsolve([], x)\n    EmptySet\n\n    * An error is raised if any nonlinearity is detected, even\n      if it could be removed with expansion\n\n    >>> linsolve([x*(1/x - 1)], x)\n    Traceback (most recent call last):\n    ...\n    NonlinearError: nonlinear term: 1/x\n\n    >>> linsolve([x*(y + 1)], x, y)\n    Traceback (most recent call last):\n    ...\n    NonlinearError: nonlinear cross-term: x*(y + 1)\n\n    >>> linsolve([x**2 - 1], x)\n    Traceback (most recent call last):\n    ...\n    NonlinearError: nonlinear term: x**2\n    ",
    "section": "Solveset Module Reference",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "nonlinsolve",
    "full_id": "sympy.solvers.solveset.nonlinsolve",
    "type": "function",
    "description": "\n    Solve system of $N$ nonlinear equations with $M$ variables, which means both\n    under and overdetermined systems are supported. Positive dimensional\n    system is also supported (A system with infinitely many solutions is said\n    to be positive-dimensional). In a positive dimensional system the solution will\n    be dependent on at least one symbol. Returns both real solution\n    and complex solution (if they exist).\n\n    Parameters\n    ==========\n\n    system : list of equations\n        The target system of equations\n    symbols : list of Symbols\n        symbols should be given as a sequence eg. list\n\n    Returns\n    =======\n\n    A :class:`~.FiniteSet` of ordered tuple of values of `symbols` for which the `system`\n    has solution. Order of values in the tuple is same as symbols present in\n    the parameter `symbols`.\n\n    Please note that general :class:`~.FiniteSet` is unordered, the solution\n    returned here is not simply a :class:`~.FiniteSet` of solutions, rather it\n    is a :class:`~.FiniteSet` of ordered tuple, i.e. the first and only\n    argument to :class:`~.FiniteSet` is a tuple of solutions, which is\n    ordered, and, hence ,the returned solution is ordered.\n\n    Also note that solution could also have been returned as an ordered tuple,\n    FiniteSet is just a wrapper ``{}`` around the tuple. It has no other\n    significance except for the fact it is just used to maintain a consistent\n    output format throughout the solveset.\n\n    For the given set of equations, the respective input types\n    are given below:\n\n    .. math:: xy - 1 = 0\n    .. math:: 4x^2 + y^2 - 5 = 0\n\n    ::\n\n       system  = [x*y - 1, 4*x**2 + y**2 - 5]\n       symbols = [x, y]\n\n    Raises\n    ======\n\n    ValueError\n        The input is not valid.\n        The symbols are not given.\n    AttributeError\n        The input symbols are not `Symbol` type.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, nonlinsolve\n    >>> x, y, z = symbols('x, y, z', real=True)\n    >>> nonlinsolve([x*y - 1, 4*x**2 + y**2 - 5], [x, y])\n    {(-1, -1), (-1/2, -2), (1/2, 2), (1, 1)}\n\n    1. Positive dimensional system and complements:\n\n    >>> from sympy import pprint\n    >>> from sympy.polys.polytools import is_zero_dimensional\n    >>> a, b, c, d = symbols('a, b, c, d', extended_real=True)\n    >>> eq1 =  a + b + c + d\n    >>> eq2 = a*b + b*c + c*d + d*a\n    >>> eq3 = a*b*c + b*c*d + c*d*a + d*a*b\n    >>> eq4 = a*b*c*d - 1\n    >>> system = [eq1, eq2, eq3, eq4]\n    >>> is_zero_dimensional(system)\n    False\n    >>> pprint(nonlinsolve(system, [a, b, c, d]), use_unicode=False)\n      -1       1               1      -1\n    {(---, -d, -, {d} \\ {0}), (-, -d, ---, {d} \\ {0})}\n       d       d               d       d\n    >>> nonlinsolve([(x+y)**2 - 4, x + y - 2], [x, y])\n    {(2 - y, y)}\n\n    2. If some of the equations are non-polynomial then `nonlinsolve`\n    will call the ``substitution`` function and return real and complex solutions,\n    if present.\n\n    >>> from sympy import exp, sin\n    >>> nonlinsolve([exp(x) - sin(y), y**2 - 4], [x, y])\n    {(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),\n     (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}\n\n    3. If system is non-linear polynomial and zero-dimensional then it\n    returns both solution (real and complex solutions, if present) using\n    :func:`~.solve_poly_system`:\n\n    >>> from sympy import sqrt\n    >>> nonlinsolve([x**2 - 2*y**2 -2, x*y - 2], [x, y])\n    {(-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I)}\n\n    4. ``nonlinsolve`` can solve some linear (zero or positive dimensional)\n    system (because it uses the :func:`sympy.polys.polytools.groebner` function to get the\n    groebner basis and then uses the ``substitution`` function basis as the\n    new `system`). But it is not recommended to solve linear system using\n    ``nonlinsolve``, because :func:`~.linsolve` is better for general linear systems.\n\n    >>> nonlinsolve([x + 2*y -z - 3, x - y - 4*z + 9, y + z - 4], [x, y, z])\n    {(3*z - 5, 4 - z, z)}\n\n    5. System having polynomial equations and only real solution is\n    solved using :func:`~.solve_poly_system`:\n\n    >>> e1 = sqrt(x**2 + y**2) - 10\n    >>> e2 = sqrt(y**2 + (-x + 10)**2) - 3\n    >>> nonlinsolve((e1, e2), (x, y))\n    {(191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20)}\n    >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [x, y])\n    {(1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5))}\n    >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [y, x])\n    {(2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5))}\n\n    6. It is better to use symbols instead of trigonometric functions or\n    :class:`~.Function`. For example, replace $\\sin(x)$ with a symbol, replace\n    $f(x)$ with a symbol and so on. Get a solution from ``nonlinsolve`` and then\n    use :func:`~.solveset` to get the value of $x$.\n\n    How nonlinsolve is better than old solver ``_solve_system`` :\n    =============================================================\n\n    1. A positive dimensional system solver: nonlinsolve can return\n    solution for positive dimensional system. It finds the\n    Groebner Basis of the positive dimensional system(calling it as\n    basis) then we can start solving equation(having least number of\n    variable first in the basis) using solveset and substituting that\n    solved solutions into other equation(of basis) to get solution in\n    terms of minimum variables. Here the important thing is how we\n    are substituting the known values and in which equations.\n\n    2. Real and complex solutions: nonlinsolve returns both real\n    and complex solution. If all the equations in the system are polynomial\n    then using :func:`~.solve_poly_system` both real and complex solution is returned.\n    If all the equations in the system are not polynomial equation then goes to\n    ``substitution`` method with this polynomial and non polynomial equation(s),\n    to solve for unsolved variables. Here to solve for particular variable\n    solveset_real and solveset_complex is used. For both real and complex\n    solution ``_solve_using_known_values`` is used inside ``substitution``\n    (``substitution`` will be called when any non-polynomial equation is present).\n    If a solution is valid its general solution is added to the final result.\n\n    3. :class:`~.Complement` and :class:`~.Intersection` will be added:\n    nonlinsolve maintains dict for complements and intersections. If solveset\n    find complements or/and intersections with any interval or set during the\n    execution of ``substitution`` function, then complement or/and\n    intersection for that variable is added before returning final solution.\n\n    ",
    "section": "Solveset Module Reference",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "_transolve",
    "full_id": "sympy.solvers.solveset._transolve",
    "type": "function",
    "description": "\n    Function to solve transcendental equations. It is a helper to\n    ``solveset`` and should be used internally. ``_transolve``\n    currently supports the following class of equations:\n\n        - Exponential equations\n        - Logarithmic equations\n\n    Parameters\n    ==========\n\n    f : Any transcendental equation that needs to be solved.\n        This needs to be an expression, which is assumed\n        to be equal to ``0``.\n\n    symbol : The variable for which the equation is solved.\n        This needs to be of class ``Symbol``.\n\n    domain : A set over which the equation is solved.\n        This needs to be of class ``Set``.\n\n    Returns\n    =======\n\n    Set\n        A set of values for ``symbol`` for which ``f`` is equal to\n        zero. An ``EmptySet`` is returned if ``f`` does not have solutions\n        in respective domain. A ``ConditionSet`` is returned as unsolved\n        object if algorithms to evaluate complete solution are not\n        yet implemented.\n\n    How to use ``_transolve``\n    =========================\n\n    ``_transolve`` should not be used as an independent function, because\n    it assumes that the equation (``f``) and the ``symbol`` comes from\n    ``solveset`` and might have undergone a few modification(s).\n    To use ``_transolve`` as an independent function the equation (``f``)\n    and the ``symbol`` should be passed as they would have been by\n    ``solveset``.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.solveset import _transolve as transolve\n    >>> from sympy.solvers.solvers import _tsolve as tsolve\n    >>> from sympy import symbols, S, pprint\n    >>> x = symbols('x', real=True) # assumption added\n    >>> transolve(5**(x - 3) - 3**(2*x + 1), x, S.Reals)\n    {-(log(3) + 3*log(5))/(-log(5) + 2*log(3))}\n\n    How ``_transolve`` works\n    ========================\n\n    ``_transolve`` uses two types of helper functions to solve equations\n    of a particular class:\n\n    Identifying helpers: To determine whether a given equation\n    belongs to a certain class of equation or not. Returns either\n    ``True`` or ``False``.\n\n    Solving helpers: Once an equation is identified, a corresponding\n    helper either solves the equation or returns a form of the equation\n    that ``solveset`` might better be able to handle.\n\n    * Philosophy behind the module\n\n    The purpose of ``_transolve`` is to take equations which are not\n    already polynomial in their generator(s) and to either recast them\n    as such through a valid transformation or to solve them outright.\n    A pair of helper functions for each class of supported\n    transcendental functions are employed for this purpose. One\n    identifies the transcendental form of an equation and the other\n    either solves it or recasts it into a tractable form that can be\n    solved by  ``solveset``.\n    For example, an equation in the form `ab^{f(x)} - cd^{g(x)} = 0`\n    can be transformed to\n    `\\log(a) + f(x)\\log(b) - \\log(c) - g(x)\\log(d) = 0`\n    (under certain assumptions) and this can be solved with ``solveset``\n    if `f(x)` and `g(x)` are in polynomial form.\n\n    How ``_transolve`` is better than ``_tsolve``\n    =============================================\n\n    1) Better output\n\n    ``_transolve`` provides expressions in a more simplified form.\n\n    Consider a simple exponential equation\n\n    >>> f = 3**(2*x) - 2**(x + 3)\n    >>> pprint(transolve(f, x, S.Reals), use_unicode=False)\n        -3*log(2)\n    {------------------}\n     -2*log(3) + log(2)\n    >>> pprint(tsolve(f, x), use_unicode=False)\n         /   3     \\\n         | --------|\n         | log(2/9)|\n    [-log\\2         /]\n\n    2) Extensible\n\n    The API of ``_transolve`` is designed such that it is easily\n    extensible, i.e. the code that solves a given class of\n    equations is encapsulated in a helper and not mixed in with\n    the code of ``_transolve`` itself.\n\n    3) Modular\n\n    ``_transolve`` is designed to be modular i.e, for every class of\n    equation a separate helper for identification and solving is\n    implemented. This makes it easy to change or modify any of the\n    method implemented directly in the helpers without interfering\n    with the actual structure of the API.\n\n    4) Faster Computation\n\n    Solving equation via ``_transolve`` is much faster as compared to\n    ``_tsolve``. In ``solve``, attempts are made computing every possibility\n    to get the solutions. This series of attempts makes solving a bit\n    slow. In ``_transolve``, computation begins only after a particular\n    type of equation is identified.\n\n    How to add new class of equations\n    =================================\n\n    Adding a new class of equation solver is a three-step procedure:\n\n    - Identify the type of the equations\n\n      Determine the type of the class of equations to which they belong:\n      it could be of ``Add``, ``Pow``, etc. types. Separate internal functions\n      are used for each type. Write identification and solving helpers\n      and use them from within the routine for the given type of equation\n      (after adding it, if necessary). Something like:\n\n      .. code-block:: python\n\n        def add_type(lhs, rhs, x):\n            ....\n            if _is_exponential(lhs, x):\n                new_eq = _solve_exponential(lhs, rhs, x)\n        ....\n        rhs, lhs = eq.as_independent(x)\n        if lhs.is_Add:\n            result = add_type(lhs, rhs, x)\n\n    - Define the identification helper.\n\n    - Define the solving helper.\n\n    Apart from this, a few other things needs to be taken care while\n    adding an equation solver:\n\n    - Naming conventions:\n      Name of the identification helper should be as\n      ``_is_class`` where class will be the name or abbreviation\n      of the class of equation. The solving helper will be named as\n      ``_solve_class``.\n      For example: for exponential equations it becomes\n      ``_is_exponential`` and ``_solve_expo``.\n    - The identifying helpers should take two input parameters,\n      the equation to be checked and the variable for which a solution\n      is being sought, while solving helpers would require an additional\n      domain parameter.\n    - Be sure to consider corner cases.\n    - Add tests for each helper.\n    - Add a docstring to your helper that describes the method\n      implemented.\n      The documentation of the helpers should identify:\n\n      - the purpose of the helper,\n      - the method used to identify and solve the equation,\n      - a proof of correctness\n      - the return values of the helpers\n    ",
    "section": "transolve",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "_is_exponential",
    "full_id": "sympy.solvers.solveset._is_exponential",
    "type": "function",
    "description": "\n    Return ``True`` if one or more terms contain ``symbol`` only in\n    exponents, else ``False``.\n\n    Parameters\n    ==========\n\n    f : Expr\n        The equation to be checked\n\n    symbol : Symbol\n        The variable in which the equation is checked\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, cos, exp\n    >>> from sympy.solvers.solveset import _is_exponential as check\n    >>> x, y = symbols('x y')\n    >>> check(y, y)\n    False\n    >>> check(x**y - 1, y)\n    True\n    >>> check(x**y*2**y - 1, y)\n    True\n    >>> check(exp(x + 3) + 3**x, x)\n    True\n    >>> check(cos(2**x), x)\n    False\n\n    * Philosophy behind the helper\n\n    The function extracts each term of the equation and checks if it is\n    of exponential form w.r.t ``symbol``.\n    ",
    "section": "transolve",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "_solve_exponential",
    "full_id": "sympy.solvers.solveset._solve_exponential",
    "type": "function",
    "description": "\n    Helper function for solving (supported) exponential equations.\n\n    Exponential equations are the sum of (currently) at most\n    two terms with one or both of them having a power with a\n    symbol-dependent exponent.\n\n    For example\n\n    .. math:: 5^{2x + 3} - 5^{3x - 1}\n\n    .. math:: 4^{5 - 9x} - e^{2 - x}\n\n    Parameters\n    ==========\n\n    lhs, rhs : Expr\n        The exponential equation to be solved, `lhs = rhs`\n\n    symbol : Symbol\n        The variable in which the equation is solved\n\n    domain : Set\n        A set over which the equation is solved.\n\n    Returns\n    =======\n\n    A set of solutions satisfying the given equation.\n    A ``ConditionSet`` if the equation is unsolvable or\n    if the assumptions are not properly defined, in that case\n    a different style of ``ConditionSet`` is returned having the\n    solution(s) of the equation with the desired assumptions.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.solveset import _solve_exponential as solve_expo\n    >>> from sympy import symbols, S\n    >>> x = symbols('x', real=True)\n    >>> a, b = symbols('a b')\n    >>> solve_expo(2**x + 3**x - 5**x, 0, x, S.Reals)  # not solvable\n    ConditionSet(x, Eq(2**x + 3**x - 5**x, 0), Reals)\n    >>> solve_expo(a**x - b**x, 0, x, S.Reals)  # solvable but incorrect assumptions\n    ConditionSet(x, (a > 0) & (b > 0), {0})\n    >>> solve_expo(3**(2*x) - 2**(x + 3), 0, x, S.Reals)\n    {-3*log(2)/(-2*log(3) + log(2))}\n    >>> solve_expo(2**x - 4**x, 0, x, S.Reals)\n    {0}\n\n    * Proof of correctness of the method\n\n    The logarithm function is the inverse of the exponential function.\n    The defining relation between exponentiation and logarithm is:\n\n    .. math:: {\\log_b x} = y \\enspace if \\enspace b^y = x\n\n    Therefore if we are given an equation with exponent terms, we can\n    convert every term to its corresponding logarithmic form. This is\n    achieved by taking logarithms and expanding the equation using\n    logarithmic identities so that it can easily be handled by ``solveset``.\n\n    For example:\n\n    .. math:: 3^{2x} = 2^{x + 3}\n\n    Taking log both sides will reduce the equation to\n\n    .. math:: (2x)\\log(3) = (x + 3)\\log(2)\n\n    This form can be easily handed by ``solveset``.\n    ",
    "section": "transolve",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "_solve_logarithm",
    "full_id": "sympy.solvers.solveset._solve_logarithm",
    "type": "function",
    "description": "\n    Helper to solve logarithmic equations which are reducible\n    to a single instance of `\\log`.\n\n    Logarithmic equations are (currently) the equations that contains\n    `\\log` terms which can be reduced to a single `\\log` term or\n    a constant using various logarithmic identities.\n\n    For example:\n\n    .. math:: \\log(x) + \\log(x - 4)\n\n    can be reduced to:\n\n    .. math:: \\log(x(x - 4))\n\n    Parameters\n    ==========\n\n    lhs, rhs : Expr\n        The logarithmic equation to be solved, `lhs = rhs`\n\n    symbol : Symbol\n        The variable in which the equation is solved\n\n    domain : Set\n        A set over which the equation is solved.\n\n    Returns\n    =======\n\n    A set of solutions satisfying the given equation.\n    A ``ConditionSet`` if the equation is unsolvable.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, log, S\n    >>> from sympy.solvers.solveset import _solve_logarithm as solve_log\n    >>> x = symbols('x')\n    >>> f = log(x - 3) + log(x + 3)\n    >>> solve_log(f, 0, x, S.Reals)\n    {-sqrt(10), sqrt(10)}\n\n    * Proof of correctness\n\n    A logarithm is another way to write exponent and is defined by\n\n    .. math:: {\\log_b x} = y \\enspace if \\enspace b^y = x\n\n    When one side of the equation contains a single logarithm, the\n    equation can be solved by rewriting the equation as an equivalent\n    exponential equation as defined above. But if one side contains\n    more than one logarithm, we need to use the properties of logarithm\n    to condense it into a single logarithm.\n\n    Take for example\n\n    .. math:: \\log(2x) - 15 = 0\n\n    contains single logarithm, therefore we can directly rewrite it to\n    exponential form as\n\n    .. math:: x = \\frac{e^{15}}{2}\n\n    But if the equation has more than one logarithm as\n\n    .. math:: \\log(x - 3) + \\log(x + 3) = 0\n\n    we use logarithmic identities to convert it into a reduced form\n\n    Using,\n\n    .. math:: \\log(a) + \\log(b) = \\log(ab)\n\n    the equation becomes,\n\n    .. math:: \\log((x - 3)(x + 3))\n\n    This equation contains one logarithm and can be solved by rewriting\n    to exponents.\n    ",
    "section": "transolve",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "_is_logarithmic",
    "full_id": "sympy.solvers.solveset._is_logarithmic",
    "type": "function",
    "description": "\n    Return ``True`` if the equation is in the form\n    `a\\log(f(x)) + b\\log(g(x)) + ... + c` else ``False``.\n\n    Parameters\n    ==========\n\n    f : Expr\n        The equation to be checked\n\n    symbol : Symbol\n        The variable in which the equation is checked\n\n    Returns\n    =======\n\n    ``True`` if the equation is logarithmic otherwise ``False``.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, tan, log\n    >>> from sympy.solvers.solveset import _is_logarithmic as check\n    >>> x, y = symbols('x y')\n    >>> check(log(x + 2) - log(x + 3), x)\n    True\n    >>> check(tan(log(2*x)), x)\n    False\n    >>> check(x*log(x), x)\n    False\n    >>> check(x + log(x), x)\n    False\n    >>> check(y + log(x), x)\n    True\n\n    * Philosophy behind the helper\n\n    The function extracts each term and checks whether it is\n    logarithmic w.r.t ``symbol``.\n    ",
    "section": "transolve",
    "url": "https://docs.sympy.org/latest/modules/solvers/solveset.html"
  },
  {
    "name": "add",
    "full_id": "sympy.algebras.Quaternion.add",
    "type": "method",
    "description": "Adds quaternions.\n\n        Parameters\n        ==========\n\n        other : Quaternion\n            The quaternion to add to current (self) quaternion.\n\n        Returns\n        =======\n\n        Quaternion\n            The resultant quaternion after adding self to other\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy import symbols\n        >>> q1 = Quaternion(1, 2, 3, 4)\n        >>> q2 = Quaternion(5, 6, 7, 8)\n        >>> q1.add(q2)\n        6 + 8*i + 10*j + 12*k\n        >>> q1 + 5\n        6 + 2*i + 3*j + 4*k\n        >>> x = symbols('x', real = True)\n        >>> q1.add(x)\n        (x + 1) + 2*i + 3*j + 4*k\n\n        Quaternions over complex fields :\n\n        >>> from sympy import Quaternion\n        >>> from sympy import I\n        >>> q3 = Quaternion(3 + 4*I, 2 + 5*I, 0, 7 + 8*I, real_field = False)\n        >>> q3.add(2 + 3*I)\n        (5 + 7*I) + (2 + 5*I)*i + 0*j + (7 + 8*I)*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "angle",
    "full_id": "sympy.algebras.Quaternion.angle",
    "type": "method",
    "description": "\n        Returns the angle of the quaternion measured in the real-axis plane.\n\n        Explanation\n        ===========\n\n        Given a quaternion $q = a + bi + cj + dk$ where $a$, $b$, $c$ and $d$\n        are real numbers, returns the angle of the quaternion given by\n\n        .. math::\n            \\theta := 2 \\operatorname{atan_2}\\left(\\sqrt{b^2 + c^2 + d^2}, {a}\\right)\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(1, 4, 4, 4)\n        >>> q.angle()\n        2*atan(4*sqrt(3))\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "arc_coplanar",
    "full_id": "sympy.algebras.Quaternion.arc_coplanar",
    "type": "method",
    "description": "\n        Returns True if the transformation arcs represented by the input quaternions happen in the same plane.\n\n        Explanation\n        ===========\n\n        Two quaternions are said to be coplanar (in this arc sense) when their axes are parallel.\n        The plane of a quaternion is the one normal to its axis.\n\n        Parameters\n        ==========\n\n        other : a Quaternion\n\n        Returns\n        =======\n\n        True : if the planes of the two quaternions are the same, apart from its orientation/sign.\n        False : if the planes of the two quaternions are not the same, apart from its orientation/sign.\n        None : if plane of either of the quaternion is unknown.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q1 = Quaternion(1, 4, 4, 4)\n        >>> q2 = Quaternion(3, 8, 8, 8)\n        >>> Quaternion.arc_coplanar(q1, q2)\n        True\n\n        >>> q1 = Quaternion(2, 8, 13, 12)\n        >>> Quaternion.arc_coplanar(q1, q2)\n        False\n\n        See Also\n        ========\n\n        vector_coplanar\n        is_pure\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "axis",
    "full_id": "sympy.algebras.Quaternion.axis",
    "type": "method",
    "description": "\n        Returns $\\mathbf{Ax}(q)$, the axis of the quaternion $q$.\n\n        Explanation\n        ===========\n\n        Given a quaternion $q = a + bi + cj + dk$, returns $\\mathbf{Ax}(q)$  i.e., the versor of the vector part of that quaternion\n        equal to $\\mathbf{U}[\\mathbf{V}(q)]$.\n        The axis is always an imaginary unit with square equal to $-1 + 0i + 0j + 0k$.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(1, 1, 1, 1)\n        >>> q.axis()\n        0 + sqrt(3)/3*i + sqrt(3)/3*j + sqrt(3)/3*k\n\n        See Also\n        ========\n\n        vector_part\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "exp",
    "full_id": "sympy.algebras.Quaternion.exp",
    "type": "method",
    "description": "Returns the exponential of $q$, given by $e^q$.\n\n        Returns\n        =======\n\n        Quaternion\n            The exponential of the quaternion.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> q = Quaternion(1, 2, 3, 4)\n        >>> q.exp()\n        E*cos(sqrt(29))\n        + 2*sqrt(29)*E*sin(sqrt(29))/29*i\n        + 3*sqrt(29)*E*sin(sqrt(29))/29*j\n        + 4*sqrt(29)*E*sin(sqrt(29))/29*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "from_Matrix",
    "full_id": "sympy.algebras.Quaternion.from_Matrix",
    "type": "method",
    "description": "Returns quaternion from elements of a column vector`.\n        If vector_only is True, returns only imaginary part as a Matrix of\n        length 3.\n\n        Parameters\n        ==========\n\n        elements : Matrix, list or tuple of length 3 or 4. If length is 3,\n            assume real part is zero.\n            Default value: False\n\n        Returns\n        =======\n\n        Quaternion\n            A quaternion created from the input elements.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy.abc import a, b, c, d\n        >>> q = Quaternion.from_Matrix([a, b, c, d])\n        >>> q\n        a + b*i + c*j + d*k\n\n        >>> q = Quaternion.from_Matrix([b, c, d])\n        >>> q\n        0 + b*i + c*j + d*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "from_axis_angle",
    "full_id": "sympy.algebras.Quaternion.from_axis_angle",
    "type": "method",
    "description": "Returns a rotation quaternion given the axis and the angle of rotation.\n\n        Parameters\n        ==========\n\n        vector : tuple of three numbers\n            The vector representation of the given axis.\n        angle : number\n            The angle by which axis is rotated (in radians).\n\n        Returns\n        =======\n\n        Quaternion\n            The normalized rotation quaternion calculated from the given axis and the angle of rotation.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy import pi, sqrt\n        >>> q = Quaternion.from_axis_angle((sqrt(3)/3, sqrt(3)/3, sqrt(3)/3), 2*pi/3)\n        >>> q\n        1/2 + 1/2*i + 1/2*j + 1/2*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "from_euler",
    "full_id": "sympy.algebras.Quaternion.from_euler",
    "type": "method",
    "description": "Returns quaternion equivalent to rotation represented by the Euler\n        angles, in the sequence defined by ``seq``.\n\n        Parameters\n        ==========\n\n        angles : list, tuple or Matrix of 3 numbers\n            The Euler angles (in radians).\n        seq : string of length 3\n            Represents the sequence of rotations.\n            For extrinsic rotations, seq must be all lowercase and its elements\n            must be from the set ``{'x', 'y', 'z'}``\n            For intrinsic rotations, seq must be all uppercase and its elements\n            must be from the set ``{'X', 'Y', 'Z'}``\n\n        Returns\n        =======\n\n        Quaternion\n            The normalized rotation quaternion calculated from the Euler angles\n            in the given sequence.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy import pi\n        >>> q = Quaternion.from_euler([pi/2, 0, 0], 'xyz')\n        >>> q\n        sqrt(2)/2 + sqrt(2)/2*i + 0*j + 0*k\n\n        >>> q = Quaternion.from_euler([0, pi/2, pi] , 'zyz')\n        >>> q\n        0 + (-sqrt(2)/2)*i + 0*j + sqrt(2)/2*k\n\n        >>> q = Quaternion.from_euler([0, pi/2, pi] , 'ZYZ')\n        >>> q\n        0 + sqrt(2)/2*i + 0*j + sqrt(2)/2*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "from_rotation_matrix",
    "full_id": "sympy.algebras.Quaternion.from_rotation_matrix",
    "type": "method",
    "description": "Returns the equivalent quaternion of a matrix. The quaternion will be normalized\n        only if the matrix is special orthogonal (orthogonal and det(M) = 1).\n\n        Parameters\n        ==========\n\n        M : Matrix\n            Input matrix to be converted to equivalent quaternion. M must be special\n            orthogonal (orthogonal and det(M) = 1) for the quaternion to be normalized.\n\n        Returns\n        =======\n\n        Quaternion\n            The quaternion equivalent to given matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy import Matrix, symbols, cos, sin, trigsimp\n        >>> x = symbols('x')\n        >>> M = Matrix([[cos(x), -sin(x), 0], [sin(x), cos(x), 0], [0, 0, 1]])\n        >>> q = trigsimp(Quaternion.from_rotation_matrix(M))\n        >>> q\n        sqrt(2)*sqrt(cos(x) + 1)/2 + 0*i + 0*j + sqrt(2 - 2*cos(x))*sign(sin(x))/2*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "index_vector",
    "full_id": "sympy.algebras.Quaternion.index_vector",
    "type": "method",
    "description": "\n        Returns the index vector of the quaternion.\n\n        Explanation\n        ===========\n\n        The index vector is given by $\\mathbf{T}(q)$, the norm (or magnitude) of\n        the quaternion $q$, multiplied by $\\mathbf{Ax}(q)$, the axis of $q$.\n\n        Returns\n        =======\n\n        Quaternion: representing index vector of the provided quaternion.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(2, 4, 2, 4)\n        >>> q.index_vector()\n        0 + 4*sqrt(10)/3*i + 2*sqrt(10)/3*j + 4*sqrt(10)/3*k\n\n        See Also\n        ========\n\n        axis\n        norm\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "integrate",
    "full_id": "sympy.algebras.Quaternion.integrate",
    "type": "method",
    "description": "Computes integration of quaternion.\n\n        Returns\n        =======\n\n        Quaternion\n            Integration of the quaternion(self) with the given variable.\n\n        Examples\n        ========\n\n        Indefinite Integral of quaternion :\n\n        >>> from sympy import Quaternion\n        >>> from sympy.abc import x\n        >>> q = Quaternion(1, 2, 3, 4)\n        >>> q.integrate(x)\n        x + 2*x*i + 3*x*j + 4*x*k\n\n        Definite integral of quaternion :\n\n        >>> from sympy import Quaternion\n        >>> from sympy.abc import x\n        >>> q = Quaternion(1, 2, 3, 4)\n        >>> q.integrate((x, 1, 5))\n        4 + 8*i + 12*j + 16*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "inverse",
    "full_id": "sympy.algebras.Quaternion.inverse",
    "type": "method",
    "description": "Returns the inverse of the quaternion.",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "is_pure",
    "full_id": "sympy.algebras.Quaternion.is_pure",
    "type": "method",
    "description": "\n        Returns true if the quaternion is pure, false if the quaternion is not pure\n        or returns none if it is unknown.\n\n        Explanation\n        ===========\n\n        A pure quaternion (also a vector quaternion) is a quaternion with scalar\n        part equal to 0.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(0, 8, 13, 12)\n        >>> q.is_pure()\n        True\n\n        See Also\n        ========\n        scalar_part\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "is_zero_quaternion",
    "full_id": "sympy.algebras.Quaternion.is_zero_quaternion",
    "type": "method",
    "description": "\n        Returns true if the quaternion is a zero quaternion or false if it is not a zero quaternion\n        and None if the value is unknown.\n\n        Explanation\n        ===========\n\n        A zero quaternion is a quaternion with both scalar part and\n        vector part equal to 0.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(1, 0, 0, 0)\n        >>> q.is_zero_quaternion()\n        False\n\n        >>> q = Quaternion(0, 0, 0, 0)\n        >>> q.is_zero_quaternion()\n        True\n\n        See Also\n        ========\n        scalar_part\n        vector_part\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "log",
    "full_id": "sympy.algebras.Quaternion.log",
    "type": "method",
    "description": "Returns the logarithm of the quaternion, given by $\\log q$.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> q = Quaternion(1, 2, 3, 4)\n        >>> q.log()\n        log(sqrt(30))\n        + 2*sqrt(29)*acos(sqrt(30)/30)/29*i\n        + 3*sqrt(29)*acos(sqrt(30)/30)/29*j\n        + 4*sqrt(29)*acos(sqrt(30)/30)/29*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "mensor",
    "full_id": "sympy.algebras.Quaternion.mensor",
    "type": "method",
    "description": "\n        Returns the natural logarithm of the norm(magnitude) of the quaternion.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(2, 4, 2, 4)\n        >>> q.mensor()\n        log(2*sqrt(10))\n        >>> q.norm()\n        2*sqrt(10)\n\n        See Also\n        ========\n\n        norm\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.algebras.Quaternion.mul",
    "type": "method",
    "description": "Multiplies quaternions.\n\n        Parameters\n        ==========\n\n        other : Quaternion or symbol\n            The quaternion to multiply to current (self) quaternion.\n\n        Returns\n        =======\n\n        Quaternion\n            The resultant quaternion after multiplying self with other\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy import symbols\n        >>> q1 = Quaternion(1, 2, 3, 4)\n        >>> q2 = Quaternion(5, 6, 7, 8)\n        >>> q1.mul(q2)\n        (-60) + 12*i + 30*j + 24*k\n        >>> q1.mul(2)\n        2 + 4*i + 6*j + 8*k\n        >>> x = symbols('x', real = True)\n        >>> q1.mul(x)\n        x + 2*x*i + 3*x*j + 4*x*k\n\n        Quaternions over complex fields :\n\n        >>> from sympy import Quaternion\n        >>> from sympy import I\n        >>> q3 = Quaternion(3 + 4*I, 2 + 5*I, 0, 7 + 8*I, real_field = False)\n        >>> q3.mul(2 + 3*I)\n        (2 + 3*I)*(3 + 4*I) + (2 + 3*I)*(2 + 5*I)*i + 0*j + (2 + 3*I)*(7 + 8*I)*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "norm",
    "full_id": "sympy.algebras.Quaternion.norm",
    "type": "method",
    "description": "Returns the norm of the quaternion.",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "normalize",
    "full_id": "sympy.algebras.Quaternion.normalize",
    "type": "method",
    "description": "Returns the normalized form of the quaternion.",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "orthogonal",
    "full_id": "sympy.algebras.Quaternion.orthogonal",
    "type": "method",
    "description": "\n        Returns the orthogonality of two quaternions.\n\n        Explanation\n        ===========\n\n        Two pure quaternions are called orthogonal when their product is anti-commutative.\n\n        Parameters\n        ==========\n\n        other : a Quaternion\n\n        Returns\n        =======\n\n        True : if the two pure quaternions seen as 3D vectors are orthogonal.\n        False : if the two pure quaternions seen as 3D vectors are not orthogonal.\n        None : if the two pure quaternions seen as 3D vectors are orthogonal is unknown.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(0, 4, 4, 4)\n        >>> q1 = Quaternion(0, 8, 8, 8)\n        >>> q.orthogonal(q1)\n        False\n\n        >>> q1 = Quaternion(0, 2, 2, 0)\n        >>> q = Quaternion(0, 2, -2, 0)\n        >>> q.orthogonal(q1)\n        True\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "parallel",
    "full_id": "sympy.algebras.Quaternion.parallel",
    "type": "method",
    "description": "\n        Returns True if the two pure quaternions seen as 3D vectors are parallel.\n\n        Explanation\n        ===========\n\n        Two pure quaternions are called parallel when their vector product is commutative which\n        implies that the quaternions seen as 3D vectors have same direction.\n\n        Parameters\n        ==========\n\n        other : a Quaternion\n\n        Returns\n        =======\n\n        True : if the two pure quaternions seen as 3D vectors are parallel.\n        False : if the two pure quaternions seen as 3D vectors are not parallel.\n        None : if the two pure quaternions seen as 3D vectors are parallel is unknown.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(0, 4, 4, 4)\n        >>> q1 = Quaternion(0, 8, 8, 8)\n        >>> q.parallel(q1)\n        True\n\n        >>> q1 = Quaternion(0, 8, 13, 12)\n        >>> q.parallel(q1)\n        False\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "pow",
    "full_id": "sympy.algebras.Quaternion.pow",
    "type": "method",
    "description": "Finds the pth power of the quaternion.\n\n        Parameters\n        ==========\n\n        p : int\n            Power to be applied on quaternion.\n\n        Returns\n        =======\n\n        Quaternion\n            Returns the p-th power of the current quaternion.\n            Returns the inverse if p = -1.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> q = Quaternion(1, 2, 3, 4)\n        >>> q.pow(4)\n        668 + (-224)*i + (-336)*j + (-448)*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "pow_cos_sin",
    "full_id": "sympy.algebras.Quaternion.pow_cos_sin",
    "type": "method",
    "description": "Computes the pth power in the cos-sin form.\n\n        Parameters\n        ==========\n\n        p : int\n            Power to be applied on quaternion.\n\n        Returns\n        =======\n\n        Quaternion\n            The p-th power in the cos-sin form.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> q = Quaternion(1, 2, 3, 4)\n        >>> q.pow_cos_sin(4)\n        900*cos(4*acos(sqrt(30)/30))\n        + 1800*sqrt(29)*sin(4*acos(sqrt(30)/30))/29*i\n        + 2700*sqrt(29)*sin(4*acos(sqrt(30)/30))/29*j\n        + 3600*sqrt(29)*sin(4*acos(sqrt(30)/30))/29*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "product_matrix_left",
    "full_id": "sympy.algebras.Quaternion.product_matrix_left",
    "type": "property",
    "description": "Returns 4 x 4 Matrix equivalent to a Hamilton product from the\n        left. This can be useful when treating quaternion elements as column\n        vectors. Given a quaternion $q = a + bi + cj + dk$ where a, b, c and d\n        are real numbers, the product matrix from the left is:\n\n        .. math::\n\n            M  =  \\begin{bmatrix} a  &-b  &-c  &-d \\\\\n                                  b  & a  &-d  & c \\\\\n                                  c  & d  & a  &-b \\\\\n                                  d  &-c  & b  & a \\end{bmatrix}\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy.abc import a, b, c, d\n        >>> q1 = Quaternion(1, 0, 0, 1)\n        >>> q2 = Quaternion(a, b, c, d)\n        >>> q1.product_matrix_left\n        Matrix([\n        [1, 0,  0, -1],\n        [0, 1, -1,  0],\n        [0, 1,  1,  0],\n        [1, 0,  0,  1]])\n\n        >>> q1.product_matrix_left * q2.to_Matrix()\n        Matrix([\n        [a - d],\n        [b - c],\n        [b + c],\n        [a + d]])\n\n        This is equivalent to:\n\n        >>> (q1 * q2).to_Matrix()\n        Matrix([\n        [a - d],\n        [b - c],\n        [b + c],\n        [a + d]])\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "product_matrix_right",
    "full_id": "sympy.algebras.Quaternion.product_matrix_right",
    "type": "property",
    "description": "Returns 4 x 4 Matrix equivalent to a Hamilton product from the\n        right. This can be useful when treating quaternion elements as column\n        vectors. Given a quaternion $q = a + bi + cj + dk$ where a, b, c and d\n        are real numbers, the product matrix from the left is:\n\n        .. math::\n\n            M  =  \\begin{bmatrix} a  &-b  &-c  &-d \\\\\n                                  b  & a  & d  &-c \\\\\n                                  c  &-d  & a  & b \\\\\n                                  d  & c  &-b  & a \\end{bmatrix}\n\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy.abc import a, b, c, d\n        >>> q1 = Quaternion(a, b, c, d)\n        >>> q2 = Quaternion(1, 0, 0, 1)\n        >>> q2.product_matrix_right\n        Matrix([\n        [1, 0, 0, -1],\n        [0, 1, 1, 0],\n        [0, -1, 1, 0],\n        [1, 0, 0, 1]])\n\n        Note the switched arguments: the matrix represents the quaternion on\n        the right, but is still considered as a matrix multiplication from the\n        left.\n\n        >>> q2.product_matrix_right * q1.to_Matrix()\n        Matrix([\n        [ a - d],\n        [ b + c],\n        [-b + c],\n        [ a + d]])\n\n        This is equivalent to:\n\n        >>> (q1 * q2).to_Matrix()\n        Matrix([\n        [ a - d],\n        [ b + c],\n        [-b + c],\n        [ a + d]])\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "rotate_point",
    "full_id": "sympy.algebras.Quaternion.rotate_point",
    "type": "method",
    "description": "Returns the coordinates of the point pin (a 3 tuple) after rotation.\n\n        Parameters\n        ==========\n\n        pin : tuple\n            A 3-element tuple of coordinates of a point which needs to be\n            rotated.\n        r : Quaternion or tuple\n            Axis and angle of rotation.\n\n            It's important to note that when r is a tuple, it must be of the form\n            (axis, angle)\n\n        Returns\n        =======\n\n        tuple\n            The coordinates of the point after rotation.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy import symbols, trigsimp, cos, sin\n        >>> x = symbols('x')\n        >>> q = Quaternion(cos(x/2), 0, 0, sin(x/2))\n        >>> trigsimp(Quaternion.rotate_point((1, 1, 1), q))\n        (sqrt(2)*cos(x + pi/4), sqrt(2)*sin(x + pi/4), 1)\n        >>> (axis, angle) = q.to_axis_angle()\n        >>> trigsimp(Quaternion.rotate_point((1, 1, 1), (axis, angle)))\n        (sqrt(2)*cos(x + pi/4), sqrt(2)*sin(x + pi/4), 1)\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "scalar_part",
    "full_id": "sympy.algebras.Quaternion.scalar_part",
    "type": "method",
    "description": "Returns scalar part($\\mathbf{S}(q)$) of the quaternion q.\n\n        Explanation\n        ===========\n\n        Given a quaternion $q = a + bi + cj + dk$, returns $\\mathbf{S}(q) = a$.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(4, 8, 13, 12)\n        >>> q.scalar_part()\n        4\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "set_norm",
    "full_id": "sympy.algebras.Quaternion.set_norm",
    "type": "method",
    "description": "Sets norm of an already instantiated quaternion.\n\n        Parameters\n        ==========\n\n        norm : None or number\n            Pre-defined quaternion norm. If a value is given, Quaternion.norm\n            returns this pre-defined value instead of calculating the norm\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy.abc import a, b, c, d\n        >>> q = Quaternion(a, b, c, d)\n        >>> q.norm()\n        sqrt(a**2 + b**2 + c**2 + d**2)\n\n        Setting the norm:\n\n        >>> q.set_norm(1)\n        >>> q.norm()\n        1\n\n        Removing set norm:\n\n        >>> q.set_norm(None)\n        >>> q.norm()\n        sqrt(a**2 + b**2 + c**2 + d**2)\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "to_Matrix",
    "full_id": "sympy.algebras.Quaternion.to_Matrix",
    "type": "method",
    "description": "Returns elements of quaternion as a column vector.\n        By default, a ``Matrix`` of length 4 is returned, with the real part as the\n        first element.\n        If ``vector_only`` is ``True``, returns only imaginary part as a Matrix of\n        length 3.\n\n        Parameters\n        ==========\n\n        vector_only : bool\n            If True, only imaginary part is returned.\n            Default value: False\n\n        Returns\n        =======\n\n        Matrix\n            A column vector constructed by the elements of the quaternion.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy.abc import a, b, c, d\n        >>> q = Quaternion(a, b, c, d)\n        >>> q\n        a + b*i + c*j + d*k\n\n        >>> q.to_Matrix()\n        Matrix([\n        [a],\n        [b],\n        [c],\n        [d]])\n\n\n        >>> q.to_Matrix(vector_only=True)\n        Matrix([\n        [b],\n        [c],\n        [d]])\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "to_axis_angle",
    "full_id": "sympy.algebras.Quaternion.to_axis_angle",
    "type": "method",
    "description": "Returns the axis and angle of rotation of a quaternion.\n\n        Returns\n        =======\n\n        tuple\n            Tuple of (axis, angle)\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> q = Quaternion(1, 1, 1, 1)\n        >>> (axis, angle) = q.to_axis_angle()\n        >>> axis\n        (sqrt(3)/3, sqrt(3)/3, sqrt(3)/3)\n        >>> angle\n        2*pi/3\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "to_euler",
    "full_id": "sympy.algebras.Quaternion.to_euler",
    "type": "method",
    "description": "Returns Euler angles representing same rotation as the quaternion,\n        in the sequence given by ``seq``. This implements the method described\n        in [1]_.\n\n        For degenerate cases (gymbal lock cases), the third angle is\n        set to zero.\n\n        Parameters\n        ==========\n\n        seq : string of length 3\n            Represents the sequence of rotations.\n            For extrinsic rotations, seq must be all lowercase and its elements\n            must be from the set ``{'x', 'y', 'z'}``\n            For intrinsic rotations, seq must be all uppercase and its elements\n            must be from the set ``{'X', 'Y', 'Z'}``\n\n        angle_addition : bool\n            When True, first and third angles are given as an addition and\n            subtraction of two simpler ``atan2`` expressions. When False, the\n            first and third angles are each given by a single more complicated\n            ``atan2`` expression. This equivalent expression is given by:\n\n            .. math::\n\n                \\operatorname{atan_2} (b,a) \\pm \\operatorname{atan_2} (d,c) =\n                \\operatorname{atan_2} (bc\\pm ad, ac\\mp bd)\n\n            Default value: True\n\n        avoid_square_root : bool\n            When True, the second angle is calculated with an expression based\n            on ``acos``, which is slightly more complicated but avoids a square\n            root. When False, second angle is calculated with ``atan2``, which\n            is simpler and can be better for numerical reasons (some\n            numerical implementations of ``acos`` have problems near zero).\n            Default value: False\n\n\n        Returns\n        =======\n\n        Tuple\n            The Euler angles calculated from the quaternion\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy.abc import a, b, c, d\n        >>> euler = Quaternion(a, b, c, d).to_euler('zyz')\n        >>> euler\n        (-atan2(-b, c) + atan2(d, a),\n         2*atan2(sqrt(b**2 + c**2), sqrt(a**2 + d**2)),\n         atan2(-b, c) + atan2(d, a))\n\n\n        References\n        ==========\n\n        .. [1] https://doi.org/10.1371/journal.pone.0276302\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "to_rotation_matrix",
    "full_id": "sympy.algebras.Quaternion.to_rotation_matrix",
    "type": "method",
    "description": "Returns the equivalent rotation transformation matrix of the quaternion\n        which represents rotation about the origin if ``v`` is not passed.\n\n        Parameters\n        ==========\n\n        v : tuple or None\n            Default value: None\n        homogeneous : bool\n            When True, gives an expression that may be more efficient for\n            symbolic calculations but less so for direct evaluation. Both\n            formulas are mathematically equivalent.\n            Default value: True\n\n        Returns\n        =======\n\n        tuple\n            Returns the equivalent rotation transformation matrix of the quaternion\n            which represents rotation about the origin if v is not passed.\n\n        Examples\n        ========\n\n        >>> from sympy import Quaternion\n        >>> from sympy import symbols, trigsimp, cos, sin\n        >>> x = symbols('x')\n        >>> q = Quaternion(cos(x/2), 0, 0, sin(x/2))\n        >>> trigsimp(q.to_rotation_matrix())\n        Matrix([\n        [cos(x), -sin(x), 0],\n        [sin(x),  cos(x), 0],\n        [     0,       0, 1]])\n\n        Generates a 4x4 transformation matrix (used for rotation about a point\n        other than the origin) if the point(v) is passed as an argument.\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "vector_coplanar",
    "full_id": "sympy.algebras.Quaternion.vector_coplanar",
    "type": "method",
    "description": "\n        Returns True if the axis of the pure quaternions seen as 3D vectors\n        ``q1``, ``q2``, and ``q3`` are coplanar.\n\n        Explanation\n        ===========\n\n        Three pure quaternions are vector coplanar if the quaternions seen as 3D vectors are coplanar.\n\n        Parameters\n        ==========\n\n        q1\n            A pure Quaternion.\n        q2\n            A pure Quaternion.\n        q3\n            A pure Quaternion.\n\n        Returns\n        =======\n\n        True : if the axis of the pure quaternions seen as 3D vectors\n        q1, q2, and q3 are coplanar.\n        False : if the axis of the pure quaternions seen as 3D vectors\n        q1, q2, and q3 are not coplanar.\n        None : if the axis of the pure quaternions seen as 3D vectors\n        q1, q2, and q3 are coplanar is unknown.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q1 = Quaternion(0, 4, 4, 4)\n        >>> q2 = Quaternion(0, 8, 8, 8)\n        >>> q3 = Quaternion(0, 24, 24, 24)\n        >>> Quaternion.vector_coplanar(q1, q2, q3)\n        True\n\n        >>> q1 = Quaternion(0, 8, 16, 8)\n        >>> q2 = Quaternion(0, 8, 3, 12)\n        >>> Quaternion.vector_coplanar(q1, q2, q3)\n        False\n\n        See Also\n        ========\n\n        axis\n        is_pure\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "vector_part",
    "full_id": "sympy.algebras.Quaternion.vector_part",
    "type": "method",
    "description": "\n        Returns $\\mathbf{V}(q)$, the vector part of the quaternion $q$.\n\n        Explanation\n        ===========\n\n        Given a quaternion $q = a + bi + cj + dk$, returns $\\mathbf{V}(q) = bi + cj + dk$.\n\n        Examples\n        ========\n\n        >>> from sympy.algebras.quaternion import Quaternion\n        >>> q = Quaternion(1, 1, 1, 1)\n        >>> q.vector_part()\n        0 + 1*i + 1*j + 1*k\n\n        >>> q = Quaternion(4, 8, 13, 12)\n        >>> q.vector_part()\n        0 + 8*i + 13*j + 12*k\n\n        ",
    "section": "Quaternion Reference",
    "url": "https://docs.sympy.org/latest/modules/algebras.html"
  },
  {
    "name": "euler_maclaurin",
    "full_id": "sympy.concrete.summations.Sum.euler_maclaurin",
    "type": "method",
    "description": "\n        Return an Euler-Maclaurin approximation of self, where m is the\n        number of leading terms to sum directly and n is the number of\n        terms in the tail.\n\n        With m = n = 0, this is simply the corresponding integral\n        plus a first-order endpoint correction.\n\n        Returns (s, e) where s is the Euler-Maclaurin approximation\n        and e is the estimated error (taken to be the magnitude of\n        the first omitted term in the tail):\n\n            >>> from sympy.abc import k, a, b\n            >>> from sympy import Sum\n            >>> Sum(1/k, (k, 2, 5)).doit().evalf()\n            1.28333333333333\n            >>> s, e = Sum(1/k, (k, 2, 5)).euler_maclaurin()\n            >>> s\n            -log(2) + 7/20 + log(5)\n            >>> from sympy import sstr\n            >>> print(sstr((s.evalf(), e.evalf()), full_prec=True))\n            (1.26629073187415, 0.0175000000000000)\n\n        The endpoints may be symbolic:\n\n            >>> s, e = Sum(1/k, (k, a, b)).euler_maclaurin()\n            >>> s\n            -log(a) + log(b) + 1/(2*b) + 1/(2*a)\n            >>> e\n            Abs(1/(12*b**2) - 1/(12*a**2))\n\n        If the function is a polynomial of degree at most 2n+1, the\n        Euler-Maclaurin formula becomes exact (and e = 0 is returned):\n\n            >>> Sum(k, (k, 2, b)).euler_maclaurin()\n            (b**2/2 + b/2 - 1, 0)\n            >>> Sum(k, (k, 2, b)).doit()\n            b**2/2 + b/2 - 1\n\n        With a nonzero eps specified, the summation is ended\n        as soon as the remainder term is less than the epsilon.\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "eval_zeta_function",
    "full_id": "sympy.concrete.summations.Sum.eval_zeta_function",
    "type": "method",
    "description": "\n        Check whether the function matches with the zeta function.\n\n        If it matches, then return a `Piecewise` expression because\n        zeta function does not converge unless `s > 1` and `q > 0`\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "is_absolutely_convergent",
    "full_id": "sympy.concrete.summations.Sum.is_absolutely_convergent",
    "type": "method",
    "description": "\n        Checks for the absolute convergence of an infinite series.\n\n        Same as checking convergence of absolute value of sequence_term of\n        an infinite series.\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Absolute_convergence\n\n        Examples\n        ========\n\n        >>> from sympy import Sum, Symbol, oo\n        >>> n = Symbol('n', integer=True)\n        >>> Sum((-1)**n, (n, 1, oo)).is_absolutely_convergent()\n        False\n        >>> Sum((-1)**n/n**2, (n, 1, oo)).is_absolutely_convergent()\n        True\n\n        See Also\n        ========\n\n        Sum.is_convergent\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "is_convergent",
    "full_id": "sympy.concrete.summations.Sum.is_convergent",
    "type": "method",
    "description": "\n        Checks for the convergence of a Sum.\n\n        Explanation\n        ===========\n\n        We divide the study of convergence of infinite sums and products in\n        two parts.\n\n        First Part:\n        One part is the question whether all the terms are well defined, i.e.,\n        they are finite in a sum and also non-zero in a product. Zero\n        is the analogy of (minus) infinity in products as\n        :math:`e^{-\\infty} = 0`.\n\n        Second Part:\n        The second part is the question of convergence after infinities,\n        and zeros in products, have been omitted assuming that their number\n        is finite. This means that we only consider the tail of the sum or\n        product, starting from some point after which all terms are well\n        defined.\n\n        For example, in a sum of the form:\n\n        .. math::\n\n            \\sum_{1 \\leq i < \\infty} \\frac{1}{n^2 + an + b}\n\n        where a and b are numbers. The routine will return true, even if there\n        are infinities in the term sequence (at most two). An analogous\n        product would be:\n\n        .. math::\n\n            \\prod_{1 \\leq i < \\infty} e^{\\frac{1}{n^2 + an + b}}\n\n        This is how convergence is interpreted. It is concerned with what\n        happens at the limit. Finding the bad terms is another independent\n        matter.\n\n        Note: It is responsibility of user to see that the sum or product\n        is well defined.\n\n        There are various tests employed to check the convergence like\n        divergence test, root test, integral test, alternating series test,\n        comparison tests, Dirichlet tests. It returns true if Sum is convergent\n        and false if divergent and NotImplementedError if it cannot be checked.\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Convergence_tests\n\n        Examples\n        ========\n\n        >>> from sympy import factorial, S, Sum, Symbol, oo\n        >>> n = Symbol('n', integer=True)\n        >>> Sum(n/(n - 1), (n, 4, 7)).is_convergent()\n        True\n        >>> Sum(n/(2*n + 1), (n, 1, oo)).is_convergent()\n        False\n        >>> Sum(factorial(n)/5**n, (n, 1, oo)).is_convergent()\n        False\n        >>> Sum(1/n**(S(6)/5), (n, 1, oo)).is_convergent()\n        True\n\n        See Also\n        ========\n\n        Sum.is_absolutely_convergent\n        sympy.concrete.products.Product.is_convergent\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "reverse_order",
    "full_id": "sympy.concrete.summations.Sum.reverse_order",
    "type": "method",
    "description": "\n        Reverse the order of a limit in a Sum.\n\n        Explanation\n        ===========\n\n        ``reverse_order(self, *indices)`` reverses some limits in the expression\n        ``self`` which can be either a ``Sum`` or a ``Product``. The selectors in\n        the argument ``indices`` specify some indices whose limits get reversed.\n        These selectors are either variable names or numerical indices counted\n        starting from the inner-most limit tuple.\n\n        Examples\n        ========\n\n        >>> from sympy import Sum\n        >>> from sympy.abc import x, y, a, b, c, d\n\n        >>> Sum(x, (x, 0, 3)).reverse_order(x)\n        Sum(-x, (x, 4, -1))\n        >>> Sum(x*y, (x, 1, 5), (y, 0, 6)).reverse_order(x, y)\n        Sum(x*y, (x, 6, 0), (y, 7, -1))\n        >>> Sum(x, (x, a, b)).reverse_order(x)\n        Sum(-x, (x, b + 1, a - 1))\n        >>> Sum(x, (x, a, b)).reverse_order(0)\n        Sum(-x, (x, b + 1, a - 1))\n\n        While one should prefer variable names when specifying which limits\n        to reverse, the index counting notation comes in handy in case there\n        are several symbols with the same name.\n\n        >>> S = Sum(x**2, (x, a, b), (x, c, d))\n        >>> S\n        Sum(x**2, (x, a, b), (x, c, d))\n        >>> S0 = S.reverse_order(0)\n        >>> S0\n        Sum(-x**2, (x, b + 1, a - 1), (x, c, d))\n        >>> S1 = S0.reverse_order(1)\n        >>> S1\n        Sum(x**2, (x, b + 1, a - 1), (x, d + 1, c - 1))\n\n        Of course we can mix both notations:\n\n        >>> Sum(x*y, (x, a, b), (y, 2, 5)).reverse_order(x, 1)\n        Sum(x*y, (x, b + 1, a - 1), (y, 6, 1))\n        >>> Sum(x*y, (x, a, b), (y, 2, 5)).reverse_order(y, x)\n        Sum(x*y, (x, b + 1, a - 1), (y, 6, 1))\n\n        See Also\n        ========\n\n        sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index, reorder_limit,\n        sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder\n\n        References\n        ==========\n\n        .. [1] Michael Karr, \"Summation in Finite Terms\", Journal of the ACM,\n               Volume 28 Issue 2, April 1981, Pages 305-350\n               https://dl.acm.org/doi/10.1145/322248.322255\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "is_convergent",
    "full_id": "sympy.concrete.products.Product.is_convergent",
    "type": "method",
    "description": "\n        See docs of :obj:`.Sum.is_convergent()` for explanation of convergence\n        in SymPy.\n\n        Explanation\n        ===========\n\n        The infinite product:\n\n        .. math::\n\n            \\prod_{1 \\leq i < \\infty} f(i)\n\n        is defined by the sequence of partial products:\n\n        .. math::\n\n            \\prod_{i=1}^{n} f(i) = f(1) f(2) \\cdots f(n)\n\n        as n increases without bound. The product converges to a non-zero\n        value if and only if the sum:\n\n        .. math::\n\n            \\sum_{1 \\leq i < \\infty} \\log{f(n)}\n\n        converges.\n\n        Examples\n        ========\n\n        >>> from sympy import Product, Symbol, cos, pi, exp, oo\n        >>> n = Symbol('n', integer=True)\n        >>> Product(n/(n + 1), (n, 1, oo)).is_convergent()\n        False\n        >>> Product(1/n**2, (n, 1, oo)).is_convergent()\n        False\n        >>> Product(cos(pi/n), (n, 1, oo)).is_convergent()\n        True\n        >>> Product(exp(-n**2), (n, 1, oo)).is_convergent()\n        False\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Infinite_product\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "reverse_order",
    "full_id": "sympy.concrete.products.Product.reverse_order",
    "type": "method",
    "description": "\n        Reverse the order of a limit in a Product.\n\n        Explanation\n        ===========\n\n        ``reverse_order(expr, *indices)`` reverses some limits in the expression\n        ``expr`` which can be either a ``Sum`` or a ``Product``. The selectors in\n        the argument ``indices`` specify some indices whose limits get reversed.\n        These selectors are either variable names or numerical indices counted\n        starting from the inner-most limit tuple.\n\n        Examples\n        ========\n\n        >>> from sympy import gamma, Product, simplify, Sum\n        >>> from sympy.abc import x, y, a, b, c, d\n        >>> P = Product(x, (x, a, b))\n        >>> Pr = P.reverse_order(x)\n        >>> Pr\n        Product(1/x, (x, b + 1, a - 1))\n        >>> Pr = Pr.doit()\n        >>> Pr\n        1/RisingFactorial(b + 1, a - b - 1)\n        >>> simplify(Pr.rewrite(gamma))\n        Piecewise((gamma(b + 1)/gamma(a), b > -1), ((-1)**(-a + b + 1)*gamma(1 - a)/gamma(-b), True))\n        >>> P = P.doit()\n        >>> P\n        RisingFactorial(a, -a + b + 1)\n        >>> simplify(P.rewrite(gamma))\n        Piecewise((gamma(b + 1)/gamma(a), a > 0), ((-1)**(-a + b + 1)*gamma(1 - a)/gamma(-b), True))\n\n        While one should prefer variable names when specifying which limits\n        to reverse, the index counting notation comes in handy in case there\n        are several symbols with the same name.\n\n        >>> S = Sum(x*y, (x, a, b), (y, c, d))\n        >>> S\n        Sum(x*y, (x, a, b), (y, c, d))\n        >>> S0 = S.reverse_order(0)\n        >>> S0\n        Sum(-x*y, (x, b + 1, a - 1), (y, c, d))\n        >>> S1 = S0.reverse_order(1)\n        >>> S1\n        Sum(x*y, (x, b + 1, a - 1), (y, d + 1, c - 1))\n\n        Of course we can mix both notations:\n\n        >>> Sum(x*y, (x, a, b), (y, 2, 5)).reverse_order(x, 1)\n        Sum(x*y, (x, b + 1, a - 1), (y, 6, 1))\n        >>> Sum(x*y, (x, a, b), (y, 2, 5)).reverse_order(y, x)\n        Sum(x*y, (x, b + 1, a - 1), (y, 6, 1))\n\n        See Also\n        ========\n\n        sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index,\n        reorder_limit,\n        sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder\n\n        References\n        ==========\n\n        .. [1] Michael Karr, \"Summation in Finite Terms\", Journal of the ACM,\n               Volume 28 Issue 2, April 1981, Pages 305-350\n               https://dl.acm.org/doi/10.1145/322248.322255\n\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "change_index",
    "full_id": "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.change_index",
    "type": "method",
    "description": "\n        Change index of a Sum or Product.\n\n        Perform a linear transformation `x \\mapsto a x + b` on the index variable\n        `x`. For `a` the only values allowed are `\\pm 1`. A new variable to be used\n        after the change of index can also be specified.\n\n        Explanation\n        ===========\n\n        ``change_index(expr, var, trafo, newvar=None)`` where ``var`` specifies the\n        index variable `x` to transform. The transformation ``trafo`` must be linear\n        and given in terms of ``var``. If the optional argument ``newvar`` is\n        provided then ``var`` gets replaced by ``newvar`` in the final expression.\n\n        Examples\n        ========\n\n        >>> from sympy import Sum, Product, simplify\n        >>> from sympy.abc import x, y, a, b, c, d, u, v, i, j, k, l\n\n        >>> S = Sum(x, (x, a, b))\n        >>> S.doit()\n        -a**2/2 + a/2 + b**2/2 + b/2\n\n        >>> Sn = S.change_index(x, x + 1, y)\n        >>> Sn\n        Sum(y - 1, (y, a + 1, b + 1))\n        >>> Sn.doit()\n        -a**2/2 + a/2 + b**2/2 + b/2\n\n        >>> Sn = S.change_index(x, -x, y)\n        >>> Sn\n        Sum(-y, (y, -b, -a))\n        >>> Sn.doit()\n        -a**2/2 + a/2 + b**2/2 + b/2\n\n        >>> Sn = S.change_index(x, x+u)\n        >>> Sn\n        Sum(-u + x, (x, a + u, b + u))\n        >>> Sn.doit()\n        -a**2/2 - a*u + a/2 + b**2/2 + b*u + b/2 - u*(-a + b + 1) + u\n        >>> simplify(Sn.doit())\n        -a**2/2 + a/2 + b**2/2 + b/2\n\n        >>> Sn = S.change_index(x, -x - u, y)\n        >>> Sn\n        Sum(-u - y, (y, -b - u, -a - u))\n        >>> Sn.doit()\n        -a**2/2 - a*u + a/2 + b**2/2 + b*u + b/2 - u*(-a + b + 1) + u\n        >>> simplify(Sn.doit())\n        -a**2/2 + a/2 + b**2/2 + b/2\n\n        >>> P = Product(i*j**2, (i, a, b), (j, c, d))\n        >>> P\n        Product(i*j**2, (i, a, b), (j, c, d))\n        >>> P2 = P.change_index(i, i+3, k)\n        >>> P2\n        Product(j**2*(k - 3), (k, a + 3, b + 3), (j, c, d))\n        >>> P3 = P2.change_index(j, -j, l)\n        >>> P3\n        Product(l**2*(k - 3), (k, a + 3, b + 3), (l, -d, -c))\n\n        When dealing with symbols only, we can make a\n        general linear transformation:\n\n        >>> Sn = S.change_index(x, u*x+v, y)\n        >>> Sn\n        Sum((-v + y)/u, (y, b*u + v, a*u + v))\n        >>> Sn.doit()\n        -v*(a*u - b*u + 1)/u + (a**2*u**2/2 + a*u*v + a*u/2 - b**2*u**2/2 - b*u*v + b*u/2 + v)/u\n        >>> simplify(Sn.doit())\n        a**2*u/2 + a/2 - b**2*u/2 + b/2\n\n        However, the last result can be inconsistent with usual\n        summation where the index increment is always 1. This is\n        obvious as we get back the original value only for ``u``\n        equal +1 or -1.\n\n        See Also\n        ========\n\n        sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index,\n        reorder_limit,\n        sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder,\n        sympy.concrete.summations.Sum.reverse_order,\n        sympy.concrete.products.Product.reverse_order\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "has_empty_sequence",
    "full_id": "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.has_empty_sequence",
    "type": "property",
    "description": "\n        Returns True if the Sum or Product is computed for an empty sequence.\n\n        Examples\n        ========\n\n        >>> from sympy import Sum, Product, Symbol\n        >>> m = Symbol('m')\n        >>> Sum(m, (m, 1, 0)).has_empty_sequence\n        True\n\n        >>> Sum(m, (m, 1, 1)).has_empty_sequence\n        False\n\n        >>> M = Symbol('M', integer=True, positive=True)\n        >>> Product(m, (m, 1, M)).has_empty_sequence\n        False\n\n        >>> Product(m, (m, 2, M)).has_empty_sequence\n\n        >>> Product(m, (m, M + 1, M)).has_empty_sequence\n        True\n\n        >>> N = Symbol('N', integer=True, positive=True)\n        >>> Sum(m, (m, N, M)).has_empty_sequence\n\n        >>> N = Symbol('N', integer=True, negative=True)\n        >>> Sum(m, (m, N, M)).has_empty_sequence\n        False\n\n        See Also\n        ========\n\n        has_reversed_limits\n        has_finite_limits\n\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "index",
    "full_id": "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index",
    "type": "method",
    "description": "\n        Return the index of a dummy variable in the list of limits.\n\n        Explanation\n        ===========\n\n        ``index(expr, x)``  returns the index of the dummy variable ``x`` in the\n        limits of ``expr``. Note that we start counting with 0 at the inner-most\n        limits tuple.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y, a, b, c, d\n        >>> from sympy import Sum, Product\n        >>> Sum(x*y, (x, a, b), (y, c, d)).index(x)\n        0\n        >>> Sum(x*y, (x, a, b), (y, c, d)).index(y)\n        1\n        >>> Product(x*y, (x, a, b), (y, c, d)).index(x)\n        0\n        >>> Product(x*y, (x, a, b), (y, c, d)).index(y)\n        1\n\n        See Also\n        ========\n\n        reorder_limit, reorder, sympy.concrete.summations.Sum.reverse_order,\n        sympy.concrete.products.Product.reverse_order\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "reorder",
    "full_id": "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder",
    "type": "method",
    "description": "\n        Reorder limits in a expression containing a Sum or a Product.\n\n        Explanation\n        ===========\n\n        ``expr.reorder(*arg)`` reorders the limits in the expression ``expr``\n        according to the list of tuples given by ``arg``. These tuples can\n        contain numerical indices or index variable names or involve both.\n\n        Examples\n        ========\n\n        >>> from sympy import Sum, Product\n        >>> from sympy.abc import x, y, z, a, b, c, d, e, f\n\n        >>> Sum(x*y, (x, a, b), (y, c, d)).reorder((x, y))\n        Sum(x*y, (y, c, d), (x, a, b))\n\n        >>> Sum(x*y*z, (x, a, b), (y, c, d), (z, e, f)).reorder((x, y), (x, z), (y, z))\n        Sum(x*y*z, (z, e, f), (y, c, d), (x, a, b))\n\n        >>> P = Product(x*y*z, (x, a, b), (y, c, d), (z, e, f))\n        >>> P.reorder((x, y), (x, z), (y, z))\n        Product(x*y*z, (z, e, f), (y, c, d), (x, a, b))\n\n        We can also select the index variables by counting them, starting\n        with the inner-most one:\n\n        >>> Sum(x**2, (x, a, b), (x, c, d)).reorder((0, 1))\n        Sum(x**2, (x, c, d), (x, a, b))\n\n        And of course we can mix both schemes:\n\n        >>> Sum(x*y, (x, a, b), (y, c, d)).reorder((y, x))\n        Sum(x*y, (y, c, d), (x, a, b))\n        >>> Sum(x*y, (x, a, b), (y, c, d)).reorder((y, 0))\n        Sum(x*y, (y, c, d), (x, a, b))\n\n        See Also\n        ========\n\n        reorder_limit, index, sympy.concrete.summations.Sum.reverse_order,\n        sympy.concrete.products.Product.reverse_order\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "reorder_limit",
    "full_id": "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit",
    "type": "method",
    "description": "\n        Interchange two limit tuples of a Sum or Product expression.\n\n        Explanation\n        ===========\n\n        ``expr.reorder_limit(x, y)`` interchanges two limit tuples. The\n        arguments ``x`` and ``y`` are integers corresponding to the index\n        variables of the two limits which are to be interchanged. The\n        expression ``expr`` has to be either a Sum or a Product.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y, z, a, b, c, d, e, f\n        >>> from sympy import Sum, Product\n\n        >>> Sum(x*y*z, (x, a, b), (y, c, d), (z, e, f)).reorder_limit(0, 2)\n        Sum(x*y*z, (z, e, f), (y, c, d), (x, a, b))\n        >>> Sum(x**2, (x, a, b), (x, c, d)).reorder_limit(1, 0)\n        Sum(x**2, (x, c, d), (x, a, b))\n\n        >>> Product(x*y*z, (x, a, b), (y, c, d), (z, e, f)).reorder_limit(0, 2)\n        Product(x*y*z, (z, e, f), (y, c, d), (x, a, b))\n\n        See Also\n        ========\n\n        index, reorder, sympy.concrete.summations.Sum.reverse_order,\n        sympy.concrete.products.Product.reverse_order\n        ",
    "section": "Concrete Class Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "summation",
    "full_id": "sympy.concrete.summations.summation",
    "type": "function",
    "description": "\n    Compute the summation of f with respect to symbols.\n\n    Explanation\n    ===========\n\n    The notation for symbols is similar to the notation used in Integral.\n    summation(f, (i, a, b)) computes the sum of f with respect to i from a to b,\n    i.e.,\n\n    ::\n\n                                    b\n                                  ____\n                                  \\   `\n        summation(f, (i, a, b)) =  )    f\n                                  /___,\n                                  i = a\n\n    If it cannot compute the sum, it returns an unevaluated Sum object.\n    Repeated sums can be computed by introducing additional symbols tuples::\n\n    Examples\n    ========\n\n    >>> from sympy import summation, oo, symbols, log\n    >>> i, n, m = symbols('i n m', integer=True)\n\n    >>> summation(2*i - 1, (i, 1, n))\n    n**2\n    >>> summation(1/2**i, (i, 0, oo))\n    2\n    >>> summation(1/log(n)**n, (n, 2, oo))\n    Sum(log(n)**(-n), (n, 2, oo))\n    >>> summation(i, (i, 0, n), (n, 0, m))\n    m**3/6 + m**2/2 + m/3\n\n    >>> from sympy.abc import x\n    >>> from sympy import factorial\n    >>> summation(x**n/factorial(n), (n, 0, oo))\n    exp(x)\n\n    See Also\n    ========\n\n    Sum\n    Product, sympy.concrete.products.product\n\n    ",
    "section": "Concrete Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "product",
    "full_id": "sympy.concrete.products.product",
    "type": "function",
    "description": "\n    Compute the product.\n\n    Explanation\n    ===========\n\n    The notation for symbols is similar to the notation used in Sum or\n    Integral. product(f, (i, a, b)) computes the product of f with\n    respect to i from a to b, i.e.,\n\n    ::\n\n                                     b\n                                   _____\n        product(f(n), (i, a, b)) = |   | f(n)\n                                   |   |\n                                   i = a\n\n    If it cannot compute the product, it returns an unevaluated Product object.\n    Repeated products can be computed by introducing additional symbols tuples::\n\n    Examples\n    ========\n\n    >>> from sympy import product, symbols\n    >>> i, n, m, k = symbols('i n m k', integer=True)\n\n    >>> product(i, (i, 1, k))\n    factorial(k)\n    >>> product(m, (i, 1, k))\n    m**k\n    >>> product(i, (i, 1, k), (k, 1, n))\n    Product(factorial(k), (k, 1, n))\n\n    ",
    "section": "Concrete Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "gosper_normal",
    "full_id": "sympy.concrete.gosper.gosper_normal",
    "type": "function",
    "description": "\n    Compute the Gosper's normal form of ``f`` and ``g``.\n\n    Explanation\n    ===========\n\n    Given relatively prime univariate polynomials ``f`` and ``g``,\n    rewrite their quotient to a normal form defined as follows:\n\n    .. math::\n        \\frac{f(n)}{g(n)} = Z \\cdot \\frac{A(n) C(n+1)}{B(n) C(n)}\n\n    where ``Z`` is an arbitrary constant and ``A``, ``B``, ``C`` are\n    monic polynomials in ``n`` with the following properties:\n\n    1. `\\gcd(A(n), B(n+h)) = 1 \\forall h \\in \\mathbb{N}`\n    2. `\\gcd(B(n), C(n+1)) = 1`\n    3. `\\gcd(A(n), C(n)) = 1`\n\n    This normal form, or rational factorization in other words, is a\n    crucial step in Gosper's algorithm and in solving of difference\n    equations. It can be also used to decide if two hypergeometric\n    terms are similar or not.\n\n    This procedure will return a tuple containing elements of this\n    factorization in the form ``(Z*A, B, C)``.\n\n    Examples\n    ========\n\n    >>> from sympy.concrete.gosper import gosper_normal\n    >>> from sympy.abc import n\n\n    >>> gosper_normal(4*n+5, 2*(4*n+1)*(2*n+3), n, polys=False)\n    (1/4, n + 3/2, n + 1/4)\n\n    ",
    "section": "Concrete Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "gosper_term",
    "full_id": "sympy.concrete.gosper.gosper_term",
    "type": "function",
    "description": "\n    Compute Gosper's hypergeometric term for ``f``.\n\n    Explanation\n    ===========\n\n    Suppose ``f`` is a hypergeometric term such that:\n\n    .. math::\n        s_n = \\sum_{k=0}^{n-1} f_k\n\n    and `f_k` does not depend on `n`. Returns a hypergeometric\n    term `g_n` such that `g_{n+1} - g_n = f_n`.\n\n    Examples\n    ========\n\n    >>> from sympy.concrete.gosper import gosper_term\n    >>> from sympy import factorial\n    >>> from sympy.abc import n\n\n    >>> gosper_term((4*n + 1)*factorial(n)/factorial(2*n + 1), n)\n    (-n - 1/2)/(n + 1/4)\n\n    ",
    "section": "Concrete Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "gosper_sum",
    "full_id": "sympy.concrete.gosper.gosper_sum",
    "type": "function",
    "description": "\n    Gosper's hypergeometric summation algorithm.\n\n    Explanation\n    ===========\n\n    Given a hypergeometric term ``f`` such that:\n\n    .. math ::\n        s_n = \\sum_{k=0}^{n-1} f_k\n\n    and `f(n)` does not depend on `n`, returns `g_{n} - g(0)` where\n    `g_{n+1} - g_n = f_n`, or ``None`` if `s_n` cannot be expressed\n    in closed form as a sum of hypergeometric terms.\n\n    Examples\n    ========\n\n    >>> from sympy.concrete.gosper import gosper_sum\n    >>> from sympy import factorial\n    >>> from sympy.abc import n, k\n\n    >>> f = (4*k + 1)*factorial(k)/factorial(2*k + 1)\n    >>> gosper_sum(f, (k, 0, n))\n    (-factorial(n) + 2*factorial(2*n + 1))/factorial(2*n + 1)\n    >>> _.subs(n, 2) == sum(f.subs(k, i) for i in [0, 1, 2])\n    True\n    >>> gosper_sum(f, (k, 3, n))\n    (-60*factorial(n) + factorial(2*n + 1))/(60*factorial(2*n + 1))\n    >>> _.subs(n, 5) == sum(f.subs(k, i) for i in [3, 4, 5])\n    True\n\n    References\n    ==========\n\n    .. [1] Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B,\n           AK Peters, Ltd., Wellesley, MA, USA, 1997, pp. 73--100\n\n    ",
    "section": "Concrete Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/concrete.html"
  },
  {
    "name": "sympify",
    "full_id": "sympy.core.sympify.sympify",
    "type": "function",
    "description": "\n    Converts an arbitrary expression to a type that can be used inside SymPy.\n\n    Explanation\n    ===========\n\n    It will convert Python ints into instances of :class:`~.Integer`, floats\n    into instances of :class:`~.Float`, etc. It is also able to coerce\n    symbolic expressions which inherit from :class:`~.Basic`. This can be\n    useful in cooperation with SAGE.\n\n    .. warning::\n        Note that this function uses ``eval``, and thus shouldn't be used on\n        unsanitized input.\n\n    If the argument is already a type that SymPy understands, it will do\n    nothing but return that value. This can be used at the beginning of a\n    function to ensure you are working with the correct type.\n\n    Examples\n    ========\n\n    >>> from sympy import sympify\n\n    >>> sympify(2).is_integer\n    True\n    >>> sympify(2).is_real\n    True\n\n    >>> sympify(2.0).is_real\n    True\n    >>> sympify(\"2.0\").is_real\n    True\n    >>> sympify(\"2e-45\").is_real\n    True\n\n    If the expression could not be converted, a SympifyError is raised.\n\n    >>> sympify(\"x***2\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: \"could not parse 'x***2'\"\n\n    When attempting to parse non-Python syntax using ``sympify``, it raises a\n    ``SympifyError``:\n\n    >>> sympify(\"2x+1\")\n    Traceback (most recent call last):\n    ...\n    SympifyError: Sympify of expression 'could not parse '2x+1'' failed\n\n    To parse non-Python syntax, use ``parse_expr`` from ``sympy.parsing.sympy_parser``.\n\n    >>> from sympy.parsing.sympy_parser import parse_expr\n    >>> parse_expr(\"2x+1\", transformations=\"all\")\n    2*x + 1\n\n    For more details about ``transformations``: see :func:`~sympy.parsing.sympy_parser.parse_expr`\n\n    Locals\n    ------\n\n    The sympification happens with access to everything that is loaded\n    by ``from sympy import *``; anything used in a string that is not\n    defined by that import will be converted to a symbol. In the following,\n    the ``bitcount`` function is treated as a symbol and the ``O`` is\n    interpreted as the :class:`~.Order` object (used with series) and it raises\n    an error when used improperly:\n\n    >>> s = 'bitcount(42)'\n    >>> sympify(s)\n    bitcount(42)\n    >>> sympify(\"O(x)\")\n    O(x)\n    >>> sympify(\"O + 1\")\n    Traceback (most recent call last):\n    ...\n    TypeError: unbound method...\n\n    In order to have ``bitcount`` be recognized it can be imported into a\n    namespace dictionary and passed as locals:\n\n    >>> ns = {}\n    >>> exec('from sympy.core.evalf import bitcount', ns)\n    >>> sympify(s, locals=ns)\n    6\n\n    In order to have the ``O`` interpreted as a Symbol, identify it as such\n    in the namespace dictionary. This can be done in a variety of ways; all\n    three of the following are possibilities:\n\n    >>> from sympy import Symbol\n    >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n    >>> exec('from sympy.abc import O', ns)  # method 2\n    >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n    >>> sympify(\"O + 1\", locals=ns)\n    O + 1\n\n    If you want *all* single-letter and Greek-letter variables to be symbols\n    then you can use the clashing-symbols dictionaries that have been defined\n    there as private variables: ``_clash1`` (single-letter variables),\n    ``_clash2`` (the multi-letter Greek names) or ``_clash`` (both single and\n    multi-letter names that are defined in ``abc``).\n\n    >>> from sympy.abc import _clash1\n    >>> set(_clash1)  # if this fails, see issue #23903\n    {'E', 'I', 'N', 'O', 'Q', 'S'}\n    >>> sympify('I & Q', _clash1)\n    I & Q\n\n    Strict\n    ------\n\n    If the option ``strict`` is set to ``True``, only the types for which an\n    explicit conversion has been defined are converted. In the other\n    cases, a SympifyError is raised.\n\n    >>> print(sympify(None))\n    None\n    >>> sympify(None, strict=True)\n    Traceback (most recent call last):\n    ...\n    SympifyError: SympifyError: None\n\n    .. deprecated:: 1.6\n\n       ``sympify(obj)`` automatically falls back to ``str(obj)`` when all\n       other conversion methods fail, but this is deprecated. ``strict=True``\n       will disable this deprecated behavior. See\n       :ref:`deprecated-sympify-string-fallback`.\n\n    Evaluation\n    ----------\n\n    If the option ``evaluate`` is set to ``False``, then arithmetic and\n    operators will be converted into their SymPy equivalents and the\n    ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n    be denested first. This is done via an AST transformation that replaces\n    operators with their SymPy equivalents, so if an operand redefines any\n    of those operations, the redefined operators will not be used. If\n    argument a is not a string, the mathematical expression is evaluated\n    before being passed to sympify, so adding ``evaluate=False`` will still\n    return the evaluated result of expression.\n\n    >>> sympify('2**2 / 3 + 5')\n    19/3\n    >>> sympify('2**2 / 3 + 5', evaluate=False)\n    2**2/3 + 5\n    >>> sympify('4/2+7', evaluate=True)\n    9\n    >>> sympify('4/2+7', evaluate=False)\n    4/2 + 7\n    >>> sympify(4/2+7, evaluate=False)\n    9.00000000000000\n\n    Extending\n    ---------\n\n    To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n    just define a ``_sympy_`` method to your class. You can do that even to\n    classes that you do not own by subclassing or adding the method at runtime.\n\n    >>> from sympy import Matrix\n    >>> class MyList1(object):\n    ...     def __iter__(self):\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    ...     def _sympy_(self): return Matrix(self)\n    >>> sympify(MyList1())\n    Matrix([\n    [1],\n    [2]])\n\n    If you do not have control over the class definition you could also use the\n    ``converter`` global dictionary. The key is the class and the value is a\n    function that takes a single argument and returns the desired SymPy\n    object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n\n    >>> class MyList2(object):   # XXX Do not do this if you control the class!\n    ...     def __iter__(self):  #     Use _sympy_!\n    ...         yield 1\n    ...         yield 2\n    ...         return\n    ...     def __getitem__(self, i): return list(self)[i]\n    >>> from sympy.core.sympify import converter\n    >>> converter[MyList2] = lambda x: Matrix(x)\n    >>> sympify(MyList2())\n    Matrix([\n    [1],\n    [2]])\n\n    Notes\n    =====\n\n    The keywords ``rational`` and ``convert_xor`` are only used\n    when the input is a string.\n\n    convert_xor\n    -----------\n\n    >>> sympify('x^y',convert_xor=True)\n    x**y\n    >>> sympify('x^y',convert_xor=False)\n    x ^ y\n\n    rational\n    --------\n\n    >>> sympify('0.1',rational=False)\n    0.1\n    >>> sympify('0.1',rational=True)\n    1/10\n\n    Sometimes autosimplification during sympification results in expressions\n    that are very different in structure than what was entered. Until such\n    autosimplification is no longer done, the ``kernS`` function might be of\n    some use. In the example below you can see how an expression reduces to\n    $-1$ by autosimplification, but does not do so when ``kernS`` is used.\n\n    >>> from sympy.core.sympify import kernS\n    >>> from sympy.abc import x\n    >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n    -1\n    >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n    >>> sympify(s)\n    -1\n    >>> kernS(s)\n    -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n\n    Parameters\n    ==========\n\n    a :\n        - any object defined in SymPy\n        - standard numeric Python types: ``int``, ``long``, ``float``, ``Decimal``\n        - strings (like ``\"0.09\"``, ``\"2e-19\"`` or ``'sin(x)'``)\n        - booleans, including ``None`` (will leave ``None`` unchanged)\n        - dicts, lists, sets or tuples containing any of the above\n\n    convert_xor : bool, optional\n        If true, treats ``^`` as exponentiation.\n        If False, treats ``^`` as XOR itself.\n        Used only when input is a string.\n\n    locals : any object defined in SymPy, optional\n        In order to have strings be recognized it can be imported\n        into a namespace dictionary and passed as locals.\n\n    strict : bool, optional\n        If the option strict is set to ``True``, only the types for which\n        an explicit conversion has been defined are converted. In the\n        other cases, a SympifyError is raised.\n\n    rational : bool, optional\n        If ``True``, converts floats into :class:`~.Rational`.\n        If ``False``, it lets floats remain as it is.\n        Used only when input is a string.\n\n    evaluate : bool, optional\n        If False, then arithmetic and operators will be converted into\n        their SymPy equivalents. If True the expression will be evaluated\n        and the result will be returned.\n\n    ",
    "section": "sympify",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "__cacheit",
    "full_id": "sympy.core.cache.__cacheit",
    "type": "function",
    "description": "caching decorator.\n\n    important: the result of cached function must be *immutable*\n\n\n    Examples\n    ========\n\n    >>> from sympy import cacheit\n    >>> @cacheit\n    ... def f(a, b):\n    ...    return a+b\n\n    >>> @cacheit\n    ... def f(a, b): # noqa: F811\n    ...    return [a, b] # <-- WRONG, returns mutable object\n\n    to force cacheit to check returned results mutability and consistency,\n    set environment variable SYMPY_USE_CACHE to 'debug'\n    ",
    "section": "cache",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "args",
    "full_id": "sympy.core.basic.Basic.args",
    "type": "property",
    "description": "Returns a tuple of arguments of 'self'.\n\n        Examples\n        ========\n\n        >>> from sympy import cot\n        >>> from sympy.abc import x, y\n\n        >>> cot(x).args\n        (x,)\n\n        >>> cot(x).args[0]\n        x\n\n        >>> (x*y).args\n        (x, y)\n\n        >>> (x*y).args[1]\n        y\n\n        Notes\n        =====\n\n        Never use self._args, always use self.args.\n        Only use _args in __new__ when creating a new function.\n        Do not override .args() from Basic (so that it is easy to\n        change the interface in the future if needed).\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_content_primitive",
    "full_id": "sympy.core.basic.Basic.as_content_primitive",
    "type": "method",
    "description": "A stub to allow Basic args (like Tuple) to be skipped when computing\n        the content and primitive components of an expression.\n\n        See Also\n        ========\n\n        sympy.core.expr.Expr.as_content_primitive\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_dummy",
    "full_id": "sympy.core.basic.Basic.as_dummy",
    "type": "method",
    "description": "Return the expression with any objects having structurally\n        bound symbols replaced with unique, canonical symbols within\n        the object in which they appear and having only the default\n        assumption for commutativity being True. When applied to a\n        symbol a new symbol having only the same commutativity will be\n        returned.\n\n        Examples\n        ========\n\n        >>> from sympy import Integral, Symbol\n        >>> from sympy.abc import x\n        >>> r = Symbol('r', real=True)\n        >>> Integral(r, (r, x)).as_dummy()\n        Integral(_0, (_0, x))\n        >>> _.variables[0].is_real is None\n        True\n        >>> r.as_dummy()\n        _r\n\n        Notes\n        =====\n\n        Any object that has structurally bound variables should have\n        a property, `bound_symbols` that returns those symbols\n        appearing in the object.\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "assumptions0",
    "full_id": "sympy.core.basic.Basic.assumptions0",
    "type": "property",
    "description": "\n        Return object `type` assumptions.\n\n        For example:\n\n          Symbol('x', real=True)\n          Symbol('x', integer=True)\n\n        are different objects. In other words, besides Python type (Symbol in\n        this case), the initial assumptions are also forming their typeinfo.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.abc import x\n        >>> x.assumptions0\n        {'commutative': True}\n        >>> x = Symbol(\"x\", positive=True)\n        >>> x.assumptions0\n        {'commutative': True, 'complex': True, 'extended_negative': False,\n         'extended_nonnegative': True, 'extended_nonpositive': False,\n         'extended_nonzero': True, 'extended_positive': True, 'extended_real':\n         True, 'finite': True, 'hermitian': True, 'imaginary': False,\n         'infinite': False, 'negative': False, 'nonnegative': True,\n         'nonpositive': False, 'nonzero': True, 'positive': True, 'real':\n         True, 'zero': False}\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "atoms",
    "full_id": "sympy.core.basic.Basic.atoms",
    "type": "method",
    "description": "Returns the atoms that form the current object.\n\n        By default, only objects that are truly atomic and cannot\n        be divided into smaller pieces are returned: symbols, numbers,\n        and number symbols like I and pi. It is possible to request\n        atoms of any type, however, as demonstrated below.\n\n        Examples\n        ========\n\n        >>> from sympy import I, pi, sin\n        >>> from sympy.abc import x, y\n        >>> (1 + x + 2*sin(y + I*pi)).atoms()\n        {1, 2, I, pi, x, y}\n\n        If one or more types are given, the results will contain only\n        those types of atoms.\n\n        >>> from sympy import Number, NumberSymbol, Symbol\n        >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n        {x, y}\n\n        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n        {1, 2}\n\n        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n        {1, 2, pi}\n\n        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n        {1, 2, I, pi}\n\n        Note that I (imaginary unit) and zoo (complex infinity) are special\n        types of number symbols and are not part of the NumberSymbol class.\n\n        The type can be given implicitly, too:\n\n        >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n        {x, y}\n\n        Be careful to check your assumptions when using the implicit option\n        since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n        of SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n        integers in an expression:\n\n        >>> from sympy import S\n        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n        {1}\n\n        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n        {1, 2}\n\n        Finally, arguments to atoms() can select more than atomic atoms: any\n        SymPy type (loaded in core/__init__.py) can be listed as an argument\n        and those types of \"atoms\" as found in scanning the arguments of the\n        expression recursively:\n\n        >>> from sympy import Function, Mul\n        >>> from sympy.core.function import AppliedUndef\n        >>> f = Function('f')\n        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n        {f(x), sin(y + I*pi)}\n        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n        {f(x)}\n\n        >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n        {I*pi, 2*sin(y + I*pi)}\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "canonical_variables",
    "full_id": "sympy.core.basic.Basic.canonical_variables",
    "type": "property",
    "description": "Return a dictionary mapping any variable defined in\n        ``self.bound_symbols`` to Symbols that do not clash\n        with any free symbols in the expression.\n\n        Examples\n        ========\n\n        >>> from sympy import Lambda\n        >>> from sympy.abc import x\n        >>> Lambda(x, 2*x).canonical_variables\n        {x: _0}\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "class_key",
    "full_id": "sympy.core.basic.Basic.class_key",
    "type": "method",
    "description": "Nice order of classes.",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "compare",
    "full_id": "sympy.core.basic.Basic.compare",
    "type": "method",
    "description": "\n        Return -1, 0, 1 if the object is less than, equal,\n        or greater than other in a canonical sense.\n        Non-Basic are always greater than Basic.\n        If both names of the classes being compared appear\n        in the `ordering_of_classes` then the ordering will\n        depend on the appearance of the names there.\n        If either does not appear in that list, then the\n        comparison is based on the class name.\n        If the names are the same then a comparison is made\n        on the length of the hashable content.\n        Items of the equal-lengthed contents are then\n        successively compared using the same rules. If there\n        is never a difference then 0 is returned.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> x.compare(y)\n        -1\n        >>> x.compare(x)\n        0\n        >>> y.compare(x)\n        1\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "count",
    "full_id": "sympy.core.basic.Basic.count",
    "type": "method",
    "description": "Count the number of matching subexpressions.",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "count_ops",
    "full_id": "sympy.core.basic.Basic.count_ops",
    "type": "method",
    "description": "Wrapper for count_ops that returns the operation count.",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.core.basic.Basic.doit",
    "type": "method",
    "description": "Evaluate objects that are not evaluated by default like limits,\n        integrals, sums and products. All objects of this kind will be\n        evaluated recursively, unless some species were excluded via 'hints'\n        or unless the 'deep' hint was set to 'False'.\n\n        >>> from sympy import Integral\n        >>> from sympy.abc import x\n\n        >>> 2*Integral(x, x)\n        2*Integral(x, x)\n\n        >>> (2*Integral(x, x)).doit()\n        x**2\n\n        >>> (2*Integral(x, x)).doit(deep=False)\n        2*Integral(x, x)\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "dummy_eq",
    "full_id": "sympy.core.basic.Basic.dummy_eq",
    "type": "method",
    "description": "\n        Compare two expressions and handle dummy symbols.\n\n        Examples\n        ========\n\n        >>> from sympy import Dummy\n        >>> from sympy.abc import x, y\n\n        >>> u = Dummy('u')\n\n        >>> (u**2 + 1).dummy_eq(x**2 + 1)\n        True\n        >>> (u**2 + 1) == (x**2 + 1)\n        False\n\n        >>> (u**2 + y).dummy_eq(x**2 + y, x)\n        True\n        >>> (u**2 + y).dummy_eq(x**2 + y, y)\n        False\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "find",
    "full_id": "sympy.core.basic.Basic.find",
    "type": "method",
    "description": "Find all subexpressions matching a query.",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.core.basic.Basic.free_symbols",
    "type": "property",
    "description": "Return from the atoms of self those which are free symbols.\n\n        Not all free symbols are ``Symbol``. Eg: IndexedBase('I')[0].free_symbols\n\n        For most expressions, all symbols are free symbols. For some classes\n        this is not true. e.g. Integrals use Symbols for the dummy variables\n        which are bound variables, so Integral has a method to return all\n        symbols except those. Derivative keeps track of symbols with respect\n        to which it will perform a derivative; those are\n        bound variables, too, so it has its own free_symbols method.\n\n        Any other method that uses bound variables should implement a\n        free_symbols method.",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "fromiter",
    "full_id": "sympy.core.basic.Basic.fromiter",
    "type": "method",
    "description": "\n        Create a new object from an iterable.\n\n        This is a convenience function that allows one to create objects from\n        any iterable, without having to convert to a list or tuple first.\n\n        Examples\n        ========\n\n        >>> from sympy import Tuple\n        >>> Tuple.fromiter(i for i in range(5))\n        (0, 1, 2, 3, 4)\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "func",
    "full_id": "sympy.core.basic.Basic.func",
    "type": "property",
    "description": "\n        The top-level function in an expression.\n\n        The following should hold for all objects::\n\n            >> x == x.func(*x.args)\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> a = 2*x\n        >>> a.func\n        <class 'sympy.core.mul.Mul'>\n        >>> a.args\n        (2, x)\n        >>> a.func(*a.args)\n        2*x\n        >>> a == a.func(*a.args)\n        True\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "has",
    "full_id": "sympy.core.basic.Basic.has",
    "type": "method",
    "description": "\n        Test whether any subexpression matches any of the patterns.\n\n        Examples\n        ========\n\n        >>> from sympy import sin\n        >>> from sympy.abc import x, y, z\n        >>> (x**2 + sin(x*y)).has(z)\n        False\n        >>> (x**2 + sin(x*y)).has(x, y, z)\n        True\n        >>> x.has(x)\n        True\n\n        Note ``has`` is a structural algorithm with no knowledge of\n        mathematics. Consider the following half-open interval:\n\n        >>> from sympy import Interval\n        >>> i = Interval.Lopen(0, 5); i\n        Interval.Lopen(0, 5)\n        >>> i.args\n        (0, 5, True, False)\n        >>> i.has(4)  # there is no \"4\" in the arguments\n        False\n        >>> i.has(0)  # there *is* a \"0\" in the arguments\n        True\n\n        Instead, use ``contains`` to determine whether a number is in the\n        interval or not:\n\n        >>> i.contains(4)\n        True\n        >>> i.contains(0)\n        False\n\n\n        Note that ``expr.has(*patterns)`` is exactly equivalent to\n        ``any(expr.has(p) for p in patterns)``. In particular, ``False`` is\n        returned when the list of patterns is empty.\n\n        >>> x.has()\n        False\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "has_free",
    "full_id": "sympy.core.basic.Basic.has_free",
    "type": "method",
    "description": "Return True if self has object(s) ``x`` as a free expression\n        else False.\n\n        Examples\n        ========\n\n        >>> from sympy import Integral, Function\n        >>> from sympy.abc import x, y\n        >>> f = Function('f')\n        >>> g = Function('g')\n        >>> expr = Integral(f(x), (f(x), 1, g(y)))\n        >>> expr.free_symbols\n        {y}\n        >>> expr.has_free(g(y))\n        True\n        >>> expr.has_free(*(x, f(x)))\n        False\n\n        This works for subexpressions and types, too:\n\n        >>> expr.has_free(g)\n        True\n        >>> (x + y + 1).has_free(y + 1)\n        True\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "has_xfree",
    "full_id": "sympy.core.basic.Basic.has_xfree",
    "type": "method",
    "description": "Return True if self has any of the patterns in s as a\n        free argument, else False. This is like `Basic.has_free`\n        but this will only report exact argument matches.\n\n        Examples\n        ========\n\n        >>> from sympy import Function\n        >>> from sympy.abc import x, y\n        >>> f = Function('f')\n        >>> f(x).has_xfree({f})\n        False\n        >>> f(x).has_xfree({f(x)})\n        True\n        >>> f(x + 1).has_xfree({x})\n        True\n        >>> f(x + 1).has_xfree({x + 1})\n        True\n        >>> f(x + y + 1).has_xfree({x + 1})\n        False\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_comparable",
    "full_id": "sympy.core.basic.Basic.is_comparable",
    "type": "property",
    "description": "Return True if self can be computed to a real number\n        (or already is a real number) with precision, else False.\n\n        Examples\n        ========\n\n        >>> from sympy import exp_polar, pi, I\n        >>> (I*exp_polar(I*pi/2)).is_comparable\n        True\n        >>> (I*exp_polar(I*pi*2)).is_comparable\n        False\n\n        A False result does not mean that `self` cannot be rewritten\n        into a form that would be comparable. For example, the\n        difference computed below is zero but without simplification\n        it does not evaluate to a zero with precision:\n\n        >>> e = 2**pi*(1 + 2**pi)\n        >>> dif = e - e.expand()\n        >>> dif.is_comparable\n        False\n        >>> dif.n(2)._prec\n        1\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_same",
    "full_id": "sympy.core.basic.Basic.is_same",
    "type": "method",
    "description": "Return True if a and b are structurally the same, else False.\n        If `approx` is supplied, it will be used to test whether two\n        numbers are the same or not. By default, only numbers of the\n        same type will compare equal, so S.Half != Float(0.5).\n\n        Examples\n        ========\n\n        In SymPy (unlike Python) two numbers do not compare the same if they are\n        not of the same type:\n\n        >>> from sympy import S\n        >>> 2.0 == S(2)\n        False\n        >>> 0.5 == S.Half\n        False\n\n        By supplying a function with which to compare two numbers, such\n        differences can be ignored. e.g. `equal_valued` will return True\n        for decimal numbers having a denominator that is a power of 2,\n        regardless of precision.\n\n        >>> from sympy import Float\n        >>> from sympy.core.numbers import equal_valued\n        >>> (S.Half/4).is_same(Float(0.125, 1), equal_valued)\n        True\n        >>> Float(1, 2).is_same(Float(1, 10), equal_valued)\n        True\n\n        But decimals without a power of 2 denominator will compare\n        as not being the same.\n\n        >>> Float(0.1, 9).is_same(Float(0.1, 10), equal_valued)\n        False\n\n        But arbitrary differences can be ignored by supplying a function\n        to test the equivalence of two numbers:\n\n        >>> import math\n        >>> Float(0.1, 9).is_same(Float(0.1, 10), math.isclose)\n        True\n\n        Other objects might compare the same even though types are not the\n        same. This routine will only return True if two expressions are\n        identical in terms of class types.\n\n        >>> from sympy import eye, Basic\n        >>> eye(1) == S(eye(1))  # mutable vs immutable\n        True\n        >>> Basic.is_same(eye(1), S(eye(1)))\n        False\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "match",
    "full_id": "sympy.core.basic.Basic.match",
    "type": "method",
    "description": "\n        Pattern matching.\n\n        Wild symbols match all.\n\n        Return ``None`` when expression (self) does not match\n        with pattern. Otherwise return a dictionary such that::\n\n          pattern.xreplace(self.match(pattern)) == self\n\n        Examples\n        ========\n\n        >>> from sympy import Wild, Sum\n        >>> from sympy.abc import x, y\n        >>> p = Wild(\"p\")\n        >>> q = Wild(\"q\")\n        >>> r = Wild(\"r\")\n        >>> e = (x+y)**(x+y)\n        >>> e.match(p**p)\n        {p_: x + y}\n        >>> e.match(p**q)\n        {p_: x + y, q_: x + y}\n        >>> e = (2*x)**2\n        >>> e.match(p*q**r)\n        {p_: 4, q_: x, r_: 2}\n        >>> (p*q**r).xreplace(e.match(p*q**r))\n        4*x**2\n\n        Structurally bound symbols are ignored during matching:\n\n        >>> Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))\n        {p_: 2}\n\n        But they can be identified if desired:\n\n        >>> Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))\n        {p_: 2, q_: x}\n\n        The ``old`` flag will give the old-style pattern matching where\n        expressions and patterns are essentially solved to give the\n        match. Both of the following give None unless ``old=True``:\n\n        >>> (x - 2).match(p - x, old=True)\n        {p_: 2*x - 2}\n        >>> (2/x).match(p*x, old=True)\n        {p_: 2/x**2}\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "matches",
    "full_id": "sympy.core.basic.Basic.matches",
    "type": "method",
    "description": "\n        Helper method for match() that looks for a match between Wild symbols\n        in self and expressions in expr.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, Wild, Basic\n        >>> a, b, c = symbols('a b c')\n        >>> x = Wild('x')\n        >>> Basic(a + x, x).matches(Basic(a + b, c)) is None\n        True\n        >>> Basic(a + x, x).matches(Basic(a + b + c, b + c))\n        {x_: b + c}\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "rcall",
    "full_id": "sympy.core.basic.Basic.rcall",
    "type": "method",
    "description": "Apply on the argument recursively through the expression tree.\n\n        This method is used to simulate a common abuse of notation for\n        operators. For instance, in SymPy the following will not work:\n\n        ``(x+Lambda(y, 2*y))(z) == x+2*z``,\n\n        however, you can use:\n\n        >>> from sympy import Lambda\n        >>> from sympy.abc import x, y, z\n        >>> (x + Lambda(y, 2*y)).rcall(z)\n        x + 2*z\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "refine",
    "full_id": "sympy.core.basic.Basic.refine",
    "type": "method",
    "description": "See the refine function in sympy.assumptions",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "replace",
    "full_id": "sympy.core.basic.Basic.replace",
    "type": "method",
    "description": "\n        Replace matching subexpressions of ``self`` with ``value``.\n\n        If ``map = True`` then also return the mapping {old: new} where ``old``\n        was a sub-expression found with query and ``new`` is the replacement\n        value for it. If the expression itself does not match the query, then\n        the returned value will be ``self.xreplace(map)`` otherwise it should\n        be ``self.subs(ordered(map.items()))``.\n\n        Traverses an expression tree and performs replacement of matching\n        subexpressions from the bottom to the top of the tree. The default\n        approach is to do the replacement in a simultaneous fashion so\n        changes made are targeted only once. If this is not desired or causes\n        problems, ``simultaneous`` can be set to False.\n\n        In addition, if an expression containing more than one Wild symbol\n        is being used to match subexpressions and the ``exact`` flag is None\n        it will be set to True so the match will only succeed if all non-zero\n        values are received for each Wild that appears in the match pattern.\n        Setting this to False accepts a match of 0; while setting it True\n        accepts all matches that have a 0 in them. See example below for\n        cautions.\n\n        The list of possible combinations of queries and replacement values\n        is listed below:\n\n        Examples\n        ========\n\n        Initial setup\n\n        >>> from sympy import log, sin, cos, tan, Wild, Mul, Add\n        >>> from sympy.abc import x, y\n        >>> f = log(sin(x)) + tan(sin(x**2))\n\n        1.1. type -> type\n            obj.replace(type, newtype)\n\n            When object of type ``type`` is found, replace it with the\n            result of passing its argument(s) to ``newtype``.\n\n            >>> f.replace(sin, cos)\n            log(cos(x)) + tan(cos(x**2))\n            >>> sin(x).replace(sin, cos, map=True)\n            (cos(x), {sin(x): cos(x)})\n            >>> (x*y).replace(Mul, Add)\n            x + y\n\n        1.2. type -> func\n            obj.replace(type, func)\n\n            When object of type ``type`` is found, apply ``func`` to its\n            argument(s). ``func`` must be written to handle the number\n            of arguments of ``type``.\n\n            >>> f.replace(sin, lambda arg: sin(2*arg))\n            log(sin(2*x)) + tan(sin(2*x**2))\n            >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))\n            sin(2*x*y)\n\n        2.1. pattern -> expr\n            obj.replace(pattern(wild), expr(wild))\n\n            Replace subexpressions matching ``pattern`` with the expression\n            written in terms of the Wild symbols in ``pattern``.\n\n            >>> a, b = map(Wild, 'ab')\n            >>> f.replace(sin(a), tan(a))\n            log(tan(x)) + tan(tan(x**2))\n            >>> f.replace(sin(a), tan(a/2))\n            log(tan(x/2)) + tan(tan(x**2/2))\n            >>> f.replace(sin(a), a)\n            log(x) + tan(x**2)\n            >>> (x*y).replace(a*x, a)\n            y\n\n            Matching is exact by default when more than one Wild symbol\n            is used: matching fails unless the match gives non-zero\n            values for all Wild symbols:\n\n            >>> (2*x + y).replace(a*x + b, b - a)\n            y - 2\n            >>> (2*x).replace(a*x + b, b - a)\n            2*x\n\n            When set to False, the results may be non-intuitive:\n\n            >>> (2*x).replace(a*x + b, b - a, exact=False)\n            2/x\n\n        2.2. pattern -> func\n            obj.replace(pattern(wild), lambda wild: expr(wild))\n\n            All behavior is the same as in 2.1 but now a function in terms of\n            pattern variables is used rather than an expression:\n\n            >>> f.replace(sin(a), lambda a: sin(2*a))\n            log(sin(2*x)) + tan(sin(2*x**2))\n\n        3.1. func -> func\n            obj.replace(filter, func)\n\n            Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``\n            is True.\n\n            >>> g = 2*sin(x**3)\n            >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)\n            4*sin(x**9)\n\n        The expression itself is also targeted by the query but is done in\n        such a fashion that changes are not made twice.\n\n            >>> e = x*(x*y + 1)\n            >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)\n            2*x*(2*x*y + 1)\n\n        When matching a single symbol, `exact` will default to True, but\n        this may or may not be the behavior that is desired:\n\n        Here, we want `exact=False`:\n\n        >>> from sympy import Function\n        >>> f = Function('f')\n        >>> e = f(1) + f(0)\n        >>> q = f(a), lambda a: f(a + 1)\n        >>> e.replace(*q, exact=False)\n        f(1) + f(2)\n        >>> e.replace(*q, exact=True)\n        f(0) + f(2)\n\n        But here, the nature of matching makes selecting\n        the right setting tricky:\n\n        >>> e = x**(1 + y)\n        >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)\n        x\n        >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)\n        x**(-x - y + 1)\n        >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)\n        x\n        >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)\n        x**(1 - y)\n\n        It is probably better to use a different form of the query\n        that describes the target expression more precisely:\n\n        >>> (1 + x**(1 + y)).replace(\n        ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,\n        ... lambda x: x.base**(1 - (x.exp - 1)))\n        ...\n        x**(1 - y) + 1\n\n        See Also\n        ========\n\n        subs: substitution of subexpressions as defined by the objects\n              themselves.\n        xreplace: exact node replacement in expr tree; also capable of\n                  using matching rules\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "rewrite",
    "full_id": "sympy.core.basic.Basic.rewrite",
    "type": "method",
    "description": "\n        Rewrite *self* using a defined rule.\n\n        Rewriting transforms an expression to another, which is mathematically\n        equivalent but structurally different. For example you can rewrite\n        trigonometric functions as complex exponentials or combinatorial\n        functions as gamma function.\n\n        This method takes a *pattern* and a *rule* as positional arguments.\n        *pattern* is optional parameter which defines the types of expressions\n        that will be transformed. If it is not passed, all possible expressions\n        will be rewritten. *rule* defines how the expression will be rewritten.\n\n        Parameters\n        ==========\n\n        args : Expr\n            A *rule*, or *pattern* and *rule*.\n            - *pattern* is a type or an iterable of types.\n            - *rule* can be any object.\n\n        deep : bool, optional\n            If ``True``, subexpressions are recursively transformed. Default is\n            ``True``.\n\n        Examples\n        ========\n\n        If *pattern* is unspecified, all possible expressions are transformed.\n\n        >>> from sympy import cos, sin, exp, I\n        >>> from sympy.abc import x\n        >>> expr = cos(x) + I*sin(x)\n        >>> expr.rewrite(exp)\n        exp(I*x)\n\n        Pattern can be a type or an iterable of types.\n\n        >>> expr.rewrite(sin, exp)\n        exp(I*x)/2 + cos(x) - exp(-I*x)/2\n        >>> expr.rewrite([cos,], exp)\n        exp(I*x)/2 + I*sin(x) + exp(-I*x)/2\n        >>> expr.rewrite([cos, sin], exp)\n        exp(I*x)\n\n        Rewriting behavior can be implemented by defining ``_eval_rewrite()``\n        method.\n\n        >>> from sympy import Expr, sqrt, pi\n        >>> class MySin(Expr):\n        ...     def _eval_rewrite(self, rule, args, **hints):\n        ...         x, = args\n        ...         if rule == cos:\n        ...             return cos(pi/2 - x, evaluate=False)\n        ...         if rule == sqrt:\n        ...             return sqrt(1 - cos(x)**2)\n        >>> MySin(MySin(x)).rewrite(cos)\n        cos(-cos(-x + pi/2) + pi/2)\n        >>> MySin(x).rewrite(sqrt)\n        sqrt(1 - cos(x)**2)\n\n        Defining ``_eval_rewrite_as_[...]()`` method is supported for backwards\n        compatibility reason. This may be removed in the future and using it is\n        discouraged.\n\n        >>> class MySin(Expr):\n        ...     def _eval_rewrite_as_cos(self, *args, **hints):\n        ...         x, = args\n        ...         return cos(pi/2 - x, evaluate=False)\n        >>> MySin(x).rewrite(cos)\n        cos(-x + pi/2)\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "simplify",
    "full_id": "sympy.core.basic.Basic.simplify",
    "type": "method",
    "description": "See the simplify function in sympy.simplify",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "sort_key",
    "full_id": "sympy.core.basic.Basic.sort_key",
    "type": "method",
    "description": "\n        Return a sort key.\n\n        Examples\n        ========\n\n        >>> from sympy import S, I\n\n        >>> sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())\n        [1/2, -I, I]\n\n        >>> S(\"[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]\")\n        [x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]\n        >>> sorted(_, key=lambda x: x.sort_key())\n        [x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "subs",
    "full_id": "sympy.core.basic.Basic.subs",
    "type": "method",
    "description": "\n        Substitutes old for new in an expression after sympifying args.\n\n        `args` is either:\n          - two arguments, e.g. foo.subs(old, new)\n          - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n             o an iterable container with (old, new) pairs. In this case the\n               replacements are processed in the order given with successive\n               patterns possibly affecting replacements already made.\n             o a dict or set whose key/value items correspond to old/new pairs.\n               In this case the old/new pairs will be sorted by op count and in\n               case of a tie, by number of args and the default_sort_key. The\n               resulting sorted list is then processed as an iterable container\n               (see previous).\n\n        If the keyword ``simultaneous`` is True, the subexpressions will not be\n        evaluated until all the substitutions have been made.\n\n        Examples\n        ========\n\n        >>> from sympy import pi, exp, limit, oo\n        >>> from sympy.abc import x, y\n        >>> (1 + x*y).subs(x, pi)\n        pi*y + 1\n        >>> (1 + x*y).subs({x:pi, y:2})\n        1 + 2*pi\n        >>> (1 + x*y).subs([(x, pi), (y, 2)])\n        1 + 2*pi\n        >>> reps = [(y, x**2), (x, 2)]\n        >>> (x + y).subs(reps)\n        6\n        >>> (x + y).subs(reversed(reps))\n        x**2 + 2\n\n        >>> (x**2 + x**4).subs(x**2, y)\n        y**2 + y\n\n        To replace only the x**2 but not the x**4, use xreplace:\n\n        >>> (x**2 + x**4).xreplace({x**2: y})\n        x**4 + y\n\n        To delay evaluation until all substitutions have been made,\n        set the keyword ``simultaneous`` to True:\n\n        >>> (x/y).subs([(x, 0), (y, 0)])\n        0\n        >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n        nan\n\n        This has the added feature of not allowing subsequent substitutions\n        to affect those already made:\n\n        >>> ((x + y)/y).subs({x + y: y, y: x + y})\n        1\n        >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n        y/(x + y)\n\n        In order to obtain a canonical result, unordered iterables are\n        sorted by count_op length, number of arguments and by the\n        default_sort_key to break any ties. All other iterables are left\n        unsorted.\n\n        >>> from sympy import sqrt, sin, cos\n        >>> from sympy.abc import a, b, c, d, e\n\n        >>> A = (sqrt(sin(2*x)), a)\n        >>> B = (sin(2*x), b)\n        >>> C = (cos(2*x), c)\n        >>> D = (x, d)\n        >>> E = (exp(x), e)\n\n        >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n\n        >>> expr.subs(dict([A, B, C, D, E]))\n        a*c*sin(d*e) + b\n\n        The resulting expression represents a literal replacement of the\n        old arguments with the new arguments. This may not reflect the\n        limiting behavior of the expression:\n\n        >>> (x**3 - 3*x).subs({x: oo})\n        nan\n\n        >>> limit(x**3 - 3*x, x, oo)\n        oo\n\n        If the substitution will be followed by numerical\n        evaluation, it is better to pass the substitution to\n        evalf as\n\n        >>> (1/x).evalf(subs={x: 3.0}, n=21)\n        0.333333333333333333333\n\n        rather than\n\n        >>> (1/x).subs({x: 3.0}).evalf(21)\n        0.333333333333333314830\n\n        as the former will ensure that the desired level of precision is\n        obtained.\n\n        See Also\n        ========\n        replace: replacement capable of doing wildcard-like matching,\n                 parsing of match, and conditional replacements\n        xreplace: exact node replacement in expr tree; also capable of\n                  using matching rules\n        sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "xreplace",
    "full_id": "sympy.core.basic.Basic.xreplace",
    "type": "method",
    "description": "\n        Replace occurrences of objects within the expression.\n\n        Parameters\n        ==========\n\n        rule : dict-like\n            Expresses a replacement rule\n\n        Returns\n        =======\n\n        xreplace : the result of the replacement\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, pi, exp\n        >>> x, y, z = symbols('x y z')\n        >>> (1 + x*y).xreplace({x: pi})\n        pi*y + 1\n        >>> (1 + x*y).xreplace({x: pi, y: 2})\n        1 + 2*pi\n\n        Replacements occur only if an entire node in the expression tree is\n        matched:\n\n        >>> (x*y + z).xreplace({x*y: pi})\n        z + pi\n        >>> (x*y*z).xreplace({x*y: pi})\n        x*y*z\n        >>> (2*x).xreplace({2*x: y, x: z})\n        y\n        >>> (2*2*x).xreplace({2*x: y, x: z})\n        4*z\n        >>> (x + y + 2).xreplace({x + y: 2})\n        x + y + 2\n        >>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})\n        x + exp(y) + 2\n\n        xreplace does not differentiate between free and bound symbols. In the\n        following, subs(x, y) would not change x since it is a bound symbol,\n        but xreplace does:\n\n        >>> from sympy import Integral\n        >>> Integral(x, (x, 1, 2*x)).xreplace({x: y})\n        Integral(y, (y, 1, 2*y))\n\n        Trying to replace x with an expression raises an error:\n\n        >>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP\n        ValueError: Invalid limits given: ((2*y, 1, 4*y),)\n\n        See Also\n        ========\n        replace: replacement capable of doing wildcard-like matching,\n                 parsing of match, and conditional replacements\n        subs: substitution of subexpressions as defined by the objects\n              themselves.\n\n        ",
    "section": "basic",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "apart",
    "full_id": "sympy.core.expr.Expr.apart",
    "type": "method",
    "description": "See the apart function in sympy.polys",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "args_cnc",
    "full_id": "sympy.core.expr.Expr.args_cnc",
    "type": "method",
    "description": "Return [commutative factors, non-commutative factors] of self.\n\n        Explanation\n        ===========\n\n        self is treated as a Mul and the ordering of the factors is maintained.\n        If ``cset`` is True the commutative factors will be returned in a set.\n        If there were repeated factors (as may happen with an unevaluated Mul)\n        then an error will be raised unless it is explicitly suppressed by\n        setting ``warn`` to False.\n\n        Note: -1 is always separated from a Number unless split_1 is False.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, oo\n        >>> A, B = symbols('A B', commutative=0)\n        >>> x, y = symbols('x y')\n        >>> (-2*x*y).args_cnc()\n        [[-1, 2, x, y], []]\n        >>> (-2.5*x).args_cnc()\n        [[-1, 2.5, x], []]\n        >>> (-2*x*A*B*y).args_cnc()\n        [[-1, 2, x, y], [A, B]]\n        >>> (-2*x*A*B*y).args_cnc(split_1=False)\n        [[-2, x, y], [A, B]]\n        >>> (-2*x*y).args_cnc(cset=True)\n        [{-1, 2, x, y}, []]\n\n        The arg is always treated as a Mul:\n\n        >>> (-2 + x + A).args_cnc()\n        [[], [x - 2 + A]]\n        >>> (-oo).args_cnc() # -oo is a singleton\n        [[-1, oo], []]\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_coeff_Add",
    "full_id": "sympy.core.expr.Expr.as_coeff_Add",
    "type": "method",
    "description": "Efficiently extract the coefficient of a summation.",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_coeff_Mul",
    "full_id": "sympy.core.expr.Expr.as_coeff_Mul",
    "type": "method",
    "description": "Efficiently extract the coefficient of a product.",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_coeff_add",
    "full_id": "sympy.core.expr.Expr.as_coeff_add",
    "type": "method",
    "description": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\n        c should be a Rational added to any terms of the Add that are\n        independent of deps.\n\n        args should be a tuple of all other terms of ``a``; args is empty\n        if self is a Number or if self is independent of deps (when given).\n\n        This should be used when you do not know if self is an Add or not but\n        you want to treat self as an Add or if you want to process the\n        individual arguments of the tail of self as an Add.\n\n        - if you know self is an Add and want only the head, use self.args[0];\n        - if you do not want to process the arguments of the tail but need the\n          tail then use self.as_two_terms() which gives the head and tail.\n        - if you want to split self into an independent and dependent parts\n          use ``self.as_independent(*deps)``\n\n        >>> from sympy import S\n        >>> from sympy.abc import x, y\n        >>> (S(3)).as_coeff_add()\n        (3, ())\n        >>> (3 + x).as_coeff_add()\n        (3, (x,))\n        >>> (3 + x + y).as_coeff_add(x)\n        (y + 3, (x,))\n        >>> (3 + y).as_coeff_add(x)\n        (y + 3, ())\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_coeff_exponent",
    "full_id": "sympy.core.expr.Expr.as_coeff_exponent",
    "type": "method",
    "description": "``c*x**e -> c,e`` where x can be any symbolic expression.",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_coeff_mul",
    "full_id": "sympy.core.expr.Expr.as_coeff_mul",
    "type": "method",
    "description": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\n        c should be a Rational multiplied by any factors of the Mul that are\n        independent of deps.\n\n        args should be a tuple of all other factors of m; args is empty\n        if self is a Number or if self is independent of deps (when given).\n\n        This should be used when you do not know if self is a Mul or not but\n        you want to treat self as a Mul or if you want to process the\n        individual arguments of the tail of self as a Mul.\n\n        - if you know self is a Mul and want only the head, use self.args[0];\n        - if you do not want to process the arguments of the tail but need the\n          tail then use self.as_two_terms() which gives the head and tail;\n        - if you want to split self into an independent and dependent parts\n          use ``self.as_independent(*deps)``\n\n        >>> from sympy import S\n        >>> from sympy.abc import x, y\n        >>> (S(3)).as_coeff_mul()\n        (3, ())\n        >>> (3*x*y).as_coeff_mul()\n        (3, (x, y))\n        >>> (3*x*y).as_coeff_mul(x)\n        (3*y, (x,))\n        >>> (3*y).as_coeff_mul(x)\n        (3*y, ())\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_coefficient",
    "full_id": "sympy.core.expr.Expr.as_coefficient",
    "type": "method",
    "description": "\n        Extracts symbolic coefficient at the given expression. In\n        other words, this functions separates 'self' into the product\n        of 'expr' and 'expr'-free coefficient. If such separation\n        is not possible it will return None.\n\n        Examples\n        ========\n\n        >>> from sympy import E, pi, sin, I, Poly\n        >>> from sympy.abc import x\n\n        >>> E.as_coefficient(E)\n        1\n        >>> (2*E).as_coefficient(E)\n        2\n        >>> (2*sin(E)*E).as_coefficient(E)\n\n        Two terms have E in them so a sum is returned. (If one were\n        desiring the coefficient of the term exactly matching E then\n        the constant from the returned expression could be selected.\n        Or, for greater precision, a method of Poly can be used to\n        indicate the desired term from which the coefficient is\n        desired.)\n\n        >>> (2*E + x*E).as_coefficient(E)\n        x + 2\n        >>> _.args[0]  # just want the exact match\n        2\n        >>> p = Poly(2*E + x*E); p\n        Poly(x*E + 2*E, x, E, domain='ZZ')\n        >>> p.coeff_monomial(E)\n        2\n        >>> p.nth(0, 1)\n        2\n\n        Since the following cannot be written as a product containing\n        E as a factor, None is returned. (If the coefficient ``2*x`` is\n        desired then the ``coeff`` method should be used.)\n\n        >>> (2*E*x + x).as_coefficient(E)\n        >>> (2*E*x + x).coeff(E)\n        2*x\n\n        >>> (E*(x + 1) + x).as_coefficient(E)\n\n        >>> (2*pi*I).as_coefficient(pi*I)\n        2\n        >>> (2*I).as_coefficient(pi*I)\n\n        See Also\n        ========\n\n        coeff: return sum of terms have a given factor\n        as_coeff_Add: separate the additive constant from an expression\n        as_coeff_Mul: separate the multiplicative constant from an expression\n        as_independent: separate x-dependent terms/factors from others\n        sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n        sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used\n\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_coefficients_dict",
    "full_id": "sympy.core.expr.Expr.as_coefficients_dict",
    "type": "method",
    "description": "Return a dictionary mapping terms to their Rational coefficient.\n        Since the dictionary is a defaultdict, inquiries about terms which\n        were not present will return a coefficient of 0.\n\n        If symbols ``syms`` are provided, any multiplicative terms\n        independent of them will be considered a coefficient and a\n        regular dictionary of syms-dependent generators as keys and\n        their corresponding coefficients as values will be returned.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import a, x, y\n        >>> (3*x + a*x + 4).as_coefficients_dict()\n        {1: 4, x: 3, a*x: 1}\n        >>> _[a]\n        0\n        >>> (3*a*x).as_coefficients_dict()\n        {a*x: 3}\n        >>> (3*a*x).as_coefficients_dict(x)\n        {x: 3*a}\n        >>> (3*a*x).as_coefficients_dict(y)\n        {1: 3*a*x}\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_content_primitive",
    "full_id": "sympy.core.expr.Expr.as_content_primitive",
    "type": "method",
    "description": "This method should recursively remove a Rational from all arguments\n        and return that (content) and the new self (primitive). The content\n        should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.\n        The primitive need not be in canonical form and should try to preserve\n        the underlying structure if possible (i.e. expand_mul should not be\n        applied to self).\n\n        Examples\n        ========\n\n        >>> from sympy import sqrt\n        >>> from sympy.abc import x, y, z\n\n        >>> eq = 2 + 2*x + 2*y*(3 + 3*y)\n\n        The as_content_primitive function is recursive and retains structure:\n\n        >>> eq.as_content_primitive()\n        (2, x + 3*y*(y + 1) + 1)\n\n        Integer powers will have Rationals extracted from the base:\n\n        >>> ((2 + 6*x)**2).as_content_primitive()\n        (4, (3*x + 1)**2)\n        >>> ((2 + 6*x)**(2*y)).as_content_primitive()\n        (1, (2*(3*x + 1))**(2*y))\n\n        Terms may end up joining once their as_content_primitives are added:\n\n        >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n        (11, x*(y + 1))\n        >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n        (9, x*(y + 1))\n        >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n        (1, 6.0*x*(y + 1) + 3*z*(y + 1))\n        >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n        (121, x**2*(y + 1)**2)\n        >>> ((x*(1 + y) + 0.4*x*(3 + 3*y))**2).as_content_primitive()\n        (1, 4.84*x**2*(y + 1)**2)\n\n        Radical content can also be factored out of the primitive:\n\n        >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n        (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n        If clear=False (default is True) then content will not be removed\n        from an Add if it can be distributed to leave one or more\n        terms with integer coefficients.\n\n        >>> (x/2 + y).as_content_primitive()\n        (1/2, x + 2*y)\n        >>> (x/2 + y).as_content_primitive(clear=False)\n        (1, x/2 + y)\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_expr",
    "full_id": "sympy.core.expr.Expr.as_expr",
    "type": "method",
    "description": "\n        Convert a polynomial to a SymPy expression.\n\n        Examples\n        ========\n\n        >>> from sympy import sin\n        >>> from sympy.abc import x, y\n\n        >>> f = (x**2 + x*y).as_poly(x, y)\n        >>> f.as_expr()\n        x**2 + x*y\n\n        >>> sin(x).as_expr()\n        sin(x)\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_independent",
    "full_id": "sympy.core.expr.Expr.as_independent",
    "type": "method",
    "description": "\n        A mostly naive separation of a Mul or Add into arguments that are not\n        are dependent on deps. To obtain as complete a separation of variables\n        as possible, use a separation method first, e.g.:\n\n        * separatevars() to change Mul, Add and Pow (including exp) into Mul\n        * .expand(mul=True) to change Add or Mul into Add\n        * .expand(log=True) to change log expr into an Add\n\n        The only non-naive thing that is done here is to respect noncommutative\n        ordering of variables and to always return (0, 0) for `self` of zero\n        regardless of hints.\n\n        For nonzero `self`, the returned tuple (i, d) has the\n        following interpretation:\n\n        * i will has no variable that appears in deps\n        * d will either have terms that contain variables that are in deps, or\n          be equal to 0 (when self is an Add) or 1 (when self is a Mul)\n        * if self is an Add then self = i + d\n        * if self is a Mul then self = i*d\n        * otherwise (self, S.One) or (S.One, self) is returned.\n\n        To force the expression to be treated as an Add, use the hint as_Add=True\n\n        Examples\n        ========\n\n        -- self is an Add\n\n        >>> from sympy import sin, cos, exp\n        >>> from sympy.abc import x, y, z\n\n        >>> (x + x*y).as_independent(x)\n        (0, x*y + x)\n        >>> (x + x*y).as_independent(y)\n        (x, x*y)\n        >>> (2*x*sin(x) + y + x + z).as_independent(x)\n        (y + z, 2*x*sin(x) + x)\n        >>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n        (z, 2*x*sin(x) + x + y)\n\n        -- self is a Mul\n\n        >>> (x*sin(x)*cos(y)).as_independent(x)\n        (cos(y), x*sin(x))\n\n        non-commutative terms cannot always be separated out when self is a Mul\n\n        >>> from sympy import symbols\n        >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n        >>> (n1 + n1*n2).as_independent(n2)\n        (n1, n1*n2)\n        >>> (n2*n1 + n1*n2).as_independent(n2)\n        (0, n1*n2 + n2*n1)\n        >>> (n1*n2*n3).as_independent(n1)\n        (1, n1*n2*n3)\n        >>> (n1*n2*n3).as_independent(n2)\n        (n1, n2*n3)\n        >>> ((x-n1)*(x-y)).as_independent(x)\n        (1, (x - y)*(x - n1))\n\n        -- self is anything else:\n\n        >>> (sin(x)).as_independent(x)\n        (1, sin(x))\n        >>> (sin(x)).as_independent(y)\n        (sin(x), 1)\n        >>> exp(x+y).as_independent(x)\n        (1, exp(x + y))\n\n        -- force self to be treated as an Add:\n\n        >>> (3*x).as_independent(x, as_Add=True)\n        (0, 3*x)\n\n        -- force self to be treated as a Mul:\n\n        >>> (3+x).as_independent(x, as_Add=False)\n        (1, x + 3)\n        >>> (-3+x).as_independent(x, as_Add=False)\n        (1, x - 3)\n\n        Note how the below differs from the above in making the\n        constant on the dep term positive.\n\n        >>> (y*(-3+x)).as_independent(x)\n        (y, x - 3)\n\n        -- use .as_independent() for true independence testing instead\n           of .has(). The former considers only symbols in the free\n           symbols while the latter considers all symbols\n\n        >>> from sympy import Integral\n        >>> I = Integral(x, (x, 1, 2))\n        >>> I.has(x)\n        True\n        >>> x in I.free_symbols\n        False\n        >>> I.as_independent(x) == (I, 1)\n        True\n        >>> (I + x).as_independent(x) == (I, x)\n        True\n\n        Note: when trying to get independent terms, a separation method\n        might need to be used first. In this case, it is important to keep\n        track of what you send to this routine so you know how to interpret\n        the returned values\n\n        >>> from sympy import separatevars, log\n        >>> separatevars(exp(x+y)).as_independent(x)\n        (exp(y), exp(x))\n        >>> (x + x*y).as_independent(y)\n        (x, x*y)\n        >>> separatevars(x + x*y).as_independent(y)\n        (x, y + 1)\n        >>> (x*(1 + y)).as_independent(y)\n        (x, y + 1)\n        >>> (x*(1 + y)).expand(mul=True).as_independent(y)\n        (x, x*y)\n        >>> a, b=symbols('a b', positive=True)\n        >>> (log(a*b).expand(log=True)).as_independent(b)\n        (log(a), log(b))\n\n        See Also\n        ========\n\n        separatevars\n        expand_log\n        sympy.core.add.Add.as_two_terms\n        sympy.core.mul.Mul.as_two_terms\n        as_coeff_mul\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_leading_term",
    "full_id": "sympy.core.expr.Expr.as_leading_term",
    "type": "method",
    "description": "\n        Returns the leading (nonzero) term of the series expansion of self.\n\n        The _eval_as_leading_term routines are used to do this, and they must\n        always return a non-zero value.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> (1 + x + x**2).as_leading_term(x)\n        1\n        >>> (1/x**2 + x + x**2).as_leading_term(x)\n        x**(-2)\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_numer_denom",
    "full_id": "sympy.core.expr.Expr.as_numer_denom",
    "type": "method",
    "description": "Return the numerator and the denominator of an expression.\n\n        expression -> a/b -> a, b\n\n        This is just a stub that should be defined by\n        an object's class methods to get anything else.\n\n        See Also\n        ========\n\n        normal: return ``a/b`` instead of ``(a, b)``\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_ordered_factors",
    "full_id": "sympy.core.expr.Expr.as_ordered_factors",
    "type": "method",
    "description": "Return list of ordered factors (if Mul) else [self].",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_ordered_terms",
    "full_id": "sympy.core.expr.Expr.as_ordered_terms",
    "type": "method",
    "description": "\n        Transform an expression to an ordered list of terms.\n\n        Examples\n        ========\n\n        >>> from sympy import sin, cos\n        >>> from sympy.abc import x\n\n        >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()\n        [sin(x)**2*cos(x), sin(x)**2, 1]\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_poly",
    "full_id": "sympy.core.expr.Expr.as_poly",
    "type": "method",
    "description": "Converts ``self`` to a polynomial or returns ``None``.\n\n        Explanation\n        ===========\n\n        >>> from sympy import sin\n        >>> from sympy.abc import x, y\n\n        >>> print((x**2 + x*y).as_poly())\n        Poly(x**2 + x*y, x, y, domain='ZZ')\n\n        >>> print((x**2 + x*y).as_poly(x, y))\n        Poly(x**2 + x*y, x, y, domain='ZZ')\n\n        >>> print((x**2 + sin(y)).as_poly(x, y))\n        None\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_powers_dict",
    "full_id": "sympy.core.expr.Expr.as_powers_dict",
    "type": "method",
    "description": "Return self as a dictionary of factors with each factor being\n        treated as a power. The keys are the bases of the factors and the\n        values, the corresponding exponents. The resulting dictionary should\n        be used with caution if the expression is a Mul and contains non-\n        commutative factors since the order that they appeared will be lost in\n        the dictionary.\n\n        See Also\n        ========\n        as_ordered_factors: An alternative for noncommutative applications,\n                            returning an ordered list of factors.\n        args_cnc: Similar to as_ordered_factors, but guarantees separation\n                  of commutative and noncommutative factors.\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_real_imag",
    "full_id": "sympy.core.expr.Expr.as_real_imag",
    "type": "method",
    "description": "Performs complex expansion on 'self' and returns a tuple\n        containing collected both real and imaginary parts. This\n        method cannot be confused with re() and im() functions,\n        which does not perform complex expansion at evaluation.\n\n        However it is possible to expand both re() and im()\n        functions and get exactly the same results as with\n        a single call to this function.\n\n        >>> from sympy import symbols, I\n\n        >>> x, y = symbols('x,y', real=True)\n\n        >>> (x + y*I).as_real_imag()\n        (x, y)\n\n        >>> from sympy.abc import z, w\n\n        >>> (z + w*I).as_real_imag()\n        (re(z) - im(w), re(w) + im(z))\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_terms",
    "full_id": "sympy.core.expr.Expr.as_terms",
    "type": "method",
    "description": "Transform an expression to a list of terms.",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "aseries",
    "full_id": "sympy.core.expr.Expr.aseries",
    "type": "method",
    "description": "Asymptotic Series expansion of self.\n        This is equivalent to ``self.series(x, oo, n)``.\n\n        Parameters\n        ==========\n\n        self : Expression\n               The expression whose series is to be expanded.\n\n        x : Symbol\n            It is the variable of the expression to be calculated.\n\n        n : Value\n            The value used to represent the order in terms of ``x**n``,\n            up to which the series is to be expanded.\n\n        hir : Boolean\n              Set this parameter to be True to produce hierarchical series.\n              It stops the recursion at an early level and may provide nicer\n              and more useful results.\n\n        bound : Value, Integer\n                Use the ``bound`` parameter to give limit on rewriting\n                coefficients in its normalised form.\n\n        Examples\n        ========\n\n        >>> from sympy import sin, exp\n        >>> from sympy.abc import x\n\n        >>> e = sin(1/x + exp(-x)) - sin(1/x)\n\n        >>> e.aseries(x)\n        (1/(24*x**4) - 1/(2*x**2) + 1 + O(x**(-6), (x, oo)))*exp(-x)\n\n        >>> e.aseries(x, n=3, hir=True)\n        -exp(-2*x)*sin(1/x)/2 + exp(-x)*cos(1/x) + O(exp(-3*x), (x, oo))\n\n        >>> e = exp(exp(x)/(1 - 1/x))\n\n        >>> e.aseries(x)\n        exp(exp(x)/(1 - 1/x))\n\n        >>> e.aseries(x, bound=3) # doctest: +SKIP\n        exp(exp(x)/x**2)*exp(exp(x)/x)*exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x**2)*exp(exp(x))\n\n        For rational expressions this method may return original expression without the Order term.\n        >>> (1/x).aseries(x, n=8)\n        1/x\n\n        Returns\n        =======\n\n        Expr\n            Asymptotic series expansion of the expression.\n\n        Notes\n        =====\n\n        This algorithm is directly induced from the limit computational algorithm provided by Gruntz.\n        It majorly uses the mrv and rewrite sub-routines. The overall idea of this algorithm is first\n        to look for the most rapidly varying subexpression w of a given expression f and then expands f\n        in a series in w. Then same thing is recursively done on the leading coefficient\n        till we get constant coefficients.\n\n        If the most rapidly varying subexpression of a given expression f is f itself,\n        the algorithm tries to find a normalised representation of the mrv set and rewrites f\n        using this normalised representation.\n\n        If the expansion contains an order term, it will be either ``O(x ** (-n))`` or ``O(w ** (-n))``\n        where ``w`` belongs to the most rapidly varying expression of ``self``.\n\n        References\n        ==========\n\n        .. [1] Gruntz, Dominik. A new algorithm for computing asymptotic series.\n               In: Proc. 1993 Int. Symp. Symbolic and Algebraic Computation. 1993.\n               pp. 239-244.\n        .. [2] Gruntz thesis - p90\n        .. [3] https://en.wikipedia.org/wiki/Asymptotic_expansion\n\n        See Also\n        ========\n\n        Expr.aseries: See the docstring of this function for complete details of this wrapper.\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "cancel",
    "full_id": "sympy.core.expr.Expr.cancel",
    "type": "method",
    "description": "See the cancel function in sympy.polys",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "coeff",
    "full_id": "sympy.core.expr.Expr.coeff",
    "type": "method",
    "description": "\n        Returns the coefficient from the term(s) containing ``x**n``. If ``n``\n        is zero then all terms independent of ``x`` will be returned.\n\n        Explanation\n        ===========\n\n        When ``x`` is noncommutative, the coefficient to the left (default) or\n        right of ``x`` can be returned. The keyword 'right' is ignored when\n        ``x`` is commutative.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.abc import x, y, z\n\n        You can select terms that have an explicit negative in front of them:\n\n        >>> (-x + 2*y).coeff(-1)\n        x\n        >>> (x - 2*y).coeff(-1)\n        2*y\n\n        You can select terms with no Rational coefficient:\n\n        >>> (x + 2*y).coeff(1)\n        x\n        >>> (3 + 2*x + 4*x**2).coeff(1)\n        0\n\n        You can select terms independent of x by making n=0; in this case\n        expr.as_independent(x)[0] is returned (and 0 will be returned instead\n        of None):\n\n        >>> (3 + 2*x + 4*x**2).coeff(x, 0)\n        3\n        >>> eq = ((x + 1)**3).expand() + 1\n        >>> eq\n        x**3 + 3*x**2 + 3*x + 2\n        >>> [eq.coeff(x, i) for i in reversed(range(4))]\n        [1, 3, 3, 2]\n        >>> eq -= 2\n        >>> [eq.coeff(x, i) for i in reversed(range(4))]\n        [1, 3, 3, 0]\n\n        You can select terms that have a numerical term in front of them:\n\n        >>> (-x - 2*y).coeff(2)\n        -y\n        >>> from sympy import sqrt\n        >>> (x + sqrt(2)*x).coeff(sqrt(2))\n        x\n\n        The matching is exact:\n\n        >>> (3 + 2*x + 4*x**2).coeff(x)\n        2\n        >>> (3 + 2*x + 4*x**2).coeff(x**2)\n        4\n        >>> (3 + 2*x + 4*x**2).coeff(x**3)\n        0\n        >>> (z*(x + y)**2).coeff((x + y)**2)\n        z\n        >>> (z*(x + y)**2).coeff(x + y)\n        0\n\n        In addition, no factoring is done, so 1 + z*(1 + y) is not obtained\n        from the following:\n\n        >>> (x + z*(x + x*y)).coeff(x)\n        1\n\n        If such factoring is desired, factor_terms can be used first:\n\n        >>> from sympy import factor_terms\n        >>> factor_terms(x + z*(x + x*y)).coeff(x)\n        z*(y + 1) + 1\n\n        >>> n, m, o = symbols('n m o', commutative=False)\n        >>> n.coeff(n)\n        1\n        >>> (3*n).coeff(n)\n        3\n        >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m\n        1 + m\n        >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m\n        m\n\n        If there is more than one possible coefficient 0 is returned:\n\n        >>> (n*m + m*n).coeff(n)\n        0\n\n        If there is only one possible coefficient, it is returned:\n\n        >>> (n*m + x*m*n).coeff(m*n)\n        x\n        >>> (n*m + x*m*n).coeff(m*n, right=1)\n        1\n\n        See Also\n        ========\n\n        as_coefficient: separate the expression into a coefficient and factor\n        as_coeff_Add: separate the additive constant from an expression\n        as_coeff_Mul: separate the multiplicative constant from an expression\n        as_independent: separate x-dependent terms/factors from others\n        sympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n        sympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "collect",
    "full_id": "sympy.core.expr.Expr.collect",
    "type": "method",
    "description": "See the collect function in sympy.simplify",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "combsimp",
    "full_id": "sympy.core.expr.Expr.combsimp",
    "type": "method",
    "description": "See the combsimp function in sympy.simplify",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "compute_leading_term",
    "full_id": "sympy.core.expr.Expr.compute_leading_term",
    "type": "method",
    "description": "Deprecated function to compute the leading term of a series.\n\n        as_leading_term is only allowed for results of .series()\n        This is a wrapper to compute a series first.\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "conjugate",
    "full_id": "sympy.core.expr.Expr.conjugate",
    "type": "method",
    "description": "Returns the complex conjugate of 'self'.",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "could_extract_minus_sign",
    "full_id": "sympy.core.expr.Expr.could_extract_minus_sign",
    "type": "method",
    "description": "Return True if self has -1 as a leading factor or has\n        more literal negative signs than positive signs in a sum,\n        otherwise False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> e = x - y\n        >>> {i.could_extract_minus_sign() for i in (e, -e)}\n        {False, True}\n\n        Though the ``y - x`` is considered like ``-(x - y)``, since it\n        is in a product without a leading factor of -1, the result is\n        false below:\n\n        >>> (x*(y - x)).could_extract_minus_sign()\n        False\n\n        To put something in canonical form wrt to sign, use `signsimp`:\n\n        >>> from sympy import signsimp\n        >>> signsimp(x*(y - x))\n        -x*(x - y)\n        >>> _.could_extract_minus_sign()\n        True\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "equals",
    "full_id": "sympy.core.expr.Expr.equals",
    "type": "method",
    "description": "Return True if self == other, False if it does not, or None. If\n        failing_expression is True then the expression which did not simplify\n        to a 0 will be returned instead of None.\n\n        Explanation\n        ===========\n\n        If ``self`` is a Number (or complex number) that is not zero, then\n        the result is False.\n\n        If ``self`` is a number and has not evaluated to zero, evalf will be\n        used to test whether the expression evaluates to zero. If it does so\n        and the result has significance (i.e. the precision is either -1, for\n        a Rational result, or is greater than 1) then the evalf value will be\n        used to return True or False.\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand",
    "full_id": "sympy.core.expr.Expr.expand",
    "type": "method",
    "description": "\n        Expand an expression using hints.\n\n        See the docstring of the expand() function in sympy.core.function for\n        more information.\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expr_free_symbols",
    "full_id": "sympy.core.expr.Expr.expr_free_symbols",
    "type": "property",
    "description": "\n        Like ``free_symbols``, but returns the free symbols only if\n        they are contained in an expression node.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> (x + y).expr_free_symbols # doctest: +SKIP\n        {x, y}\n\n        If the expression is contained in a non-expression object, do not return\n        the free symbols. Compare:\n\n        >>> from sympy import Tuple\n        >>> t = Tuple(x + y)\n        >>> t.expr_free_symbols # doctest: +SKIP\n        set()\n        >>> t.free_symbols\n        {x, y}\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "extract_additively",
    "full_id": "sympy.core.expr.Expr.extract_additively",
    "type": "method",
    "description": "Return self - c if it's possible to subtract c from self and\n        make all matching coefficients move towards zero, else return None.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> e = 2*x + 3\n        >>> e.extract_additively(x + 1)\n        x + 2\n        >>> e.extract_additively(3*x)\n        >>> e.extract_additively(4)\n        >>> (y*(x + 1)).extract_additively(x + 1)\n        >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)\n        (x + 1)*(x + 2*y) + 3\n\n        See Also\n        ========\n        extract_multiplicatively\n        coeff\n        as_coefficient\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "extract_branch_factor",
    "full_id": "sympy.core.expr.Expr.extract_branch_factor",
    "type": "method",
    "description": "\n        Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.\n        Return (z, n).\n\n        >>> from sympy import exp_polar, I, pi\n        >>> from sympy.abc import x, y\n        >>> exp_polar(I*pi).extract_branch_factor()\n        (exp_polar(I*pi), 0)\n        >>> exp_polar(2*I*pi).extract_branch_factor()\n        (1, 1)\n        >>> exp_polar(-pi*I).extract_branch_factor()\n        (exp_polar(I*pi), -1)\n        >>> exp_polar(3*pi*I + x).extract_branch_factor()\n        (exp_polar(x + I*pi), 1)\n        >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()\n        (y*exp_polar(2*pi*x), -1)\n        >>> exp_polar(-I*pi/2).extract_branch_factor()\n        (exp_polar(-I*pi/2), 0)\n\n        If allow_half is True, also extract exp_polar(I*pi):\n\n        >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)\n        (1, 1/2)\n        >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)\n        (1, 1)\n        >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)\n        (1, 3/2)\n        >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)\n        (1, -1/2)\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "extract_multiplicatively",
    "full_id": "sympy.core.expr.Expr.extract_multiplicatively",
    "type": "method",
    "description": "Return None if it's not possible to make self in the form\n        c * something in a nice way, i.e. preserving the properties\n        of arguments of self.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, Rational\n\n        >>> x, y = symbols('x,y', real=True)\n\n        >>> ((x*y)**3).extract_multiplicatively(x**2 * y)\n        x*y**2\n\n        >>> ((x*y)**3).extract_multiplicatively(x**4 * y)\n\n        >>> (2*x).extract_multiplicatively(2)\n        x\n\n        >>> (2*x).extract_multiplicatively(3)\n\n        >>> (Rational(1, 2)*x).extract_multiplicatively(3)\n        x/6\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "factor",
    "full_id": "sympy.core.expr.Expr.factor",
    "type": "method",
    "description": "See the factor() function in sympy.polys.polytools",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "fourier_series",
    "full_id": "sympy.core.expr.Expr.fourier_series",
    "type": "method",
    "description": "Compute fourier sine/cosine series of self.\n\n        See the docstring of the :func:`fourier_series` in sympy.series.fourier\n        for more information.\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "fps",
    "full_id": "sympy.core.expr.Expr.fps",
    "type": "method",
    "description": "\n        Compute formal power power series of self.\n\n        See the docstring of the :func:`fps` function in sympy.series.formal for\n        more information.\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "gammasimp",
    "full_id": "sympy.core.expr.Expr.gammasimp",
    "type": "method",
    "description": "See the gammasimp function in sympy.simplify",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "getO",
    "full_id": "sympy.core.expr.Expr.getO",
    "type": "method",
    "description": "Returns the additive O(..) symbol if there is one, else None.",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "getn",
    "full_id": "sympy.core.expr.Expr.getn",
    "type": "method",
    "description": "\n        Returns the order of the expression.\n\n        Explanation\n        ===========\n\n        The order is determined either from the O(...) term. If there\n        is no O(...) term, it returns None.\n\n        Examples\n        ========\n\n        >>> from sympy import O\n        >>> from sympy.abc import x\n        >>> (1 + x + O(x**2)).getn()\n        2\n        >>> (1 + x).getn()\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "integrate",
    "full_id": "sympy.core.expr.Expr.integrate",
    "type": "method",
    "description": "See the integrate function in sympy.integrals",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "invert",
    "full_id": "sympy.core.expr.Expr.invert",
    "type": "method",
    "description": "Return the multiplicative inverse of ``self`` mod ``g``\n        where ``self`` (and ``g``) may be symbolic expressions).\n\n        See Also\n        ========\n        sympy.core.intfunc.mod_inverse, sympy.polys.polytools.invert\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_algebraic_expr",
    "full_id": "sympy.core.expr.Expr.is_algebraic_expr",
    "type": "method",
    "description": "\n        This tests whether a given expression is algebraic or not, in the\n        given symbols, syms. When syms is not given, all free symbols\n        will be used. The rational function does not have to be in expanded\n        or in any kind of canonical form.\n\n        This function returns False for expressions that are \"algebraic\n        expressions\" with symbolic exponents. This is a simple extension to the\n        is_rational_function, including rational exponentiation.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol, sqrt\n        >>> x = Symbol('x', real=True)\n        >>> sqrt(1 + x).is_rational_function()\n        False\n        >>> sqrt(1 + x).is_algebraic_expr()\n        True\n\n        This function does not attempt any nontrivial simplifications that may\n        result in an expression that does not appear to be an algebraic\n        expression to become one.\n\n        >>> from sympy import exp, factor\n        >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)\n        >>> a.is_algebraic_expr(x)\n        False\n        >>> factor(a).is_algebraic_expr()\n        True\n\n        See Also\n        ========\n\n        is_rational_function\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Algebraic_expression\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_constant",
    "full_id": "sympy.core.expr.Expr.is_constant",
    "type": "method",
    "description": "Return True if self is constant, False if not, or None if\n        the constancy could not be determined conclusively.\n\n        Explanation\n        ===========\n\n        If an expression has no free symbols then it is a constant. If\n        there are free symbols it is possible that the expression is a\n        constant, perhaps (but not necessarily) zero. To test such\n        expressions, a few strategies are tried:\n\n        1) numerical evaluation at two random points. If two such evaluations\n        give two different values and the values have a precision greater than\n        1 then self is not constant. If the evaluations agree or could not be\n        obtained with any precision, no decision is made. The numerical testing\n        is done only if ``wrt`` is different than the free symbols.\n\n        2) differentiation with respect to variables in 'wrt' (or all free\n        symbols if omitted) to see if the expression is constant or not. This\n        will not always lead to an expression that is zero even though an\n        expression is constant (see added test in test_expr.py). If\n        all derivatives are zero then self is constant with respect to the\n        given symbols.\n\n        3) finding out zeros of denominator expression with free_symbols.\n        It will not be constant if there are zeros. It gives more negative\n        answers for expression that are not constant.\n\n        If neither evaluation nor differentiation can prove the expression is\n        constant, None is returned unless two numerical values happened to be\n        the same and the flag ``failing_number`` is True -- in that case the\n        numerical value will be returned.\n\n        If flag simplify=False is passed, self will not be simplified;\n        the default is True since self should be simplified before testing.\n\n        Examples\n        ========\n\n        >>> from sympy import cos, sin, Sum, S, pi\n        >>> from sympy.abc import a, n, x, y\n        >>> x.is_constant()\n        False\n        >>> S(2).is_constant()\n        True\n        >>> Sum(x, (x, 1, 10)).is_constant()\n        True\n        >>> Sum(x, (x, 1, n)).is_constant()\n        False\n        >>> Sum(x, (x, 1, n)).is_constant(y)\n        True\n        >>> Sum(x, (x, 1, n)).is_constant(n)\n        False\n        >>> Sum(x, (x, 1, n)).is_constant(x)\n        True\n        >>> eq = a*cos(x)**2 + a*sin(x)**2 - a\n        >>> eq.is_constant()\n        True\n        >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0\n        True\n\n        >>> (0**x).is_constant()\n        False\n        >>> x.is_constant()\n        False\n        >>> (x**x).is_constant()\n        False\n        >>> one = cos(x)**2 + sin(x)**2\n        >>> one.is_constant()\n        True\n        >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1\n        True\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_meromorphic",
    "full_id": "sympy.core.expr.Expr.is_meromorphic",
    "type": "method",
    "description": "\n        This tests whether an expression is meromorphic as\n        a function of the given symbol ``x`` at the point ``a``.\n\n        This method is intended as a quick test that will return\n        None if no decision can be made without simplification or\n        more detailed analysis.\n\n        Examples\n        ========\n\n        >>> from sympy import zoo, log, sin, sqrt\n        >>> from sympy.abc import x\n\n        >>> f = 1/x**2 + 1 - 2*x**3\n        >>> f.is_meromorphic(x, 0)\n        True\n        >>> f.is_meromorphic(x, 1)\n        True\n        >>> f.is_meromorphic(x, zoo)\n        True\n\n        >>> g = x**log(3)\n        >>> g.is_meromorphic(x, 0)\n        False\n        >>> g.is_meromorphic(x, 1)\n        True\n        >>> g.is_meromorphic(x, zoo)\n        False\n\n        >>> h = sin(1/x)*x**2\n        >>> h.is_meromorphic(x, 0)\n        False\n        >>> h.is_meromorphic(x, 1)\n        True\n        >>> h.is_meromorphic(x, zoo)\n        True\n\n        Multivalued functions are considered meromorphic when their\n        branches are meromorphic. Thus most functions are meromorphic\n        everywhere except at essential singularities and branch points.\n        In particular, they will be meromorphic also on branch cuts\n        except at their endpoints.\n\n        >>> log(x).is_meromorphic(x, -1)\n        True\n        >>> log(x).is_meromorphic(x, 0)\n        False\n        >>> sqrt(x).is_meromorphic(x, -1)\n        True\n        >>> sqrt(x).is_meromorphic(x, 0)\n        False\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_number",
    "full_id": "sympy.core.expr.Expr.is_number",
    "type": "property",
    "description": "Returns True if ``self`` has no free symbols and no\n        undefined functions (AppliedUndef, to be precise). It will be\n        faster than ``if not self.free_symbols``, however, since\n        ``is_number`` will fail as soon as it hits a free symbol\n        or undefined function.\n\n        Examples\n        ========\n\n        >>> from sympy import Function, Integral, cos, sin, pi\n        >>> from sympy.abc import x\n        >>> f = Function('f')\n\n        >>> x.is_number\n        False\n        >>> f(1).is_number\n        False\n        >>> (2*x).is_number\n        False\n        >>> (2 + Integral(2, x)).is_number\n        False\n        >>> (2 + Integral(2, (x, 1, 2))).is_number\n        True\n\n        Not all numbers are Numbers in the SymPy sense:\n\n        >>> pi.is_number, pi.is_Number\n        (True, False)\n\n        If something is a number it should evaluate to a number with\n        real and imaginary parts that are Numbers; the result may not\n        be comparable, however, since the real and/or imaginary part\n        of the result may not have precision.\n\n        >>> cos(1).is_number and cos(1).is_comparable\n        True\n\n        >>> z = cos(1)**2 + sin(1)**2 - 1\n        >>> z.is_number\n        True\n        >>> z.is_comparable\n        False\n\n        See Also\n        ========\n\n        sympy.core.basic.Basic.is_comparable\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_polynomial",
    "full_id": "sympy.core.expr.Expr.is_polynomial",
    "type": "method",
    "description": "\n        Return True if self is a polynomial in syms and False otherwise.\n\n        This checks if self is an exact polynomial in syms.  This function\n        returns False for expressions that are \"polynomials\" with symbolic\n        exponents.  Thus, you should be able to apply polynomial algorithms to\n        expressions for which this returns True, and Poly(expr, \\*syms) should\n        work if and only if expr.is_polynomial(\\*syms) returns True. The\n        polynomial does not have to be in expanded form.  If no symbols are\n        given, all free symbols in the expression will be used.\n\n        This is not part of the assumptions system.  You cannot do\n        Symbol('z', polynomial=True).\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol, Function\n        >>> x = Symbol('x')\n        >>> ((x**2 + 1)**4).is_polynomial(x)\n        True\n        >>> ((x**2 + 1)**4).is_polynomial()\n        True\n        >>> (2**x + 1).is_polynomial(x)\n        False\n        >>> (2**x + 1).is_polynomial(2**x)\n        True\n        >>> f = Function('f')\n        >>> (f(x) + 1).is_polynomial(x)\n        False\n        >>> (f(x) + 1).is_polynomial(f(x))\n        True\n        >>> (1/f(x) + 1).is_polynomial(f(x))\n        False\n\n        >>> n = Symbol('n', nonnegative=True, integer=True)\n        >>> (x**n + 1).is_polynomial(x)\n        False\n\n        This function does not attempt any nontrivial simplifications that may\n        result in an expression that does not appear to be a polynomial to\n        become one.\n\n        >>> from sympy import sqrt, factor, cancel\n        >>> y = Symbol('y', positive=True)\n        >>> a = sqrt(y**2 + 2*y + 1)\n        >>> a.is_polynomial(y)\n        False\n        >>> factor(a)\n        y + 1\n        >>> factor(a).is_polynomial(y)\n        True\n\n        >>> b = (y**2 + 2*y + 1)/(y + 1)\n        >>> b.is_polynomial(y)\n        False\n        >>> cancel(b)\n        y + 1\n        >>> cancel(b).is_polynomial(y)\n        True\n\n        See also .is_rational_function()\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_rational_function",
    "full_id": "sympy.core.expr.Expr.is_rational_function",
    "type": "method",
    "description": "\n        Test whether function is a ratio of two polynomials in the given\n        symbols, syms. When syms is not given, all free symbols will be used.\n        The rational function does not have to be in expanded or in any kind of\n        canonical form.\n\n        This function returns False for expressions that are \"rational\n        functions\" with symbolic exponents.  Thus, you should be able to call\n        .as_numer_denom() and apply polynomial algorithms to the result for\n        expressions for which this returns True.\n\n        This is not part of the assumptions system.  You cannot do\n        Symbol('z', rational_function=True).\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol, sin\n        >>> from sympy.abc import x, y\n\n        >>> (x/y).is_rational_function()\n        True\n\n        >>> (x**2).is_rational_function()\n        True\n\n        >>> (x/sin(y)).is_rational_function(y)\n        False\n\n        >>> n = Symbol('n', integer=True)\n        >>> (x**n + 1).is_rational_function(x)\n        False\n\n        This function does not attempt any nontrivial simplifications that may\n        result in an expression that does not appear to be a rational function\n        to become one.\n\n        >>> from sympy import sqrt, factor\n        >>> y = Symbol('y', positive=True)\n        >>> a = sqrt(y**2 + 2*y + 1)/y\n        >>> a.is_rational_function(y)\n        False\n        >>> factor(a)\n        (y + 1)/y\n        >>> factor(a).is_rational_function(y)\n        True\n\n        See also is_algebraic_expr().\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "leadterm",
    "full_id": "sympy.core.expr.Expr.leadterm",
    "type": "method",
    "description": "\n        Returns the leading term a*x**b as a tuple (a, b).\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> (1+x+x**2).leadterm(x)\n        (1, 0)\n        >>> (1/x**2+x+x**2).leadterm(x)\n        (1, -2)\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "limit",
    "full_id": "sympy.core.expr.Expr.limit",
    "type": "method",
    "description": "Compute limit x->xlim.",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "lseries",
    "full_id": "sympy.core.expr.Expr.lseries",
    "type": "method",
    "description": "\n        Wrapper for series yielding an iterator of the terms of the series.\n\n        Note: an infinite series will yield an infinite iterator. The following,\n        for exaxmple, will never terminate. It will just keep printing terms\n        of the sin(x) series::\n\n          for term in sin(x).lseries(x):\n              print term\n\n        The advantage of lseries() over nseries() is that many times you are\n        just interested in the next term in the series (i.e. the first term for\n        example), but you do not know how many you should ask for in nseries()\n        using the \"n\" parameter.\n\n        See also nseries().\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "normal",
    "full_id": "sympy.core.expr.Expr.normal",
    "type": "method",
    "description": "Return the expression as a fraction.\n\n        expression -> a/b\n\n        See Also\n        ========\n\n        as_numer_denom: return ``(a, b)`` instead of ``a/b``\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "nseries",
    "full_id": "sympy.core.expr.Expr.nseries",
    "type": "method",
    "description": "\n        Wrapper to _eval_nseries if assumptions allow, else to series.\n\n        If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is\n        called. This calculates \"n\" terms in the innermost expressions and\n        then builds up the final series just by \"cross-multiplying\" everything\n        out.\n\n        The optional ``logx`` parameter can be used to replace any log(x) in the\n        returned series with a symbolic value to avoid evaluating log(x) at 0. A\n        symbol to use in place of log(x) should be provided.\n\n        Advantage -- it's fast, because we do not have to determine how many\n        terms we need to calculate in advance.\n\n        Disadvantage -- you may end up with less terms than you may have\n        expected, but the O(x**n) term appended will always be correct and\n        so the result, though perhaps shorter, will also be correct.\n\n        If any of those assumptions is not met, this is treated like a\n        wrapper to series which will try harder to return the correct\n        number of terms.\n\n        See also lseries().\n\n        Examples\n        ========\n\n        >>> from sympy import sin, log, Symbol\n        >>> from sympy.abc import x, y\n        >>> sin(x).nseries(x, 0, 6)\n        x - x**3/6 + x**5/120 + O(x**6)\n        >>> log(x+1).nseries(x, 0, 5)\n        x - x**2/2 + x**3/3 - x**4/4 + O(x**5)\n\n        Handling of the ``logx`` parameter --- in the following example the\n        expansion fails since ``sin`` does not have an asymptotic expansion\n        at -oo (the limit of log(x) as x approaches 0):\n\n        >>> e = sin(log(x))\n        >>> e.nseries(x, 0, 6)\n        Traceback (most recent call last):\n        ...\n        PoleError: ...\n        ...\n        >>> logx = Symbol('logx')\n        >>> e.nseries(x, 0, 6, logx=logx)\n        sin(logx)\n\n        In the following example, the expansion works but only returns self\n        unless the ``logx`` parameter is used:\n\n        >>> e = x**y\n        >>> e.nseries(x, 0, 2)\n        x**y\n        >>> e.nseries(x, 0, 2, logx=logx)\n        exp(logx*y)\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "nsimplify",
    "full_id": "sympy.core.expr.Expr.nsimplify",
    "type": "method",
    "description": "See the nsimplify function in sympy.simplify",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "powsimp",
    "full_id": "sympy.core.expr.Expr.powsimp",
    "type": "method",
    "description": "See the powsimp function in sympy.simplify",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "primitive",
    "full_id": "sympy.core.expr.Expr.primitive",
    "type": "method",
    "description": "Return the positive Rational that can be extracted non-recursively\n        from every term of self (i.e., self is treated like an Add). This is\n        like the as_coeff_Mul() method but primitive always extracts a positive\n        Rational (never a negative or a Float).\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> (3*(x + 1)**2).primitive()\n        (3, (x + 1)**2)\n        >>> a = (6*x + 2); a.primitive()\n        (2, 3*x + 1)\n        >>> b = (x/2 + 3); b.primitive()\n        (1/2, x + 6)\n        >>> (a*b).primitive() == (1, a*b)\n        True\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "radsimp",
    "full_id": "sympy.core.expr.Expr.radsimp",
    "type": "method",
    "description": "See the radsimp function in sympy.simplify",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "ratsimp",
    "full_id": "sympy.core.expr.Expr.ratsimp",
    "type": "method",
    "description": "See the ratsimp function in sympy.simplify",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "removeO",
    "full_id": "sympy.core.expr.Expr.removeO",
    "type": "method",
    "description": "Removes the additive O(..) symbol if there is one",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "round",
    "full_id": "sympy.core.expr.Expr.round",
    "type": "method",
    "description": "Return x rounded to the given decimal place.\n\n        If a complex number would results, apply round to the real\n        and imaginary components of the number.\n\n        Examples\n        ========\n\n        >>> from sympy import pi, E, I, S, Number\n        >>> pi.round()\n        3\n        >>> pi.round(2)\n        3.14\n        >>> (2*pi + E*I).round()\n        6 + 3*I\n\n        The round method has a chopping effect:\n\n        >>> (2*pi + I/10).round()\n        6\n        >>> (pi/10 + 2*I).round()\n        2*I\n        >>> (pi/10 + E*I).round(2)\n        0.31 + 2.72*I\n\n        Notes\n        =====\n\n        The Python ``round`` function uses the SymPy ``round`` method so it\n        will always return a SymPy number (not a Python float or int):\n\n        >>> isinstance(round(S(123), -2), Number)\n        True\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "separate",
    "full_id": "sympy.core.expr.Expr.separate",
    "type": "method",
    "description": "See the separate function in sympy.simplify",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "series",
    "full_id": "sympy.core.expr.Expr.series",
    "type": "method",
    "description": "\n        Series expansion of \"self\" around ``x = x0`` yielding either terms of\n        the series one by one (the lazy series given when n=None), else\n        all the terms at once when n != None.\n\n        Returns the series expansion of \"self\" around the point ``x = x0``\n        with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).\n\n        If ``x=None`` and ``self`` is univariate, the univariate symbol will\n        be supplied, otherwise an error will be raised.\n\n        Parameters\n        ==========\n\n        expr : Expression\n               The expression whose series is to be expanded.\n\n        x : Symbol\n            It is the variable of the expression to be calculated.\n\n        x0 : Value\n             The value around which ``x`` is calculated. Can be any value\n             from ``-oo`` to ``oo``.\n\n        n : Value\n            The value used to represent the order in terms of ``x**n``,\n            up to which the series is to be expanded.\n\n        dir : String, optional\n              The series-expansion can be bi-directional. If ``dir=\"+\"``,\n              then (x->x0+). If ``dir=\"-\", then (x->x0-). For infinite\n              ``x0`` (``oo`` or ``-oo``), the ``dir`` argument is determined\n              from the direction of the infinity (i.e., ``dir=\"-\"`` for\n              ``oo``).\n\n        logx : optional\n               It is used to replace any log(x) in the returned series with a\n               symbolic value rather than evaluating the actual value.\n\n        cdir : optional\n               It stands for complex direction, and indicates the direction\n               from which the expansion needs to be evaluated.\n\n        Examples\n        ========\n\n        >>> from sympy import cos, exp, tan\n        >>> from sympy.abc import x, y\n        >>> cos(x).series()\n        1 - x**2/2 + x**4/24 + O(x**6)\n        >>> cos(x).series(n=4)\n        1 - x**2/2 + O(x**4)\n        >>> cos(x).series(x, x0=1, n=2)\n        cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))\n        >>> e = cos(x + exp(y))\n        >>> e.series(y, n=2)\n        cos(x + 1) - y*sin(x + 1) + O(y**2)\n        >>> e.series(x, n=2)\n        cos(exp(y)) - x*sin(exp(y)) + O(x**2)\n\n        If ``n=None`` then a generator of the series terms will be returned.\n\n        >>> term=cos(x).series(n=None)\n        >>> [next(term) for i in range(2)]\n        [1, -x**2/2]\n\n        For ``dir=+`` (default) the series is calculated from the right and\n        for ``dir=-`` the series from the left. For smooth functions this\n        flag will not alter the results.\n\n        >>> abs(x).series(dir=\"+\")\n        x\n        >>> abs(x).series(dir=\"-\")\n        -x\n        >>> f = tan(x)\n        >>> f.series(x, 2, 6, \"+\")\n        tan(2) + (1 + tan(2)**2)*(x - 2) + (x - 2)**2*(tan(2)**3 + tan(2)) +\n        (x - 2)**3*(1/3 + 4*tan(2)**2/3 + tan(2)**4) + (x - 2)**4*(tan(2)**5 +\n        5*tan(2)**3/3 + 2*tan(2)/3) + (x - 2)**5*(2/15 + 17*tan(2)**2/15 +\n        2*tan(2)**4 + tan(2)**6) + O((x - 2)**6, (x, 2))\n\n        >>> f.series(x, 2, 3, \"-\")\n        tan(2) + (2 - x)*(-tan(2)**2 - 1) + (2 - x)**2*(tan(2)**3 + tan(2))\n        + O((x - 2)**3, (x, 2))\n\n        For rational expressions this method may return original expression without the Order term.\n        >>> (1/x).series(x, n=8)\n        1/x\n\n        Returns\n        =======\n\n        Expr : Expression\n            Series expansion of the expression about x0\n\n        Raises\n        ======\n\n        TypeError\n            If \"n\" and \"x0\" are infinity objects\n\n        PoleError\n            If \"x0\" is an infinity object\n\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "taylor_term",
    "full_id": "sympy.core.expr.Expr.taylor_term",
    "type": "method",
    "description": "General method for the taylor term.\n\n        This method is slow, because it differentiates n-times. Subclasses can\n        redefine it to make it faster by using the \"previous_terms\".\n        ",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "together",
    "full_id": "sympy.core.expr.Expr.together",
    "type": "method",
    "description": "See the together function in sympy.polys",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "trigsimp",
    "full_id": "sympy.core.expr.Expr.trigsimp",
    "type": "method",
    "description": "See the trigsimp function in sympy.simplify",
    "section": "expr",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "symbols",
    "full_id": "sympy.core.symbol.symbols",
    "type": "function",
    "description": "\n    Transform strings into instances of :class:`Symbol` class.\n\n    :func:`symbols` function returns a sequence of symbols with names taken\n    from ``names`` argument, which can be a comma or whitespace delimited\n    string, or a sequence of strings::\n\n        >>> from sympy import symbols, Function\n\n        >>> x, y, z = symbols('x,y,z')\n        >>> a, b, c = symbols('a b c')\n\n    The type of output is dependent on the properties of input arguments::\n\n        >>> symbols('x')\n        x\n        >>> symbols('x,')\n        (x,)\n        >>> symbols('x,y')\n        (x, y)\n        >>> symbols(('a', 'b', 'c'))\n        (a, b, c)\n        >>> symbols(['a', 'b', 'c'])\n        [a, b, c]\n        >>> symbols({'a', 'b', 'c'})\n        {a, b, c}\n\n    If an iterable container is needed for a single symbol, set the ``seq``\n    argument to ``True`` or terminate the symbol name with a comma::\n\n        >>> symbols('x', seq=True)\n        (x,)\n\n    To reduce typing, range syntax is supported to create indexed symbols.\n    Ranges are indicated by a colon and the type of range is determined by\n    the character to the right of the colon. If the character is a digit\n    then all contiguous digits to the left are taken as the nonnegative\n    starting value (or 0 if there is no digit left of the colon) and all\n    contiguous digits to the right are taken as 1 greater than the ending\n    value::\n\n        >>> symbols('x:10')\n        (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)\n\n        >>> symbols('x5:10')\n        (x5, x6, x7, x8, x9)\n        >>> symbols('x5(:2)')\n        (x50, x51)\n\n        >>> symbols('x5:10,y:5')\n        (x5, x6, x7, x8, x9, y0, y1, y2, y3, y4)\n\n        >>> symbols(('x5:10', 'y:5'))\n        ((x5, x6, x7, x8, x9), (y0, y1, y2, y3, y4))\n\n    If the character to the right of the colon is a letter, then the single\n    letter to the left (or 'a' if there is none) is taken as the start\n    and all characters in the lexicographic range *through* the letter to\n    the right are used as the range::\n\n        >>> symbols('x:z')\n        (x, y, z)\n        >>> symbols('x:c')  # null range\n        ()\n        >>> symbols('x(:c)')\n        (xa, xb, xc)\n\n        >>> symbols(':c')\n        (a, b, c)\n\n        >>> symbols('a:d, x:z')\n        (a, b, c, d, x, y, z)\n\n        >>> symbols(('a:d', 'x:z'))\n        ((a, b, c, d), (x, y, z))\n\n    Multiple ranges are supported; contiguous numerical ranges should be\n    separated by parentheses to disambiguate the ending number of one\n    range from the starting number of the next::\n\n        >>> symbols('x:2(1:3)')\n        (x01, x02, x11, x12)\n        >>> symbols(':3:2')  # parsing is from left to right\n        (00, 01, 10, 11, 20, 21)\n\n    Only one pair of parentheses surrounding ranges are removed, so to\n    include parentheses around ranges, double them. And to include spaces,\n    commas, or colons, escape them with a backslash::\n\n        >>> symbols('x((a:b))')\n        (x(a), x(b))\n        >>> symbols(r'x(:1\\,:2)')  # or r'x((:1)\\,(:2))'\n        (x(0,0), x(0,1))\n\n    All newly created symbols have assumptions set according to ``args``::\n\n        >>> a = symbols('a', integer=True)\n        >>> a.is_integer\n        True\n\n        >>> x, y, z = symbols('x,y,z', real=True)\n        >>> x.is_real and y.is_real and z.is_real\n        True\n\n    Despite its name, :func:`symbols` can create symbol-like objects like\n    instances of Function or Wild classes. To achieve this, set ``cls``\n    keyword argument to the desired type::\n\n        >>> symbols('f,g,h', cls=Function)\n        (f, g, h)\n\n        >>> type(_[0])\n        <class 'sympy.core.function.UndefinedFunction'>\n\n    ",
    "section": "symbol",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "var",
    "full_id": "sympy.core.symbol.var",
    "type": "function",
    "description": "\n    Create symbols and inject them into the global namespace.\n\n    Explanation\n    ===========\n\n    This calls :func:`symbols` with the same arguments and puts the results\n    into the *global* namespace. It's recommended not to use :func:`var` in\n    library code, where :func:`symbols` has to be used::\n\n    Examples\n    ========\n\n    >>> from sympy import var\n\n    >>> var('x')\n    x\n    >>> x # noqa: F821\n    x\n\n    >>> var('a,ab,abc')\n    (a, ab, abc)\n    >>> abc # noqa: F821\n    abc\n\n    >>> var('x,y', real=True)\n    (x, y)\n    >>> x.is_real and y.is_real # noqa: F821\n    True\n\n    See :func:`symbols` documentation for more details on what kinds of\n    arguments can be passed to :func:`var`.\n\n    ",
    "section": "symbol",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "num_digits",
    "full_id": "sympy.core.intfunc.num_digits",
    "type": "function",
    "description": "Return the number of digits needed to express n in give base.\n\n    Examples\n    ========\n\n    >>> from sympy.core.intfunc import num_digits\n    >>> num_digits(10)\n    2\n    >>> num_digits(10, 2)  # 1010 -> 4 digits\n    4\n    >>> num_digits(-100, 16)  # -64 -> 2 digits\n    2\n\n\n    Parameters\n    ==========\n\n    n: integer\n        The number whose digits are counted.\n\n    b: integer\n        The base in which digits are computed.\n\n    See Also\n    ========\n    sympy.ntheory.digits.digits, sympy.ntheory.digits.count_digits\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "trailing",
    "full_id": "sympy.core.intfunc.trailing",
    "type": "function",
    "description": "Count the number of trailing zero digits in the binary\n    representation of n, i.e. determine the largest power of 2\n    that divides n.\n\n    Examples\n    ========\n\n    >>> from sympy import trailing\n    >>> trailing(128)\n    7\n    >>> trailing(63)\n    0\n\n    See Also\n    ========\n    sympy.ntheory.factor_.multiplicity\n\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "ilcm",
    "full_id": "sympy.core.intfunc.ilcm",
    "type": "function",
    "description": "Computes integer least common multiple.\n\n    Examples\n    ========\n\n    >>> from sympy import ilcm\n    >>> ilcm(5, 10)\n    10\n    >>> ilcm(7, 3)\n    21\n    >>> ilcm(5, 10, 15)\n    30\n\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "igcd",
    "full_id": "sympy.core.intfunc.igcd",
    "type": "function",
    "description": "Computes nonnegative integer greatest common divisor.\n\n    Explanation\n    ===========\n\n    The algorithm is based on the well known Euclid's algorithm [1]_. To\n    improve speed, ``igcd()`` has its own caching mechanism.\n    If you do not need the cache mechanism, using ``sympy.external.gmpy.gcd``.\n\n    Examples\n    ========\n\n    >>> from sympy import igcd\n    >>> igcd(2, 4)\n    2\n    >>> igcd(5, 10, 15)\n    5\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Euclidean_algorithm\n\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "igcd_lehmer",
    "full_id": "sympy.core.intfunc.igcd_lehmer",
    "type": "function",
    "description": "Computes greatest common divisor of two integers.\n\n    Explanation\n    ===========\n\n    Euclid's algorithm for the computation of the greatest\n    common divisor ``gcd(a, b)``  of two (positive) integers\n    $a$ and $b$ is based on the division identity\n    $$ a = q \\times b + r$$,\n    where the quotient  $q$  and the remainder  $r$  are integers\n    and  $0 \\le r < b$. Then each common divisor of  $a$  and  $b$\n    divides  $r$, and it follows that  ``gcd(a, b) == gcd(b, r)``.\n    The algorithm works by constructing the sequence\n    r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn\n    is the remainder from the division of the two preceding\n    elements.\n\n    In Python, ``q = a // b``  and  ``r = a % b``  are obtained by the\n    floor division and the remainder operations, respectively.\n    These are the most expensive arithmetic operations, especially\n    for large  a  and  b.\n\n    Lehmer's algorithm [1]_ is based on the observation that the quotients\n    ``qn = r(n-1) // rn``  are in general small integers even\n    when  a  and  b  are very large. Hence the quotients can be\n    usually determined from a relatively small number of most\n    significant bits.\n\n    The efficiency of the algorithm is further enhanced by not\n    computing each long remainder in Euclid's sequence. The remainders\n    are linear combinations of  a  and  b  with integer coefficients\n    derived from the quotients. The coefficients can be computed\n    as far as the quotients can be determined from the chosen\n    most significant parts of  a  and  b. Only then a new pair of\n    consecutive remainders is computed and the algorithm starts\n    anew with this pair.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm\n\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "igcdex",
    "full_id": "sympy.core.intfunc.igcdex",
    "type": "function",
    "description": "Returns x, y, g such that g = x*a + y*b = gcd(a, b).\n\n    Examples\n    ========\n\n    >>> from sympy.core.intfunc import igcdex\n    >>> igcdex(2, 3)\n    (-1, 1, 1)\n    >>> igcdex(10, 12)\n    (-1, 1, 2)\n\n    >>> x, y, g = igcdex(100, 2004)\n    >>> x, y, g\n    (-20, 1, 4)\n    >>> x*100 + y*2004\n    4\n\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "isqrt",
    "full_id": "sympy.core.intfunc.isqrt",
    "type": "function",
    "description": "Return the largest integer less than or equal to `\\sqrt{n}`.\n\n    Parameters\n    ==========\n\n    n : non-negative integer\n\n    Returns\n    =======\n\n    int : `\\left\\lfloor\\sqrt{n}\\right\\rfloor`\n\n    Raises\n    ======\n\n    ValueError\n        If n is negative.\n    TypeError\n        If n is of a type that cannot be compared to ``int``.\n        Therefore, a TypeError is raised for ``str``, but not for ``float``.\n\n    Examples\n    ========\n\n    >>> from sympy.core.intfunc import isqrt\n    >>> isqrt(0)\n    0\n    >>> isqrt(9)\n    3\n    >>> isqrt(10)\n    3\n    >>> isqrt(\"30\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    >>> from sympy.core.numbers import Rational\n    >>> isqrt(Rational(-1, 2))\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be nonnegative\n\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "integer_nthroot",
    "full_id": "sympy.core.intfunc.integer_nthroot",
    "type": "function",
    "description": "\n    Return a tuple containing x = floor(y**(1/n))\n    and a boolean indicating whether the result is exact (that is,\n    whether x**n == y).\n\n    Examples\n    ========\n\n    >>> from sympy import integer_nthroot\n    >>> integer_nthroot(16, 2)\n    (4, True)\n    >>> integer_nthroot(26, 2)\n    (5, False)\n\n    To simply determine if a number is a perfect square, the is_square\n    function should be used:\n\n    >>> from sympy.ntheory.primetest import is_square\n    >>> is_square(26)\n    False\n\n    See Also\n    ========\n    sympy.ntheory.primetest.is_square\n    integer_log\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "integer_log",
    "full_id": "sympy.core.intfunc.integer_log",
    "type": "function",
    "description": "\n    Returns ``(e, bool)`` where e is the largest nonnegative integer\n    such that :math:`|n| \\geq |b^e|` and ``bool`` is True if $n = b^e$.\n\n    Examples\n    ========\n\n    >>> from sympy import integer_log\n    >>> integer_log(125, 5)\n    (3, True)\n    >>> integer_log(17, 9)\n    (1, False)\n\n    If the base is positive and the number negative the\n    return value will always be the same except for 2:\n\n    >>> integer_log(-4, 2)\n    (2, False)\n    >>> integer_log(-16, 4)\n    (0, False)\n\n    When the base is negative, the returned value\n    will only be True if the parity of the exponent is\n    correct for the sign of the base:\n\n    >>> integer_log(4, -2)\n    (2, True)\n    >>> integer_log(8, -2)\n    (3, False)\n    >>> integer_log(-8, -2)\n    (3, True)\n    >>> integer_log(-4, -2)\n    (2, False)\n\n    See Also\n    ========\n    integer_nthroot\n    sympy.ntheory.primetest.is_square\n    sympy.ntheory.factor_.multiplicity\n    sympy.ntheory.factor_.perfect_power\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "mod_inverse",
    "full_id": "sympy.core.intfunc.mod_inverse",
    "type": "function",
    "description": "\n    Return the number $c$ such that, $a \\times c = 1 \\pmod{m}$\n    where $c$ has the same sign as $m$. If no such value exists,\n    a ValueError is raised.\n\n    Examples\n    ========\n\n    >>> from sympy import mod_inverse, S\n\n    Suppose we wish to find multiplicative inverse $x$ of\n    3 modulo 11. This is the same as finding $x$ such\n    that $3x = 1 \\pmod{11}$. One value of x that satisfies\n    this congruence is 4. Because $3 \\times 4 = 12$ and $12 = 1 \\pmod{11}$.\n    This is the value returned by ``mod_inverse``:\n\n    >>> mod_inverse(3, 11)\n    4\n    >>> mod_inverse(-3, 11)\n    7\n\n    When there is a common factor between the numerators of\n    `a` and `m` the inverse does not exist:\n\n    >>> mod_inverse(2, 4)\n    Traceback (most recent call last):\n    ...\n    ValueError: inverse of 2 mod 4 does not exist\n\n    >>> mod_inverse(S(2)/7, S(5)/2)\n    7/2\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\n    .. [2] https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n    ",
    "section": "intfunc",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "cofactors",
    "full_id": "sympy.core.numbers.Number.cofactors",
    "type": "method",
    "description": "Compute GCD and cofactors of `self` and `other`.",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.core.numbers.Number.gcd",
    "type": "method",
    "description": "Compute GCD of `self` and `other`.",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.core.numbers.Number.lcm",
    "type": "method",
    "description": "Compute LCM of `self` and `other`.",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_content_primitive",
    "full_id": "sympy.core.numbers.Rational.as_content_primitive",
    "type": "method",
    "description": "Return the tuple (R, self/R) where R is the positive Rational\n        extracted from self.\n\n        Examples\n        ========\n\n        >>> from sympy import S\n        >>> (S(-3)/2).as_content_primitive()\n        (3/2, -1)\n\n        See docstring of Expr.as_content_primitive for more examples.\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "factors",
    "full_id": "sympy.core.numbers.Rational.factors",
    "type": "method",
    "description": "A wrapper to factorint which return factors of self that are\n        smaller than limit (or cheap to compute). Special methods of\n        factoring are disabled by default so that only trial division is used.\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "limit_denominator",
    "full_id": "sympy.core.numbers.Rational.limit_denominator",
    "type": "method",
    "description": "Closest Rational to self with denominator at most max_denominator.\n\n        Examples\n        ========\n\n        >>> from sympy import Rational\n        >>> Rational('3.141592653589793').limit_denominator(10)\n        22/7\n        >>> Rational('3.141592653589793').limit_denominator(100)\n        311/99\n\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "__new__",
    "full_id": "sympy.core.numbers.AlgebraicNumber.__new__",
    "type": "method",
    "description": "\n        Construct a new algebraic number $\\alpha$ belonging to a number field\n        $k = \\mathbb{Q}(\\theta)$.\n\n        There are four instance attributes to be determined:\n\n        ===========  ============================================================================\n        Attribute    Type/Meaning\n        ===========  ============================================================================\n        ``root``     :py:class:`~.Expr` for $\\theta$ as a complex number\n        ``minpoly``  :py:class:`~.Poly`, the minimal polynomial of $\\theta$\n        ``rep``      :py:class:`~sympy.polys.polyclasses.DMP` giving $\\alpha$ as poly in $\\theta$\n        ``alias``    :py:class:`~.Symbol` for $\\theta$, or ``None``\n        ===========  ============================================================================\n\n        See Parameters section for how they are determined.\n\n        Parameters\n        ==========\n\n        expr : :py:class:`~.Expr`, or pair $(m, r)$\n            There are three distinct modes of construction, depending on what\n            is passed as *expr*.\n\n            **(1)** *expr* is an :py:class:`~.AlgebraicNumber`:\n            In this case we begin by copying all four instance attributes from\n            *expr*. If *coeffs* were also given, we compose the two coeff\n            polynomials (see below). If an *alias* was given, it overrides.\n\n            **(2)** *expr* is any other type of :py:class:`~.Expr`:\n            Then ``root`` will equal *expr*. Therefore it\n            must express an algebraic quantity, and we will compute its\n            ``minpoly``.\n\n            **(3)** *expr* is an ordered pair $(m, r)$ giving the\n            ``minpoly`` $m$, and a ``root`` $r$ thereof, which together\n            define $\\theta$. In this case $m$ may be either a univariate\n            :py:class:`~.Poly` or any :py:class:`~.Expr` which represents the\n            same, while $r$ must be some :py:class:`~.Expr` representing a\n            complex number that is a root of $m$, including both explicit\n            expressions in radicals, and instances of\n            :py:class:`~.ComplexRootOf` or :py:class:`~.AlgebraicNumber`.\n\n        coeffs : list, :py:class:`~.ANP`, None, optional (default=None)\n            This defines ``rep``, giving the algebraic number $\\alpha$ as a\n            polynomial in $\\theta$.\n\n            If a list, the elements should be integers or rational numbers.\n            If an :py:class:`~.ANP`, we take its coefficients (using its\n            :py:meth:`~.ANP.to_list()` method). If ``None``, then the list of\n            coefficients defaults to ``[1, 0]``, meaning that $\\alpha = \\theta$\n            is the primitive element of the field.\n\n            If *expr* was an :py:class:`~.AlgebraicNumber`, let $g(x)$ be its\n            ``rep`` polynomial, and let $f(x)$ be the polynomial defined by\n            *coeffs*. Then ``self.rep`` will represent the composition\n            $(f \\circ g)(x)$.\n\n        alias : str, :py:class:`~.Symbol`, None, optional (default=None)\n            This is a way to provide a name for the primitive element. We\n            described several ways in which the *expr* argument can define the\n            value of the primitive element, but none of these methods gave it\n            a name. Here, for example, *alias* could be set as\n            ``Symbol('theta')``, in order to make this symbol appear when\n            $\\alpha$ is printed, or rendered as a polynomial, using the\n            :py:meth:`~.as_poly()` method.\n\n        Examples\n        ========\n\n        Recall that we are constructing an algebraic number as a field element\n        $\\alpha \\in \\mathbb{Q}(\\theta)$.\n\n        >>> from sympy import AlgebraicNumber, sqrt, CRootOf, S\n        >>> from sympy.abc import x\n\n        Example (1): $\\alpha = \\theta = \\sqrt{2}$\n\n        >>> a1 = AlgebraicNumber(sqrt(2))\n        >>> a1.minpoly_of_element().as_expr(x)\n        x**2 - 2\n        >>> a1.evalf(10)\n        1.414213562\n\n        Example (2): $\\alpha = 3 \\sqrt{2} - 5$, $\\theta = \\sqrt{2}$. We can\n        either build on the last example:\n\n        >>> a2 = AlgebraicNumber(a1, [3, -5])\n        >>> a2.as_expr()\n        -5 + 3*sqrt(2)\n\n        or start from scratch:\n\n        >>> a2 = AlgebraicNumber(sqrt(2), [3, -5])\n        >>> a2.as_expr()\n        -5 + 3*sqrt(2)\n\n        Example (3): $\\alpha = 6 \\sqrt{2} - 11$, $\\theta = \\sqrt{2}$. Again we\n        can build on the previous example, and we see that the coeff polys are\n        composed:\n\n        >>> a3 = AlgebraicNumber(a2, [2, -1])\n        >>> a3.as_expr()\n        -11 + 6*sqrt(2)\n\n        reflecting the fact that $(2x - 1) \\circ (3x - 5) = 6x - 11$.\n\n        Example (4): $\\alpha = \\sqrt{2}$, $\\theta = \\sqrt{2} + \\sqrt{3}$. The\n        easiest way is to use the :py:func:`~.to_number_field()` function:\n\n        >>> from sympy import to_number_field\n        >>> a4 = to_number_field(sqrt(2), sqrt(2) + sqrt(3))\n        >>> a4.minpoly_of_element().as_expr(x)\n        x**2 - 2\n        >>> a4.to_root()\n        sqrt(2)\n        >>> a4.primitive_element()\n        sqrt(2) + sqrt(3)\n        >>> a4.coeffs()\n        [1/2, 0, -9/2, 0]\n\n        but if you already knew the right coefficients, you could construct it\n        directly:\n\n        >>> a4 = AlgebraicNumber(sqrt(2) + sqrt(3), [S(1)/2, 0, S(-9)/2, 0])\n        >>> a4.to_root()\n        sqrt(2)\n        >>> a4.primitive_element()\n        sqrt(2) + sqrt(3)\n\n        Example (5): Construct the Golden Ratio as an element of the 5th\n        cyclotomic field, supposing we already know its coefficients. This time\n        we introduce the alias $\\zeta$ for the primitive element of the field:\n\n        >>> from sympy import cyclotomic_poly\n        >>> from sympy.abc import zeta\n        >>> a5 = AlgebraicNumber(CRootOf(cyclotomic_poly(5), -1),\n        ...                  [-1, -1, 0, 0], alias=zeta)\n        >>> a5.as_poly().as_expr()\n        -zeta**3 - zeta**2\n        >>> a5.evalf()\n        1.61803398874989\n\n        (The index ``-1`` to ``CRootOf`` selects the complex root with the\n        largest real and imaginary parts, which in this case is\n        $\\mathrm{e}^{2i\\pi/5}$. See :py:class:`~.ComplexRootOf`.)\n\n        Example (6): Building on the last example, construct the number\n        $2 \\phi \\in \\mathbb{Q}(\\phi)$, where $\\phi$ is the Golden Ratio:\n\n        >>> from sympy.abc import phi\n        >>> a6 = AlgebraicNumber(a5.to_root(), coeffs=[2, 0], alias=phi)\n        >>> a6.as_poly().as_expr()\n        2*phi\n        >>> a6.primitive_element().evalf()\n        1.61803398874989\n\n        Note that we needed to use ``a5.to_root()``, since passing ``a5`` as\n        the first argument would have constructed the number $2 \\phi$ as an\n        element of the field $\\mathbb{Q}(\\zeta)$:\n\n        >>> a6_wrong = AlgebraicNumber(a5, coeffs=[2, 0])\n        >>> a6_wrong.as_poly().as_expr()\n        -2*zeta**3 - 2*zeta**2\n        >>> a6_wrong.primitive_element().evalf()\n        0.309016994374947 + 0.951056516295154*I\n\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_expr",
    "full_id": "sympy.core.numbers.AlgebraicNumber.as_expr",
    "type": "method",
    "description": "Create a Basic expression from ``self``.",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_poly",
    "full_id": "sympy.core.numbers.AlgebraicNumber.as_poly",
    "type": "method",
    "description": "Create a Poly instance from ``self``.",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "coeffs",
    "full_id": "sympy.core.numbers.AlgebraicNumber.coeffs",
    "type": "method",
    "description": "Returns all SymPy coefficients of an algebraic number.",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "field_element",
    "full_id": "sympy.core.numbers.AlgebraicNumber.field_element",
    "type": "method",
    "description": "\n        Form another element of the same number field.\n\n        Explanation\n        ===========\n\n        If we represent $\\alpha \\in \\mathbb{Q}(\\theta)$, form another element\n        $\\beta \\in \\mathbb{Q}(\\theta)$ of the same number field.\n\n        Parameters\n        ==========\n\n        coeffs : list, :py:class:`~.ANP`\n            Like the *coeffs* arg to the class\n            :py:meth:`constructor<.AlgebraicNumber.__new__>`, defines the\n            new element as a polynomial in the primitive element.\n\n            If a list, the elements should be integers or rational numbers.\n            If an :py:class:`~.ANP`, we take its coefficients (using its\n            :py:meth:`~.ANP.to_list()` method).\n\n        Examples\n        ========\n\n        >>> from sympy import AlgebraicNumber, sqrt\n        >>> a = AlgebraicNumber(sqrt(5), [-1, 1])\n        >>> b = a.field_element([3, 2])\n        >>> print(a)\n        1 - sqrt(5)\n        >>> print(b)\n        2 + 3*sqrt(5)\n        >>> print(b.primitive_element() == a.primitive_element())\n        True\n\n        See Also\n        ========\n\n        AlgebraicNumber\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_aliased",
    "full_id": "sympy.core.numbers.AlgebraicNumber.is_aliased",
    "type": "property",
    "description": "Returns ``True`` if ``alias`` was set.",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_primitive_element",
    "full_id": "sympy.core.numbers.AlgebraicNumber.is_primitive_element",
    "type": "property",
    "description": "\n        Say whether this algebraic number $\\alpha \\in \\mathbb{Q}(\\theta)$ is\n        equal to the primitive element $\\theta$ for its field.\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "minpoly_of_element",
    "full_id": "sympy.core.numbers.AlgebraicNumber.minpoly_of_element",
    "type": "method",
    "description": "\n        Compute the minimal polynomial for this algebraic number.\n\n        Explanation\n        ===========\n\n        Recall that we represent an element $\\alpha \\in \\mathbb{Q}(\\theta)$.\n        Our instance attribute ``self.minpoly`` is the minimal polynomial for\n        our primitive element $\\theta$. This method computes the minimal\n        polynomial for $\\alpha$.\n\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "native_coeffs",
    "full_id": "sympy.core.numbers.AlgebraicNumber.native_coeffs",
    "type": "method",
    "description": "Returns all native coefficients of an algebraic number.",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "primitive_element",
    "full_id": "sympy.core.numbers.AlgebraicNumber.primitive_element",
    "type": "method",
    "description": "\n        Get the primitive element $\\theta$ for the number field\n        $\\mathbb{Q}(\\theta)$ to which this algebraic number $\\alpha$ belongs.\n\n        Returns\n        =======\n\n        AlgebraicNumber\n\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "to_algebraic_integer",
    "full_id": "sympy.core.numbers.AlgebraicNumber.to_algebraic_integer",
    "type": "method",
    "description": "Convert ``self`` to an algebraic integer.",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "to_primitive_element",
    "full_id": "sympy.core.numbers.AlgebraicNumber.to_primitive_element",
    "type": "method",
    "description": "\n        Convert ``self`` to an :py:class:`~.AlgebraicNumber` instance that is\n        equal to its own primitive element.\n\n        Explanation\n        ===========\n\n        If we represent $\\alpha \\in \\mathbb{Q}(\\theta)$, $\\alpha \\neq \\theta$,\n        construct a new :py:class:`~.AlgebraicNumber` that represents\n        $\\alpha \\in \\mathbb{Q}(\\alpha)$.\n\n        Examples\n        ========\n\n        >>> from sympy import sqrt, to_number_field\n        >>> from sympy.abc import x\n        >>> a = to_number_field(sqrt(2), sqrt(2) + sqrt(3))\n\n        The :py:class:`~.AlgebraicNumber` ``a`` represents the number\n        $\\sqrt{2}$ in the field $\\mathbb{Q}(\\sqrt{2} + \\sqrt{3})$. Rendering\n        ``a`` as a polynomial,\n\n        >>> a.as_poly().as_expr(x)\n        x**3/2 - 9*x/2\n\n        reflects the fact that $\\sqrt{2} = \\theta^3/2 - 9 \\theta/2$, where\n        $\\theta = \\sqrt{2} + \\sqrt{3}$.\n\n        ``a`` is not equal to its own primitive element. Its minpoly\n\n        >>> a.minpoly.as_poly().as_expr(x)\n        x**4 - 10*x**2 + 1\n\n        is that of $\\theta$.\n\n        Converting to a primitive element,\n\n        >>> a_prim = a.to_primitive_element()\n        >>> a_prim.minpoly.as_poly().as_expr(x)\n        x**2 - 2\n\n        we obtain an :py:class:`~.AlgebraicNumber` whose ``minpoly`` is that of\n        the number itself.\n\n        Parameters\n        ==========\n\n        radicals : boolean, optional (default=True)\n            If ``True``, then we will try to return an\n            :py:class:`~.AlgebraicNumber` whose ``root`` is an expression\n            in radicals. If that is not possible (or if *radicals* is\n            ``False``), ``root`` will be a :py:class:`~.ComplexRootOf`.\n\n        Returns\n        =======\n\n        AlgebraicNumber\n\n        See Also\n        ========\n\n        is_primitive_element\n\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "to_root",
    "full_id": "sympy.core.numbers.AlgebraicNumber.to_root",
    "type": "method",
    "description": "\n        Convert to an :py:class:`~.Expr` that is not an\n        :py:class:`~.AlgebraicNumber`, specifically, either a\n        :py:class:`~.ComplexRootOf`, or, optionally and where possible, an\n        expression in radicals.\n\n        Parameters\n        ==========\n\n        radicals : boolean, optional (default=True)\n            If ``True``, then we will try to return the root as an expression\n            in radicals. If that is not possible, we will return a\n            :py:class:`~.ComplexRootOf`.\n\n        minpoly : :py:class:`~.Poly`\n            If the minimal polynomial for `self` has been pre-computed, it can\n            be passed in order to save time.\n\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "approximation",
    "full_id": "sympy.core.numbers.NumberSymbol.approximation",
    "type": "method",
    "description": "Return an interval with number_cls endpoints\n        that contains the value of NumberSymbol.\n        If not implemented, then return None.\n        ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "seterr",
    "full_id": "sympy.core.numbers.seterr",
    "type": "function",
    "description": "\n    Should SymPy raise an exception on 0/0 or return a nan?\n\n    divide == True .... raise an exception\n    divide == False ... return nan\n    ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "equal_valued",
    "full_id": "sympy.core.numbers.equal_valued",
    "type": "function",
    "description": "Compare expressions treating plain floats as rationals.\n\n    Examples\n    ========\n\n    >>> from sympy import S, symbols, Rational, Float\n    >>> from sympy.core.numbers import equal_valued\n    >>> equal_valued(1, 2)\n    False\n    >>> equal_valued(1, 1)\n    True\n\n    In SymPy expressions with Floats compare unequal to corresponding\n    expressions with rationals:\n\n    >>> x = symbols('x')\n    >>> x**2 == x**2.0\n    False\n\n    However an individual Float compares equal to a Rational:\n\n    >>> Rational(1, 2) == Float(0.5)\n    False\n\n    In a future version of SymPy this might change so that Rational and Float\n    compare unequal. This function provides the behavior currently expected of\n    ``==`` so that it could still be used if the behavior of ``==`` were to\n    change in future.\n\n    >>> equal_valued(1, 1.0) # Float vs Rational\n    True\n    >>> equal_valued(S(1).n(3), S(1).n(5)) # Floats of different precision\n    True\n\n    Explanation\n    ===========\n\n    In future SymPy verions Float and Rational might compare unequal and floats\n    with different precisions might compare unequal. In that context a function\n    is needed that can check if a number is equal to 1 or 0 etc. The idea is\n    that instead of testing ``if x == 1:`` if we want to accept floats like\n    ``1.0`` as well then the test can be written as ``if equal_valued(x, 1):``\n    or ``if equal_valued(x, 2):``. Since this function is intended to be used\n    in situations where one or both operands are expected to be concrete\n    numbers like 1 or 0 the function does not recurse through the args of any\n    compound expression to compare any nested floats.\n\n    References\n    ==========\n\n    .. [1] https://github.com/sympy/sympy/pull/20033\n    ",
    "section": "numbers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_base_exp",
    "full_id": "sympy.core.power.Pow.as_base_exp",
    "type": "method",
    "description": "Return base and exp of self.\n\n        Explanation\n        ===========\n\n        If base a Rational less than 1, then return 1/Rational, -exp.\n        If this extra processing is not needed, the base and exp\n        properties will give the raw arguments.\n\n        Examples\n        ========\n\n        >>> from sympy import Pow, S\n        >>> p = Pow(S.Half, 2, evaluate=False)\n        >>> p.as_base_exp()\n        (2, -2)\n        >>> p.args\n        (1/2, 2)\n        >>> p.base, p.exp\n        (1/2, 2)\n\n        ",
    "section": "power",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_content_primitive",
    "full_id": "sympy.core.power.Pow.as_content_primitive",
    "type": "method",
    "description": "Return the tuple (R, self/R) where R is the positive Rational\n        extracted from self.\n\n        Examples\n        ========\n\n        >>> from sympy import sqrt\n        >>> sqrt(4 + 4*sqrt(2)).as_content_primitive()\n        (2, sqrt(1 + sqrt(2)))\n        >>> sqrt(3 + 3*sqrt(2)).as_content_primitive()\n        (1, sqrt(3)*sqrt(1 + sqrt(2)))\n\n        >>> from sympy import expand_power_base, powsimp, Mul\n        >>> from sympy.abc import x, y\n\n        >>> ((2*x + 2)**2).as_content_primitive()\n        (4, (x + 1)**2)\n        >>> (4**((1 + y)/2)).as_content_primitive()\n        (2, 4**(y/2))\n        >>> (3**((1 + y)/2)).as_content_primitive()\n        (1, 3**((y + 1)/2))\n        >>> (3**((5 + y)/2)).as_content_primitive()\n        (9, 3**((y + 1)/2))\n        >>> eq = 3**(2 + 2*x)\n        >>> powsimp(eq) == eq\n        True\n        >>> eq.as_content_primitive()\n        (9, 3**(2*x))\n        >>> powsimp(Mul(*_))\n        3**(2*x + 2)\n\n        >>> eq = (2 + 2*x)**y\n        >>> s = expand_power_base(eq); s.is_Mul, s\n        (False, (2*x + 2)**y)\n        >>> eq.as_content_primitive()\n        (1, (2*(x + 1))**y)\n        >>> s = expand_power_base(_[1]); s.is_Mul, s\n        (True, 2**y*(x + 1)**y)\n\n        See docstring of Expr.as_content_primitive for more examples.\n        ",
    "section": "power",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_content_primitive",
    "full_id": "sympy.core.mul.Mul.as_content_primitive",
    "type": "method",
    "description": "Return the tuple (R, self/R) where R is the positive Rational\n        extracted from self.\n\n        Examples\n        ========\n\n        >>> from sympy import sqrt\n        >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n        (6, -sqrt(2)*(1 - sqrt(2)))\n\n        See docstring of Expr.as_content_primitive for more examples.\n        ",
    "section": "mul",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_ordered_factors",
    "full_id": "sympy.core.mul.Mul.as_ordered_factors",
    "type": "method",
    "description": "Transform an expression into an ordered list of factors.\n\n        Examples\n        ========\n\n        >>> from sympy import sin, cos\n        >>> from sympy.abc import x, y\n\n        >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()\n        [2, x, y, sin(x), cos(x)]\n\n        ",
    "section": "mul",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_two_terms",
    "full_id": "sympy.core.mul.Mul.as_two_terms",
    "type": "method",
    "description": "Return head and tail of self.\n\n        This is the most efficient way to get the head and tail of an\n        expression.\n\n        - if you want only the head, use self.args[0];\n        - if you want to process the arguments of the tail then use\n          self.as_coef_mul() which gives the head and a tuple containing\n          the arguments of the tail when treated as a Mul.\n        - if you want the coefficient when self is treated as an Add\n          then use self.as_coeff_add()[0]\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> (3*x*y).as_two_terms()\n        (3, x*y)\n        ",
    "section": "mul",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "flatten",
    "full_id": "sympy.core.mul.Mul.flatten",
    "type": "method",
    "description": "Return commutative, noncommutative and order arguments by\n        combining related terms.\n\n        Notes\n        =====\n            * In an expression like ``a*b*c``, Python process this through SymPy\n              as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.\n\n              -  Sometimes terms are not combined as one would like:\n                 {c.f. https://github.com/sympy/sympy/issues/4596}\n\n                >>> from sympy import Mul, sqrt\n                >>> from sympy.abc import x, y, z\n                >>> 2*(x + 1) # this is the 2-arg Mul behavior\n                2*x + 2\n                >>> y*(x + 1)*2\n                2*y*(x + 1)\n                >>> 2*(x + 1)*y # 2-arg result will be obtained first\n                y*(2*x + 2)\n                >>> Mul(2, x + 1, y) # all 3 args simultaneously processed\n                2*y*(x + 1)\n                >>> 2*((x + 1)*y) # parentheses can control this behavior\n                2*y*(x + 1)\n\n                Powers with compound bases may not find a single base to\n                combine with unless all arguments are processed at once.\n                Post-processing may be necessary in such cases.\n                {c.f. https://github.com/sympy/sympy/issues/5728}\n\n                >>> a = sqrt(x*sqrt(y))\n                >>> a**3\n                (x*sqrt(y))**(3/2)\n                >>> Mul(a,a,a)\n                (x*sqrt(y))**(3/2)\n                >>> a*a*a\n                x*sqrt(y)*sqrt(x*sqrt(y))\n                >>> _.subs(a.base, z).subs(z, a.base)\n                (x*sqrt(y))**(3/2)\n\n              -  If more than two terms are being multiplied then all the\n                 previous terms will be re-processed for each new argument.\n                 So if each of ``a``, ``b`` and ``c`` were :class:`Mul`\n                 expression, then ``a*b*c`` (or building up the product\n                 with ``*=``) will process all the arguments of ``a`` and\n                 ``b`` twice: once when ``a*b`` is computed and again when\n                 ``c`` is multiplied.\n\n                 Using ``Mul(a, b, c)`` will process all arguments once.\n\n            * The results of Mul are cached according to arguments, so flatten\n              will only be called once for ``Mul(a, b, c)``. If you can\n              structure a calculation so the arguments are most likely to be\n              repeats then this can save time in computing the answer. For\n              example, say you had a Mul, M, that you wished to divide by ``d[i]``\n              and multiply by ``n[i]`` and you suspect there are many repeats\n              in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather\n              than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the\n              product, ``M*n[i]`` will be returned without flattening -- the\n              cached value will be returned. If you divide by the ``d[i]``\n              first (and those are more unique than the ``n[i]``) then that will\n              create a new Mul, ``M/d[i]`` the args of which will be traversed\n              again when it is multiplied by ``n[i]``.\n\n              {c.f. https://github.com/sympy/sympy/issues/5706}\n\n              This consideration is moot if the cache is turned off.\n\n            NB\n            --\n              The validity of the above notes depends on the implementation\n              details of Mul and flatten which may change at any time. Therefore,\n              you should only consider them when your code is highly performance\n              sensitive.\n\n              Removal of 1 from the sequence is already handled by AssocOp.__new__.\n        ",
    "section": "mul",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "prod",
    "full_id": "sympy.core.mul.prod",
    "type": "function",
    "description": "Return product of elements of a. Start with int 1 so if only\n       ints are included then an int result is returned.\n\n    Examples\n    ========\n\n    >>> from sympy import prod, S\n    >>> prod(range(3))\n    0\n    >>> type(_) is int\n    True\n    >>> prod([S(2), 3])\n    6\n    >>> _.is_Integer\n    True\n\n    You can start the product at something other than 1:\n\n    >>> prod([1, 2], 3)\n    6\n\n    ",
    "section": "mul",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_coeff_add",
    "full_id": "sympy.core.add.Add.as_coeff_add",
    "type": "method",
    "description": "\n        Returns a tuple (coeff, args) where self is treated as an Add and coeff\n        is the Number term and args is a tuple of all other terms.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> (7 + 3*x).as_coeff_add()\n        (7, (3*x,))\n        >>> (7*x).as_coeff_add()\n        (0, (7*x,))\n        ",
    "section": "add",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_content_primitive",
    "full_id": "sympy.core.add.Add.as_content_primitive",
    "type": "method",
    "description": "Return the tuple (R, self/R) where R is the positive Rational\n        extracted from self. If radical is True (default is False) then\n        common radicals will be removed and included as a factor of the\n        primitive expression.\n\n        Examples\n        ========\n\n        >>> from sympy import sqrt\n        >>> (3 + 3*sqrt(2)).as_content_primitive()\n        (3, 1 + sqrt(2))\n\n        Radical content can also be factored out of the primitive:\n\n        >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n        (2, sqrt(2)*(1 + 2*sqrt(5)))\n\n        See docstring of Expr.as_content_primitive for more examples.\n        ",
    "section": "add",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_numer_denom",
    "full_id": "sympy.core.add.Add.as_numer_denom",
    "type": "method",
    "description": "\n        Decomposes an expression to its numerator part and its\n        denominator part.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y, z\n        >>> (x*y/z).as_numer_denom()\n        (x*y, z)\n        >>> (x*(y + 1)/y**7).as_numer_denom()\n        (x*(y + 1), y**7)\n\n        See Also\n        ========\n\n        sympy.core.expr.Expr.as_numer_denom\n        ",
    "section": "add",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_real_imag",
    "full_id": "sympy.core.add.Add.as_real_imag",
    "type": "method",
    "description": "\n        Return a tuple representing a complex number.\n\n        Examples\n        ========\n\n        >>> from sympy import I\n        >>> (7 + 9*I).as_real_imag()\n        (7, 9)\n        >>> ((1 + I)/(1 - I)).as_real_imag()\n        (0, 1)\n        >>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n        (-5, 5)\n        ",
    "section": "add",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_two_terms",
    "full_id": "sympy.core.add.Add.as_two_terms",
    "type": "method",
    "description": "Return head and tail of self.\n\n        This is the most efficient way to get the head and tail of an\n        expression.\n\n        - if you want only the head, use self.args[0];\n        - if you want to process the arguments of the tail then use\n          self.as_coef_add() which gives the head and a tuple containing\n          the arguments of the tail when treated as an Add.\n        - if you want the coefficient when self is treated as a Mul\n          then use self.as_coeff_mul()[0]\n\n        >>> from sympy.abc import x, y\n        >>> (3*x - 2*y + 5).as_two_terms()\n        (5, 3*x - 2*y)\n        ",
    "section": "add",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "extract_leading_order",
    "full_id": "sympy.core.add.Add.extract_leading_order",
    "type": "method",
    "description": "\n        Returns the leading term and its order.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> (x + 1 + 1/x**5).extract_leading_order(x)\n        ((x**(-5), O(x**(-5))),)\n        >>> (1 + x).extract_leading_order(x)\n        ((1, O(1)),)\n        >>> (x + x**2).extract_leading_order(x)\n        ((x, O(x)),)\n\n        ",
    "section": "add",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "flatten",
    "full_id": "sympy.core.add.Add.flatten",
    "type": "method",
    "description": "\n        Takes the sequence \"seq\" of nested Adds and returns a flatten list.\n\n        Returns: (commutative_part, noncommutative_part, order_symbols)\n\n        Applies associativity, all terms are commutable with respect to\n        addition.\n\n        NB: the removal of 0 is already handled by AssocOp.__new__\n\n        See Also\n        ========\n\n        sympy.core.mul.Mul.flatten\n\n        ",
    "section": "add",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "primitive",
    "full_id": "sympy.core.add.Add.primitive",
    "type": "method",
    "description": "\n        Return ``(R, self/R)`` where ``R``` is the Rational GCD of ``self```.\n\n        ``R`` is collected only from the leading coefficient of each term.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n\n        >>> (2*x + 4*y).primitive()\n        (2, x + 2*y)\n\n        >>> (2*x/3 + 4*y/9).primitive()\n        (2/9, 3*x + 2*y)\n\n        >>> (2*x/3 + 4.2*y).primitive()\n        (1/3, 2*x + 12.6*y)\n\n        No subprocessing of term factors is performed:\n\n        >>> ((2 + 2*x)*x + 2).primitive()\n        (1, x*(2*x + 2) + 2)\n\n        Recursive processing can be done with the ``as_content_primitive()``\n        method:\n\n        >>> ((2 + 2*x)*x + 2).as_content_primitive()\n        (2, x*(x + 1) + 1)\n\n        See also: primitive() function in polytools.py\n\n        ",
    "section": "add",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "canonical",
    "full_id": "sympy.core.relational.Relational.canonical",
    "type": "property",
    "description": "Return a canonical form of the relational by putting a\n        number on the rhs, canonically removing a sign or else\n        ordering the args canonically. No other simplification is\n        attempted.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> x < 2\n        x < 2\n        >>> _.reversed.canonical\n        x < 2\n        >>> (-y < x).canonical\n        x > -y\n        >>> (-y > x).canonical\n        x < -y\n        >>> (-y < -x).canonical\n        x < y\n\n        The canonicalization is recursively applied:\n\n        >>> from sympy import Eq\n        >>> Eq(x < y, y > x).canonical\n        True\n        ",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "equals",
    "full_id": "sympy.core.relational.Relational.equals",
    "type": "method",
    "description": "Return True if the sides of the relationship are mathematically\n        identical and the type of relationship is the same.\n        If failing_expression is True, return the expression whose truth value\n        was unknown.",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "lhs",
    "full_id": "sympy.core.relational.Relational.lhs",
    "type": "property",
    "description": "The left-hand side of the relation.",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "negated",
    "full_id": "sympy.core.relational.Relational.negated",
    "type": "property",
    "description": "Return the negated relationship.\n\n        Examples\n        ========\n\n        >>> from sympy import Eq\n        >>> from sympy.abc import x\n        >>> Eq(x, 1)\n        Eq(x, 1)\n        >>> _.negated\n        Ne(x, 1)\n        >>> x < 1\n        x < 1\n        >>> _.negated\n        x >= 1\n\n        Notes\n        =====\n\n        This works more or less identical to ``~``/``Not``. The difference is\n        that ``negated`` returns the relationship even if ``evaluate=False``.\n        Hence, this is useful in code when checking for e.g. negated relations\n        to existing ones as it will not be affected by the `evaluate` flag.\n\n        ",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "reversed",
    "full_id": "sympy.core.relational.Relational.reversed",
    "type": "property",
    "description": "Return the relationship with sides reversed.\n\n        Examples\n        ========\n\n        >>> from sympy import Eq\n        >>> from sympy.abc import x\n        >>> Eq(x, 1)\n        Eq(x, 1)\n        >>> _.reversed\n        Eq(1, x)\n        >>> x < 1\n        x < 1\n        >>> _.reversed\n        1 > x\n        ",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "reversedsign",
    "full_id": "sympy.core.relational.Relational.reversedsign",
    "type": "property",
    "description": "Return the relationship with signs reversed.\n\n        Examples\n        ========\n\n        >>> from sympy import Eq\n        >>> from sympy.abc import x\n        >>> Eq(x, 1)\n        Eq(x, 1)\n        >>> _.reversedsign\n        Eq(-x, -1)\n        >>> x < 1\n        x < 1\n        >>> _.reversedsign\n        -x > -1\n        ",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "rhs",
    "full_id": "sympy.core.relational.Relational.rhs",
    "type": "property",
    "description": "The right-hand side of the relation.",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "strict",
    "full_id": "sympy.core.relational.Relational.strict",
    "type": "property",
    "description": "return the strict version of the inequality or self\n\n        EXAMPLES\n        ========\n\n        >>> from sympy.abc import x\n        >>> (x <= 1).strict\n        x < 1\n        >>> _.strict\n        x < 1\n        ",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "weak",
    "full_id": "sympy.core.relational.Relational.weak",
    "type": "property",
    "description": "return the non-strict version of the inequality or self\n\n        EXAMPLES\n        ========\n\n        >>> from sympy.abc import x\n        >>> (x < 1).weak\n        x <= 1\n        >>> _.weak\n        x <= 1\n        ",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_poly",
    "full_id": "sympy.core.relational.Equality.as_poly",
    "type": "method",
    "description": "Returns lhs-rhs as a Poly\n\n        Examples\n        ========\n\n        >>> from sympy import Eq\n        >>> from sympy.abc import x\n        >>> Eq(x**2, 1).as_poly(x)\n        Poly(x**2 - 1, x, domain='ZZ')\n        ",
    "section": "relational",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "bound_symbols",
    "full_id": "sympy.core.function.Lambda.bound_symbols",
    "type": "property",
    "description": "The variables used in the internal representation of the function",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expr",
    "full_id": "sympy.core.function.Lambda.expr",
    "type": "property",
    "description": "The return value of the function",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "is_identity",
    "full_id": "sympy.core.function.Lambda.is_identity",
    "type": "property",
    "description": "Return ``True`` if this ``Lambda`` is an identity function.",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "signature",
    "full_id": "sympy.core.function.Lambda.signature",
    "type": "property",
    "description": "The expected form of the arguments to be unpacked into variables",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "_diff_wrt",
    "full_id": "sympy.core.function.Derivative._diff_wrt",
    "type": "property",
    "description": "An expression may be differentiated wrt a Derivative if\n        it is in elementary form.\n\n        Examples\n        ========\n\n        >>> from sympy import Function, Derivative, cos\n        >>> from sympy.abc import x\n        >>> f = Function('f')\n\n        >>> Derivative(f(x), x)._diff_wrt\n        True\n        >>> Derivative(cos(x), x)._diff_wrt\n        False\n        >>> Derivative(x + 1, x)._diff_wrt\n        False\n\n        A Derivative might be an unevaluated form of what will not be\n        a valid variable of differentiation if evaluated. For example,\n\n        >>> Derivative(f(f(x)), x).doit()\n        Derivative(f(x), x)*Derivative(f(f(x)), f(x))\n\n        Such an expression will present the same ambiguities as arise\n        when dealing with any other product, like ``2*x``, so ``_diff_wrt``\n        is False:\n\n        >>> Derivative(f(f(x)), x)._diff_wrt\n        False\n        ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "_sort_variable_count",
    "full_id": "sympy.core.function.Derivative._sort_variable_count",
    "type": "method",
    "description": "\n        Sort (variable, count) pairs into canonical order while\n        retaining order of variables that do not commute during\n        differentiation:\n\n        * symbols and functions commute with each other\n        * derivatives commute with each other\n        * a derivative does not commute with anything it contains\n        * any other object is not allowed to commute if it has\n          free symbols in common with another object\n\n        Examples\n        ========\n\n        >>> from sympy import Derivative, Function, symbols\n        >>> vsort = Derivative._sort_variable_count\n        >>> x, y, z = symbols('x y z')\n        >>> f, g, h = symbols('f g h', cls=Function)\n\n        Contiguous items are collapsed into one pair:\n\n        >>> vsort([(x, 1), (x, 1)])\n        [(x, 2)]\n        >>> vsort([(y, 1), (f(x), 1), (y, 1), (f(x), 1)])\n        [(y, 2), (f(x), 2)]\n\n        Ordering is canonical.\n\n        >>> def vsort0(*v):\n        ...     # docstring helper to\n        ...     # change vi -> (vi, 0), sort, and return vi vals\n        ...     return [i[0] for i in vsort([(i, 0) for i in v])]\n\n        >>> vsort0(y, x)\n        [x, y]\n        >>> vsort0(g(y), g(x), f(y))\n        [f(y), g(x), g(y)]\n\n        Symbols are sorted as far to the left as possible but never\n        move to the left of a derivative having the same symbol in\n        its variables; the same applies to AppliedUndef which are\n        always sorted after Symbols:\n\n        >>> dfx = f(x).diff(x)\n        >>> assert vsort0(dfx, y) == [y, dfx]\n        >>> assert vsort0(dfx, x) == [dfx, x]\n        ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "as_finite_difference",
    "full_id": "sympy.core.function.Derivative.as_finite_difference",
    "type": "method",
    "description": "Expresses a Derivative instance as a finite difference.\n\n        Parameters\n        ==========\n\n        points : sequence or coefficient, optional\n            If sequence: discrete values (length >= order+1) of the\n            independent variable used for generating the finite\n            difference weights.\n            If it is a coefficient, it will be used as the step-size\n            for generating an equidistant sequence of length order+1\n            centered around ``x0``. Default: 1 (step-size 1)\n\n        x0 : number or Symbol, optional\n            the value of the independent variable (``wrt``) at which the\n            derivative is to be approximated. Default: same as ``wrt``.\n\n        wrt : Symbol, optional\n            \"with respect to\" the variable for which the (partial)\n            derivative is to be approximated for. If not provided it\n            is required that the derivative is ordinary. Default: ``None``.\n\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, Function, exp, sqrt, Symbol\n        >>> x, h = symbols('x h')\n        >>> f = Function('f')\n        >>> f(x).diff(x).as_finite_difference()\n        -f(x - 1/2) + f(x + 1/2)\n\n        The default step size and number of points are 1 and\n        ``order + 1`` respectively. We can change the step size by\n        passing a symbol as a parameter:\n\n        >>> f(x).diff(x).as_finite_difference(h)\n        -f(-h/2 + x)/h + f(h/2 + x)/h\n\n        We can also specify the discretized values to be used in a\n        sequence:\n\n        >>> f(x).diff(x).as_finite_difference([x, x+h, x+2*h])\n        -3*f(x)/(2*h) + 2*f(h + x)/h - f(2*h + x)/(2*h)\n\n        The algorithm is not restricted to use equidistant spacing, nor\n        do we need to make the approximation around ``x0``, but we can get\n        an expression estimating the derivative at an offset:\n\n        >>> e, sq2 = exp(1), sqrt(2)\n        >>> xl = [x-h, x+h, x+e*h]\n        >>> f(x).diff(x, 1).as_finite_difference(xl, x+h*sq2)  # doctest: +ELLIPSIS\n        2*h*((h + sqrt(2)*h)/(2*h) - (-sqrt(2)*h + h)/(2*h))*f(E*h + x)/...\n\n        To approximate ``Derivative`` around ``x0`` using a non-equidistant\n        spacing step, the algorithm supports assignment of undefined\n        functions to ``points``:\n\n        >>> dx = Function('dx')\n        >>> f(x).diff(x).as_finite_difference(points=dx(x), x0=x-h)\n        -f(-h + x - dx(-h + x)/2)/dx(-h + x) + f(-h + x + dx(-h + x)/2)/dx(-h + x)\n\n        Partial derivatives are also supported:\n\n        >>> y = Symbol('y')\n        >>> d2fdxdy=f(x,y).diff(x,y)\n        >>> d2fdxdy.as_finite_difference(wrt=x)\n        -Derivative(f(x - 1/2, y), y) + Derivative(f(x + 1/2, y), y)\n\n        We can apply ``as_finite_difference`` to ``Derivative`` instances in\n        compound expressions using ``replace``:\n\n        >>> (1 + 42**f(x).diff(x)).replace(lambda arg: arg.is_Derivative,\n        ...     lambda arg: arg.as_finite_difference())\n        42**(-f(x - 1/2) + f(x + 1/2)) + 1\n\n\n        See also\n        ========\n\n        sympy.calculus.finite_diff.apply_finite_diff\n        sympy.calculus.finite_diff.differentiate_finite\n        sympy.calculus.finite_diff.finite_diff_weights\n\n        ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "doit_numerically",
    "full_id": "sympy.core.function.Derivative.doit_numerically",
    "type": "method",
    "description": "\n        Evaluate the derivative at z numerically.\n\n        When we can represent derivatives at a point, this should be folded\n        into the normal evalf. For now, we need a special method.\n        ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "diff",
    "full_id": "sympy.core.function.diff",
    "type": "function",
    "description": "\n    Differentiate f with respect to symbols.\n\n    Explanation\n    ===========\n\n    This is just a wrapper to unify .diff() and the Derivative class; its\n    interface is similar to that of integrate().  You can use the same\n    shortcuts for multiple variables as with Derivative.  For example,\n    diff(f(x), x, x, x) and diff(f(x), x, 3) both return the third derivative\n    of f(x).\n\n    You can pass evaluate=False to get an unevaluated Derivative class.  Note\n    that if there are 0 symbols (such as diff(f(x), x, 0), then the result will\n    be the function (the zeroth derivative), even if evaluate=False.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, cos, Function, diff\n    >>> from sympy.abc import x, y\n    >>> f = Function('f')\n\n    >>> diff(sin(x), x)\n    cos(x)\n    >>> diff(f(x), x, x, x)\n    Derivative(f(x), (x, 3))\n    >>> diff(f(x), x, 3)\n    Derivative(f(x), (x, 3))\n    >>> diff(sin(x)*cos(y), x, 2, y, 2)\n    sin(x)*cos(y)\n\n    >>> type(diff(sin(x), x))\n    cos\n    >>> type(diff(sin(x), x, evaluate=False))\n    <class 'sympy.core.function.Derivative'>\n    >>> type(diff(sin(x), x, 0))\n    sin\n    >>> type(diff(sin(x), x, 0, evaluate=False))\n    sin\n\n    >>> diff(sin(x))\n    cos(x)\n    >>> diff(sin(x*y))\n    Traceback (most recent call last):\n    ...\n    ValueError: specify differentiation variables to differentiate sin(x*y)\n\n    Note that ``diff(sin(x))`` syntax is meant only for convenience\n    in interactive sessions and should be avoided in library code.\n\n    References\n    ==========\n\n    .. [1] https://reference.wolfram.com/legacy/v5_2/Built-inFunctions/AlgebraicComputation/Calculus/D.html\n\n    See Also\n    ========\n\n    Derivative\n    idiff: computes the derivative implicitly\n\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "nargs",
    "full_id": "sympy.core.function.FunctionClass.nargs",
    "type": "property",
    "description": "Return a set of the allowed number of arguments for the function.\n\n        Examples\n        ========\n\n        >>> from sympy import Function\n        >>> f = Function('f')\n\n        If the function can take any number of arguments, the set of whole\n        numbers is returned:\n\n        >>> Function('f').nargs\n        Naturals0\n\n        If the function was initialized to accept one or more arguments, a\n        corresponding set will be returned:\n\n        >>> Function('f', nargs=1).nargs\n        {1}\n        >>> Function('f', nargs=(2, 1)).nargs\n        {1, 2}\n\n        The undefined function, after application, also has the nargs\n        attribute; the actual number of arguments is always available by\n        checking the ``args`` attribute:\n\n        >>> f = Function('f')\n        >>> f(1).nargs\n        Naturals0\n        >>> len(f(1).args)\n        1\n        ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "bound_symbols",
    "full_id": "sympy.core.function.Subs.bound_symbols",
    "type": "property",
    "description": "The variables to be evaluated",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expr",
    "full_id": "sympy.core.function.Subs.expr",
    "type": "property",
    "description": "The expression on which the substitution operates",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "point",
    "full_id": "sympy.core.function.Subs.point",
    "type": "property",
    "description": "The values for which the variables are to be substituted",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand",
    "full_id": "sympy.core.function.expand",
    "type": "function",
    "description": "\n    Expand an expression using methods given as hints.\n\n    Explanation\n    ===========\n\n    Hints evaluated unless explicitly set to False are:  ``basic``, ``log``,\n    ``multinomial``, ``mul``, ``power_base``, and ``power_exp`` The following\n    hints are supported but not applied unless set to True:  ``complex``,\n    ``func``, and ``trig``.  In addition, the following meta-hints are\n    supported by some or all of the other hints:  ``frac``, ``numer``,\n    ``denom``, ``modulus``, and ``force``.  ``deep`` is supported by all\n    hints.  Additionally, subclasses of Expr may define their own hints or\n    meta-hints.\n\n    The ``basic`` hint is used for any special rewriting of an object that\n    should be done automatically (along with the other hints like ``mul``)\n    when expand is called. This is a catch-all hint to handle any sort of\n    expansion that may not be described by the existing hint names. To use\n    this hint an object should override the ``_eval_expand_basic`` method.\n    Objects may also define their own expand methods, which are not run by\n    default.  See the API section below.\n\n    If ``deep`` is set to ``True`` (the default), things like arguments of\n    functions are recursively expanded.  Use ``deep=False`` to only expand on\n    the top level.\n\n    If the ``force`` hint is used, assumptions about variables will be ignored\n    in making the expansion.\n\n    Hints\n    =====\n\n    These hints are run by default\n\n    mul\n    ---\n\n    Distributes multiplication over addition:\n\n    >>> from sympy import cos, exp, sin\n    >>> from sympy.abc import x, y, z\n    >>> (y*(x + z)).expand(mul=True)\n    x*y + y*z\n\n    multinomial\n    -----------\n\n    Expand (x + y + ...)**n where n is a positive integer.\n\n    >>> ((x + y + z)**2).expand(multinomial=True)\n    x**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2\n\n    power_exp\n    ---------\n\n    Expand addition in exponents into multiplied bases.\n\n    >>> exp(x + y).expand(power_exp=True)\n    exp(x)*exp(y)\n    >>> (2**(x + y)).expand(power_exp=True)\n    2**x*2**y\n\n    power_base\n    ----------\n\n    Split powers of multiplied bases.\n\n    This only happens by default if assumptions allow, or if the\n    ``force`` meta-hint is used:\n\n    >>> ((x*y)**z).expand(power_base=True)\n    (x*y)**z\n    >>> ((x*y)**z).expand(power_base=True, force=True)\n    x**z*y**z\n    >>> ((2*y)**z).expand(power_base=True)\n    2**z*y**z\n\n    Note that in some cases where this expansion always holds, SymPy performs\n    it automatically:\n\n    >>> (x*y)**2\n    x**2*y**2\n\n    log\n    ---\n\n    Pull out power of an argument as a coefficient and split logs products\n    into sums of logs.\n\n    Note that these only work if the arguments of the log function have the\n    proper assumptions--the arguments must be positive and the exponents must\n    be real--or else the ``force`` hint must be True:\n\n    >>> from sympy import log, symbols\n    >>> log(x**2*y).expand(log=True)\n    log(x**2*y)\n    >>> log(x**2*y).expand(log=True, force=True)\n    2*log(x) + log(y)\n    >>> x, y = symbols('x,y', positive=True)\n    >>> log(x**2*y).expand(log=True)\n    2*log(x) + log(y)\n\n    basic\n    -----\n\n    This hint is intended primarily as a way for custom subclasses to enable\n    expansion by default.\n\n    These hints are not run by default:\n\n    complex\n    -------\n\n    Split an expression into real and imaginary parts.\n\n    >>> x, y = symbols('x,y')\n    >>> (x + y).expand(complex=True)\n    re(x) + re(y) + I*im(x) + I*im(y)\n    >>> cos(x).expand(complex=True)\n    -I*sin(re(x))*sinh(im(x)) + cos(re(x))*cosh(im(x))\n\n    Note that this is just a wrapper around ``as_real_imag()``.  Most objects\n    that wish to redefine ``_eval_expand_complex()`` should consider\n    redefining ``as_real_imag()`` instead.\n\n    func\n    ----\n\n    Expand other functions.\n\n    >>> from sympy import gamma\n    >>> gamma(x + 1).expand(func=True)\n    x*gamma(x)\n\n    trig\n    ----\n\n    Do trigonometric expansions.\n\n    >>> cos(x + y).expand(trig=True)\n    -sin(x)*sin(y) + cos(x)*cos(y)\n    >>> sin(2*x).expand(trig=True)\n    2*sin(x)*cos(x)\n\n    Note that the forms of ``sin(n*x)`` and ``cos(n*x)`` in terms of ``sin(x)``\n    and ``cos(x)`` are not unique, due to the identity `\\sin^2(x) + \\cos^2(x)\n    = 1`.  The current implementation uses the form obtained from Chebyshev\n    polynomials, but this may change.  See `this MathWorld article\n    <https://mathworld.wolfram.com/Multiple-AngleFormulas.html>`_ for more\n    information.\n\n    Notes\n    =====\n\n    - You can shut off unwanted methods::\n\n        >>> (exp(x + y)*(x + y)).expand()\n        x*exp(x)*exp(y) + y*exp(x)*exp(y)\n        >>> (exp(x + y)*(x + y)).expand(power_exp=False)\n        x*exp(x + y) + y*exp(x + y)\n        >>> (exp(x + y)*(x + y)).expand(mul=False)\n        (x + y)*exp(x)*exp(y)\n\n    - Use deep=False to only expand on the top level::\n\n        >>> exp(x + exp(x + y)).expand()\n        exp(x)*exp(exp(x)*exp(y))\n        >>> exp(x + exp(x + y)).expand(deep=False)\n        exp(x)*exp(exp(x + y))\n\n    - Hints are applied in an arbitrary, but consistent order (in the current\n      implementation, they are applied in alphabetical order, except\n      multinomial comes before mul, but this may change).  Because of this,\n      some hints may prevent expansion by other hints if they are applied\n      first. For example, ``mul`` may distribute multiplications and prevent\n      ``log`` and ``power_base`` from expanding them. Also, if ``mul`` is\n      applied before ``multinomial`, the expression might not be fully\n      distributed. The solution is to use the various ``expand_hint`` helper\n      functions or to use ``hint=False`` to this function to finely control\n      which hints are applied. Here are some examples::\n\n        >>> from sympy import expand, expand_mul, expand_power_base\n        >>> x, y, z = symbols('x,y,z', positive=True)\n\n        >>> expand(log(x*(y + z)))\n        log(x) + log(y + z)\n\n      Here, we see that ``log`` was applied before ``mul``.  To get the mul\n      expanded form, either of the following will work::\n\n        >>> expand_mul(log(x*(y + z)))\n        log(x*y + x*z)\n        >>> expand(log(x*(y + z)), log=False)\n        log(x*y + x*z)\n\n      A similar thing can happen with the ``power_base`` hint::\n\n        >>> expand((x*(y + z))**x)\n        (x*y + x*z)**x\n\n      To get the ``power_base`` expanded form, either of the following will\n      work::\n\n        >>> expand((x*(y + z))**x, mul=False)\n        x**x*(y + z)**x\n        >>> expand_power_base((x*(y + z))**x)\n        x**x*(y + z)**x\n\n        >>> expand((x + y)*y/x)\n        y + y**2/x\n\n      The parts of a rational expression can be targeted::\n\n        >>> expand((x + y)*y/x/(x + 1), frac=True)\n        (x*y + y**2)/(x**2 + x)\n        >>> expand((x + y)*y/x/(x + 1), numer=True)\n        (x*y + y**2)/(x*(x + 1))\n        >>> expand((x + y)*y/x/(x + 1), denom=True)\n        y*(x + y)/(x**2 + x)\n\n    - The ``modulus`` meta-hint can be used to reduce the coefficients of an\n      expression post-expansion::\n\n        >>> expand((3*x + 1)**2)\n        9*x**2 + 6*x + 1\n        >>> expand((3*x + 1)**2, modulus=5)\n        4*x**2 + x + 1\n\n    - Either ``expand()`` the function or ``.expand()`` the method can be\n      used.  Both are equivalent::\n\n        >>> expand((x + 1)**2)\n        x**2 + 2*x + 1\n        >>> ((x + 1)**2).expand()\n        x**2 + 2*x + 1\n\n    API\n    ===\n\n    Objects can define their own expand hints by defining\n    ``_eval_expand_hint()``.  The function should take the form::\n\n        def _eval_expand_hint(self, **hints):\n            # Only apply the method to the top-level expression\n            ...\n\n    See also the example below.  Objects should define ``_eval_expand_hint()``\n    methods only if ``hint`` applies to that specific object.  The generic\n    ``_eval_expand_hint()`` method defined in Expr will handle the no-op case.\n\n    Each hint should be responsible for expanding that hint only.\n    Furthermore, the expansion should be applied to the top-level expression\n    only.  ``expand()`` takes care of the recursion that happens when\n    ``deep=True``.\n\n    You should only call ``_eval_expand_hint()`` methods directly if you are\n    100% sure that the object has the method, as otherwise you are liable to\n    get unexpected ``AttributeError``s.  Note, again, that you do not need to\n    recursively apply the hint to args of your object: this is handled\n    automatically by ``expand()``.  ``_eval_expand_hint()`` should\n    generally not be used at all outside of an ``_eval_expand_hint()`` method.\n    If you want to apply a specific expansion from within another method, use\n    the public ``expand()`` function, method, or ``expand_hint()`` functions.\n\n    In order for expand to work, objects must be rebuildable by their args,\n    i.e., ``obj.func(*obj.args) == obj`` must hold.\n\n    Expand methods are passed ``**hints`` so that expand hints may use\n    'metahints'--hints that control how different expand methods are applied.\n    For example, the ``force=True`` hint described above that causes\n    ``expand(log=True)`` to ignore assumptions is such a metahint.  The\n    ``deep`` meta-hint is handled exclusively by ``expand()`` and is not\n    passed to ``_eval_expand_hint()`` methods.\n\n    Note that expansion hints should generally be methods that perform some\n    kind of 'expansion'.  For hints that simply rewrite an expression, use the\n    .rewrite() API.\n\n    Examples\n    ========\n\n    >>> from sympy import Expr, sympify\n    >>> class MyClass(Expr):\n    ...     def __new__(cls, *args):\n    ...         args = sympify(args)\n    ...         return Expr.__new__(cls, *args)\n    ...\n    ...     def _eval_expand_double(self, *, force=False, **hints):\n    ...         '''\n    ...         Doubles the args of MyClass.\n    ...\n    ...         If there more than four args, doubling is not performed,\n    ...         unless force=True is also used (False by default).\n    ...         '''\n    ...         if not force and len(self.args) > 4:\n    ...             return self\n    ...         return self.func(*(self.args + self.args))\n    ...\n    >>> a = MyClass(1, 2, MyClass(3, 4))\n    >>> a\n    MyClass(1, 2, MyClass(3, 4))\n    >>> a.expand(double=True)\n    MyClass(1, 2, MyClass(3, 4, 3, 4), 1, 2, MyClass(3, 4, 3, 4))\n    >>> a.expand(double=True, deep=False)\n    MyClass(1, 2, MyClass(3, 4), 1, 2, MyClass(3, 4))\n\n    >>> b = MyClass(1, 2, 3, 4, 5)\n    >>> b.expand(double=True)\n    MyClass(1, 2, 3, 4, 5)\n    >>> b.expand(double=True, force=True)\n    MyClass(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n    See Also\n    ========\n\n    expand_log, expand_mul, expand_multinomial, expand_complex, expand_trig,\n    expand_power_base, expand_power_exp, expand_func, sympy.simplify.hyperexpand.hyperexpand\n\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "count_ops",
    "full_id": "sympy.core.function.count_ops",
    "type": "function",
    "description": "\n    Return a representation (integer or expression) of the operations in expr.\n\n    Parameters\n    ==========\n\n    expr : Expr\n        If expr is an iterable, the sum of the op counts of the\n        items will be returned.\n\n    visual : bool, optional\n        If ``False`` (default) then the sum of the coefficients of the\n        visual expression will be returned.\n        If ``True`` then the number of each type of operation is shown\n        with the core class types (or their virtual equivalent) multiplied by the\n        number of times they occur.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import a, b, x, y\n    >>> from sympy import sin, count_ops\n\n    Although there is not a SUB object, minus signs are interpreted as\n    either negations or subtractions:\n\n    >>> (x - y).count_ops(visual=True)\n    SUB\n    >>> (-x).count_ops(visual=True)\n    NEG\n\n    Here, there are two Adds and a Pow:\n\n    >>> (1 + a + b**2).count_ops(visual=True)\n    2*ADD + POW\n\n    In the following, an Add, Mul, Pow and two functions:\n\n    >>> (sin(x)*x + sin(x)**2).count_ops(visual=True)\n    ADD + MUL + POW + 2*SIN\n\n    for a total of 5:\n\n    >>> (sin(x)*x + sin(x)**2).count_ops(visual=False)\n    5\n\n    Note that \"what you type\" is not always what you get. The expression\n    1/x/y is translated by sympy into 1/(x*y) so it gives a DIV and MUL rather\n    than two DIVs:\n\n    >>> (1/x/y).count_ops(visual=True)\n    DIV + MUL\n\n    The visual option can be used to demonstrate the difference in\n    operations for expressions in different forms. Here, the Horner\n    representation is compared with the expanded form of a polynomial:\n\n    >>> eq=x*(1 + x*(2 + x*(3 + x)))\n    >>> count_ops(eq.expand(), visual=True) - count_ops(eq, visual=True)\n    -MUL + 3*POW\n\n    The count_ops function also handles iterables:\n\n    >>> count_ops([x, sin(x), None, True, x + 2], visual=False)\n    2\n    >>> count_ops([x, sin(x), None, True, x + 2], visual=True)\n    ADD + SIN\n    >>> count_ops({x: sin(x), x + 2: y + 1}, visual=True)\n    2*ADD + SIN\n\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand_mul",
    "full_id": "sympy.core.function.expand_mul",
    "type": "function",
    "description": "\n    Wrapper around expand that only uses the mul hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_mul, exp, log\n    >>> x, y = symbols('x,y', positive=True)\n    >>> expand_mul(exp(x+y)*(x+y)*log(x*y**2))\n    x*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2)\n\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand_log",
    "full_id": "sympy.core.function.expand_log",
    "type": "function",
    "description": "\n    Wrapper around expand that only uses the log hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_log, exp, log\n    >>> x, y = symbols('x,y', positive=True)\n    >>> expand_log(exp(x+y)*(x+y)*log(x*y**2))\n    (x + y)*(log(x) + 2*log(y))*exp(x + y)\n\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand_func",
    "full_id": "sympy.core.function.expand_func",
    "type": "function",
    "description": "\n    Wrapper around expand that only uses the func hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import expand_func, gamma\n    >>> from sympy.abc import x\n    >>> expand_func(gamma(x + 2))\n    x*(x + 1)*gamma(x)\n\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand_trig",
    "full_id": "sympy.core.function.expand_trig",
    "type": "function",
    "description": "\n    Wrapper around expand that only uses the trig hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import expand_trig, sin\n    >>> from sympy.abc import x, y\n    >>> expand_trig(sin(x+y)*(x+y))\n    (x + y)*(sin(x)*cos(y) + sin(y)*cos(x))\n\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand_complex",
    "full_id": "sympy.core.function.expand_complex",
    "type": "function",
    "description": "\n    Wrapper around expand that only uses the complex hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import expand_complex, exp, sqrt, I\n    >>> from sympy.abc import z\n    >>> expand_complex(exp(z))\n    I*exp(re(z))*sin(im(z)) + exp(re(z))*cos(im(z))\n    >>> expand_complex(sqrt(I))\n    sqrt(2)/2 + sqrt(2)*I/2\n\n    See Also\n    ========\n\n    sympy.core.expr.Expr.as_real_imag\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand_multinomial",
    "full_id": "sympy.core.function.expand_multinomial",
    "type": "function",
    "description": "\n    Wrapper around expand that only uses the multinomial hint.  See the expand\n    docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, expand_multinomial, exp\n    >>> x, y = symbols('x y', positive=True)\n    >>> expand_multinomial((x + exp(x + 1))**2)\n    x**2 + 2*x*exp(x + 1) + exp(2*x + 2)\n\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand_power_exp",
    "full_id": "sympy.core.function.expand_power_exp",
    "type": "function",
    "description": "\n    Wrapper around expand that only uses the power_exp hint.\n\n    See the expand docstring for more information.\n\n    Examples\n    ========\n\n    >>> from sympy import expand_power_exp, Symbol\n    >>> from sympy.abc import x, y\n    >>> expand_power_exp(3**(y + 2))\n    9*3**y\n    >>> expand_power_exp(x**(y + 2))\n    x**(y + 2)\n\n    If ``x = 0`` the value of the expression depends on the\n    value of ``y``; if the expression were expanded the result\n    would be 0. So expansion is only done if ``x != 0``:\n\n    >>> expand_power_exp(Symbol('x', zero=False)**(y + 2))\n    x**2*x**y\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "expand_power_base",
    "full_id": "sympy.core.function.expand_power_base",
    "type": "function",
    "description": "\n    Wrapper around expand that only uses the power_base hint.\n\n    A wrapper to expand(power_base=True) which separates a power with a base\n    that is a Mul into a product of powers, without performing any other\n    expansions, provided that assumptions about the power's base and exponent\n    allow.\n\n    deep=False (default is True) will only apply to the top-level expression.\n\n    force=True (default is False) will cause the expansion to ignore\n    assumptions about the base and exponent. When False, the expansion will\n    only happen if the base is non-negative or the exponent is an integer.\n\n    >>> from sympy.abc import x, y, z\n    >>> from sympy import expand_power_base, sin, cos, exp, Symbol\n\n    >>> (x*y)**2\n    x**2*y**2\n\n    >>> (2*x)**y\n    (2*x)**y\n    >>> expand_power_base(_)\n    2**y*x**y\n\n    >>> expand_power_base((x*y)**z)\n    (x*y)**z\n    >>> expand_power_base((x*y)**z, force=True)\n    x**z*y**z\n    >>> expand_power_base(sin((x*y)**z), deep=False)\n    sin((x*y)**z)\n    >>> expand_power_base(sin((x*y)**z), force=True)\n    sin(x**z*y**z)\n\n    >>> expand_power_base((2*sin(x))**y + (2*cos(x))**y)\n    2**y*sin(x)**y + 2**y*cos(x)**y\n\n    >>> expand_power_base((2*exp(y))**x)\n    2**x*exp(y)**x\n\n    >>> expand_power_base((2*cos(x))**y)\n    2**y*cos(x)**y\n\n    Notice that sums are left untouched. If this is not the desired behavior,\n    apply full ``expand()`` to the expression:\n\n    >>> expand_power_base(((x+y)*z)**2)\n    z**2*(x + y)**2\n    >>> (((x+y)*z)**2).expand()\n    x**2*z**2 + 2*x*y*z**2 + y**2*z**2\n\n    >>> expand_power_base((2*y)**(1+z))\n    2**(z + 1)*y**(z + 1)\n    >>> ((2*y)**(1+z)).expand()\n    2*2**z*y**(z + 1)\n\n    The power that is unexpanded can be expanded safely when\n    ``y != 0``, otherwise different values might be obtained for the expression:\n\n    >>> prev = _\n\n    If we indicate that ``y`` is positive but then replace it with\n    a value of 0 after expansion, the expression becomes 0:\n\n    >>> p = Symbol('p', positive=True)\n    >>> prev.subs(y, p).expand().subs(p, 0)\n    0\n\n    But if ``z = -1`` the expression would not be zero:\n\n    >>> prev.subs(y, 0).subs(z, -1)\n    1\n\n    See Also\n    ========\n\n    expand\n\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "nfloat",
    "full_id": "sympy.core.function.nfloat",
    "type": "function",
    "description": "Make all Rationals in expr Floats except those in exponents\n    (unless the exponents flag is set to True) and those in undefined\n    functions. When processing dictionaries, do not modify the keys\n    unless ``dkeys=True``.\n\n    Examples\n    ========\n\n    >>> from sympy import nfloat, cos, pi, sqrt\n    >>> from sympy.abc import x, y\n    >>> nfloat(x**4 + x/2 + cos(pi/3) + 1 + sqrt(y))\n    x**4 + 0.5*x + sqrt(y) + 1.5\n    >>> nfloat(x**4 + sqrt(y), exponent=True)\n    x**4.0 + y**0.5\n\n    Container types are not modified:\n\n    >>> type(nfloat((1, 2))) is tuple\n    True\n    ",
    "section": "function",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "evalf",
    "full_id": "sympy.core.evalf.EvalfMixin.evalf",
    "type": "method",
    "description": "\n        Evaluate the given formula to an accuracy of *n* digits.\n\n        Parameters\n        ==========\n\n        subs : dict, optional\n            Substitute numerical values for symbols, e.g.\n            ``subs={x:3, y:1+pi}``. The substitutions must be given as a\n            dictionary.\n\n        maxn : int, optional\n            Allow a maximum temporary working precision of maxn digits.\n\n        chop : bool or number, optional\n            Specifies how to replace tiny real or imaginary parts in\n            subresults by exact zeros.\n\n            When ``True`` the chop value defaults to standard precision.\n\n            Otherwise the chop value is used to determine the\n            magnitude of \"small\" for purposes of chopping.\n\n            >>> from sympy import N\n            >>> x = 1e-4\n            >>> N(x, chop=True)\n            0.000100000000000000\n            >>> N(x, chop=1e-5)\n            0.000100000000000000\n            >>> N(x, chop=1e-4)\n            0\n\n        strict : bool, optional\n            Raise ``PrecisionExhausted`` if any subresult fails to\n            evaluate to full accuracy, given the available maxprec.\n\n        quad : str, optional\n            Choose algorithm for numerical quadrature. By default,\n            tanh-sinh quadrature is used. For oscillatory\n            integrals on an infinite interval, try ``quad='osc'``.\n\n        verbose : bool, optional\n            Print debug information.\n\n        Notes\n        =====\n\n        When Floats are naively substituted into an expression,\n        precision errors may adversely affect the result. For example,\n        adding 1e16 (a Float) to 1 will truncate to 1e16; if 1e16 is\n        then subtracted, the result will be 0.\n        That is exactly what happens in the following:\n\n        >>> from sympy.abc import x, y, z\n        >>> values = {x: 1e16, y: 1, z: 1e16}\n        >>> (x + y - z).subs(values)\n        0\n\n        Using the subs argument for evalf is the accurate way to\n        evaluate such an expression:\n\n        >>> (x + y - z).evalf(subs=values)\n        1.00000000000000\n        ",
    "section": "evalf",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "N",
    "full_id": "sympy.core.evalf.N",
    "type": "function",
    "description": "\n    Calls x.evalf(n, \\*\\*options).\n\n    Explanations\n    ============\n\n    Both .n() and N() are equivalent to .evalf(); use the one that you like better.\n    See also the docstring of .evalf() for information on the options.\n\n    Examples\n    ========\n\n    >>> from sympy import Sum, oo, N\n    >>> from sympy.abc import k\n    >>> Sum(1/k**k, (k, 1, oo))\n    Sum(k**(-k), (k, 1, oo))\n    >>> N(_, 4)\n    1.291\n\n    ",
    "section": "evalf",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "index",
    "full_id": "sympy.core.containers.Tuple.index",
    "type": "method",
    "description": "Searches and returns the first index of the value.",
    "section": "containers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "kind",
    "full_id": "sympy.core.containers.Tuple.kind",
    "type": "property",
    "description": "\n        The kind of a Tuple instance.\n\n        The kind of a Tuple is always of :class:`TupleKind` but\n        parametrised by the number of elements and the kind of each element.\n\n        Examples\n        ========\n\n        >>> from sympy import Tuple, Matrix\n        >>> Tuple(1, 2).kind\n        TupleKind(NumberKind, NumberKind)\n        >>> Tuple(Matrix([1, 2]), 1).kind\n        TupleKind(MatrixKind(NumberKind), NumberKind)\n        >>> Tuple(1, 2).kind.element_kind\n        (NumberKind, NumberKind)\n\n        See Also\n        ========\n\n        sympy.matrices.kind.MatrixKind\n        sympy.core.kind.NumberKind\n        ",
    "section": "containers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "tuple_count",
    "full_id": "sympy.core.containers.Tuple.tuple_count",
    "type": "method",
    "description": "Return number of occurrences of value.",
    "section": "containers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "get",
    "full_id": "sympy.core.containers.Dict.get",
    "type": "method",
    "description": "Returns the value for key if the key is in the dictionary.",
    "section": "containers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "items",
    "full_id": "sympy.core.containers.Dict.items",
    "type": "method",
    "description": "Returns a set-like object providing a view on dict's items.",
    "section": "containers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "keys",
    "full_id": "sympy.core.containers.Dict.keys",
    "type": "method",
    "description": "Returns the list of the dict's keys.",
    "section": "containers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "values",
    "full_id": "sympy.core.containers.Dict.values",
    "type": "method",
    "description": "Returns the list of the dict's values.",
    "section": "containers",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "gcd_terms",
    "full_id": "sympy.core.exprtools.gcd_terms",
    "type": "function",
    "description": "Compute the GCD of ``terms`` and put them together.\n\n    Parameters\n    ==========\n\n    terms : Expr\n        Can be an expression or a non-Basic sequence of expressions\n        which will be handled as though they are terms from a sum.\n\n    isprimitive : bool, optional\n        If ``isprimitive`` is True the _gcd_terms will not run the primitive\n        method on the terms.\n\n    clear : bool, optional\n        It controls the removal of integers from the denominator of an Add\n        expression. When True (default), all numerical denominator will be cleared;\n        when False the denominators will be cleared only if all terms had numerical\n        denominators other than 1.\n\n    fraction : bool, optional\n        When True (default), will put the expression over a common\n        denominator.\n\n    Examples\n    ========\n\n    >>> from sympy import gcd_terms\n    >>> from sympy.abc import x, y\n\n    >>> gcd_terms((x + 1)**2*y + (x + 1)*y**2)\n    y*(x + 1)*(x + y + 1)\n    >>> gcd_terms(x/2 + 1)\n    (x + 2)/2\n    >>> gcd_terms(x/2 + 1, clear=False)\n    x/2 + 1\n    >>> gcd_terms(x/2 + y/2, clear=False)\n    (x + y)/2\n    >>> gcd_terms(x/2 + 1/x)\n    (x**2 + 2)/(2*x)\n    >>> gcd_terms(x/2 + 1/x, fraction=False)\n    (x + 2/x)/2\n    >>> gcd_terms(x/2 + 1/x, fraction=False, clear=False)\n    x/2 + 1/x\n\n    >>> gcd_terms(x/2/y + 1/x/y)\n    (x**2 + 2)/(2*x*y)\n    >>> gcd_terms(x/2/y + 1/x/y, clear=False)\n    (x**2/2 + 1)/(x*y)\n    >>> gcd_terms(x/2/y + 1/x/y, clear=False, fraction=False)\n    (x/2 + 1/x)/y\n\n    The ``clear`` flag was ignored in this case because the returned\n    expression was a rational expression, not a simple sum.\n\n    See Also\n    ========\n\n    factor_terms, sympy.polys.polytools.terms_gcd\n\n    ",
    "section": "exprtools",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "factor_terms",
    "full_id": "sympy.core.exprtools.factor_terms",
    "type": "function",
    "description": "Remove common factors from terms in all arguments without\n    changing the underlying structure of the expr. No expansion or\n    simplification (and no processing of non-commutatives) is performed.\n\n    Parameters\n    ==========\n\n    radical: bool, optional\n        If radical=True then a radical common to all terms will be factored\n        out of any Add sub-expressions of the expr.\n\n    clear : bool, optional\n        If clear=False (default) then coefficients will not be separated\n        from a single Add if they can be distributed to leave one or more\n        terms with integer coefficients.\n\n    fraction : bool, optional\n        If fraction=True (default is False) then a common denominator will be\n        constructed for the expression.\n\n    sign : bool, optional\n        If sign=True (default) then even if the only factor in common is a -1,\n        it will be factored out of the expression.\n\n    Examples\n    ========\n\n    >>> from sympy import factor_terms, Symbol\n    >>> from sympy.abc import x, y\n    >>> factor_terms(x + x*(2 + 4*y)**3)\n    x*(8*(2*y + 1)**3 + 1)\n    >>> A = Symbol('A', commutative=False)\n    >>> factor_terms(x*A + x*A + x*y*A)\n    x*(y*A + 2*A)\n\n    When ``clear`` is False, a rational will only be factored out of an\n    Add expression if all terms of the Add have coefficients that are\n    fractions:\n\n    >>> factor_terms(x/2 + 1, clear=False)\n    x/2 + 1\n    >>> factor_terms(x/2 + 1, clear=True)\n    (x + 2)/2\n\n    If a -1 is all that can be factored out, to *not* factor it out, the\n    flag ``sign`` must be False:\n\n    >>> factor_terms(-x - y)\n    -(x + y)\n    >>> factor_terms(-x - y, sign=False)\n    -x - y\n    >>> factor_terms(-2*x - 2*y, sign=False)\n    -2*(x + y)\n\n    See Also\n    ========\n\n    gcd_terms, sympy.polys.polytools.terms_gcd\n\n    ",
    "section": "exprtools",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "default_sort_key",
    "full_id": "sympy.core.sorting.default_sort_key",
    "type": "function",
    "description": "Return a key that can be used for sorting.\n\n    The key has the structure:\n\n    (class_key, (len(args), args), exponent.sort_key(), coefficient)\n\n    This key is supplied by the sort_key routine of Basic objects when\n    ``item`` is a Basic object or an object (other than a string) that\n    sympifies to a Basic object. Otherwise, this function produces the\n    key.\n\n    The ``order`` argument is passed along to the sort_key routine and is\n    used to determine how the terms *within* an expression are ordered.\n    (See examples below) ``order`` options are: 'lex', 'grlex', 'grevlex',\n    and reversed values of the same (e.g. 'rev-lex'). The default order\n    value is None (which translates to 'lex').\n\n    Examples\n    ========\n\n    >>> from sympy import S, I, default_sort_key, sin, cos, sqrt\n    >>> from sympy.core.function import UndefinedFunction\n    >>> from sympy.abc import x\n\n    The following are equivalent ways of getting the key for an object:\n\n    >>> x.sort_key() == default_sort_key(x)\n    True\n\n    Here are some examples of the key that is produced:\n\n    >>> default_sort_key(UndefinedFunction('f'))\n    ((0, 0, 'UndefinedFunction'), (1, ('f',)), ((1, 0, 'Number'),\n        (0, ()), (), 1), 1)\n    >>> default_sort_key('1')\n    ((0, 0, 'str'), (1, ('1',)), ((1, 0, 'Number'), (0, ()), (), 1), 1)\n    >>> default_sort_key(S.One)\n    ((1, 0, 'Number'), (0, ()), (), 1)\n    >>> default_sort_key(2)\n    ((1, 0, 'Number'), (0, ()), (), 2)\n\n    While sort_key is a method only defined for SymPy objects,\n    default_sort_key will accept anything as an argument so it is\n    more robust as a sorting key. For the following, using key=\n    lambda i: i.sort_key() would fail because 2 does not have a sort_key\n    method; that's why default_sort_key is used. Note, that it also\n    handles sympification of non-string items likes ints:\n\n    >>> a = [2, I, -I]\n    >>> sorted(a, key=default_sort_key)\n    [2, -I, I]\n\n    The returned key can be used anywhere that a key can be specified for\n    a function, e.g. sort, min, max, etc...:\n\n    >>> a.sort(key=default_sort_key); a[0]\n    2\n    >>> min(a, key=default_sort_key)\n    2\n\n    Notes\n    =====\n\n    The key returned is useful for getting items into a canonical order\n    that will be the same across platforms. It is not directly useful for\n    sorting lists of expressions:\n\n    >>> a, b = x, 1/x\n\n    Since ``a`` has only 1 term, its value of sort_key is unaffected by\n    ``order``:\n\n    >>> a.sort_key() == a.sort_key('rev-lex')\n    True\n\n    If ``a`` and ``b`` are combined then the key will differ because there\n    are terms that can be ordered:\n\n    >>> eq = a + b\n    >>> eq.sort_key() == eq.sort_key('rev-lex')\n    False\n    >>> eq.as_ordered_terms()\n    [x, 1/x]\n    >>> eq.as_ordered_terms('rev-lex')\n    [1/x, x]\n\n    But since the keys for each of these terms are independent of ``order``'s\n    value, they do not sort differently when they appear separately in a list:\n\n    >>> sorted(eq.args, key=default_sort_key)\n    [1/x, x]\n    >>> sorted(eq.args, key=lambda i: default_sort_key(i, order='rev-lex'))\n    [1/x, x]\n\n    The order of terms obtained when using these keys is the order that would\n    be obtained if those terms were *factors* in a product.\n\n    Although it is useful for quickly putting expressions in canonical order,\n    it does not sort expressions based on their complexity defined by the\n    number of operations, power of variables and others:\n\n    >>> sorted([sin(x)*cos(x), sin(x)], key=default_sort_key)\n    [sin(x)*cos(x), sin(x)]\n    >>> sorted([x, x**2, sqrt(x), x**3], key=default_sort_key)\n    [sqrt(x), x, x**2, x**3]\n\n    See Also\n    ========\n\n    ordered, sympy.core.expr.Expr.as_ordered_factors, sympy.core.expr.Expr.as_ordered_terms\n\n    ",
    "section": "Sorting",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "ordered",
    "full_id": "sympy.core.sorting.ordered",
    "type": "function",
    "description": "Return an iterator of the seq where keys are used to break ties\n    in a conservative fashion: if, after applying a key, there are no\n    ties then no other keys will be computed.\n\n    Two default keys will be applied if 1) keys are not provided or\n    2) the given keys do not resolve all ties (but only if ``default``\n    is True). The two keys are ``_nodes`` (which places smaller\n    expressions before large) and ``default_sort_key`` which (if the\n    ``sort_key`` for an object is defined properly) should resolve\n    any ties. This strategy is similar to sorting done by\n    ``Basic.compare``, but differs in that ``ordered`` never makes a\n    decision based on an objects name.\n\n    If ``warn`` is True then an error will be raised if there were no\n    keys remaining to break ties. This can be used if it was expected that\n    there should be no ties between items that are not identical.\n\n    Examples\n    ========\n\n    >>> from sympy import ordered, count_ops\n    >>> from sympy.abc import x, y\n\n    The count_ops is not sufficient to break ties in this list and the first\n    two items appear in their original order (i.e. the sorting is stable):\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3],\n    ...    count_ops, default=False, warn=False))\n    ...\n    [y + 2, x + 2, x**2 + y + 3]\n\n    The default_sort_key allows the tie to be broken:\n\n    >>> list(ordered([y + 2, x + 2, x**2 + y + 3]))\n    ...\n    [x + 2, y + 2, x**2 + y + 3]\n\n    Here, sequences are sorted by length, then sum:\n\n    >>> seq, keys = [[[1, 2, 1], [0, 3, 1], [1, 1, 3], [2], [1]], [\n    ...    lambda x: len(x),\n    ...    lambda x: sum(x)]]\n    ...\n    >>> list(ordered(seq, keys, default=False, warn=False))\n    [[1], [2], [1, 2, 1], [0, 3, 1], [1, 1, 3]]\n\n    If ``warn`` is True, an error will be raised if there were not\n    enough keys to break ties:\n\n    >>> list(ordered(seq, keys, default=False, warn=True))\n    Traceback (most recent call last):\n    ...\n    ValueError: not enough keys to break ties\n\n\n    Notes\n    =====\n\n    The decorated sort is one of the fastest ways to sort a sequence for\n    which special item comparison is desired: the sequence is decorated,\n    sorted on the basis of the decoration (e.g. making all letters lower\n    case) and then undecorated. If one wants to break ties for items that\n    have the same decorated value, a second key can be used. But if the\n    second key is expensive to compute then it is inefficient to decorate\n    all items with both keys: only those items having identical first key\n    values need to be decorated. This function applies keys successively\n    only when needed to break ties. By yielding an iterator, use of the\n    tie-breaker is delayed as long as possible.\n\n    This function is best used in cases when use of the first key is\n    expected to be a good hashing function; if there are no unique hashes\n    from application of a key, then that key should not have been used. The\n    exception, however, is that even if there are many collisions, if the\n    first group is small and one does not need to process all items in the\n    list then time will not be wasted sorting what one was not interested\n    in. For example, if one were looking for the minimum in a list and\n    there were several criteria used to define the sort order, then this\n    function would be good at returning that quickly if the first group\n    of candidates is small relative to the number of items being processed.\n\n    ",
    "section": "Sorting",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "random_complex_number",
    "full_id": "sympy.core.random.random_complex_number",
    "type": "function",
    "description": "\n    Return a random complex number.\n\n    To reduce chance of hitting branch cuts or anything, we guarantee\n    b <= Im z <= d, a <= Re z <= c\n\n    When rational is True, a rational approximation to a random number\n    is obtained within specified tolerance, if any.\n    ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "verify_numerically",
    "full_id": "sympy.core.random.verify_numerically",
    "type": "function",
    "description": "\n    Test numerically that f and g agree when evaluated in the argument z.\n\n    If z is None, all symbols will be tested. This routine does not test\n    whether there are Floats present with precision higher than 15 digits\n    so if there are, your results may not be what you expect due to round-\n    off errors.\n\n    Examples\n    ========\n\n    >>> from sympy import sin, cos\n    >>> from sympy.abc import x\n    >>> from sympy.core.random import verify_numerically as tn\n    >>> tn(sin(x)**2 + cos(x)**2, 1, x)\n    True\n    ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "test_derivative_numerically",
    "full_id": "sympy.core.random.test_derivative_numerically",
    "type": "function",
    "description": "\n    Test numerically that the symbolically computed derivative of f\n    with respect to z is correct.\n\n    This routine does not test whether there are Floats present with\n    precision higher than 15 digits so if there are, your results may\n    not be what you expect due to round-off errors.\n\n    Examples\n    ========\n\n    >>> from sympy import sin\n    >>> from sympy.abc import x\n    >>> from sympy.core.random import test_derivative_numerically as td\n    >>> td(sin(x), x)\n    True\n    ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "_randrange",
    "full_id": "sympy.core.random._randrange",
    "type": "function",
    "description": "Return a randrange generator.\n\n    ``seed`` can be\n\n    * None - return randomly seeded generator\n    * int - return a generator seeded with the int\n    * list - the values to be returned will be taken from the list\n      in the order given; the provided list is not modified.\n\n    Examples\n    ========\n\n    >>> from sympy.core.random import _randrange\n    >>> rr = _randrange()\n    >>> rr(1000) # doctest: +SKIP\n    999\n    >>> rr = _randrange(3)\n    >>> rr(1000) # doctest: +SKIP\n    238\n    >>> rr = _randrange([0, 5, 1, 3, 4])\n    >>> rr(3), rr(3)\n    (0, 1)\n    ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "_randint",
    "full_id": "sympy.core.random._randint",
    "type": "function",
    "description": "Return a randint generator.\n\n    ``seed`` can be\n\n    * None - return randomly seeded generator\n    * int - return a generator seeded with the int\n    * list - the values to be returned will be taken from the list\n      in the order given; the provided list is not modified.\n\n    Examples\n    ========\n\n    >>> from sympy.core.random import _randint\n    >>> ri = _randint()\n    >>> ri(1, 1000) # doctest: +SKIP\n    999\n    >>> ri = _randint(3)\n    >>> ri(1, 1000) # doctest: +SKIP\n    238\n    >>> ri = _randint([0, 5, 1, 2, 4])\n    >>> ri(1, 3), ri(1, 3)\n    (1, 2)\n    ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "bottom_up",
    "full_id": "sympy.core.traversal.bottom_up",
    "type": "function",
    "description": "Apply ``F`` to all expressions in an expression tree from the\n    bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;\n    if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.\n    ",
    "section": "Traversal",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "postorder_traversal",
    "full_id": "sympy.core.traversal.postorder_traversal",
    "type": "function",
    "description": "\n    Do a postorder traversal of a tree.\n\n    This generator recursively yields nodes that it has visited in a postorder\n    fashion. That is, it descends through the tree depth-first to yield all of\n    a node's children's postorder traversal before yielding the node itself.\n\n    Parameters\n    ==========\n\n    node : SymPy expression\n        The expression to traverse.\n    keys : (default None) sort key(s)\n        The key(s) used to sort args of Basic objects. When None, args of Basic\n        objects are processed in arbitrary order. If key is defined, it will\n        be passed along to ordered() as the only key(s) to use to sort the\n        arguments; if ``key`` is simply True then the default keys of\n        ``ordered`` will be used (node count and default_sort_key).\n\n    Yields\n    ======\n    subtree : SymPy expression\n        All of the subtrees in the tree.\n\n    Examples\n    ========\n\n    >>> from sympy import postorder_traversal\n    >>> from sympy.abc import w, x, y, z\n\n    The nodes are returned in the order that they are encountered unless key\n    is given; simply passing key=True will guarantee that the traversal is\n    unique.\n\n    >>> list(postorder_traversal(w + (x + y)*z)) # doctest: +SKIP\n    [z, y, x, x + y, z*(x + y), w, w + z*(x + y)]\n    >>> list(postorder_traversal(w + (x + y)*z, keys=True))\n    [w, z, x, y, x + y, z*(x + y), w + z*(x + y)]\n\n\n    ",
    "section": "Traversal",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "preorder_traversal",
    "full_id": "sympy.core.traversal.preorder_traversal",
    "type": "function",
    "description": "\n    Do a pre-order traversal of a tree.\n\n    This iterator recursively yields nodes that it has visited in a pre-order\n    fashion. That is, it yields the current node then descends through the\n    tree breadth-first to yield all of a node's children's pre-order\n    traversal.\n\n\n    For an expression, the order of the traversal depends on the order of\n    .args, which in many cases can be arbitrary.\n\n    Parameters\n    ==========\n    node : SymPy expression\n        The expression to traverse.\n    keys : (default None) sort key(s)\n        The key(s) used to sort args of Basic objects. When None, args of Basic\n        objects are processed in arbitrary order. If key is defined, it will\n        be passed along to ordered() as the only key(s) to use to sort the\n        arguments; if ``key`` is simply True then the default keys of ordered\n        will be used.\n\n    Yields\n    ======\n    subtree : SymPy expression\n        All of the subtrees in the tree.\n\n    Examples\n    ========\n\n    >>> from sympy import preorder_traversal, symbols\n    >>> x, y, z = symbols('x y z')\n\n    The nodes are returned in the order that they are encountered unless key\n    is given; simply passing key=True will guarantee that the traversal is\n    unique.\n\n    >>> list(preorder_traversal((x + y)*z, keys=None)) # doctest: +SKIP\n    [z*(x + y), z, x + y, y, x]\n    >>> list(preorder_traversal((x + y)*z, keys=True))\n    [z*(x + y), z, x + y, x, y]\n\n    ",
    "section": "Traversal",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "use",
    "full_id": "sympy.core.traversal.use",
    "type": "function",
    "description": "\n    Use ``func`` to transform ``expr`` at the given level.\n\n    Examples\n    ========\n\n    >>> from sympy import use, expand\n    >>> from sympy.abc import x, y\n\n    >>> f = (x + y)**2*x + 1\n\n    >>> use(f, expand, level=2)\n    x*(x**2 + 2*x*y + y**2) + 1\n    >>> expand(f)\n    x**3 + 2*x**2*y + x*y**2 + 1\n\n    ",
    "section": "Traversal",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "walk",
    "full_id": "sympy.core.traversal.walk",
    "type": "function",
    "description": "Iterate through the args that are the given types (target) and\n    return a list of the args that were traversed; arguments\n    that are not of the specified types are not traversed.\n\n    Examples\n    ========\n\n    >>> from sympy.core.traversal import walk\n    >>> from sympy import Min, Max\n    >>> from sympy.abc import x, y, z\n    >>> list(walk(Min(x, Max(y, Min(1, z))), Min))\n    [Min(x, Max(y, Min(1, z)))]\n    >>> list(walk(Min(x, Max(y, Min(1, z))), Min, Max))\n    [Min(x, Max(y, Min(1, z))), Max(y, Min(1, z)), Min(1, z)]\n\n    See Also\n    ========\n\n    bottom_up\n    ",
    "section": "Traversal",
    "url": "https://docs.sympy.org/latest/modules/core.html"
  },
  {
    "name": "fft",
    "full_id": "sympy.discrete.transforms.fft",
    "type": "function",
    "description": "\n    Performs the Discrete Fourier Transform (**DFT**) in the complex domain.\n\n    The sequence is automatically padded to the right with zeros, as the\n    *radix-2 FFT* requires the number of sample points to be a power of 2.\n\n    This method should be used with default arguments only for short sequences\n    as the complexity of expressions increases with the size of the sequence.\n\n    Parameters\n    ==========\n\n    seq : iterable\n        The sequence on which **DFT** is to be applied.\n    dps : Integer\n        Specifies the number of decimal digits for precision.\n\n    Examples\n    ========\n\n    >>> from sympy import fft, ifft\n\n    >>> fft([1, 2, 3, 4])\n    [10, -2 - 2*I, -2, -2 + 2*I]\n    >>> ifft(_)\n    [1, 2, 3, 4]\n\n    >>> ifft([1, 2, 3, 4])\n    [5/2, -1/2 + I/2, -1/2, -1/2 - I/2]\n    >>> fft(_)\n    [1, 2, 3, 4]\n\n    >>> ifft([1, 7, 3, 4], dps=15)\n    [3.75, -0.5 - 0.75*I, -1.75, -0.5 + 0.75*I]\n    >>> fft(_)\n    [1.0, 7.0, 3.0, 4.0]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n    .. [2] https://mathworld.wolfram.com/FastFourierTransform.html\n\n    ",
    "section": "Fast Fourier Transform",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "ntt",
    "full_id": "sympy.discrete.transforms.ntt",
    "type": "function",
    "description": "\n    Performs the Number Theoretic Transform (**NTT**), which specializes the\n    Discrete Fourier Transform (**DFT**) over quotient ring `Z/pZ` for prime\n    `p` instead of complex numbers `C`.\n\n    The sequence is automatically padded to the right with zeros, as the\n    *radix-2 NTT* requires the number of sample points to be a power of 2.\n\n    Parameters\n    ==========\n\n    seq : iterable\n        The sequence on which **DFT** is to be applied.\n    prime : Integer\n        Prime modulus of the form `(m 2^k + 1)` to be used for performing\n        **NTT** on the sequence.\n\n    Examples\n    ========\n\n    >>> from sympy import ntt, intt\n    >>> ntt([1, 2, 3, 4], prime=3*2**8 + 1)\n    [10, 643, 767, 122]\n    >>> intt(_, 3*2**8 + 1)\n    [1, 2, 3, 4]\n    >>> intt([1, 2, 3, 4], prime=3*2**8 + 1)\n    [387, 415, 384, 353]\n    >>> ntt(_, prime=3*2**8 + 1)\n    [1, 2, 3, 4]\n\n    References\n    ==========\n\n    .. [1] http://www.apfloat.org/ntt.html\n    .. [2] https://mathworld.wolfram.com/NumberTheoreticTransform.html\n    .. [3] https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general%29\n\n    ",
    "section": "Number Theoretic Transform",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "fwht",
    "full_id": "sympy.discrete.transforms.fwht",
    "type": "function",
    "description": "\n    Performs the Walsh Hadamard Transform (**WHT**), and uses Hadamard\n    ordering for the sequence.\n\n    The sequence is automatically padded to the right with zeros, as the\n    *radix-2 FWHT* requires the number of sample points to be a power of 2.\n\n    Parameters\n    ==========\n\n    seq : iterable\n        The sequence on which WHT is to be applied.\n\n    Examples\n    ========\n\n    >>> from sympy import fwht, ifwht\n    >>> fwht([4, 2, 2, 0, 0, 2, -2, 0])\n    [8, 0, 8, 0, 8, 8, 0, 0]\n    >>> ifwht(_)\n    [4, 2, 2, 0, 0, 2, -2, 0]\n\n    >>> ifwht([19, -1, 11, -9, -7, 13, -15, 5])\n    [2, 0, 4, 0, 3, 10, 0, 0]\n    >>> fwht(_)\n    [19, -1, 11, -9, -7, 13, -15, 5]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Hadamard_transform\n    .. [2] https://en.wikipedia.org/wiki/Fast_Walsh%E2%80%93Hadamard_transform\n\n    ",
    "section": "Fast Walsh Hadamard Transform",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "mobius_transform",
    "full_id": "sympy.discrete.transforms.mobius_transform",
    "type": "function",
    "description": "\n    Performs the Mobius Transform for subset lattice with indices of\n    sequence as bitmasks.\n\n    The indices of each argument, considered as bit strings, correspond\n    to subsets of a finite set.\n\n    The sequence is automatically padded to the right with zeros, as the\n    definition of subset/superset based on bitmasks (indices) requires\n    the size of sequence to be a power of 2.\n\n    Parameters\n    ==========\n\n    seq : iterable\n        The sequence on which Mobius Transform is to be applied.\n    subset : bool\n        Specifies if Mobius Transform is applied by enumerating subsets\n        or supersets of the given set.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy import mobius_transform, inverse_mobius_transform\n    >>> x, y, z = symbols('x y z')\n\n    >>> mobius_transform([x, y, z])\n    [x, x + y, x + z, x + y + z]\n    >>> inverse_mobius_transform(_)\n    [x, y, z, 0]\n\n    >>> mobius_transform([x, y, z], subset=False)\n    [x + y + z, y, z, 0]\n    >>> inverse_mobius_transform(_, subset=False)\n    [x, y, z, 0]\n\n    >>> mobius_transform([1, 2, 3, 4])\n    [1, 3, 4, 10]\n    >>> inverse_mobius_transform(_)\n    [1, 2, 3, 4]\n    >>> mobius_transform([1, 2, 3, 4], subset=False)\n    [10, 6, 7, 4]\n    >>> inverse_mobius_transform(_, subset=False)\n    [1, 2, 3, 4]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/M%C3%B6bius_inversion_formula\n    .. [2] https://people.csail.mit.edu/rrw/presentations/subset-conv.pdf\n    .. [3] https://arxiv.org/pdf/1211.0189.pdf\n\n    ",
    "section": "M\u00f6bius Transform",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "convolution",
    "full_id": "sympy.discrete.convolutions.convolution",
    "type": "function",
    "description": "\n    Performs convolution by determining the type of desired\n    convolution using hints.\n\n    Exactly one of ``dps``, ``prime``, ``dyadic``, ``subset`` arguments\n    should be specified explicitly for identifying the type of convolution,\n    and the argument ``cycle`` can be specified optionally.\n\n    For the default arguments, linear convolution is performed using **FFT**.\n\n    Parameters\n    ==========\n\n    a, b : iterables\n        The sequences for which convolution is performed.\n    cycle : Integer\n        Specifies the length for doing cyclic convolution.\n    dps : Integer\n        Specifies the number of decimal digits for precision for\n        performing **FFT** on the sequence.\n    prime : Integer\n        Prime modulus of the form `(m 2^k + 1)` to be used for\n        performing **NTT** on the sequence.\n    dyadic : bool\n        Identifies the convolution type as dyadic (*bitwise-XOR*)\n        convolution, which is performed using **FWHT**.\n    subset : bool\n        Identifies the convolution type as subset convolution.\n\n    Examples\n    ========\n\n    >>> from sympy import convolution, symbols, S, I\n    >>> u, v, w, x, y, z = symbols('u v w x y z')\n\n    >>> convolution([1 + 2*I, 4 + 3*I], [S(5)/4, 6], dps=3)\n    [1.25 + 2.5*I, 11.0 + 15.8*I, 24.0 + 18.0*I]\n    >>> convolution([1, 2, 3], [4, 5, 6], cycle=3)\n    [31, 31, 28]\n\n    >>> convolution([111, 777], [888, 444], prime=19*2**10 + 1)\n    [1283, 19351, 14219]\n    >>> convolution([111, 777], [888, 444], prime=19*2**10 + 1, cycle=2)\n    [15502, 19351]\n\n    >>> convolution([u, v], [x, y, z], dyadic=True)\n    [u*x + v*y, u*y + v*x, u*z, v*z]\n    >>> convolution([u, v], [x, y, z], dyadic=True, cycle=2)\n    [u*x + u*z + v*y, u*y + v*x + v*z]\n\n    >>> convolution([u, v, w], [x, y, z], subset=True)\n    [u*x, u*y + v*x, u*z + w*x, v*z + w*y]\n    >>> convolution([u, v, w], [x, y, z], subset=True, cycle=3)\n    [u*x + v*z + w*y, u*y + v*x, u*z + w*x]\n\n    ",
    "section": "Convolution",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "convolution_fft",
    "full_id": "sympy.discrete.convolutions.convolution_fft",
    "type": "function",
    "description": "\n    Performs linear convolution using Fast Fourier Transform.\n\n    Parameters\n    ==========\n\n    a, b : iterables\n        The sequences for which convolution is performed.\n    dps : Integer\n        Specifies the number of decimal digits for precision.\n\n    Examples\n    ========\n\n    >>> from sympy import S, I\n    >>> from sympy.discrete.convolutions import convolution_fft\n\n    >>> convolution_fft([2, 3], [4, 5])\n    [8, 22, 15]\n    >>> convolution_fft([2, 5], [6, 7, 3])\n    [12, 44, 41, 15]\n    >>> convolution_fft([1 + 2*I, 4 + 3*I], [S(5)/4, 6])\n    [5/4 + 5*I/2, 11 + 63*I/4, 24 + 18*I]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Convolution_theorem\n    .. [2] https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general%29\n\n    ",
    "section": "Convolution using Fast Fourier Transform",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "convolution_ntt",
    "full_id": "sympy.discrete.convolutions.convolution_ntt",
    "type": "function",
    "description": "\n    Performs linear convolution using Number Theoretic Transform.\n\n    Parameters\n    ==========\n\n    a, b : iterables\n        The sequences for which convolution is performed.\n    prime : Integer\n        Prime modulus of the form `(m 2^k + 1)` to be used for performing\n        **NTT** on the sequence.\n\n    Examples\n    ========\n\n    >>> from sympy.discrete.convolutions import convolution_ntt\n    >>> convolution_ntt([2, 3], [4, 5], prime=19*2**10 + 1)\n    [8, 22, 15]\n    >>> convolution_ntt([2, 5], [6, 7, 3], prime=19*2**10 + 1)\n    [12, 44, 41, 15]\n    >>> convolution_ntt([333, 555], [222, 666], prime=19*2**10 + 1)\n    [15555, 14219, 19404]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Convolution_theorem\n    .. [2] https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general%29\n\n    ",
    "section": "Convolution using Number Theoretic Transform",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "convolution_fwht",
    "full_id": "sympy.discrete.convolutions.convolution_fwht",
    "type": "function",
    "description": "\n    Performs dyadic (*bitwise-XOR*) convolution using Fast Walsh Hadamard\n    Transform.\n\n    The convolution is automatically padded to the right with zeros, as the\n    *radix-2 FWHT* requires the number of sample points to be a power of 2.\n\n    Parameters\n    ==========\n\n    a, b : iterables\n        The sequences for which convolution is performed.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, S, I\n    >>> from sympy.discrete.convolutions import convolution_fwht\n\n    >>> u, v, x, y = symbols('u v x y')\n    >>> convolution_fwht([u, v], [x, y])\n    [u*x + v*y, u*y + v*x]\n\n    >>> convolution_fwht([2, 3], [4, 5])\n    [23, 22]\n    >>> convolution_fwht([2, 5 + 4*I, 7], [6*I, 7, 3 + 4*I])\n    [56 + 68*I, -10 + 30*I, 6 + 50*I, 48 + 32*I]\n\n    >>> convolution_fwht([S(33)/7, S(55)/6, S(7)/4], [S(2)/3, 5])\n    [2057/42, 1870/63, 7/6, 35/4]\n\n    References\n    ==========\n\n    .. [1] https://www.radioeng.cz/fulltexts/2002/02_03_40_42.pdf\n    .. [2] https://en.wikipedia.org/wiki/Hadamard_transform\n\n    ",
    "section": "Convolution using Fast Walsh Hadamard Transform",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "convolution_subset",
    "full_id": "sympy.discrete.convolutions.convolution_subset",
    "type": "function",
    "description": "\n    Performs Subset Convolution of given sequences.\n\n    The indices of each argument, considered as bit strings, correspond to\n    subsets of a finite set.\n\n    The sequence is automatically padded to the right with zeros, as the\n    definition of subset based on bitmasks (indices) requires the size of\n    sequence to be a power of 2.\n\n    Parameters\n    ==========\n\n    a, b : iterables\n        The sequences for which convolution is performed.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, S\n    >>> from sympy.discrete.convolutions import convolution_subset\n    >>> u, v, x, y, z = symbols('u v x y z')\n\n    >>> convolution_subset([u, v], [x, y])\n    [u*x, u*y + v*x]\n    >>> convolution_subset([u, v, x], [y, z])\n    [u*y, u*z + v*y, x*y, x*z]\n\n    >>> convolution_subset([1, S(2)/3], [3, 4])\n    [3, 6]\n    >>> convolution_subset([1, 3, S(5)/7], [7])\n    [7, 21, 5, 0]\n\n    References\n    ==========\n\n    .. [1] https://people.csail.mit.edu/rrw/presentations/subset-conv.pdf\n\n    ",
    "section": "Subset Convolution",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "covering_product",
    "full_id": "sympy.discrete.convolutions.covering_product",
    "type": "function",
    "description": "\n    Returns the covering product of given sequences.\n\n    The indices of each argument, considered as bit strings, correspond to\n    subsets of a finite set.\n\n    The covering product of given sequences is a sequence which contains\n    the sum of products of the elements of the given sequences grouped by\n    the *bitwise-OR* of the corresponding indices.\n\n    The sequence is automatically padded to the right with zeros, as the\n    definition of subset based on bitmasks (indices) requires the size of\n    sequence to be a power of 2.\n\n    Parameters\n    ==========\n\n    a, b : iterables\n        The sequences for which covering product is to be obtained.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, S, I, covering_product\n    >>> u, v, x, y, z = symbols('u v x y z')\n\n    >>> covering_product([u, v], [x, y])\n    [u*x, u*y + v*x + v*y]\n    >>> covering_product([u, v, x], [y, z])\n    [u*y, u*z + v*y + v*z, x*y, x*z]\n\n    >>> covering_product([1, S(2)/3], [3, 4 + 5*I])\n    [3, 26/3 + 25*I/3]\n    >>> covering_product([1, 3, S(5)/7], [7, 8])\n    [7, 53, 5, 40/7]\n\n    References\n    ==========\n\n    .. [1] https://people.csail.mit.edu/rrw/presentations/subset-conv.pdf\n\n    ",
    "section": "Covering Product",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "intersecting_product",
    "full_id": "sympy.discrete.convolutions.intersecting_product",
    "type": "function",
    "description": "\n    Returns the intersecting product of given sequences.\n\n    The indices of each argument, considered as bit strings, correspond to\n    subsets of a finite set.\n\n    The intersecting product of given sequences is the sequence which\n    contains the sum of products of the elements of the given sequences\n    grouped by the *bitwise-AND* of the corresponding indices.\n\n    The sequence is automatically padded to the right with zeros, as the\n    definition of subset based on bitmasks (indices) requires the size of\n    sequence to be a power of 2.\n\n    Parameters\n    ==========\n\n    a, b : iterables\n        The sequences for which intersecting product is to be obtained.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, S, I, intersecting_product\n    >>> u, v, x, y, z = symbols('u v x y z')\n\n    >>> intersecting_product([u, v], [x, y])\n    [u*x + u*y + v*x, v*y]\n    >>> intersecting_product([u, v, x], [y, z])\n    [u*y + u*z + v*y + x*y + x*z, v*z, 0, 0]\n\n    >>> intersecting_product([1, S(2)/3], [3, 4 + 5*I])\n    [9 + 5*I, 8/3 + 10*I/3]\n    >>> intersecting_product([1, 3, S(5)/7], [7, 8])\n    [327/7, 24, 0, 0]\n\n    References\n    ==========\n\n    .. [1] https://people.csail.mit.edu/rrw/presentations/subset-conv.pdf\n\n    ",
    "section": "Intersecting Product",
    "url": "https://docs.sympy.org/latest/modules/discrete.html"
  },
  {
    "name": "replace_in_Add",
    "full_id": "sympy.codegen.rewriting.FuncMinusOneOptim.replace_in_Add",
    "type": "method",
    "description": "passed as second argument to Basic.replace(...)",
    "section": "Classes and functions for rewriting expressions (sympy.codegen.rewriting)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "create_expand_pow_optimization",
    "full_id": "sympy.codegen.rewriting.create_expand_pow_optimization",
    "type": "function",
    "description": "Creates an instance of :class:`ReplaceOptim` for expanding ``Pow``.\n\n    Explanation\n    ===========\n\n    The requirements for expansions are that the base needs to be a symbol\n    and the exponent needs to be an Integer (and be less than or equal to\n    ``limit``).\n\n    Parameters\n    ==========\n\n    limit : int\n         The highest power which is expanded into multiplication.\n    base_req : function returning bool\n         Requirement on base for expansion to happen, default is to return\n         the ``is_symbol`` attribute of the base.\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, sin\n    >>> from sympy.codegen.rewriting import create_expand_pow_optimization\n    >>> x = Symbol('x')\n    >>> expand_opt = create_expand_pow_optimization(3)\n    >>> expand_opt(x**5 + x**3)\n    x**5 + x*x*x\n    >>> expand_opt(x**5 + x**3 + sin(x)**3)\n    x**5 + sin(x)**3 + x*x*x\n    >>> opt2 = create_expand_pow_optimization(3, base_req=lambda b: not b.is_Function)\n    >>> opt2((x+1)**2 + sin(x)**2)\n    sin(x)**2 + (x + 1)*(x + 1)\n\n    ",
    "section": "Classes and functions for rewriting expressions (sympy.codegen.rewriting)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "optimize",
    "full_id": "sympy.codegen.rewriting.optimize",
    "type": "function",
    "description": "Apply optimizations to an expression.\n\n    Parameters\n    ==========\n\n    expr : expression\n    optimizations : iterable of ``Optimization`` instances\n        The optimizations will be sorted with respect to ``priority`` (highest first).\n\n    Examples\n    ========\n\n    >>> from sympy import log, Symbol\n    >>> from sympy.codegen.rewriting import optims_c99, optimize\n    >>> x = Symbol('x')\n    >>> optimize(log(x+3)/log(2) + log(x**2 + 1), optims_c99)\n    log1p(x**2) + log2(x + 3)\n\n    ",
    "section": "Classes and functions for rewriting expressions (sympy.codegen.rewriting)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "cse",
    "full_id": "sympy.codegen.ast.CodeBlock.cse",
    "type": "method",
    "description": "\n        Return a new code block with common subexpressions eliminated.\n\n        Explanation\n        ===========\n\n        See the docstring of :func:`sympy.simplify.cse_main.cse` for more\n        information.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, sin\n        >>> from sympy.codegen.ast import CodeBlock, Assignment\n        >>> x, y, z = symbols('x y z')\n\n        >>> c = CodeBlock(\n        ...     Assignment(x, 1),\n        ...     Assignment(y, sin(x) + 1),\n        ...     Assignment(z, sin(x) - 1),\n        ... )\n        ...\n        >>> c.cse()\n        CodeBlock(\n            Assignment(x, 1),\n            Assignment(x0, sin(x)),\n            Assignment(y, x0 + 1),\n            Assignment(z, x0 - 1)\n        )\n\n        ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "topological_sort",
    "full_id": "sympy.codegen.ast.CodeBlock.topological_sort",
    "type": "method",
    "description": "\n        Return a CodeBlock with topologically sorted assignments so that\n        variables are assigned before they are used.\n\n        Examples\n        ========\n\n        The existing order of assignments is preserved as much as possible.\n\n        This function assumes that variables are assigned to only once.\n\n        This is a class constructor so that the default constructor for\n        CodeBlock can error when variables are used before they are assigned.\n\n        >>> from sympy import symbols\n        >>> from sympy.codegen.ast import CodeBlock, Assignment\n        >>> x, y, z = symbols('x y z')\n\n        >>> assignments = [\n        ...     Assignment(x, y + z),\n        ...     Assignment(y, z + 1),\n        ...     Assignment(z, 2),\n        ... ]\n        >>> CodeBlock.topological_sort(assignments)\n        CodeBlock(\n            Assignment(z, 2),\n            Assignment(y, z + 1),\n            Assignment(x, y + z)\n        )\n\n        ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "cast_nocheck",
    "full_id": "sympy.codegen.ast.FloatType.cast_nocheck",
    "type": "method",
    "description": "Casts without checking if out of bounds or subnormal.",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "decimal_dig",
    "full_id": "sympy.codegen.ast.FloatType.decimal_dig",
    "type": "property",
    "description": "Number of digits needed to store & load without loss.\n\n        Explanation\n        ===========\n\n        Number of decimal digits needed to guarantee that two consecutive conversions\n        (float -> text -> float) to be idempotent. This is useful when one do not want\n        to loose precision due to rounding errors when storing a floating point value\n        as text.\n        ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "dig",
    "full_id": "sympy.codegen.ast.FloatType.dig",
    "type": "property",
    "description": "Number of decimal digits that are guaranteed to be preserved in text.\n\n        When converting text -> float -> text, you are guaranteed that at least ``dig``\n        number of digits are preserved with respect to rounding or overflow.\n        ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "eps",
    "full_id": "sympy.codegen.ast.FloatType.eps",
    "type": "property",
    "description": "Difference between 1.0 and the next representable value.",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "max",
    "full_id": "sympy.codegen.ast.FloatType.max",
    "type": "property",
    "description": "Maximum value representable.",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "max_exponent",
    "full_id": "sympy.codegen.ast.FloatType.max_exponent",
    "type": "property",
    "description": "The largest positive number n, such that 2**(n - 1) is a representable finite value.",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "min_exponent",
    "full_id": "sympy.codegen.ast.FloatType.min_exponent",
    "type": "property",
    "description": "The lowest negative number n, such that 2**(n - 1) is a valid normalized number.",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "tiny",
    "full_id": "sympy.codegen.ast.FloatType.tiny",
    "type": "property",
    "description": "The minimum positive normalized value.",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "attr_params",
    "full_id": "sympy.codegen.ast.Node.attr_params",
    "type": "method",
    "description": "Returns the parameters of the Attribute with name ``looking_for`` in self.attrs",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "kwargs",
    "full_id": "sympy.codegen.ast.Token.kwargs",
    "type": "method",
    "description": "Get instance's attributes as dict of keyword arguments.\n\n        Parameters\n        ==========\n\n        exclude : collection of str\n            Collection of keywords to exclude.\n\n        apply : callable, optional\n            Function to apply to all values.\n        ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "cast_check",
    "full_id": "sympy.codegen.ast.Type.cast_check",
    "type": "method",
    "description": "Casts a value to the data type of the instance.\n\n        Parameters\n        ==========\n\n        value : number\n        rtol : floating point number\n            Relative tolerance. (will be deduced if not given).\n        atol : floating point number\n            Absolute tolerance (in addition to ``rtol``).\n        type_aliases : dict\n            Maps substitutions for Type, e.g. {integer: int64, real: float32}\n\n        Examples\n        ========\n\n        >>> from sympy.codegen.ast import integer, float32, int8\n        >>> integer.cast_check(3.0) == 3\n        True\n        >>> float32.cast_check(1e-40)  # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n          ...\n        ValueError: Minimum value for data type bigger than new value.\n        >>> int8.cast_check(256)  # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n          ...\n        ValueError: Maximum value for data type smaller than new value.\n        >>> v10 = 12345.67894\n        >>> float32.cast_check(v10)  # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n          ...\n        ValueError: Casting gives a significantly different value.\n        >>> from sympy.codegen.ast import float64\n        >>> float64.cast_check(v10)\n        12345.67894\n        >>> from sympy import Float\n        >>> v18 = Float('0.123456789012345646')\n        >>> float64.cast_check(v18)\n        Traceback (most recent call last):\n          ...\n        ValueError: Casting gives a significantly different value.\n        >>> from sympy.codegen.ast import float80\n        >>> float80.cast_check(v18)\n        0.123456789012345649\n\n        ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "from_expr",
    "full_id": "sympy.codegen.ast.Type.from_expr",
    "type": "method",
    "description": "Deduces type from an expression or a ``Symbol``.\n\n        Parameters\n        ==========\n\n        expr : number or SymPy object\n            The type will be deduced from type or properties.\n\n        Examples\n        ========\n\n        >>> from sympy.codegen.ast import Type, integer, complex_\n        >>> Type.from_expr(2) == integer\n        True\n        >>> from sympy import Symbol\n        >>> Type.from_expr(Symbol('z', complex=True)) == complex_\n        True\n        >>> Type.from_expr(sum)  # doctest: +ELLIPSIS\n        Traceback (most recent call last):\n          ...\n        ValueError: Could not deduce type from expr.\n\n        Raises\n        ======\n\n        ValueError when type deduction fails.\n\n        ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "as_Declaration",
    "full_id": "sympy.codegen.ast.Variable.as_Declaration",
    "type": "method",
    "description": "Convenience method for creating a Declaration instance.\n\n        Explanation\n        ===========\n\n        If the variable of the Declaration need to wrap a modified\n        variable keyword arguments may be passed (overriding e.g.\n        the ``value`` of the Variable instance).\n\n        Examples\n        ========\n\n        >>> from sympy.codegen.ast import Variable, NoneToken\n        >>> x = Variable('x')\n        >>> decl1 = x.as_Declaration()\n        >>> # value is special NoneToken() which must be tested with == operator\n        >>> decl1.variable.value is None  # won't work\n        False\n        >>> decl1.variable.value == None  # not PEP-8 compliant\n        True\n        >>> decl1.variable.value == NoneToken()  # OK\n        True\n        >>> decl2 = x.as_Declaration(value=42.0)\n        >>> decl2.variable.value == 42.0\n        True\n\n        ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "deduced",
    "full_id": "sympy.codegen.ast.Variable.deduced",
    "type": "method",
    "description": "Alt. constructor with type deduction from ``Type.from_expr``.\n\n        Deduces type primarily from ``symbol``, secondarily from ``value``.\n\n        Parameters\n        ==========\n\n        symbol : Symbol\n        value : expr\n            (optional) value of the variable.\n        attrs : iterable of Attribute instances\n        cast_check : bool\n            Whether to apply ``Type.cast_check`` on ``value``.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.codegen.ast import Variable, complex_\n        >>> n = Symbol('n', integer=True)\n        >>> str(Variable.deduced(n).type)\n        'integer'\n        >>> x = Symbol('x', real=True)\n        >>> v = Variable.deduced(x)\n        >>> v.type\n        real\n        >>> z = Symbol('z', complex=True)\n        >>> Variable.deduced(z).type == complex_\n        True\n\n        ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "aug_assign",
    "full_id": "sympy.codegen.ast.aug_assign",
    "type": "function",
    "description": "\n    Create 'lhs op= rhs'.\n\n    Explanation\n    ===========\n\n    Represents augmented variable assignment for code generation. This is a\n    convenience function. You can also use the AugmentedAssignment classes\n    directly, like AddAugmentedAssignment(x, y).\n\n    Parameters\n    ==========\n\n    lhs : Expr\n        SymPy object representing the lhs of the expression. These should be\n        singular objects, such as one would use in writing code. Notable types\n        include Symbol, MatrixSymbol, MatrixElement, and Indexed. Types that\n        subclass these types are also supported.\n\n    op : str\n        Operator (+, -, /, \\*, %).\n\n    rhs : Expr\n        SymPy object representing the rhs of the expression. This can be any\n        type, provided its shape corresponds to that of the lhs. For example,\n        a Matrix type can be assigned to MatrixSymbol, but not to Symbol, as\n        the dimensions will not align.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.codegen.ast import aug_assign\n    >>> x, y = symbols('x, y')\n    >>> aug_assign(x, '+', y)\n    AddAugmentedAssignment(x, y)\n    ",
    "section": "Using the nodes",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "alignof",
    "full_id": "sympy.codegen.cnodes.alignof",
    "type": "function",
    "description": "Generate of FunctionCall instance for calling 'alignof'",
    "section": "C specific AST nodes (sympy.codegen.cnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "sizeof",
    "full_id": "sympy.codegen.cnodes.sizeof",
    "type": "function",
    "description": "Generate of FunctionCall instance for calling 'sizeof'\n\n    Examples\n    ========\n\n    >>> from sympy.codegen.ast import real\n    >>> from sympy.codegen.cnodes import sizeof\n    >>> from sympy import ccode\n    >>> ccode(sizeof(real))\n    'sizeof(double)'\n    ",
    "section": "C specific AST nodes (sympy.codegen.cnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "allocated",
    "full_id": "sympy.codegen.fnodes.allocated",
    "type": "function",
    "description": "Creates an AST node for a function call to Fortran's \"allocated(...)\"\n\n    Examples\n    ========\n\n    >>> from sympy import fcode\n    >>> from sympy.codegen.fnodes import allocated\n    >>> alloc = allocated('x')\n    >>> fcode(alloc, source_format='free')\n    'allocated(x)'\n\n    ",
    "section": "Fortran specific AST nodes (sympy.codegen.fnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "array",
    "full_id": "sympy.codegen.fnodes.array",
    "type": "function",
    "description": "Convenience function for creating a Variable instance for a Fortran array.\n\n    Parameters\n    ==========\n\n    symbol : symbol\n    dim : Attribute or iterable\n        If dim is an ``Attribute`` it need to have the name 'dimension'. If it is\n        not an ``Attribute``, then it is passed to :func:`dimension` as ``*dim``\n    intent : str\n        One of: 'in', 'out', 'inout' or None\n    \\*\\*kwargs:\n        Keyword arguments for ``Variable`` ('type' & 'value')\n\n    Examples\n    ========\n\n    >>> from sympy import fcode\n    >>> from sympy.codegen.ast import integer, real\n    >>> from sympy.codegen.fnodes import array\n    >>> arr = array('a', '*', 'in', type=integer)\n    >>> print(fcode(arr.as_Declaration(), source_format='free', standard=2003))\n    integer*4, dimension(*), intent(in) :: a\n    >>> x = array('x', [3, ':', ':'], intent='out', type=real)\n    >>> print(fcode(x.as_Declaration(value=1), source_format='free', standard=2003))\n    real*8, dimension(3, :, :), intent(out) :: x = 1\n\n    ",
    "section": "Fortran specific AST nodes (sympy.codegen.fnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "bind_C",
    "full_id": "sympy.codegen.fnodes.bind_C",
    "type": "function",
    "description": "Creates an Attribute ``bind_C`` with a name.\n\n    Parameters\n    ==========\n\n    name : str\n\n    Examples\n    ========\n\n    >>> from sympy import fcode, Symbol\n    >>> from sympy.codegen.ast import FunctionDefinition, real, Return\n    >>> from sympy.codegen.fnodes import array, sum_, bind_C\n    >>> a = Symbol('a', real=True)\n    >>> s = Symbol('s', integer=True)\n    >>> arr = array(a, dim=[s], intent='in')\n    >>> body = [Return((sum_(a**2)/s)**.5)]\n    >>> fd = FunctionDefinition(real, 'rms', [arr, s], body, attrs=[bind_C('rms')])\n    >>> print(fcode(fd, source_format='free', standard=2003))\n    real*8 function rms(a, s) bind(C, name=\"rms\")\n    real*8, dimension(s), intent(in) :: a\n    integer*4 :: s\n    rms = sqrt(sum(a**2)/s)\n    end function\n\n    ",
    "section": "Fortran specific AST nodes (sympy.codegen.fnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "dimension",
    "full_id": "sympy.codegen.fnodes.dimension",
    "type": "function",
    "description": "Creates a 'dimension' Attribute with (up to 7) extents.\n\n    Examples\n    ========\n\n    >>> from sympy import fcode\n    >>> from sympy.codegen.fnodes import dimension, intent_in\n    >>> dim = dimension('2', ':')  # 2 rows, runtime determined number of columns\n    >>> from sympy.codegen.ast import Variable, integer\n    >>> arr = Variable('a', integer, attrs=[dim, intent_in])\n    >>> fcode(arr.as_Declaration(), source_format='free', standard=2003)\n    'integer*4, dimension(2, :), intent(in) :: a'\n\n    ",
    "section": "Fortran specific AST nodes (sympy.codegen.fnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "lbound",
    "full_id": "sympy.codegen.fnodes.lbound",
    "type": "function",
    "description": "Creates an AST node for a function call to Fortran's \"lbound(...)\"\n\n    Parameters\n    ==========\n\n    array : Symbol or String\n    dim : expr\n    kind : expr\n\n    Examples\n    ========\n\n    >>> from sympy import fcode\n    >>> from sympy.codegen.fnodes import lbound\n    >>> lb = lbound('arr', dim=2)\n    >>> fcode(lb, source_format='free')\n    'lbound(arr, 2)'\n\n    ",
    "section": "Fortran specific AST nodes (sympy.codegen.fnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "reshape",
    "full_id": "sympy.codegen.fnodes.reshape",
    "type": "function",
    "description": "Creates an AST node for a function call to Fortran's \"reshape(...)\"\n\n    Parameters\n    ==========\n\n    source : Symbol or String\n    shape : ArrayExpr\n\n    ",
    "section": "Fortran specific AST nodes (sympy.codegen.fnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "shape",
    "full_id": "sympy.codegen.fnodes.shape",
    "type": "function",
    "description": "Creates an AST node for a function call to Fortran's \"shape(...)\"\n\n    Parameters\n    ==========\n\n    source : Symbol or String\n    kind : expr\n\n    Examples\n    ========\n\n    >>> from sympy import fcode\n    >>> from sympy.codegen.fnodes import shape\n    >>> shp = shape('x')\n    >>> fcode(shp, source_format='free')\n    'shape(x)'\n\n    ",
    "section": "Fortran specific AST nodes (sympy.codegen.fnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "size",
    "full_id": "sympy.codegen.fnodes.size",
    "type": "function",
    "description": "Creates an AST node for a function call to Fortran's \"size(...)\"\n\n    Examples\n    ========\n\n    >>> from sympy import fcode, Symbol\n    >>> from sympy.codegen.ast import FunctionDefinition, real, Return\n    >>> from sympy.codegen.fnodes import array, sum_, size\n    >>> a = Symbol('a', real=True)\n    >>> body = [Return((sum_(a**2)/size(a))**.5)]\n    >>> arr = array(a, dim=[':'], intent='in')\n    >>> fd = FunctionDefinition(real, 'rms', [arr], body)\n    >>> print(fcode(fd, source_format='free', standard=2003))\n    real*8 function rms(a)\n    real*8, dimension(:), intent(in) :: a\n    rms = sqrt(sum(a**2)*1d0/size(a))\n    end function\n\n    ",
    "section": "Fortran specific AST nodes (sympy.codegen.fnodes)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "newtons_method",
    "full_id": "sympy.codegen.algorithms.newtons_method",
    "type": "function",
    "description": "Generates an AST for Newton-Raphson method (a root-finding algorithm).\n\n    Explanation\n    ===========\n\n    Returns an abstract syntax tree (AST) based on ``sympy.codegen.ast`` for Netwon's\n    method of root-finding.\n\n    Parameters\n    ==========\n\n    expr : expression\n    wrt : Symbol\n        With respect to, i.e. what is the variable.\n    atol : number or expression\n        Absolute tolerance (stopping criterion)\n    rtol : number or expression\n        Relative tolerance (stopping criterion)\n    delta : Symbol\n        Will be a ``Dummy`` if ``None``.\n    debug : bool\n        Whether to print convergence information during iterations\n    itermax : number or expr\n        Maximum number of iterations.\n    counter : Symbol\n        Will be a ``Dummy`` if ``None``.\n    delta_fn: Callable[[Expr, Symbol], Expr]\n        computes the step, default is newtons method. For e.g. Halley's method\n        use delta_fn=lambda e, x: -2*e*e.diff(x)/(2*e.diff(x)**2 - e*e.diff(x, 2))\n    cse: bool\n        Perform common sub-expression elimination on delta expression\n    handle_nan: Token\n        How to handle occurrence of not-a-number (NaN).\n    bounds: Optional[tuple[Expr, Expr]]\n        Perform optimization within bounds\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, cos\n    >>> from sympy.codegen.ast import Assignment\n    >>> from sympy.codegen.algorithms import newtons_method\n    >>> x, dx, atol = symbols('x dx atol')\n    >>> expr = cos(x) - x**3\n    >>> algo = newtons_method(expr, x, atol=atol, delta=dx)\n    >>> algo.has(Assignment(dx, -expr/expr.diff(x)))\n    True\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Newton%27s_method\n\n    ",
    "section": "Algorithms (sympy.codegen.algorithms)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "newtons_method_function",
    "full_id": "sympy.codegen.algorithms.newtons_method_function",
    "type": "function",
    "description": "Generates an AST for a function implementing the Newton-Raphson method.\n\n    Parameters\n    ==========\n\n    expr : expression\n    wrt : Symbol\n        With respect to, i.e. what is the variable\n    params : iterable of symbols\n        Symbols appearing in expr that are taken as constants during the iterations\n        (these will be accepted as parameters to the generated function).\n    func_name : str\n        Name of the generated function.\n    attrs : Tuple\n        Attribute instances passed as ``attrs`` to ``FunctionDefinition``.\n    \\*\\*kwargs :\n        Keyword arguments passed to :func:`sympy.codegen.algorithms.newtons_method`.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, cos\n    >>> from sympy.codegen.algorithms import newtons_method_function\n    >>> from sympy.codegen.pyutils import render_as_module\n    >>> x = symbols('x')\n    >>> expr = cos(x) - x**3\n    >>> func = newtons_method_function(expr, x)\n    >>> py_mod = render_as_module(func)  # source code as string\n    >>> namespace = {}\n    >>> exec(py_mod, namespace, namespace)\n    >>> res = eval('newton(0.5)', namespace)\n    >>> abs(res - 0.865474033102) < 1e-12\n    True\n\n    See Also\n    ========\n\n    sympy.codegen.algorithms.newtons_method\n\n    ",
    "section": "Algorithms (sympy.codegen.algorithms)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "render_as_module",
    "full_id": "sympy.codegen.pyutils.render_as_module",
    "type": "function",
    "description": "Renders Python code as a module (with the required imports).\n\n    Parameters\n    ==========\n\n    standard :\n        See the parameter ``standard`` in\n        :meth:`sympy.printing.pycode.pycode`\n    ",
    "section": "Python utilities (sympy.codegen.pyutils)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "render_as_source_file",
    "full_id": "sympy.codegen.cutils.render_as_source_file",
    "type": "function",
    "description": "Renders a C source file (with required #include statements)",
    "section": "C utilities (sympy.codegen.cutils)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "render_as_module",
    "full_id": "sympy.codegen.futils.render_as_module",
    "type": "function",
    "description": "Creates a ``Module`` instance and renders it as a string.\n\n    This generates Fortran source code for a module with the correct ``use`` statements.\n\n    Parameters\n    ==========\n\n    definitions : iterable\n        Passed to :class:`sympy.codegen.fnodes.Module`.\n    name : str\n        Passed to :class:`sympy.codegen.fnodes.Module`.\n    declarations : iterable\n        Passed to :class:`sympy.codegen.fnodes.Module`. It will be extended with\n        use statements, 'implicit none' and public list generated from ``definitions``.\n    printer_settings : dict\n        Passed to ``FCodePrinter`` (default: ``{'standard': 2003, 'source_format': 'free'}``).\n\n    ",
    "section": "Fortran utilities (sympy.codegen.futils)",
    "url": "https://docs.sympy.org/latest/modules/codegen.html"
  },
  {
    "name": "SOPform",
    "full_id": "sympy.logic.boolalg.SOPform",
    "type": "function",
    "description": "\n    The SOPform function uses simplified_pairs and a redundant group-\n    eliminating algorithm to convert the list of all input combos that\n    generate '1' (the minterms) into the smallest sum-of-products form.\n\n    The variables must be given as the first argument.\n\n    Return a logical :py:class:`~.Or` function (i.e., the \"sum of products\" or\n    \"SOP\" form) that gives the desired outcome. If there are inputs that can\n    be ignored, pass them as a list, too.\n\n    The result will be one of the (perhaps many) functions that satisfy\n    the conditions.\n\n    Examples\n    ========\n\n    >>> from sympy.logic import SOPform\n    >>> from sympy import symbols\n    >>> w, x, y, z = symbols('w x y z')\n    >>> minterms = [[0, 0, 0, 1], [0, 0, 1, 1],\n    ...             [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 1, 1]]\n    >>> dontcares = [[0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 1]]\n    >>> SOPform([w, x, y, z], minterms, dontcares)\n    (y & z) | (~w & ~x)\n\n    The terms can also be represented as integers:\n\n    >>> minterms = [1, 3, 7, 11, 15]\n    >>> dontcares = [0, 2, 5]\n    >>> SOPform([w, x, y, z], minterms, dontcares)\n    (y & z) | (~w & ~x)\n\n    They can also be specified using dicts, which does not have to be fully\n    specified:\n\n    >>> minterms = [{w: 0, x: 1}, {y: 1, z: 1, x: 0}]\n    >>> SOPform([w, x, y, z], minterms)\n    (x & ~w) | (y & z & ~x)\n\n    Or a combination:\n\n    >>> minterms = [4, 7, 11, [1, 1, 1, 1]]\n    >>> dontcares = [{w : 0, x : 0, y: 0}, 5]\n    >>> SOPform([w, x, y, z], minterms, dontcares)\n    (w & y & z) | (~w & ~y) | (x & z & ~w)\n\n    See also\n    ========\n\n    POSform\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm\n    .. [2] https://en.wikipedia.org/wiki/Don%27t-care_term\n\n    ",
    "section": "Forming logical expressions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "POSform",
    "full_id": "sympy.logic.boolalg.POSform",
    "type": "function",
    "description": "\n    The POSform function uses simplified_pairs and a redundant-group\n    eliminating algorithm to convert the list of all input combinations\n    that generate '1' (the minterms) into the smallest product-of-sums form.\n\n    The variables must be given as the first argument.\n\n    Return a logical :py:class:`~.And` function (i.e., the \"product of sums\"\n    or \"POS\" form) that gives the desired outcome. If there are inputs that can\n    be ignored, pass them as a list, too.\n\n    The result will be one of the (perhaps many) functions that satisfy\n    the conditions.\n\n    Examples\n    ========\n\n    >>> from sympy.logic import POSform\n    >>> from sympy import symbols\n    >>> w, x, y, z = symbols('w x y z')\n    >>> minterms = [[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 1, 1],\n    ...             [1, 0, 1, 1], [1, 1, 1, 1]]\n    >>> dontcares = [[0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 1]]\n    >>> POSform([w, x, y, z], minterms, dontcares)\n    z & (y | ~w)\n\n    The terms can also be represented as integers:\n\n    >>> minterms = [1, 3, 7, 11, 15]\n    >>> dontcares = [0, 2, 5]\n    >>> POSform([w, x, y, z], minterms, dontcares)\n    z & (y | ~w)\n\n    They can also be specified using dicts, which does not have to be fully\n    specified:\n\n    >>> minterms = [{w: 0, x: 1}, {y: 1, z: 1, x: 0}]\n    >>> POSform([w, x, y, z], minterms)\n    (x | y) & (x | z) & (~w | ~x)\n\n    Or a combination:\n\n    >>> minterms = [4, 7, 11, [1, 1, 1, 1]]\n    >>> dontcares = [{w : 0, x : 0, y: 0}, 5]\n    >>> POSform([w, x, y, z], minterms, dontcares)\n    (w | x) & (y | ~w) & (z | ~y)\n\n    See also\n    ========\n\n    SOPform\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm\n    .. [2] https://en.wikipedia.org/wiki/Don%27t-care_term\n\n    ",
    "section": "Forming logical expressions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "ANFform",
    "full_id": "sympy.logic.boolalg.ANFform",
    "type": "function",
    "description": "\n    The ANFform function converts the list of truth values to\n    Algebraic Normal Form (ANF).\n\n    The variables must be given as the first argument.\n\n    Return True, False, logical :py:class:`~.And` function (i.e., the\n    \"Zhegalkin monomial\") or logical :py:class:`~.Xor` function (i.e.,\n    the \"Zhegalkin polynomial\"). When True and False\n    are represented by 1 and 0, respectively, then\n    :py:class:`~.And` is multiplication and :py:class:`~.Xor` is addition.\n\n    Formally a \"Zhegalkin monomial\" is the product (logical\n    And) of a finite set of distinct variables, including\n    the empty set whose product is denoted 1 (True).\n    A \"Zhegalkin polynomial\" is the sum (logical Xor) of a\n    set of Zhegalkin monomials, with the empty set denoted\n    by 0 (False).\n\n    Parameters\n    ==========\n\n    variables : list of variables\n    truthvalues : list of 1's and 0's (result column of truth table)\n\n    Examples\n    ========\n    >>> from sympy.logic.boolalg import ANFform\n    >>> from sympy.abc import x, y\n    >>> ANFform([x], [1, 0])\n    x ^ True\n    >>> ANFform([x, y], [0, 1, 1, 1])\n    x ^ y ^ (x & y)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Zhegalkin_polynomial\n\n    ",
    "section": "Forming logical expressions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "as_set",
    "full_id": "sympy.logic.boolalg.Boolean.as_set",
    "type": "method",
    "description": "\n        Rewrites Boolean expression in terms of real sets.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol, Eq, Or, And\n        >>> x = Symbol('x', real=True)\n        >>> Eq(x, 0).as_set()\n        {0}\n        >>> (x > 0).as_set()\n        Interval.open(0, oo)\n        >>> And(-2 < x, x < 2).as_set()\n        Interval.open(-2, 2)\n        >>> Or(x < -2, 2 < x).as_set()\n        Union(Interval.open(-oo, -2), Interval.open(2, oo))\n\n        ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "equals",
    "full_id": "sympy.logic.boolalg.Boolean.equals",
    "type": "method",
    "description": "\n        Returns ``True`` if the given formulas have the same truth table.\n        For two formulas to be equal they must have the same literals.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import A, B, C\n        >>> from sympy import And, Or, Not\n        >>> (A >> B).equals(~B >> ~A)\n        True\n        >>> Not(And(A, B, C)).equals(And(Not(A), Not(B), Not(C)))\n        False\n        >>> Not(And(A, Not(A))).equals(Or(B, Not(B)))\n        False\n\n        ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "as_set",
    "full_id": "sympy.logic.boolalg.BooleanTrue.as_set",
    "type": "method",
    "description": "\n        Rewrite logic operators and relationals in terms of real sets.\n\n        Examples\n        ========\n\n        >>> from sympy import true\n        >>> true.as_set()\n        UniversalSet\n\n        ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "as_set",
    "full_id": "sympy.logic.boolalg.BooleanFalse.as_set",
    "type": "method",
    "description": "\n        Rewrite logic operators and relationals in terms of real sets.\n\n        Examples\n        ========\n\n        >>> from sympy import false\n        >>> false.as_set()\n        EmptySet\n        ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "to_anf",
    "full_id": "sympy.logic.boolalg.to_anf",
    "type": "function",
    "description": "\n    Converts expr to Algebraic Normal Form (ANF).\n\n    ANF is a canonical normal form, which means that two\n    equivalent formulas will convert to the same ANF.\n\n    A logical expression is in ANF if it has the form\n\n    .. math:: 1 \\oplus a \\oplus b \\oplus ab \\oplus abc\n\n    i.e. it can be:\n        - purely true,\n        - purely false,\n        - conjunction of variables,\n        - exclusive disjunction.\n\n    The exclusive disjunction can only contain true, variables\n    or conjunction of variables. No negations are permitted.\n\n    If ``deep`` is ``False``, arguments of the boolean\n    expression are considered variables, i.e. only the\n    top-level expression is converted to ANF.\n\n    Examples\n    ========\n    >>> from sympy.logic.boolalg import And, Or, Not, Implies, Equivalent\n    >>> from sympy.logic.boolalg import to_anf\n    >>> from sympy.abc import A, B, C\n    >>> to_anf(Not(A))\n    A ^ True\n    >>> to_anf(And(Or(A, B), Not(C)))\n    A ^ B ^ (A & B) ^ (A & C) ^ (B & C) ^ (A & B & C)\n    >>> to_anf(Implies(Not(A), Equivalent(B, C)), deep=False)\n    True ^ ~A ^ (~A & (Equivalent(B, C)))\n\n    ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "to_cnf",
    "full_id": "sympy.logic.boolalg.to_cnf",
    "type": "function",
    "description": "\n    Convert a propositional logical sentence ``expr`` to conjunctive normal\n    form: ``((A | ~B | ...) & (B | C | ...) & ...)``.\n    If ``simplify`` is ``True``, ``expr`` is evaluated to its simplest CNF\n    form using the Quine-McCluskey algorithm; this may take a long\n    time. If there are more than 8 variables the ``force`` flag must be set\n    to ``True`` to simplify (default is ``False``).\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import to_cnf\n    >>> from sympy.abc import A, B, D\n    >>> to_cnf(~(A | B) | D)\n    (D | ~A) & (D | ~B)\n    >>> to_cnf((A | B) & (A | ~A), True)\n    A | B\n\n    ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "to_dnf",
    "full_id": "sympy.logic.boolalg.to_dnf",
    "type": "function",
    "description": "\n    Convert a propositional logical sentence ``expr`` to disjunctive normal\n    form: ``((A & ~B & ...) | (B & C & ...) | ...)``.\n    If ``simplify`` is ``True``, ``expr`` is evaluated to its simplest DNF form using\n    the Quine-McCluskey algorithm; this may take a long\n    time. If there are more than 8 variables, the ``force`` flag must be set to\n    ``True`` to simplify (default is ``False``).\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import to_dnf\n    >>> from sympy.abc import A, B, C\n    >>> to_dnf(B & (A | C))\n    (A & B) | (B & C)\n    >>> to_dnf((A & B) | (A & ~B) | (B & C) | (~B & C), True)\n    A | C\n\n    ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "to_nnf",
    "full_id": "sympy.logic.boolalg.to_nnf",
    "type": "function",
    "description": "\n    Converts ``expr`` to Negation Normal Form (NNF).\n\n    A logical expression is in NNF if it\n    contains only :py:class:`~.And`, :py:class:`~.Or` and :py:class:`~.Not`,\n    and :py:class:`~.Not` is applied only to literals.\n    If ``simplify`` is ``True``, the result contains no redundant clauses.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import A, B, C, D\n    >>> from sympy.logic.boolalg import Not, Equivalent, to_nnf\n    >>> to_nnf(Not((~A & ~B) | (C & D)))\n    (A | B) & (~C | ~D)\n    >>> to_nnf(Equivalent(A >> B, B >> A))\n    (A | ~B | (A & ~B)) & (B | ~A | (B & ~A))\n\n    ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "is_anf",
    "full_id": "sympy.logic.boolalg.is_anf",
    "type": "function",
    "description": "\n    Checks if ``expr``  is in Algebraic Normal Form (ANF).\n\n    A logical expression is in ANF if it has the form\n\n    .. math:: 1 \\oplus a \\oplus b \\oplus ab \\oplus abc\n\n    i.e. it is purely true, purely false, conjunction of\n    variables or exclusive disjunction. The exclusive\n    disjunction can only contain true, variables or\n    conjunction of variables. No negations are permitted.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import And, Not, Xor, true, is_anf\n    >>> from sympy.abc import A, B, C\n    >>> is_anf(true)\n    True\n    >>> is_anf(A)\n    True\n    >>> is_anf(And(A, B, C))\n    True\n    >>> is_anf(Xor(A, Not(B)))\n    False\n\n    ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "is_cnf",
    "full_id": "sympy.logic.boolalg.is_cnf",
    "type": "function",
    "description": "\n    Test whether or not an expression is in conjunctive normal form.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import is_cnf\n    >>> from sympy.abc import A, B, C\n    >>> is_cnf(A | B | C)\n    True\n    >>> is_cnf(A & B & C)\n    True\n    >>> is_cnf((A & B) | C)\n    False\n\n    ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "is_dnf",
    "full_id": "sympy.logic.boolalg.is_dnf",
    "type": "function",
    "description": "\n    Test whether or not an expression is in disjunctive normal form.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import is_dnf\n    >>> from sympy.abc import A, B, C\n    >>> is_dnf(A | B | C)\n    True\n    >>> is_dnf(A & B & C)\n    True\n    >>> is_dnf((A & B) | C)\n    True\n    >>> is_dnf(A & (B | C))\n    False\n\n    ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "is_nnf",
    "full_id": "sympy.logic.boolalg.is_nnf",
    "type": "function",
    "description": "\n    Checks if ``expr`` is in Negation Normal Form (NNF).\n\n    A logical expression is in NNF if it\n    contains only :py:class:`~.And`, :py:class:`~.Or` and :py:class:`~.Not`,\n    and :py:class:`~.Not` is applied only to literals.\n    If ``simplified`` is ``True``, checks if result contains no redundant clauses.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import A, B, C\n    >>> from sympy.logic.boolalg import Not, is_nnf\n    >>> is_nnf(A & B | ~C)\n    True\n    >>> is_nnf((A | ~A) & (B | C))\n    False\n    >>> is_nnf((A | ~A) & (B | C), False)\n    True\n    >>> is_nnf(Not(A & B) | C)\n    False\n    >>> is_nnf((A >> B) & (B >> A))\n    False\n\n    ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "gateinputcount",
    "full_id": "sympy.logic.boolalg.gateinputcount",
    "type": "function",
    "description": "\n    Return the total number of inputs for the logic gates realizing the\n    Boolean expression.\n\n    Returns\n    =======\n\n    int\n        Number of gate inputs\n\n    Note\n    ====\n\n    Not all Boolean functions count as gate here, only those that are\n    considered to be standard gates. These are: :py:class:`~.And`,\n    :py:class:`~.Or`, :py:class:`~.Xor`, :py:class:`~.Not`, and\n    :py:class:`~.ITE` (multiplexer). :py:class:`~.Nand`, :py:class:`~.Nor`,\n    and :py:class:`~.Xnor` will be evaluated to ``Not(And())`` etc.\n\n    Examples\n    ========\n\n    >>> from sympy.logic import And, Or, Nand, Not, gateinputcount\n    >>> from sympy.abc import x, y, z\n    >>> expr = And(x, y)\n    >>> gateinputcount(expr)\n    2\n    >>> gateinputcount(Or(expr, z))\n    4\n\n    Note that ``Nand`` is automatically evaluated to ``Not(And())`` so\n\n    >>> gateinputcount(Nand(x, y, z))\n    4\n    >>> gateinputcount(Not(And(x, y, z)))\n    4\n\n    Although this can be avoided by using ``evaluate=False``\n\n    >>> gateinputcount(Nand(x, y, z, evaluate=False))\n    3\n\n    Also note that a comparison will count as a Boolean variable:\n\n    >>> gateinputcount(And(x > z, y >= 2))\n    2\n\n    As will a symbol:\n    >>> gateinputcount(x)\n    0\n\n    ",
    "section": "Boolean functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "simplify_logic",
    "full_id": "sympy.logic.boolalg.simplify_logic",
    "type": "function",
    "description": "\n    This function simplifies a boolean function to its simplified version\n    in SOP or POS form. The return type is an :py:class:`~.Or` or\n    :py:class:`~.And` object in SymPy.\n\n    Parameters\n    ==========\n\n    expr : Boolean\n\n    form : string (``'cnf'`` or ``'dnf'``) or ``None`` (default).\n        If ``'cnf'`` or ``'dnf'``, the simplest expression in the corresponding\n        normal form is returned; if ``None``, the answer is returned\n        according to the form with fewest args (in CNF by default).\n\n    deep : bool (default ``True``)\n        Indicates whether to recursively simplify any\n        non-boolean functions contained within the input.\n\n    force : bool (default ``False``)\n        As the simplifications require exponential time in the number\n        of variables, there is by default a limit on expressions with\n        8 variables. When the expression has more than 8 variables\n        only symbolical simplification (controlled by ``deep``) is\n        made. By setting ``force`` to ``True``, this limit is removed. Be\n        aware that this can lead to very long simplification times.\n\n    dontcare : Boolean\n        Optimize expression under the assumption that inputs where this\n        expression is true are don't care. This is useful in e.g. Piecewise\n        conditions, where later conditions do not need to consider inputs that\n        are converted by previous conditions. For example, if a previous\n        condition is ``And(A, B)``, the simplification of expr can be made\n        with don't cares for ``And(A, B)``.\n\n    Examples\n    ========\n\n    >>> from sympy.logic import simplify_logic\n    >>> from sympy.abc import x, y, z\n    >>> b = (~x & ~y & ~z) | ( ~x & ~y & z)\n    >>> simplify_logic(b)\n    ~x & ~y\n    >>> simplify_logic(x | y, dontcare=y)\n    x\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Don%27t-care_term\n\n    ",
    "section": "Simplification and equivalence-testing",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "bool_map",
    "full_id": "sympy.logic.boolalg.bool_map",
    "type": "function",
    "description": "\n    Return the simplified version of *bool1*, and the mapping of variables\n    that makes the two expressions *bool1* and *bool2* represent the same\n    logical behaviour for some correspondence between the variables\n    of each.\n    If more than one mappings of this sort exist, one of them\n    is returned.\n\n    For example, ``And(x, y)`` is logically equivalent to ``And(a, b)`` for\n    the mapping ``{x: a, y: b}`` or ``{x: b, y: a}``.\n    If no such mapping exists, return ``False``.\n\n    Examples\n    ========\n\n    >>> from sympy import SOPform, bool_map, Or, And, Not, Xor\n    >>> from sympy.abc import w, x, y, z, a, b, c, d\n    >>> function1 = SOPform([x, z, y],[[1, 0, 1], [0, 0, 1]])\n    >>> function2 = SOPform([a, b, c],[[1, 0, 1], [1, 0, 0]])\n    >>> bool_map(function1, function2)\n    (y & ~z, {y: a, z: b})\n\n    The results are not necessarily unique, but they are canonical. Here,\n    ``(w, z)`` could be ``(a, d)`` or ``(d, a)``:\n\n    >>> eq =  Or(And(Not(y), w), And(Not(y), z), And(x, y))\n    >>> eq2 = Or(And(Not(c), a), And(Not(c), d), And(b, c))\n    >>> bool_map(eq, eq2)\n    ((x & y) | (w & ~y) | (z & ~y), {w: a, x: b, y: c, z: d})\n    >>> eq = And(Xor(a, b), c, And(c,d))\n    >>> bool_map(eq, eq.subs(c, x))\n    (c & d & (a | b) & (~a | ~b), {a: a, b: b, c: d, d: x})\n\n    ",
    "section": "Simplification and equivalence-testing",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "distribute_and_over_or",
    "full_id": "sympy.logic.boolalg.distribute_and_over_or",
    "type": "function",
    "description": "\n    Given a sentence ``expr`` consisting of conjunctions and disjunctions\n    of literals, return an equivalent sentence in CNF.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import distribute_and_over_or, And, Or, Not\n    >>> from sympy.abc import A, B, C\n    >>> distribute_and_over_or(Or(A, And(Not(B), Not(C))))\n    (A | ~B) & (A | ~C)\n\n    ",
    "section": "Manipulating expressions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "distribute_or_over_and",
    "full_id": "sympy.logic.boolalg.distribute_or_over_and",
    "type": "function",
    "description": "\n    Given a sentence ``expr`` consisting of conjunctions and disjunctions\n    of literals, return an equivalent sentence in DNF.\n\n    Note that the output is NOT simplified.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import distribute_or_over_and, And, Or, Not\n    >>> from sympy.abc import A, B, C\n    >>> distribute_or_over_and(And(Or(Not(A), B), C))\n    (B & C) | (C & ~A)\n\n    ",
    "section": "Manipulating expressions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "distribute_xor_over_and",
    "full_id": "sympy.logic.boolalg.distribute_xor_over_and",
    "type": "function",
    "description": "\n    Given a sentence ``expr`` consisting of conjunction and\n    exclusive disjunctions of literals, return an\n    equivalent exclusive disjunction.\n\n    Note that the output is NOT simplified.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import distribute_xor_over_and, And, Xor, Not\n    >>> from sympy.abc import A, B, C\n    >>> distribute_xor_over_and(And(Xor(Not(A), B), C))\n    (B & C) ^ (C & ~A)\n    ",
    "section": "Manipulating expressions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "eliminate_implications",
    "full_id": "sympy.logic.boolalg.eliminate_implications",
    "type": "function",
    "description": "\n    Change :py:class:`~.Implies` and :py:class:`~.Equivalent` into\n    :py:class:`~.And`, :py:class:`~.Or`, and :py:class:`~.Not`.\n    That is, return an expression that is equivalent to ``expr``, but has only\n    ``&``, ``|``, and ``~`` as logical\n    operators.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import Implies, Equivalent,          eliminate_implications\n    >>> from sympy.abc import A, B, C\n    >>> eliminate_implications(Implies(A, B))\n    B | ~A\n    >>> eliminate_implications(Equivalent(A, B))\n    (A | ~B) & (B | ~A)\n    >>> eliminate_implications(Equivalent(A, B, C))\n    (A | ~C) & (B | ~A) & (C | ~B)\n\n    ",
    "section": "Manipulating expressions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "truth_table",
    "full_id": "sympy.logic.boolalg.truth_table",
    "type": "function",
    "description": "\n    Return a generator of all possible configurations of the input variables,\n    and the result of the boolean expression for those values.\n\n    Parameters\n    ==========\n\n    expr : Boolean expression\n\n    variables : list of variables\n\n    input : bool (default ``True``)\n        Indicates whether to return the input combinations.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import truth_table\n    >>> from sympy.abc import x,y\n    >>> table = truth_table(x >> y, [x, y])\n    >>> for t in table:\n    ...     print('{0} -> {1}'.format(*t))\n    [0, 0] -> True\n    [0, 1] -> True\n    [1, 0] -> False\n    [1, 1] -> True\n\n    >>> table = truth_table(x | y, [x, y])\n    >>> list(table)\n    [([0, 0], False), ([0, 1], True), ([1, 0], True), ([1, 1], True)]\n\n    If ``input`` is ``False``, ``truth_table`` returns only a list of truth values.\n    In this case, the corresponding input values of variables can be\n    deduced from the index of a given output.\n\n    >>> from sympy.utilities.iterables import ibin\n    >>> vars = [y, x]\n    >>> values = truth_table(x >> y, vars, input=False)\n    >>> values = list(values)\n    >>> values\n    [True, False, True, True]\n\n    >>> for i, value in enumerate(values):\n    ...     print('{0} -> {1}'.format(list(zip(\n    ...     vars, ibin(i, len(vars)))), value))\n    [(y, 0), (x, 0)] -> True\n    [(y, 0), (x, 1)] -> False\n    [(y, 1), (x, 0)] -> True\n    [(y, 1), (x, 1)] -> True\n\n    ",
    "section": "Truth tables and related functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "integer_to_term",
    "full_id": "sympy.logic.boolalg.integer_to_term",
    "type": "function",
    "description": "Return a list of length ``bits`` corresponding to the binary value\n    of ``n`` with small bits to the right (last). If bits is omitted, the\n    length will be the number required to represent ``n``. If the bits are\n    desired in reversed order, use the ``[::-1]`` slice of the returned list.\n\n    If a sequence of all bits-length lists starting from ``[0, 0,..., 0]``\n    through ``[1, 1, ..., 1]`` are desired, pass a non-integer for bits, e.g.\n    ``'all'``.\n\n    If the bit *string* is desired pass ``str=True``.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import ibin\n    >>> ibin(2)\n    [1, 0]\n    >>> ibin(2, 4)\n    [0, 0, 1, 0]\n\n    If all lists corresponding to 0 to 2**n - 1, pass a non-integer\n    for bits:\n\n    >>> bits = 2\n    >>> for i in ibin(2, 'all'):\n    ...     print(i)\n    (0, 0)\n    (0, 1)\n    (1, 0)\n    (1, 1)\n\n    If a bit string is desired of a given length, use str=True:\n\n    >>> n = 123\n    >>> bits = 10\n    >>> ibin(n, bits, str=True)\n    '0001111011'\n    >>> ibin(n, bits, str=True)[::-1]  # small bits left\n    '1101111000'\n    >>> list(ibin(3, 'all', str=True))\n    ['000', '001', '010', '011', '100', '101', '110', '111']\n\n    ",
    "section": "Truth tables and related functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "term_to_integer",
    "full_id": "sympy.logic.boolalg.term_to_integer",
    "type": "function",
    "description": "\n    Return an integer corresponding to the base-2 digits given by *term*.\n\n    Parameters\n    ==========\n\n    term : a string or list of ones and zeros\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import term_to_integer\n    >>> term_to_integer([1, 0, 0])\n    4\n    >>> term_to_integer('100')\n    4\n\n    ",
    "section": "Truth tables and related functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "bool_maxterm",
    "full_id": "sympy.logic.boolalg.bool_maxterm",
    "type": "function",
    "description": "\n    Return the k-th maxterm.\n\n    Each maxterm is assigned an index based on the opposite\n    conventional binary encoding used for minterms. The maxterm\n    convention assigns the value 0 to the direct form and 1 to\n    the complemented form.\n\n    Parameters\n    ==========\n\n    k : int or list of 1's and 0's (complementation pattern)\n    variables : list of variables\n\n    Examples\n    ========\n    >>> from sympy.logic.boolalg import bool_maxterm\n    >>> from sympy.abc import x, y, z\n    >>> bool_maxterm([1, 0, 1], [x, y, z])\n    y | ~x | ~z\n    >>> bool_maxterm(6, [x, y, z])\n    z | ~x | ~y\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms\n\n    ",
    "section": "Truth tables and related functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "bool_minterm",
    "full_id": "sympy.logic.boolalg.bool_minterm",
    "type": "function",
    "description": "\n    Return the k-th minterm.\n\n    Minterms are numbered by a binary encoding of the complementation\n    pattern of the variables. This convention assigns the value 1 to\n    the direct form and 0 to the complemented form.\n\n    Parameters\n    ==========\n\n    k : int or list of 1's and 0's (complementation pattern)\n    variables : list of variables\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import bool_minterm\n    >>> from sympy.abc import x, y, z\n    >>> bool_minterm([1, 0, 1], [x, y, z])\n    x & z & ~y\n    >>> bool_minterm(6, [x, y, z])\n    x & y & ~z\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms\n\n    ",
    "section": "Truth tables and related functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "bool_monomial",
    "full_id": "sympy.logic.boolalg.bool_monomial",
    "type": "function",
    "description": "\n    Return the k-th monomial.\n\n    Monomials are numbered by a binary encoding of the presence and\n    absences of the variables. This convention assigns the value\n    1 to the presence of variable and 0 to the absence of variable.\n\n    Each boolean function can be uniquely represented by a\n    Zhegalkin Polynomial (Algebraic Normal Form). The Zhegalkin\n    Polynomial of the boolean function with `n` variables can contain\n    up to `2^n` monomials. We can enumerate all the monomials.\n    Each monomial is fully specified by the presence or absence\n    of each variable.\n\n    For example, boolean function with four variables ``(a, b, c, d)``\n    can contain up to `2^4 = 16` monomials. The 13-th monomial is the\n    product ``a & b & d``, because 13 in binary is 1, 1, 0, 1.\n\n    Parameters\n    ==========\n\n    k : int or list of 1's and 0's\n    variables : list of variables\n\n    Examples\n    ========\n    >>> from sympy.logic.boolalg import bool_monomial\n    >>> from sympy.abc import x, y, z\n    >>> bool_monomial([1, 0, 1], [x, y, z])\n    x & z\n    >>> bool_monomial(6, [x, y, z])\n    x & y\n\n    ",
    "section": "Truth tables and related functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "anf_coeffs",
    "full_id": "sympy.logic.boolalg.anf_coeffs",
    "type": "function",
    "description": "\n    Convert a list of truth values of some boolean expression\n    to the list of coefficients of the polynomial mod 2 (exclusive\n    disjunction) representing the boolean expression in ANF\n    (i.e., the \"Zhegalkin polynomial\").\n\n    There are `2^n` possible Zhegalkin monomials in `n` variables, since\n    each monomial is fully specified by the presence or absence of\n    each variable.\n\n    We can enumerate all the monomials. For example, boolean\n    function with four variables ``(a, b, c, d)`` can contain\n    up to `2^4 = 16` monomials. The 13-th monomial is the\n    product ``a & b & d``, because 13 in binary is 1, 1, 0, 1.\n\n    A given monomial's presence or absence in a polynomial corresponds\n    to that monomial's coefficient being 1 or 0 respectively.\n\n    Examples\n    ========\n    >>> from sympy.logic.boolalg import anf_coeffs, bool_monomial, Xor\n    >>> from sympy.abc import a, b, c\n    >>> truthvalues = [0, 1, 1, 0, 0, 1, 0, 1]\n    >>> coeffs = anf_coeffs(truthvalues)\n    >>> coeffs\n    [0, 1, 1, 0, 0, 0, 1, 0]\n    >>> polynomial = Xor(*[\n    ...     bool_monomial(k, [a, b, c])\n    ...     for k, coeff in enumerate(coeffs) if coeff == 1\n    ... ])\n    >>> polynomial\n    b ^ c ^ (a & b)\n\n    ",
    "section": "Truth tables and related functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "to_int_repr",
    "full_id": "sympy.logic.boolalg.to_int_repr",
    "type": "function",
    "description": "\n    Takes clauses in CNF format and puts them into an integer representation.\n\n    Examples\n    ========\n\n    >>> from sympy.logic.boolalg import to_int_repr\n    >>> from sympy.abc import x, y\n    >>> to_int_repr([x | y, y], [x, y]) == [{1, 2}, {2}]\n    True\n\n    ",
    "section": "Truth tables and related functions",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "satisfiable",
    "full_id": "sympy.logic.inference.satisfiable",
    "type": "function",
    "description": "\n    Check satisfiability of a propositional sentence.\n    Returns a model when it succeeds.\n    Returns {true: true} for trivially true expressions.\n\n    On setting all_models to True, if given expr is satisfiable then\n    returns a generator of models. However, if expr is unsatisfiable\n    then returns a generator containing the single element False.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import A, B\n    >>> from sympy.logic.inference import satisfiable\n    >>> satisfiable(A & ~B)\n    {A: True, B: False}\n    >>> satisfiable(A & ~A)\n    False\n    >>> satisfiable(True)\n    {True: True}\n    >>> next(satisfiable(A & ~A, all_models=True))\n    False\n    >>> models = satisfiable((A >> B) & B, all_models=True)\n    >>> next(models)\n    {A: False, B: True}\n    >>> next(models)\n    {A: True, B: True}\n    >>> def use_models(models):\n    ...     for model in models:\n    ...         if model:\n    ...             # Do something with the model.\n    ...             print(model)\n    ...         else:\n    ...             # Given expr is unsatisfiable.\n    ...             print(\"UNSAT\")\n    >>> use_models(satisfiable(A >> ~A, all_models=True))\n    {A: False}\n    >>> use_models(satisfiable(A ^ A, all_models=True))\n    UNSAT\n\n    ",
    "section": "Inference",
    "url": "https://docs.sympy.org/latest/modules/logic.html"
  },
  {
    "name": "boundary",
    "full_id": "sympy.sets.sets.Set.boundary",
    "type": "property",
    "description": "\n        The boundary or frontier of a set.\n\n        Explanation\n        ===========\n\n        A point x is on the boundary of a set S if\n\n        1.  x is in the closure of S.\n            I.e. Every neighborhood of x contains a point in S.\n        2.  x is not in the interior of S.\n            I.e. There does not exist an open set centered on x contained\n            entirely within S.\n\n        There are the points on the outer rim of S.  If S is open then these\n        points need not actually be contained within S.\n\n        For example, the boundary of an interval is its start and end points.\n        This is true regardless of whether or not the interval is open.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 1).boundary\n        {0, 1}\n        >>> Interval(0, 1, True, False).boundary\n        {0, 1}\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "closure",
    "full_id": "sympy.sets.sets.Set.closure",
    "type": "property",
    "description": "\n        Property method which returns the closure of a set.\n        The closure is defined as the union of the set itself and its\n        boundary.\n\n        Examples\n        ========\n        >>> from sympy import S, Interval\n        >>> S.Reals.closure\n        Reals\n        >>> Interval(0, 1).closure\n        Interval(0, 1)\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "complement",
    "full_id": "sympy.sets.sets.Set.complement",
    "type": "method",
    "description": "\n        The complement of 'self' w.r.t the given universe.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, S\n        >>> Interval(0, 1).complement(S.Reals)\n        Union(Interval.open(-oo, 0), Interval.open(1, oo))\n\n        >>> Interval(0, 1).complement(S.UniversalSet)\n        Complement(UniversalSet, Interval(0, 1))\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.sets.sets.Set.contains",
    "type": "method",
    "description": "\n        Returns a SymPy value indicating whether ``other`` is contained\n        in ``self``: ``true`` if it is, ``false`` if it is not, else\n        an unevaluated ``Contains`` expression (or, as in the case of\n        ConditionSet and a union of FiniteSet/Intervals, an expression\n        indicating the conditions for containment).\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, S\n        >>> from sympy.abc import x\n\n        >>> Interval(0, 1).contains(0.5)\n        True\n\n        As a shortcut it is possible to use the ``in`` operator, but that\n        will raise an error unless an affirmative true or false is not\n        obtained.\n\n        >>> Interval(0, 1).contains(x)\n        (0 <= x) & (x <= 1)\n        >>> x in Interval(0, 1)\n        Traceback (most recent call last):\n        ...\n        TypeError: did not evaluate to a bool: None\n\n        The result of 'in' is a bool, not a SymPy value\n\n        >>> 1 in Interval(0, 2)\n        True\n        >>> _ is S.true\n        False\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "inf",
    "full_id": "sympy.sets.sets.Set.inf",
    "type": "property",
    "description": "\n        The infimum of ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, Union\n        >>> Interval(0, 1).inf\n        0\n        >>> Union(Interval(0, 1), Interval(2, 3)).inf\n        0\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "interior",
    "full_id": "sympy.sets.sets.Set.interior",
    "type": "property",
    "description": "\n        Property method which returns the interior of a set.\n        The interior of a set S consists all points of S that do not\n        belong to the boundary of S.\n\n        Examples\n        ========\n        >>> from sympy import Interval\n        >>> Interval(0, 1).interior\n        Interval.open(0, 1)\n        >>> Interval(0, 1).boundary.interior\n        EmptySet\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "intersect",
    "full_id": "sympy.sets.sets.Set.intersect",
    "type": "method",
    "description": "\n        Returns the intersection of 'self' and 'other'.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n\n        >>> Interval(1, 3).intersect(Interval(1, 2))\n        Interval(1, 2)\n\n        >>> from sympy import imageset, Lambda, symbols, S\n        >>> n, m = symbols('n m')\n        >>> a = imageset(Lambda(n, 2*n), S.Integers)\n        >>> a.intersect(imageset(Lambda(m, 2*m + 1), S.Integers))\n        EmptySet\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.sets.sets.Set.intersection",
    "type": "method",
    "description": "\n        Alias for :meth:`intersect()`\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_closed",
    "full_id": "sympy.sets.sets.Set.is_closed",
    "type": "property",
    "description": "\n        A property method to check whether a set is closed.\n\n        Explanation\n        ===========\n\n        A set is closed if its complement is an open set. The closedness of a\n        subset of the reals is determined with respect to R and its standard\n        topology.\n\n        Examples\n        ========\n        >>> from sympy import Interval\n        >>> Interval(0, 1).is_closed\n        True\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_disjoint",
    "full_id": "sympy.sets.sets.Set.is_disjoint",
    "type": "method",
    "description": "\n        Returns True if ``self`` and ``other`` are disjoint.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 2).is_disjoint(Interval(1, 2))\n        False\n        >>> Interval(0, 2).is_disjoint(Interval(3, 4))\n        True\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Disjoint_sets\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_open",
    "full_id": "sympy.sets.sets.Set.is_open",
    "type": "property",
    "description": "\n        Property method to check whether a set is open.\n\n        Explanation\n        ===========\n\n        A set is open if and only if it has an empty intersection with its\n        boundary. In particular, a subset A of the reals is open if and only\n        if each one of its points is contained in an open interval that is a\n        subset of A.\n\n        Examples\n        ========\n        >>> from sympy import S\n        >>> S.Reals.is_open\n        True\n        >>> S.Rationals.is_open\n        False\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_proper_subset",
    "full_id": "sympy.sets.sets.Set.is_proper_subset",
    "type": "method",
    "description": "\n        Returns True if ``self`` is a proper subset of ``other``.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 0.5).is_proper_subset(Interval(0, 1))\n        True\n        >>> Interval(0, 1).is_proper_subset(Interval(0, 1))\n        False\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_proper_superset",
    "full_id": "sympy.sets.sets.Set.is_proper_superset",
    "type": "method",
    "description": "\n        Returns True if ``self`` is a proper superset of ``other``.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 1).is_proper_superset(Interval(0, 0.5))\n        True\n        >>> Interval(0, 1).is_proper_superset(Interval(0, 1))\n        False\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_subset",
    "full_id": "sympy.sets.sets.Set.is_subset",
    "type": "method",
    "description": "\n        Returns True if ``self`` is a subset of ``other``.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 0.5).is_subset(Interval(0, 1))\n        True\n        >>> Interval(0, 1).is_subset(Interval(0, 1, left_open=True))\n        False\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_superset",
    "full_id": "sympy.sets.sets.Set.is_superset",
    "type": "method",
    "description": "\n        Returns True if ``self`` is a superset of ``other``.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 0.5).is_superset(Interval(0, 1))\n        False\n        >>> Interval(0, 1).is_superset(Interval(0, 1, left_open=True))\n        True\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "isdisjoint",
    "full_id": "sympy.sets.sets.Set.isdisjoint",
    "type": "method",
    "description": "\n        Alias for :meth:`is_disjoint()`\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "issubset",
    "full_id": "sympy.sets.sets.Set.issubset",
    "type": "method",
    "description": "\n        Alias for :meth:`is_subset()`\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "issuperset",
    "full_id": "sympy.sets.sets.Set.issuperset",
    "type": "method",
    "description": "\n        Alias for :meth:`is_superset()`\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "kind",
    "full_id": "sympy.sets.sets.Set.kind",
    "type": "property",
    "description": "\n        The kind of a Set\n\n        Explanation\n        ===========\n\n        Any :class:`Set` will have kind :class:`SetKind` which is\n        parametrised by the kind of the elements of the set. For example\n        most sets are sets of numbers and will have kind\n        ``SetKind(NumberKind)``. If elements of sets are different in kind than\n        their kind will ``SetKind(UndefinedKind)``. See\n        :class:`sympy.core.kind.Kind` for an explanation of the kind system.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, Matrix, FiniteSet, EmptySet, ProductSet, PowerSet\n\n        >>> FiniteSet(Matrix([1, 2])).kind\n        SetKind(MatrixKind(NumberKind))\n\n        >>> Interval(1, 2).kind\n        SetKind(NumberKind)\n\n        >>> EmptySet.kind\n        SetKind()\n\n        A :class:`sympy.sets.powerset.PowerSet` is a set of sets:\n\n        >>> PowerSet({1, 2, 3}).kind\n        SetKind(SetKind(NumberKind))\n\n        A :class:`ProductSet` represents the set of tuples of elements of\n        other sets. Its kind is :class:`sympy.core.containers.TupleKind`\n        parametrised by the kinds of the elements of those sets:\n\n        >>> p = ProductSet(FiniteSet(1, 2), FiniteSet(3, 4))\n        >>> list(p)\n        [(1, 3), (2, 3), (1, 4), (2, 4)]\n        >>> p.kind\n        SetKind(TupleKind(NumberKind, NumberKind))\n\n        When all elements of the set do not have same kind, the kind\n        will be returned as ``SetKind(UndefinedKind)``:\n\n        >>> FiniteSet(0, Matrix([1, 2])).kind\n        SetKind(UndefinedKind)\n\n        The kind of the elements of a set are given by the ``element_kind``\n        attribute of ``SetKind``:\n\n        >>> Interval(1, 2).kind.element_kind\n        NumberKind\n\n        See Also\n        ========\n\n        NumberKind\n        sympy.core.kind.UndefinedKind\n        sympy.core.containers.TupleKind\n        MatrixKind\n        sympy.matrices.expressions.sets.MatrixSet\n        sympy.sets.conditionset.ConditionSet\n        Rationals\n        Naturals\n        Integers\n        sympy.sets.fancysets.ImageSet\n        sympy.sets.fancysets.Range\n        sympy.sets.fancysets.ComplexRegion\n        sympy.sets.powerset.PowerSet\n        sympy.sets.sets.ProductSet\n        sympy.sets.sets.Interval\n        sympy.sets.sets.Union\n        sympy.sets.sets.Intersection\n        sympy.sets.sets.Complement\n        sympy.sets.sets.EmptySet\n        sympy.sets.sets.UniversalSet\n        sympy.sets.sets.FiniteSet\n        sympy.sets.sets.SymmetricDifference\n        sympy.sets.sets.DisjointUnion\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "measure",
    "full_id": "sympy.sets.sets.Set.measure",
    "type": "property",
    "description": "\n        The (Lebesgue) measure of ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, Union\n        >>> Interval(0, 1).measure\n        1\n        >>> Union(Interval(0, 1), Interval(2, 3)).measure\n        2\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "powerset",
    "full_id": "sympy.sets.sets.Set.powerset",
    "type": "method",
    "description": "\n        Find the Power set of ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy import EmptySet, FiniteSet, Interval\n\n        A power set of an empty set:\n\n        >>> A = EmptySet\n        >>> A.powerset()\n        {EmptySet}\n\n        A power set of a finite set:\n\n        >>> A = FiniteSet(1, 2)\n        >>> a, b, c = FiniteSet(1), FiniteSet(2), FiniteSet(1, 2)\n        >>> A.powerset() == FiniteSet(a, b, c, EmptySet)\n        True\n\n        A power set of an interval:\n\n        >>> Interval(1, 2).powerset()\n        PowerSet(Interval(1, 2))\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Power_set\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "sup",
    "full_id": "sympy.sets.sets.Set.sup",
    "type": "property",
    "description": "\n        The supremum of ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, Union\n        >>> Interval(0, 1).sup\n        1\n        >>> Union(Interval(0, 1), Interval(2, 3)).sup\n        3\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "symmetric_difference",
    "full_id": "sympy.sets.sets.Set.symmetric_difference",
    "type": "method",
    "description": "\n        Returns symmetric difference of ``self`` and ``other``.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, S\n        >>> Interval(1, 3).symmetric_difference(S.Reals)\n        Union(Interval.open(-oo, 1), Interval.open(3, oo))\n        >>> Interval(1, 10).symmetric_difference(S.Reals)\n        Union(Interval.open(-oo, 1), Interval.open(10, oo))\n\n        >>> from sympy import S, EmptySet\n        >>> S.Reals.symmetric_difference(EmptySet)\n        Reals\n\n        References\n        ==========\n        .. [1] https://en.wikipedia.org/wiki/Symmetric_difference\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "union",
    "full_id": "sympy.sets.sets.Set.union",
    "type": "method",
    "description": "\n        Returns the union of ``self`` and ``other``.\n\n        Examples\n        ========\n\n        As a shortcut it is possible to use the ``+`` operator:\n\n        >>> from sympy import Interval, FiniteSet\n        >>> Interval(0, 1).union(Interval(2, 3))\n        Union(Interval(0, 1), Interval(2, 3))\n        >>> Interval(0, 1) + Interval(2, 3)\n        Union(Interval(0, 1), Interval(2, 3))\n        >>> Interval(1, 2, True, True) + FiniteSet(2, 3)\n        Union({3}, Interval.Lopen(1, 2))\n\n        Similarly it is possible to use the ``-`` operator for set differences:\n\n        >>> Interval(0, 2) - Interval(0, 1)\n        Interval.Lopen(1, 2)\n        >>> Interval(1, 3) - FiniteSet(2)\n        Union(Interval.Ropen(1, 2), Interval.Lopen(2, 3))\n\n        ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "imageset",
    "full_id": "sympy.sets.sets.imageset",
    "type": "function",
    "description": "\n    Return an image of the set under transformation ``f``.\n\n    Explanation\n    ===========\n\n    If this function cannot compute the image, it returns an\n    unevaluated ImageSet object.\n\n    .. math::\n        \\{ f(x) \\mid x \\in \\mathrm{self} \\}\n\n    Examples\n    ========\n\n    >>> from sympy import S, Interval, imageset, sin, Lambda\n    >>> from sympy.abc import x\n\n    >>> imageset(x, 2*x, Interval(0, 2))\n    Interval(0, 4)\n\n    >>> imageset(lambda x: 2*x, Interval(0, 2))\n    Interval(0, 4)\n\n    >>> imageset(Lambda(x, sin(x)), Interval(-2, 1))\n    ImageSet(Lambda(x, sin(x)), Interval(-2, 1))\n\n    >>> imageset(sin, Interval(-2, 1))\n    ImageSet(Lambda(x, sin(x)), Interval(-2, 1))\n    >>> imageset(lambda y: x + y, Interval(-2, 1))\n    ImageSet(Lambda(y, x + y), Interval(-2, 1))\n\n    Expressions applied to the set of Integers are simplified\n    to show as few negatives as possible and linear expressions\n    are converted to a canonical form. If this is not desirable\n    then the unevaluated ImageSet should be used.\n\n    >>> imageset(x, -2*x + 5, S.Integers)\n    ImageSet(Lambda(x, 2*x + 1), Integers)\n\n    See Also\n    ========\n\n    sympy.sets.fancysets.ImageSet\n\n    ",
    "section": "Basic Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "Lopen",
    "full_id": "sympy.sets.sets.Interval.Lopen",
    "type": "method",
    "description": "Return an interval not including the left boundary.",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "Ropen",
    "full_id": "sympy.sets.sets.Interval.Ropen",
    "type": "method",
    "description": "Return an interval not including the right boundary.",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "as_relational",
    "full_id": "sympy.sets.sets.Interval.as_relational",
    "type": "method",
    "description": "Rewrite an interval in terms of inequalities and logic operators.",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "end",
    "full_id": "sympy.sets.sets.Interval.end",
    "type": "property",
    "description": "\n        The right end point of the interval.\n\n        This property takes the same value as the ``sup`` property.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 1).end\n        1\n\n        ",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_left_unbounded",
    "full_id": "sympy.sets.sets.Interval.is_left_unbounded",
    "type": "property",
    "description": "Return ``True`` if the left endpoint is negative infinity.",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_right_unbounded",
    "full_id": "sympy.sets.sets.Interval.is_right_unbounded",
    "type": "property",
    "description": "Return ``True`` if the right endpoint is positive infinity.",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "left_open",
    "full_id": "sympy.sets.sets.Interval.left_open",
    "type": "property",
    "description": "\n        True if interval is left-open.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 1, left_open=True).left_open\n        True\n        >>> Interval(0, 1, left_open=False).left_open\n        False\n\n        ",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "open",
    "full_id": "sympy.sets.sets.Interval.open",
    "type": "method",
    "description": "Return an interval including neither boundary.",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "right_open",
    "full_id": "sympy.sets.sets.Interval.right_open",
    "type": "property",
    "description": "\n        True if interval is right-open.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 1, right_open=True).right_open\n        True\n        >>> Interval(0, 1, right_open=False).right_open\n        False\n\n        ",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "start",
    "full_id": "sympy.sets.sets.Interval.start",
    "type": "property",
    "description": "\n        The left end point of the interval.\n\n        This property takes the same value as the ``inf`` property.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval\n        >>> Interval(0, 1).start\n        0\n\n        ",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "as_relational",
    "full_id": "sympy.sets.sets.FiniteSet.as_relational",
    "type": "method",
    "description": "Rewrite a FiniteSet in terms of equalities and logic operators.",
    "section": "Elementary Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "as_relational",
    "full_id": "sympy.sets.sets.Union.as_relational",
    "type": "method",
    "description": "Rewrite a Union in terms of equalities and logic operators.",
    "section": "Compound Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "as_relational",
    "full_id": "sympy.sets.sets.Intersection.as_relational",
    "type": "method",
    "description": "Rewrite an Intersection in terms of equalities and logic operators",
    "section": "Compound Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "is_iterable",
    "full_id": "sympy.sets.sets.ProductSet.is_iterable",
    "type": "property",
    "description": "\n        A property method which tests whether a set is iterable or not.\n        Returns True if set is iterable, otherwise returns False.\n\n        Examples\n        ========\n\n        >>> from sympy import FiniteSet, Interval\n        >>> I = Interval(0, 1)\n        >>> A = FiniteSet(1, 2, 3, 4, 5)\n        >>> I.is_iterable\n        False\n        >>> A.is_iterable\n        True\n\n        ",
    "section": "Compound Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "as_relational",
    "full_id": "sympy.sets.sets.Complement.as_relational",
    "type": "method",
    "description": "Rewrite a complement in terms of equalities and logic\n        operators",
    "section": "Compound Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "reduce",
    "full_id": "sympy.sets.sets.Complement.reduce",
    "type": "method",
    "description": "\n        Simplify a :class:`Complement`.\n\n        ",
    "section": "Compound Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "as_relational",
    "full_id": "sympy.sets.sets.SymmetricDifference.as_relational",
    "type": "method",
    "description": "Rewrite a symmetric_difference in terms of equalities and\n        logic operators",
    "section": "Compound Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "as_relational",
    "full_id": "sympy.sets.fancysets.Range.as_relational",
    "type": "method",
    "description": "Rewrite a Range in terms of equalities and logic operators.",
    "section": "Special Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "reversed",
    "full_id": "sympy.sets.fancysets.Range.reversed",
    "type": "property",
    "description": "Return an equivalent Range in the opposite order.\n\n        Examples\n        ========\n\n        >>> from sympy import Range\n        >>> Range(10).reversed\n        Range(9, -1, -1)\n        ",
    "section": "Special Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "a_interval",
    "full_id": "sympy.sets.fancysets.ComplexRegion.a_interval",
    "type": "property",
    "description": "\n        Return the union of intervals of `x` when, self is in\n        rectangular form, or the union of intervals of `r` when\n        self is in polar form.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, ComplexRegion, Union\n        >>> a = Interval(2, 3)\n        >>> b = Interval(4, 5)\n        >>> c = Interval(1, 7)\n        >>> C1 = ComplexRegion(a*b)\n        >>> C1.a_interval\n        Interval(2, 3)\n        >>> C2 = ComplexRegion(Union(a*b, b*c))\n        >>> C2.a_interval\n        Union(Interval(2, 3), Interval(4, 5))\n\n        ",
    "section": "Special Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "b_interval",
    "full_id": "sympy.sets.fancysets.ComplexRegion.b_interval",
    "type": "property",
    "description": "\n        Return the union of intervals of `y` when, self is in\n        rectangular form, or the union of intervals of `theta`\n        when self is in polar form.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, ComplexRegion, Union\n        >>> a = Interval(2, 3)\n        >>> b = Interval(4, 5)\n        >>> c = Interval(1, 7)\n        >>> C1 = ComplexRegion(a*b)\n        >>> C1.b_interval\n        Interval(4, 5)\n        >>> C2 = ComplexRegion(Union(a*b, b*c))\n        >>> C2.b_interval\n        Interval(1, 7)\n\n        ",
    "section": "Special Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "from_real",
    "full_id": "sympy.sets.fancysets.ComplexRegion.from_real",
    "type": "method",
    "description": "\n        Converts given subset of real numbers to a complex region.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, ComplexRegion\n        >>> unit = Interval(0,1)\n        >>> ComplexRegion.from_real(unit)\n        CartesianComplexRegion(ProductSet(Interval(0, 1), {0}))\n\n        ",
    "section": "Special Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "psets",
    "full_id": "sympy.sets.fancysets.ComplexRegion.psets",
    "type": "property",
    "description": "\n        Return a tuple of sets (ProductSets) input of the self.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, ComplexRegion, Union\n        >>> a = Interval(2, 3)\n        >>> b = Interval(4, 5)\n        >>> c = Interval(1, 7)\n        >>> C1 = ComplexRegion(a*b)\n        >>> C1.psets\n        (ProductSet(Interval(2, 3), Interval(4, 5)),)\n        >>> C2 = ComplexRegion(Union(a*b, b*c))\n        >>> C2.psets\n        (ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))\n\n        ",
    "section": "Special Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "sets",
    "full_id": "sympy.sets.fancysets.ComplexRegion.sets",
    "type": "property",
    "description": "\n        Return raw input sets to the self.\n\n        Examples\n        ========\n\n        >>> from sympy import Interval, ComplexRegion, Union\n        >>> a = Interval(2, 3)\n        >>> b = Interval(4, 5)\n        >>> c = Interval(1, 7)\n        >>> C1 = ComplexRegion(a*b)\n        >>> C1.sets\n        ProductSet(Interval(2, 3), Interval(4, 5))\n        >>> C2 = ComplexRegion(Union(a*b, b*c))\n        >>> C2.sets\n        Union(ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))\n\n        ",
    "section": "Special Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "normalize_theta_set",
    "full_id": "sympy.sets.fancysets.normalize_theta_set",
    "type": "function",
    "description": "\n    Normalize a Real Set `theta` in the interval `[0, 2\\pi)`. It returns\n    a normalized value of theta in the Set. For Interval, a maximum of\n    one cycle $[0, 2\\pi]$, is returned i.e. for theta equal to $[0, 10\\pi]$,\n    returned normalized value would be $[0, 2\\pi)$. As of now intervals\n    with end points as non-multiples of ``pi`` is not supported.\n\n    Raises\n    ======\n\n    NotImplementedError\n        The algorithms for Normalizing theta Set are not yet\n        implemented.\n    ValueError\n        The input is not valid, i.e. the input is not a real set.\n    RuntimeError\n        It is a bug, please report to the github issue tracker.\n\n    Examples\n    ========\n\n    >>> from sympy.sets.fancysets import normalize_theta_set\n    >>> from sympy import Interval, FiniteSet, pi\n    >>> normalize_theta_set(Interval(9*pi/2, 5*pi))\n    Interval(pi/2, pi)\n    >>> normalize_theta_set(Interval(-3*pi/2, pi/2))\n    Interval.Ropen(0, 2*pi)\n    >>> normalize_theta_set(Interval(-pi/2, pi/2))\n    Union(Interval(0, pi/2), Interval.Ropen(3*pi/2, 2*pi))\n    >>> normalize_theta_set(Interval(-4*pi, 3*pi))\n    Interval.Ropen(0, 2*pi)\n    >>> normalize_theta_set(Interval(-3*pi/2, -pi/2))\n    Interval(pi/2, 3*pi/2)\n    >>> normalize_theta_set(FiniteSet(0, pi, 3*pi))\n    {0, pi}\n\n    ",
    "section": "Special Sets",
    "url": "https://docs.sympy.org/latest/modules/sets.html"
  },
  {
    "name": "C",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.C",
    "type": "property",
    "description": "By-element conjugation",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "D",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.D",
    "type": "property",
    "description": "Return Dirac conjugate (if ``self.rows == 4``).\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, I, eye\n        >>> m = Matrix((0, 1 + I, 2, 3))\n        >>> m.D\n        Matrix([[0, 1 - I, -2, -3]])\n        >>> m = (eye(4) + I*eye(4))\n        >>> m[0, 3] = 2\n        >>> m.D\n        Matrix([\n        [1 - I,     0,      0,      0],\n        [    0, 1 - I,      0,      0],\n        [    0,     0, -1 + I,      0],\n        [    2,     0,      0, -1 + I]])\n\n        If the matrix does not have 4 rows an AttributeError will be raised\n        because this property is only defined for matrices with 4 rows.\n\n        >>> Matrix(eye(2)).D\n        Traceback (most recent call last):\n        ...\n        AttributeError: Matrix has no attribute D.\n\n        See Also\n        ========\n\n        sympy.matrices.matrixbase.MatrixBase.conjugate: By-element conjugation\n        sympy.matrices.matrixbase.MatrixBase.H: Hermite conjugation\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "H",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.H",
    "type": "property",
    "description": "Return Hermite conjugate.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, I\n        >>> m = Matrix((0, 1 + I, 2, 3))\n        >>> m\n        Matrix([\n        [    0],\n        [1 + I],\n        [    2],\n        [    3]])\n        >>> m.H\n        Matrix([[0, 1 - I, 2, 3]])\n\n        See Also\n        ========\n\n        conjugate: By-element conjugation\n        sympy.matrices.matrixbase.MatrixBase.D: Dirac conjugation\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "LDLdecomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.LDLdecomposition",
    "type": "method",
    "description": "Returns the LDL Decomposition (L, D) of matrix A,\n    such that L * D * L.H == A if hermitian flag is True, or\n    L * D * L.T == A if hermitian is False.\n    This method eliminates the use of square root.\n    Further this ensures that all the diagonal entries of L are 1.\n    A must be a Hermitian positive-definite matrix if hermitian is True,\n    or a symmetric matrix otherwise.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, eye\n    >>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))\n    >>> L, D = A.LDLdecomposition()\n    >>> L\n    Matrix([\n    [   1,   0, 0],\n    [ 3/5,   1, 0],\n    [-1/5, 1/3, 1]])\n    >>> D\n    Matrix([\n    [25, 0, 0],\n    [ 0, 9, 0],\n    [ 0, 0, 9]])\n    >>> L * D * L.T * A.inv() == eye(A.rows)\n    True\n\n    The matrix can have complex entries:\n\n    >>> from sympy import I\n    >>> A = Matrix(((9, 3*I), (-3*I, 5)))\n    >>> L, D = A.LDLdecomposition()\n    >>> L\n    Matrix([\n    [   1, 0],\n    [-I/3, 1]])\n    >>> D\n    Matrix([\n    [9, 0],\n    [0, 4]])\n    >>> L*D*L.H == A\n    True\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.cholesky\n    sympy.matrices.matrixbase.MatrixBase.LUdecomposition\n    QRdecomposition\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "LDLsolve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.LDLsolve",
    "type": "method",
    "description": "Solves ``Ax = B`` using LDL decomposition,\n    for a general square and non-singular matrix.\n\n    For a non-square matrix with rows > cols,\n    the least squares solution is returned.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, eye\n    >>> A = eye(2)*2\n    >>> B = Matrix([[1, 2], [3, 4]])\n    >>> A.LDLsolve(B) == B/2\n    True\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.LDLdecomposition\n    sympy.matrices.dense.DenseMatrix.lower_triangular_solve\n    sympy.matrices.dense.DenseMatrix.upper_triangular_solve\n    gauss_jordan_solve\n    cholesky_solve\n    diagonal_solve\n    LUsolve\n    QRsolve\n    pinv_solve\n    cramer_solve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "LUdecomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.LUdecomposition",
    "type": "method",
    "description": "Returns (L, U, perm) where L is a lower triangular matrix with unit\n    diagonal, U is an upper triangular matrix, and perm is a list of row\n    swap index pairs. If A is the original matrix, then\n    ``A = (L*U).permuteBkwd(perm)``, and the row permutation matrix P such\n    that $P A = L U$ can be computed by ``P = eye(A.rows).permuteFwd(perm)``.\n\n    See documentation for LUCombined for details about the keyword argument\n    rankcheck, iszerofunc, and simpfunc.\n\n    Parameters\n    ==========\n\n    rankcheck : bool, optional\n        Determines if this function should detect the rank\n        deficiency of the matrixis and should raise a\n        ``ValueError``.\n\n    iszerofunc : function, optional\n        A function which determines if a given expression is zero.\n\n        The function should be a callable that takes a single\n        SymPy expression and returns a 3-valued boolean value\n        ``True``, ``False``, or ``None``.\n\n        It is internally used by the pivot searching algorithm.\n        See the notes section for a more information about the\n        pivot searching algorithm.\n\n    simpfunc : function or None, optional\n        A function that simplifies the input.\n\n        If this is specified as a function, this function should be\n        a callable that takes a single SymPy expression and returns\n        an another SymPy expression that is algebraically\n        equivalent.\n\n        If ``None``, it indicates that the pivot search algorithm\n        should not attempt to simplify any candidate pivots.\n\n        It is internally used by the pivot searching algorithm.\n        See the notes section for a more information about the\n        pivot searching algorithm.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> a = Matrix([[4, 3], [6, 3]])\n    >>> L, U, _ = a.LUdecomposition()\n    >>> L\n    Matrix([\n    [  1, 0],\n    [3/2, 1]])\n    >>> U\n    Matrix([\n    [4,    3],\n    [0, -3/2]])\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.cholesky\n    sympy.matrices.dense.DenseMatrix.LDLdecomposition\n    QRdecomposition\n    LUdecomposition_Simple\n    LUdecompositionFF\n    LUsolve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "LUdecompositionFF",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.LUdecompositionFF",
    "type": "method",
    "description": "Compute a fraction-free LU decomposition.\n\n    Returns 4 matrices P, L, D, U such that PA = L D**-1 U.\n    If the elements of the matrix belong to some integral domain I, then all\n    elements of L, D and U are guaranteed to belong to I.\n\n    See Also\n    ========\n\n    sympy.matrices.matrixbase.MatrixBase.LUdecomposition\n    LUdecomposition_Simple\n    LUsolve\n\n    References\n    ==========\n\n    .. [1] W. Zhou & D.J. Jeffrey, \"Fraction-free matrix factors: new forms\n        for LU and QR factors\". Frontiers in Computer Science in China,\n        Vol 2, no. 1, pp. 67-80, 2008.\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "LUdecomposition_Simple",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.LUdecomposition_Simple",
    "type": "method",
    "description": "Compute the PLU decomposition of the matrix.\n\n    Parameters\n    ==========\n\n    rankcheck : bool, optional\n        Determines if this function should detect the rank\n        deficiency of the matrixis and should raise a\n        ``ValueError``.\n\n    iszerofunc : function, optional\n        A function which determines if a given expression is zero.\n\n        The function should be a callable that takes a single\n        SymPy expression and returns a 3-valued boolean value\n        ``True``, ``False``, or ``None``.\n\n        It is internally used by the pivot searching algorithm.\n        See the notes section for a more information about the\n        pivot searching algorithm.\n\n    simpfunc : function or None, optional\n        A function that simplifies the input.\n\n        If this is specified as a function, this function should be\n        a callable that takes a single SymPy expression and returns\n        an another SymPy expression that is algebraically\n        equivalent.\n\n        If ``None``, it indicates that the pivot search algorithm\n        should not attempt to simplify any candidate pivots.\n\n        It is internally used by the pivot searching algorithm.\n        See the notes section for a more information about the\n        pivot searching algorithm.\n\n    Returns\n    =======\n\n    (lu, row_swaps) : (Matrix, list)\n        If the original matrix is a $m, n$ matrix:\n\n        *lu* is a $m, n$ matrix, which contains result of the\n        decomposition in a compressed form. See the notes section\n        to see how the matrix is compressed.\n\n        *row_swaps* is a $m$-element list where each element is a\n        pair of row exchange indices.\n\n        ``A = (L*U).permute_backward(perm)``, and the row\n        permutation matrix $P$ from the formula $P A = L U$ can be\n        computed by ``P=eye(A.row).permute_forward(perm)``.\n\n    Raises\n    ======\n\n    ValueError\n        Raised if ``rankcheck=True`` and the matrix is found to\n        be rank deficient during the computation.\n\n    Notes\n    =====\n\n    About the PLU decomposition:\n\n    PLU decomposition is a generalization of a LU decomposition\n    which can be extended for rank-deficient matrices.\n\n    It can further be generalized for non-square matrices, and this\n    is the notation that SymPy is using.\n\n    PLU decomposition is a decomposition of a $m, n$ matrix $A$ in\n    the form of $P A = L U$ where\n\n    * $L$ is a $m, m$ lower triangular matrix with unit diagonal\n        entries.\n    * $U$ is a $m, n$ upper triangular matrix.\n    * $P$ is a $m, m$ permutation matrix.\n\n    So, for a square matrix, the decomposition would look like:\n\n    .. math::\n        L = \\begin{bmatrix}\n        1 & 0 & 0 & \\cdots & 0 \\\\\n        L_{1, 0} & 1 & 0 & \\cdots & 0 \\\\\n        L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & 1\n        \\end{bmatrix}\n\n    .. math::\n        U = \\begin{bmatrix}\n        U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n        0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n        0 & 0 & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        0 & 0 & 0 & \\cdots & U_{n-1, n-1}\n        \\end{bmatrix}\n\n    And for a matrix with more rows than the columns,\n    the decomposition would look like:\n\n    .. math::\n        L = \\begin{bmatrix}\n        1 & 0 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n        L_{1, 0} & 1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n        L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\ddots\n        & \\vdots \\\\\n        L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & 1 & 0\n        & \\cdots & 0 \\\\\n        L_{n, 0} & L_{n, 1} & L_{n, 2} & \\cdots & L_{n, n-1} & 1\n        & \\cdots & 0 \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots\n        & \\ddots & \\vdots \\\\\n        L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & L_{m-1, n-1}\n        & 0 & \\cdots & 1 \\\\\n        \\end{bmatrix}\n\n    .. math::\n        U = \\begin{bmatrix}\n        U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n        0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n        0 & 0 & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        0 & 0 & 0 & \\cdots & U_{n-1, n-1} \\\\\n        0 & 0 & 0 & \\cdots & 0 \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        0 & 0 & 0 & \\cdots & 0\n        \\end{bmatrix}\n\n    Finally, for a matrix with more columns than the rows, the\n    decomposition would look like:\n\n    .. math::\n        L = \\begin{bmatrix}\n        1 & 0 & 0 & \\cdots & 0 \\\\\n        L_{1, 0} & 1 & 0 & \\cdots & 0 \\\\\n        L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & 1\n        \\end{bmatrix}\n\n    .. math::\n        U = \\begin{bmatrix}\n        U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, m-1}\n        & \\cdots & U_{0, n-1} \\\\\n        0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, m-1}\n        & \\cdots & U_{1, n-1} \\\\\n        0 & 0 & U_{2, 2} & \\cdots & U_{2, m-1}\n        & \\cdots & U_{2, n-1} \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\n        & \\cdots & \\vdots \\\\\n        0 & 0 & 0 & \\cdots & U_{m-1, m-1}\n        & \\cdots & U_{m-1, n-1} \\\\\n        \\end{bmatrix}\n\n    About the compressed LU storage:\n\n    The results of the decomposition are often stored in compressed\n    forms rather than returning $L$ and $U$ matrices individually.\n\n    It may be less intiuitive, but it is commonly used for a lot of\n    numeric libraries because of the efficiency.\n\n    The storage matrix is defined as following for this specific\n    method:\n\n    * The subdiagonal elements of $L$ are stored in the subdiagonal\n        portion of $LU$, that is $LU_{i, j} = L_{i, j}$ whenever\n        $i > j$.\n    * The elements on the diagonal of $L$ are all 1, and are not\n        explicitly stored.\n    * $U$ is stored in the upper triangular portion of $LU$, that is\n        $LU_{i, j} = U_{i, j}$ whenever $i <= j$.\n    * For a case of $m > n$, the right side of the $L$ matrix is\n        trivial to store.\n    * For a case of $m < n$, the below side of the $U$ matrix is\n        trivial to store.\n\n    So, for a square matrix, the compressed output matrix would be:\n\n    .. math::\n        LU = \\begin{bmatrix}\n        U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n        L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n        L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & U_{n-1, n-1}\n        \\end{bmatrix}\n\n    For a matrix with more rows than the columns, the compressed\n    output matrix would be:\n\n    .. math::\n        LU = \\begin{bmatrix}\n        U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n        L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n        L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots\n        & U_{n-1, n-1} \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots\n        & L_{m-1, n-1} \\\\\n        \\end{bmatrix}\n\n    For a matrix with more columns than the rows, the compressed\n    output matrix would be:\n\n    .. math::\n        LU = \\begin{bmatrix}\n        U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, m-1}\n        & \\cdots & U_{0, n-1} \\\\\n        L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, m-1}\n        & \\cdots & U_{1, n-1} \\\\\n        L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, m-1}\n        & \\cdots & U_{2, n-1} \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\n        & \\cdots & \\vdots \\\\\n        L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & U_{m-1, m-1}\n        & \\cdots & U_{m-1, n-1} \\\\\n        \\end{bmatrix}\n\n    About the pivot searching algorithm:\n\n    When a matrix contains symbolic entries, the pivot search algorithm\n    differs from the case where every entry can be categorized as zero or\n    nonzero.\n    The algorithm searches column by column through the submatrix whose\n    top left entry coincides with the pivot position.\n    If it exists, the pivot is the first entry in the current search\n    column that iszerofunc guarantees is nonzero.\n    If no such candidate exists, then each candidate pivot is simplified\n    if simpfunc is not None.\n    The search is repeated, with the difference that a candidate may be\n    the pivot if ``iszerofunc()`` cannot guarantee that it is nonzero.\n    In the second search the pivot is the first candidate that\n    iszerofunc can guarantee is nonzero.\n    If no such candidate exists, then the pivot is the first candidate\n    for which iszerofunc returns None.\n    If no such candidate exists, then the search is repeated in the next\n    column to the right.\n    The pivot search algorithm differs from the one in ``rref()``, which\n    relies on ``_find_reasonable_pivot()``.\n    Future versions of ``LUdecomposition_simple()`` may use\n    ``_find_reasonable_pivot()``.\n\n    See Also\n    ========\n\n    sympy.matrices.matrixbase.MatrixBase.LUdecomposition\n    LUdecompositionFF\n    LUsolve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "LUsolve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.LUsolve",
    "type": "method",
    "description": "Solve the linear system ``Ax = rhs`` for ``x`` where ``A = M``.\n\n    This is for symbolic matrices, for real or complex ones use\n    mpmath.lu_solve or mpmath.qr_solve.\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.lower_triangular_solve\n    sympy.matrices.dense.DenseMatrix.upper_triangular_solve\n    gauss_jordan_solve\n    cholesky_solve\n    diagonal_solve\n    LDLsolve\n    QRsolve\n    pinv_solve\n    LUdecomposition\n    cramer_solve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "QRdecomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.QRdecomposition",
    "type": "method",
    "description": "Returns a QR decomposition.\n\n    Explanation\n    ===========\n\n    A QR decomposition is a decomposition in the form $A = Q R$\n    where\n\n    - $Q$ is a column orthogonal matrix.\n    - $R$ is a upper triangular (trapezoidal) matrix.\n\n    A column orthogonal matrix satisfies\n    $\\mathbb{I} = Q^H Q$ while a full orthogonal matrix satisfies\n    relation $\\mathbb{I} = Q Q^H = Q^H Q$ where $I$ is an identity\n    matrix with matching dimensions.\n\n    For matrices which are not square or are rank-deficient, it is\n    sufficient to return a column orthogonal matrix because augmenting\n    them may introduce redundant computations.\n    And an another advantage of this is that you can easily inspect the\n    matrix rank by counting the number of columns of $Q$.\n\n    If you want to augment the results to return a full orthogonal\n    decomposition, you should use the following procedures.\n\n    - Augment the $Q$ matrix with columns that are orthogonal to every\n      other columns and make it square.\n    - Augment the $R$ matrix with zero rows to make it have the same\n      shape as the original matrix.\n\n    The procedure will be illustrated in the examples section.\n\n    Examples\n    ========\n\n    A full rank matrix example:\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])\n    >>> Q, R = A.QRdecomposition()\n    >>> Q\n    Matrix([\n    [ 6/7, -69/175, -58/175],\n    [ 3/7, 158/175,   6/175],\n    [-2/7,    6/35,  -33/35]])\n    >>> R\n    Matrix([\n    [14,  21, -14],\n    [ 0, 175, -70],\n    [ 0,   0,  35]])\n\n    If the matrix is square and full rank, the $Q$ matrix becomes\n    orthogonal in both directions, and needs no augmentation.\n\n    >>> Q * Q.H\n    Matrix([\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]])\n    >>> Q.H * Q\n    Matrix([\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]])\n\n    >>> A == Q*R\n    True\n\n    A rank deficient matrix example:\n\n    >>> A = Matrix([[12, -51, 0], [6, 167, 0], [-4, 24, 0]])\n    >>> Q, R = A.QRdecomposition()\n    >>> Q\n    Matrix([\n    [ 6/7, -69/175],\n    [ 3/7, 158/175],\n    [-2/7,    6/35]])\n    >>> R\n    Matrix([\n    [14,  21, 0],\n    [ 0, 175, 0]])\n\n    QRdecomposition might return a matrix Q that is rectangular.\n    In this case the orthogonality condition might be satisfied as\n    $\\mathbb{I} = Q.H*Q$ but not in the reversed product\n    $\\mathbb{I} = Q * Q.H$.\n\n    >>> Q.H * Q\n    Matrix([\n    [1, 0],\n    [0, 1]])\n    >>> Q * Q.H\n    Matrix([\n    [27261/30625,   348/30625, -1914/6125],\n    [  348/30625, 30589/30625,   198/6125],\n    [ -1914/6125,    198/6125,   136/1225]])\n\n    If you want to augment the results to be a full orthogonal\n    decomposition, you should augment $Q$ with an another orthogonal\n    column.\n\n    You are able to append an identity matrix,\n    and you can run the Gram-Schmidt\n    process to make them augmented as orthogonal basis.\n\n    >>> Q_aug = Q.row_join(Matrix.eye(3))\n    >>> Q_aug = Q_aug.QRdecomposition()[0]\n    >>> Q_aug\n    Matrix([\n    [ 6/7, -69/175, 58/175],\n    [ 3/7, 158/175, -6/175],\n    [-2/7,    6/35,  33/35]])\n    >>> Q_aug.H * Q_aug\n    Matrix([\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]])\n    >>> Q_aug * Q_aug.H\n    Matrix([\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]])\n\n    Augmenting the $R$ matrix with zero row is straightforward.\n\n    >>> R_aug = R.col_join(Matrix([[0, 0, 0]]))\n    >>> R_aug\n    Matrix([\n    [14,  21, 0],\n    [ 0, 175, 0],\n    [ 0,   0, 0]])\n    >>> Q_aug * R_aug == A\n    True\n\n    A zero matrix example:\n\n    >>> from sympy import Matrix\n    >>> A = Matrix.zeros(3, 4)\n    >>> Q, R = A.QRdecomposition()\n\n    They may return matrices with zero rows and columns.\n\n    >>> Q\n    Matrix(3, 0, [])\n    >>> R\n    Matrix(0, 4, [])\n    >>> Q*R\n    Matrix([\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0]])\n\n    As the same augmentation rule described above, $Q$ can be augmented\n    with columns of an identity matrix and $R$ can be augmented with\n    rows of a zero matrix.\n\n    >>> Q_aug = Q.row_join(Matrix.eye(3))\n    >>> R_aug = R.col_join(Matrix.zeros(3, 4))\n    >>> Q_aug * Q_aug.T\n    Matrix([\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]])\n    >>> R_aug\n    Matrix([\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0]])\n    >>> Q_aug * R_aug == A\n    True\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.cholesky\n    sympy.matrices.dense.DenseMatrix.LDLdecomposition\n    sympy.matrices.matrixbase.MatrixBase.LUdecomposition\n    QRsolve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "QRsolve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.QRsolve",
    "type": "method",
    "description": "Solve the linear system ``Ax = b``.\n\n    ``M`` is the matrix ``A``, the method argument is the vector\n    ``b``.  The method returns the solution vector ``x``.  If ``b`` is a\n    matrix, the system is solved for each column of ``b`` and the\n    return value is a matrix of the same shape as ``b``.\n\n    This method is slower (approximately by a factor of 2) but\n    more stable for floating-point arithmetic than the LUsolve method.\n    However, LUsolve usually uses an exact arithmetic, so you do not need\n    to use QRsolve.\n\n    This is mainly for educational purposes and symbolic matrices, for real\n    (or complex) matrices use mpmath.qr_solve.\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.lower_triangular_solve\n    sympy.matrices.dense.DenseMatrix.upper_triangular_solve\n    gauss_jordan_solve\n    cholesky_solve\n    diagonal_solve\n    LDLsolve\n    LUsolve\n    pinv_solve\n    QRdecomposition\n    cramer_solve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "T",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.T",
    "type": "property",
    "description": "Matrix transposition",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "__abs__",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.__abs__",
    "type": "method",
    "description": "Returns a new matrix with entry-wise absolute values.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "__add__",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.__add__",
    "type": "method",
    "description": "Return self + other, raising ShapeError if shapes do not match.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "__getitem__",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.__getitem__",
    "type": "method",
    "description": "Implementations of __getitem__ should accept ints, in which\n        case the matrix is indexed as a flat list, tuples (i,j) in which\n        case the (i,j) entry is returned, slices, or mixed tuples (a,b)\n        where a and b are any combination of slices and integers.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "__len__",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.__len__",
    "type": "method",
    "description": "Return the number of elements of ``self``.\n\n        Implemented mainly so bool(Matrix()) == False.\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "__mul__",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.__mul__",
    "type": "method",
    "description": "Return self*other where other is either a scalar or a matrix\n        of compatible dimensions.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> A = Matrix([[1, 2, 3], [4, 5, 6]])\n        >>> 2*A == A*2 == Matrix([[2, 4, 6], [8, 10, 12]])\n        True\n        >>> B = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        >>> A*B\n        Matrix([\n        [30, 36, 42],\n        [66, 81, 96]])\n        >>> B*A\n        Traceback (most recent call last):\n        ...\n        ShapeError: Matrices size mismatch.\n        >>>\n\n        See Also\n        ========\n\n        matrix_multiply_elementwise\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "__pow__",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.__pow__",
    "type": "method",
    "description": "Return self**exp a scalar or symbol.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "add",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.add",
    "type": "method",
    "description": "Return self + b.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "adjoint",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.adjoint",
    "type": "method",
    "description": "Conjugate transpose or Hermitian conjugation.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "adjugate",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.adjugate",
    "type": "method",
    "description": "Returns the adjugate, or classical adjoint, of\n    a matrix.  That is, the transpose of the matrix of cofactors.\n\n    https://en.wikipedia.org/wiki/Adjugate\n\n    Parameters\n    ==========\n\n    method : string, optional\n        Method to use to find the cofactors, can be \"bareiss\", \"berkowitz\",\n        \"bird\", \"laplace\" or \"lu\".\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[1, 2], [3, 4]])\n    >>> M.adjugate()\n    Matrix([\n    [ 4, -2],\n    [-3,  1]])\n\n    See Also\n    ========\n\n    cofactor_matrix\n    sympy.matrices.matrixbase.MatrixBase.transpose\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "analytic_func",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.analytic_func",
    "type": "method",
    "description": "\n        Computes f(A) where A is a Square Matrix\n        and f is an analytic function.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol, Matrix, S, log\n\n        >>> x = Symbol('x')\n        >>> m = Matrix([[S(5)/4, S(3)/4], [S(3)/4, S(5)/4]])\n        >>> f = log(x)\n        >>> m.analytic_func(f, x)\n        Matrix([\n        [     0, log(2)],\n        [log(2),      0]])\n\n        Parameters\n        ==========\n\n        f : Expr\n            Analytic Function\n        x : Symbol\n            parameter of f\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "applyfunc",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.applyfunc",
    "type": "method",
    "description": "Apply a function to each element of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix(2, 2, lambda i, j: i*2+j)\n        >>> m\n        Matrix([\n        [0, 1],\n        [2, 3]])\n        >>> m.applyfunc(lambda i: 2*i)\n        Matrix([\n        [0, 2],\n        [4, 6]])\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "as_real_imag",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.as_real_imag",
    "type": "method",
    "description": "Returns a tuple containing the (real, imaginary) part of matrix.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "atoms",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.atoms",
    "type": "method",
    "description": "Returns the atoms that form the current object.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import Matrix\n        >>> Matrix([[x]])\n        Matrix([[x]])\n        >>> _.atoms()\n        {x}\n        >>> Matrix([[x, y], [y, x]])\n        Matrix([\n        [x, y],\n        [y, x]])\n        >>> _.atoms()\n        {x, y}\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "berkowitz_det",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.berkowitz_det",
    "type": "method",
    "description": "Computes determinant using Berkowitz method.\n\n        See Also\n        ========\n\n        det\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "berkowitz_eigenvals",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.berkowitz_eigenvals",
    "type": "method",
    "description": "Computes eigenvalues of a Matrix using Berkowitz method.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "berkowitz_minors",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.berkowitz_minors",
    "type": "method",
    "description": "Computes principal minors using Berkowitz method.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "bidiagonal_decomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.bidiagonal_decomposition",
    "type": "method",
    "description": "\n    Returns $(U,B,V.H)$ for\n\n    $$A = UBV^{H}$$\n\n    where $A$ is the input matrix, and $B$ is its Bidiagonalized form\n\n    Note: Bidiagonal Computation can hang for symbolic matrices.\n\n    Parameters\n    ==========\n\n    upper : bool. Whether to do upper bidiagnalization or lower.\n                True for upper and False for lower.\n\n    References\n    ==========\n\n    .. [1] Algorithm 5.4.2, Matrix computations by Golub and Van Loan, 4th edition\n    .. [2] Complex Matrix Bidiagonalization, https://github.com/vslobody/Householder-Bidiagonalization\n\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "bidiagonalize",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.bidiagonalize",
    "type": "method",
    "description": "\n    Returns $B$, the Bidiagonalized form of the input matrix.\n\n    Note: Bidiagonal Computation can hang for symbolic matrices.\n\n    Parameters\n    ==========\n\n    upper : bool. Whether to do upper bidiagnalization or lower.\n                True for upper and False for lower.\n\n    References\n    ==========\n\n    .. [1] Algorithm 5.4.2, Matrix computations by Golub and Van Loan, 4th edition\n    .. [2] Complex Matrix Bidiagonalization : https://github.com/vslobody/Householder-Bidiagonalization\n\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "charpoly",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.charpoly",
    "type": "method",
    "description": "Computes characteristic polynomial det(x*I - M) where I is\n    the identity matrix.\n\n    A PurePoly is returned, so using different variables for ``x`` does\n    not affect the comparison or the polynomials:\n\n    Parameters\n    ==========\n\n    x : string, optional\n        Name for the \"lambda\" variable, defaults to \"lambda\".\n\n    simplify : function, optional\n        Simplification function to use on the characteristic polynomial\n        calculated. Defaults to ``simplify``.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> from sympy.abc import x, y\n    >>> M = Matrix([[1, 3], [2, 0]])\n    >>> M.charpoly()\n    PurePoly(lambda**2 - lambda - 6, lambda, domain='ZZ')\n    >>> M.charpoly(x) == M.charpoly(y)\n    True\n    >>> M.charpoly(x) == M.charpoly(y)\n    True\n\n    Specifying ``x`` is optional; a symbol named ``lambda`` is used by\n    default (which looks good when pretty-printed in unicode):\n\n    >>> M.charpoly().as_expr()\n    lambda**2 - lambda - 6\n\n    And if ``x`` clashes with an existing symbol, underscores will\n    be prepended to the name to make it unique:\n\n    >>> M = Matrix([[1, 2], [x, 0]])\n    >>> M.charpoly(x).as_expr()\n    _x**2 - _x - 2*x\n\n    Whether you pass a symbol or not, the generator can be obtained\n    with the gen attribute since it may not be the same as the symbol\n    that was passed:\n\n    >>> M.charpoly(x).gen\n    _x\n    >>> M.charpoly(x).gen == x\n    False\n\n    Notes\n    =====\n\n    The Samuelson-Berkowitz algorithm is used to compute\n    the characteristic polynomial efficiently and without any\n    division operations.  Thus the characteristic polynomial over any\n    commutative ring without zero divisors can be computed.\n\n    If the determinant det(x*I - M) can be found out easily as\n    in the case of an upper or a lower triangular matrix, then\n    instead of Samuelson-Berkowitz algorithm, eigenvalues are computed\n    and the characteristic polynomial with their help.\n\n    See Also\n    ========\n\n    det\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "cholesky",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.cholesky",
    "type": "method",
    "description": "Returns the Cholesky-type decomposition L of a matrix A\n    such that L * L.H == A if hermitian flag is True,\n    or L * L.T == A if hermitian is False.\n\n    A must be a Hermitian positive-definite matrix if hermitian is True,\n    or a symmetric matrix if it is False.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))\n    >>> A.cholesky()\n    Matrix([\n    [ 5, 0, 0],\n    [ 3, 3, 0],\n    [-1, 1, 3]])\n    >>> A.cholesky() * A.cholesky().T\n    Matrix([\n    [25, 15, -5],\n    [15, 18,  0],\n    [-5,  0, 11]])\n\n    The matrix can have complex entries:\n\n    >>> from sympy import I\n    >>> A = Matrix(((9, 3*I), (-3*I, 5)))\n    >>> A.cholesky()\n    Matrix([\n    [ 3, 0],\n    [-I, 2]])\n    >>> A.cholesky() * A.cholesky().H\n    Matrix([\n    [   9, 3*I],\n    [-3*I,   5]])\n\n    Non-hermitian Cholesky-type decomposition may be useful when the\n    matrix is not positive-definite.\n\n    >>> A = Matrix([[1, 2], [2, 1]])\n    >>> L = A.cholesky(hermitian=False)\n    >>> L\n    Matrix([\n    [1,         0],\n    [2, sqrt(3)*I]])\n    >>> L*L.T == A\n    True\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.LDLdecomposition\n    sympy.matrices.matrixbase.MatrixBase.LUdecomposition\n    QRdecomposition\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "cholesky_solve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.cholesky_solve",
    "type": "method",
    "description": "Solves ``Ax = B`` using Cholesky decomposition,\n    for a general square non-singular matrix.\n    For a non-square matrix with rows > cols,\n    the least squares solution is returned.\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.lower_triangular_solve\n    sympy.matrices.dense.DenseMatrix.upper_triangular_solve\n    gauss_jordan_solve\n    diagonal_solve\n    LDLsolve\n    LUsolve\n    QRsolve\n    pinv_solve\n    cramer_solve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "cofactor",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.cofactor",
    "type": "method",
    "description": "Calculate the cofactor of an element.\n\n    Parameters\n    ==========\n\n    method : string, optional\n        Method to use to find the cofactors, can be \"bareiss\", \"berkowitz\",\n        \"bird\", \"laplace\" or \"lu\".\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[1, 2], [3, 4]])\n    >>> M.cofactor(0, 1)\n    -3\n\n    See Also\n    ========\n\n    cofactor_matrix\n    minor\n    minor_submatrix\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "cofactor_matrix",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.cofactor_matrix",
    "type": "method",
    "description": "Return a matrix containing the cofactor of each element.\n\n    Parameters\n    ==========\n\n    method : string, optional\n        Method to use to find the cofactors, can be \"bareiss\", \"berkowitz\",\n        \"bird\", \"laplace\" or \"lu\".\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[1, 2], [3, 4]])\n    >>> M.cofactor_matrix()\n    Matrix([\n    [ 4, -3],\n    [-2,  1]])\n\n    See Also\n    ========\n\n    cofactor\n    minor\n    minor_submatrix\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "col",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.col",
    "type": "method",
    "description": "Elementary column selector.\n\n        Examples\n        ========\n\n        >>> from sympy import eye\n        >>> eye(2).col(0)\n        Matrix([\n        [1],\n        [0]])\n\n        See Also\n        ========\n\n        row\n        col_del\n        col_join\n        col_insert\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "col_del",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.col_del",
    "type": "method",
    "description": "Delete the specified column.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "col_insert",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.col_insert",
    "type": "method",
    "description": "Insert one or more columns at the given column position.\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.col_insert(1, V)\n        Matrix([\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 1, 0, 0]])\n\n        See Also\n        ========\n\n        col\n        row_insert\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "col_join",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.col_join",
    "type": "method",
    "description": "Concatenates two matrices along self's last and other's first row.\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(1, 3)\n        >>> M.col_join(V)\n        Matrix([\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0],\n        [1, 1, 1]])\n\n        See Also\n        ========\n\n        col\n        row_join\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "columnspace",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.columnspace",
    "type": "method",
    "description": "Returns a list of vectors (Matrix objects) that span columnspace of ``M``\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])\n    >>> M\n    Matrix([\n    [ 1,  3, 0],\n    [-2, -6, 0],\n    [ 3,  9, 6]])\n    >>> M.columnspace()\n    [Matrix([\n    [ 1],\n    [-2],\n    [ 3]]), Matrix([\n    [0],\n    [0],\n    [6]])]\n\n    See Also\n    ========\n\n    nullspace\n    rowspace\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "companion",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.companion",
    "type": "method",
    "description": "Returns a companion matrix of a polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, Poly, Symbol, symbols\n        >>> x = Symbol('x')\n        >>> c0, c1, c2, c3, c4 = symbols('c0:5')\n        >>> p = Poly(c0 + c1*x + c2*x**2 + c3*x**3 + c4*x**4 + x**5, x)\n        >>> Matrix.companion(p)\n        Matrix([\n        [0, 0, 0, 0, -c0],\n        [1, 0, 0, 0, -c1],\n        [0, 1, 0, 0, -c2],\n        [0, 0, 1, 0, -c3],\n        [0, 0, 0, 1, -c4]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "condition_number",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.condition_number",
    "type": "method",
    "description": "Returns the condition number of a matrix.\n\n        This is the maximum singular value divided by the minimum singular value\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, S\n        >>> A = Matrix([[1, 0, 0], [0, 10, 0], [0, 0, S.One/10]])\n        >>> A.condition_number()\n        100\n\n        See Also\n        ========\n\n        singular_values\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "conjugate",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.conjugate",
    "type": "method",
    "description": "Return the by-element conjugation.\n\n        Examples\n        ========\n\n        >>> from sympy import SparseMatrix, I\n        >>> a = SparseMatrix(((1, 2 + I), (3, 4), (I, -I)))\n        >>> a\n        Matrix([\n        [1, 2 + I],\n        [3,     4],\n        [I,    -I]])\n        >>> a.C\n        Matrix([\n        [ 1, 2 - I],\n        [ 3,     4],\n        [-I,     I]])\n\n        See Also\n        ========\n\n        transpose: Matrix transposition\n        H: Hermite conjugation\n        sympy.matrices.matrixbase.MatrixBase.D: Dirac conjugation\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "connected_components",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.connected_components",
    "type": "method",
    "description": "Returns the list of connected vertices of the graph when\n    a square matrix is viewed as a weighted graph.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([\n    ...     [66, 0, 0, 68, 0, 0, 0, 0, 67],\n    ...     [0, 55, 0, 0, 0, 0, 54, 53, 0],\n    ...     [0, 0, 0, 0, 1, 2, 0, 0, 0],\n    ...     [86, 0, 0, 88, 0, 0, 0, 0, 87],\n    ...     [0, 0, 10, 0, 11, 12, 0, 0, 0],\n    ...     [0, 0, 20, 0, 21, 22, 0, 0, 0],\n    ...     [0, 45, 0, 0, 0, 0, 44, 43, 0],\n    ...     [0, 35, 0, 0, 0, 0, 34, 33, 0],\n    ...     [76, 0, 0, 78, 0, 0, 0, 0, 77]])\n    >>> A.connected_components()\n    [[0, 3, 8], [1, 6, 7], [2, 4, 5]]\n\n    Notes\n    =====\n\n    Even if any symbolic elements of the matrix can be indeterminate\n    to be zero mathematically, this only takes the account of the\n    structural aspect of the matrix, so they will considered to be\n    nonzero.\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "connected_components_decomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.connected_components_decomposition",
    "type": "method",
    "description": "Decomposes a square matrix into block diagonal form only\n    using the permutations.\n\n    Explanation\n    ===========\n\n    The decomposition is in a form of $A = P^{-1} B P$ where $P$ is a\n    permutation matrix and $B$ is a block diagonal matrix.\n\n    Returns\n    =======\n\n    P, B : PermutationMatrix, BlockDiagMatrix\n        *P* is a permutation matrix for the similarity transform\n        as in the explanation. And *B* is the block diagonal matrix of\n        the result of the permutation.\n\n        If you would like to get the diagonal blocks from the\n        BlockDiagMatrix, see\n        :meth:`~sympy.matrices.expressions.blockmatrix.BlockDiagMatrix.get_diag_blocks`.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, pprint\n    >>> A = Matrix([\n    ...     [66, 0, 0, 68, 0, 0, 0, 0, 67],\n    ...     [0, 55, 0, 0, 0, 0, 54, 53, 0],\n    ...     [0, 0, 0, 0, 1, 2, 0, 0, 0],\n    ...     [86, 0, 0, 88, 0, 0, 0, 0, 87],\n    ...     [0, 0, 10, 0, 11, 12, 0, 0, 0],\n    ...     [0, 0, 20, 0, 21, 22, 0, 0, 0],\n    ...     [0, 45, 0, 0, 0, 0, 44, 43, 0],\n    ...     [0, 35, 0, 0, 0, 0, 34, 33, 0],\n    ...     [76, 0, 0, 78, 0, 0, 0, 0, 77]])\n\n    >>> P, B = A.connected_components_decomposition()\n    >>> pprint(P)\n    PermutationMatrix((1 3)(2 8 5 7 4 6))\n    >>> pprint(B)\n    [[66  68  67]                            ]\n    [[          ]                            ]\n    [[86  88  87]       0             0      ]\n    [[          ]                            ]\n    [[76  78  77]                            ]\n    [                                        ]\n    [              [55  54  53]              ]\n    [              [          ]              ]\n    [     0        [45  44  43]       0      ]\n    [              [          ]              ]\n    [              [35  34  33]              ]\n    [                                        ]\n    [                            [0   1   2 ]]\n    [                            [          ]]\n    [     0             0        [10  11  12]]\n    [                            [          ]]\n    [                            [20  21  22]]\n\n    >>> P = P.as_explicit()\n    >>> B = B.as_explicit()\n    >>> P.T*B*P == A\n    True\n\n    Notes\n    =====\n\n    This problem corresponds to the finding of the connected components\n    of a graph, when a matrix is viewed as a weighted graph.\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "copy",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.copy",
    "type": "method",
    "description": "\n        Returns the copy of a matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> A = Matrix(2, 2, [1, 2, 3, 4])\n        >>> A.copy()\n        Matrix([\n        [1, 2],\n        [3, 4]])\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "cramer_solve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.cramer_solve",
    "type": "method",
    "description": "Solves system of linear equations using Cramer's rule.\n\n    This method is relatively inefficient compared to other methods.\n    However it only uses a single division, assuming a division-free determinant\n    method is provided. This is helpful to minimize the chance of divide-by-zero\n    cases in symbolic solutions to linear systems.\n\n    Parameters\n    ==========\n    M : Matrix\n        The matrix representing the left hand side of the equation.\n    rhs : Matrix\n        The matrix representing the right hand side of the equation.\n    det_method : str or callable\n        The method to use to calculate the determinant of the matrix.\n        The default is ``'laplace'``.  If a callable is passed, it should take a\n        single argument, the matrix, and return the determinant of the matrix.\n\n    Returns\n    =======\n    x : Matrix\n        The matrix that will satisfy ``Ax = B``.  Will have as many rows as\n        matrix A has columns, and as many columns as matrix B.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([[0, -6, 1], [0, -6, -1], [-5, -2, 3]])\n    >>> B = Matrix([[-30, -9], [-18, -27], [-26, 46]])\n    >>> x = A.cramer_solve(B)\n    >>> x\n    Matrix([\n    [ 0, -5],\n    [ 4,  3],\n    [-6,  9]])\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Cramer%27s_rule#Explicit_formulas_for_small_systems\n\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "cross",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.cross",
    "type": "method",
    "description": "\n        Return the cross product of ``self`` and ``b`` relaxing the condition\n        of compatible dimensions: if each has 3 elements, a matrix of the\n        same type and shape as ``self`` will be returned. If ``b`` has the same\n        shape as ``self`` then common identities for the cross product (like\n        `a \\times b = - b \\times a`) will hold.\n\n        Parameters\n        ==========\n            b : 3x1 or 1x3 Matrix\n\n        See Also\n        ========\n\n        dot\n        hat\n        vee\n        multiply\n        multiply_elementwise\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "det",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.det",
    "type": "method",
    "description": "Computes the determinant of a matrix if ``M`` is a concrete matrix object\n    otherwise return an expressions ``Determinant(M)`` if ``M`` is a\n    ``MatrixSymbol`` or other expression.\n\n    Parameters\n    ==========\n\n    method : string, optional\n        Specifies the algorithm used for computing the matrix determinant.\n\n        If the matrix is at most 3x3, a hard-coded formula is used and the\n        specified method is ignored. Otherwise, it defaults to\n        ``'bareiss'``.\n\n        Also, if the matrix is an upper or a lower triangular matrix, determinant\n        is computed by simple multiplication of diagonal elements, and the\n        specified method is ignored.\n\n        If it is set to ``'domain-ge'``, then Gaussian elimination method will\n        be used via using DomainMatrix.\n\n        If it is set to ``'bareiss'``, Bareiss' fraction-free algorithm will\n        be used.\n\n        If it is set to ``'berkowitz'``, Berkowitz' algorithm will be used.\n\n        If it is set to ``'bird'``, Bird's algorithm will be used [1]_.\n\n        If it is set to ``'laplace'``, Laplace's algorithm will be used.\n\n        Otherwise, if it is set to ``'lu'``, LU decomposition will be used.\n\n        .. note::\n            For backward compatibility, legacy keys like \"bareis\" and\n            \"det_lu\" can still be used to indicate the corresponding\n            methods.\n            And the keys are also case-insensitive for now. However, it is\n            suggested to use the precise keys for specifying the method.\n\n    iszerofunc : FunctionType or None, optional\n        If it is set to ``None``, it will be defaulted to ``_iszero`` if the\n        method is set to ``'bareiss'``, and ``_is_zero_after_expand_mul`` if\n        the method is set to ``'lu'``.\n\n        It can also accept any user-specified zero testing function, if it\n        is formatted as a function which accepts a single symbolic argument\n        and returns ``True`` if it is tested as zero and ``False`` if it\n        tested as non-zero, and also ``None`` if it is undecidable.\n\n    Returns\n    =======\n\n    det : Basic\n        Result of determinant.\n\n    Raises\n    ======\n\n    ValueError\n        If unrecognized keys are given for ``method`` or ``iszerofunc``.\n\n    NonSquareMatrixError\n        If attempted to calculate determinant from a non-square matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, eye, det\n    >>> I3 = eye(3)\n    >>> det(I3)\n    1\n    >>> M = Matrix([[1, 2], [3, 4]])\n    >>> det(M)\n    -2\n    >>> det(M) == M.det()\n    True\n    >>> M.det(method=\"domain-ge\")\n    -2\n\n    References\n    ==========\n\n    .. [1] Bird, R. S. (2011). A simple division-free algorithm for computing\n           determinants. Inf. Process. Lett., 111(21), 1072-1074. doi:\n           10.1016/j.ipl.2011.08.006\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "det_LU_decomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.det_LU_decomposition",
    "type": "method",
    "description": "Compute matrix determinant using LU decomposition.\n\n\n        Note that this method fails if the LU decomposition itself\n        fails. In particular, if the matrix has no inverse this method\n        will fail.\n\n        TODO: Implement algorithm for sparse matrices (SFF),\n        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.\n\n        See Also\n        ========\n\n\n        det\n        berkowitz_det\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "diag",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.diag",
    "type": "method",
    "description": "Returns a matrix with the specified diagonal.\n        If matrices are passed, a block-diagonal matrix\n        is created (i.e. the \"direct sum\" of the matrices).\n\n        kwargs\n        ======\n\n        rows : rows of the resulting matrix; computed if\n               not given.\n\n        cols : columns of the resulting matrix; computed if\n               not given.\n\n        cls : class for the resulting matrix\n\n        unpack : bool which, when True (default), unpacks a single\n        sequence rather than interpreting it as a Matrix.\n\n        strict : bool which, when False (default), allows Matrices to\n        have variable-length rows.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> Matrix.diag(1, 2, 3)\n        Matrix([\n        [1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]])\n\n        The current default is to unpack a single sequence. If this is\n        not desired, set `unpack=False` and it will be interpreted as\n        a matrix.\n\n        >>> Matrix.diag([1, 2, 3]) == Matrix.diag(1, 2, 3)\n        True\n\n        When more than one element is passed, each is interpreted as\n        something to put on the diagonal. Lists are converted to\n        matrices. Filling of the diagonal always continues from\n        the bottom right hand corner of the previous item: this\n        will create a block-diagonal matrix whether the matrices\n        are square or not.\n\n        >>> col = [1, 2, 3]\n        >>> row = [[4, 5]]\n        >>> Matrix.diag(col, row)\n        Matrix([\n        [1, 0, 0],\n        [2, 0, 0],\n        [3, 0, 0],\n        [0, 4, 5]])\n\n        When `unpack` is False, elements within a list need not all be\n        of the same length. Setting `strict` to True would raise a\n        ValueError for the following:\n\n        >>> Matrix.diag([[1, 2, 3], [4, 5], [6]], unpack=False)\n        Matrix([\n        [1, 2, 3],\n        [4, 5, 0],\n        [6, 0, 0]])\n\n        The type of the returned matrix can be set with the ``cls``\n        keyword.\n\n        >>> from sympy import ImmutableMatrix\n        >>> from sympy.utilities.misc import func_name\n        >>> func_name(Matrix.diag(1, cls=ImmutableMatrix))\n        'ImmutableDenseMatrix'\n\n        A zero dimension matrix can be used to position the start of\n        the filling at the start of an arbitrary row or column:\n\n        >>> from sympy import ones\n        >>> r2 = ones(0, 2)\n        >>> Matrix.diag(r2, 1, 2)\n        Matrix([\n        [0, 0, 1, 0],\n        [0, 0, 0, 2]])\n\n        See Also\n        ========\n        eye\n        diagonal\n        .dense.diag\n        .expressions.blockmatrix.BlockMatrix\n        .sparsetools.banded\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "diagonal",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.diagonal",
    "type": "method",
    "description": "Returns the kth diagonal of self. The main diagonal\n        corresponds to `k=0`; diagonals above and below correspond to\n        `k > 0` and `k < 0`, respectively. The values of `self[i, j]`\n        for which `j - i = k`, are returned in order of increasing\n        `i + j`, starting with `i + j = |k|`.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix(3, 3, lambda i, j: j - i); m\n        Matrix([\n        [ 0,  1, 2],\n        [-1,  0, 1],\n        [-2, -1, 0]])\n        >>> _.diagonal()\n        Matrix([[0, 0, 0]])\n        >>> m.diagonal(1)\n        Matrix([[1, 1]])\n        >>> m.diagonal(-2)\n        Matrix([[-2]])\n\n        Even though the diagonal is returned as a Matrix, the element\n        retrieval can be done with a single index:\n\n        >>> Matrix.diag(1, 2, 3).diagonal()[1]  # instead of [0, 1]\n        2\n\n        See Also\n        ========\n\n        diag\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "diagonal_solve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.diagonal_solve",
    "type": "method",
    "description": "Solves ``Ax = B`` efficiently, where A is a diagonal Matrix,\n    with non-zero diagonal entries.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, eye\n    >>> A = eye(2)*2\n    >>> B = Matrix([[1, 2], [3, 4]])\n    >>> A.diagonal_solve(B) == B/2\n    True\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.lower_triangular_solve\n    sympy.matrices.dense.DenseMatrix.upper_triangular_solve\n    gauss_jordan_solve\n    cholesky_solve\n    LDLsolve\n    LUsolve\n    QRsolve\n    pinv_solve\n    cramer_solve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "diagonalize",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.diagonalize",
    "type": "method",
    "description": "\n    Return (P, D), where D is diagonal and\n\n        D = P^-1 * M * P\n\n    where M is current matrix.\n\n    Parameters\n    ==========\n\n    reals_only : bool. Whether to throw an error if complex numbers are need\n                    to diagonalize. (Default: False)\n\n    sort : bool. Sort the eigenvalues along the diagonal. (Default: False)\n\n    normalize : bool. If True, normalize the columns of P. (Default: False)\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix(3, 3, [1, 2, 0, 0, 3, 0, 2, -4, 2])\n    >>> M\n    Matrix([\n    [1,  2, 0],\n    [0,  3, 0],\n    [2, -4, 2]])\n    >>> (P, D) = M.diagonalize()\n    >>> D\n    Matrix([\n    [1, 0, 0],\n    [0, 2, 0],\n    [0, 0, 3]])\n    >>> P\n    Matrix([\n    [-1, 0, -1],\n    [ 0, 0, -1],\n    [ 2, 1,  2]])\n    >>> P.inv() * M * P\n    Matrix([\n    [1, 0, 0],\n    [0, 2, 0],\n    [0, 0, 3]])\n\n    See Also\n    ========\n\n    sympy.matrices.matrixbase.MatrixBase.is_diagonal\n    is_diagonalizable\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "diff",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.diff",
    "type": "method",
    "description": "Calculate the derivative of each element in the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> from sympy.abc import x, y\n        >>> M = Matrix([[x, y], [1, 0]])\n        >>> M.diff(x)\n        Matrix([\n        [1, 0],\n        [0, 0]])\n\n        See Also\n        ========\n\n        integrate\n        limit\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "dot",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.dot",
    "type": "method",
    "description": "Return the dot or inner product of two vectors of equal length.\n        Here ``self`` must be a ``Matrix`` of size 1 x n or n x 1, and ``b``\n        must be either a matrix of size 1 x n, n x 1, or a list/tuple of length n.\n        A scalar is returned.\n\n        By default, ``dot`` does not conjugate ``self`` or ``b``, even if there are\n        complex entries. Set ``hermitian=True`` (and optionally a ``conjugate_convention``)\n        to compute the hermitian inner product.\n\n        Possible kwargs are ``hermitian`` and ``conjugate_convention``.\n\n        If ``conjugate_convention`` is ``\"left\"``, ``\"math\"`` or ``\"maths\"``,\n        the conjugate of the first vector (``self``) is used.  If ``\"right\"``\n        or ``\"physics\"`` is specified, the conjugate of the second vector ``b`` is used.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        >>> v = Matrix([1, 1, 1])\n        >>> M.row(0).dot(v)\n        6\n        >>> M.col(0).dot(v)\n        12\n        >>> v = [3, 2, 1]\n        >>> M.row(0).dot(v)\n        10\n\n        >>> from sympy import I\n        >>> q = Matrix([1*I, 1*I, 1*I])\n        >>> q.dot(q, hermitian=False)\n        -3\n\n        >>> q.dot(q, hermitian=True)\n        3\n\n        >>> q1 = Matrix([1, 1, 1*I])\n        >>> q.dot(q1, hermitian=True, conjugate_convention=\"maths\")\n        1 - 2*I\n        >>> q.dot(q1, hermitian=True, conjugate_convention=\"physics\")\n        1 + 2*I\n\n\n        See Also\n        ========\n\n        cross\n        multiply\n        multiply_elementwise\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "dual",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.dual",
    "type": "method",
    "description": "Returns the dual of a matrix.\n\n        A dual of a matrix is:\n\n        ``(1/2)*levicivita(i, j, k, l)*M(k, l)`` summed over indices `k` and `l`\n\n        Since the levicivita method is anti_symmetric for any pairwise\n        exchange of indices, the dual of a symmetric matrix is the zero\n        matrix. Strictly speaking the dual defined here assumes that the\n        'matrix' `M` is a contravariant anti_symmetric second rank tensor,\n        so that the dual is a covariant second rank tensor.\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "echelon_form",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.echelon_form",
    "type": "method",
    "description": "Returns a matrix row-equivalent to ``M`` that is in echelon form. Note\n    that echelon form of a matrix is *not* unique, however, properties like the\n    row space and the null space are preserved.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[1, 2], [3, 4]])\n    >>> M.echelon_form()\n    Matrix([\n    [1,  2],\n    [0, -2]])\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "eigenvals",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.eigenvals",
    "type": "method",
    "description": "Compute eigenvalues of the matrix.\n\n    Parameters\n    ==========\n\n    error_when_incomplete : bool, optional\n        If it is set to ``True``, it will raise an error if not all\n        eigenvalues are computed. This is caused by ``roots`` not returning\n        a full list of eigenvalues.\n\n    simplify : bool or function, optional\n        If it is set to ``True``, it attempts to return the most\n        simplified form of expressions returned by applying default\n        simplification method in every routine.\n\n        If it is set to ``False``, it will skip simplification in this\n        particular routine to save computation resources.\n\n        If a function is passed to, it will attempt to apply\n        the particular function as simplification method.\n\n    rational : bool, optional\n        If it is set to ``True``, every floating point numbers would be\n        replaced with rationals before computation. It can solve some\n        issues of ``roots`` routine not working well with floats.\n\n    multiple : bool, optional\n        If it is set to ``True``, the result will be in the form of a\n        list.\n\n        If it is set to ``False``, the result will be in the form of a\n        dictionary.\n\n    Returns\n    =======\n\n    eigs : list or dict\n        Eigenvalues of a matrix. The return format would be specified by\n        the key ``multiple``.\n\n    Raises\n    ======\n\n    MatrixError\n        If not enough roots had got computed.\n\n    NonSquareMatrixError\n        If attempted to compute eigenvalues from a non-square matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix(3, 3, [0, 1, 1, 1, 0, 0, 1, 1, 1])\n    >>> M.eigenvals()\n    {-1: 1, 0: 1, 2: 1}\n\n    See Also\n    ========\n\n    MatrixBase.charpoly\n    eigenvects\n\n    Notes\n    =====\n\n    Eigenvalues of a matrix $A$ can be computed by solving a matrix\n    equation $\\det(A - \\lambda I) = 0$\n\n    It's not always possible to return radical solutions for\n    eigenvalues for matrices larger than $4, 4$ shape due to\n    Abel-Ruffini theorem.\n\n    If there is no radical solution is found for the eigenvalue,\n    it may return eigenvalues in the form of\n    :class:`sympy.polys.rootoftools.ComplexRootOf`.\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "eigenvects",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.eigenvects",
    "type": "method",
    "description": "Compute eigenvectors of the matrix.\n\n    Parameters\n    ==========\n\n    error_when_incomplete : bool, optional\n        Raise an error when not all eigenvalues are computed. This is\n        caused by ``roots`` not returning a full list of eigenvalues.\n\n    iszerofunc : function, optional\n        Specifies a zero testing function to be used in ``rref``.\n\n        Default value is ``_iszero``, which uses SymPy's naive and fast\n        default assumption handler.\n\n        It can also accept any user-specified zero testing function, if it\n        is formatted as a function which accepts a single symbolic argument\n        and returns ``True`` if it is tested as zero and ``False`` if it\n        is tested as non-zero, and ``None`` if it is undecidable.\n\n    simplify : bool or function, optional\n        If ``True``, ``as_content_primitive()`` will be used to tidy up\n        normalization artifacts.\n\n        It will also be used by the ``nullspace`` routine.\n\n    chop : bool or positive number, optional\n        If the matrix contains any Floats, they will be changed to Rationals\n        for computation purposes, but the answers will be returned after\n        being evaluated with evalf. The ``chop`` flag is passed to ``evalf``.\n        When ``chop=True`` a default precision will be used; a number will\n        be interpreted as the desired level of precision.\n\n    Returns\n    =======\n\n    ret : [(eigenval, multiplicity, eigenspace), ...]\n        A ragged list containing tuples of data obtained by ``eigenvals``\n        and ``nullspace``.\n\n        ``eigenspace`` is a list containing the ``eigenvector`` for each\n        eigenvalue.\n\n        ``eigenvector`` is a vector in the form of a ``Matrix``. e.g.\n        a vector of length 3 is returned as ``Matrix([a_1, a_2, a_3])``.\n\n    Raises\n    ======\n\n    NotImplementedError\n        If failed to compute nullspace.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix(3, 3, [0, 1, 1, 1, 0, 0, 1, 1, 1])\n    >>> M.eigenvects()\n    [(-1, 1, [Matrix([\n    [-1],\n    [ 1],\n    [ 0]])]), (0, 1, [Matrix([\n    [ 0],\n    [-1],\n    [ 1]])]), (2, 1, [Matrix([\n    [2/3],\n    [1/3],\n    [  1]])])]\n\n    See Also\n    ========\n\n    eigenvals\n    MatrixBase.nullspace\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "elementary_col_op",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.elementary_col_op",
    "type": "method",
    "description": "Performs the elementary column operation `op`.\n\n        `op` may be one of\n\n            * ``\"n->kn\"`` (column n goes to k*n)\n            * ``\"n<->m\"`` (swap column n and column m)\n            * ``\"n->n+km\"`` (column n goes to column n + k*column m)\n\n        Parameters\n        ==========\n\n        op : string; the elementary row operation\n        col : the column to apply the column operation\n        k : the multiple to apply in the column operation\n        col1 : one column of a column swap\n        col2 : second column of a column swap or column \"m\" in the column operation\n               \"n->n+km\"\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "elementary_row_op",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.elementary_row_op",
    "type": "method",
    "description": "Performs the elementary row operation `op`.\n\n        `op` may be one of\n\n            * ``\"n->kn\"`` (row n goes to k*n)\n            * ``\"n<->m\"`` (swap row n and row m)\n            * ``\"n->n+km\"`` (row n goes to row n + k*row m)\n\n        Parameters\n        ==========\n\n        op : string; the elementary row operation\n        row : the row to apply the row operation\n        k : the multiple to apply in the row operation\n        row1 : one row of a row swap\n        row2 : second row of a row swap or row \"m\" in the row operation\n               \"n->n+km\"\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "evalf",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.evalf",
    "type": "method",
    "description": "Apply evalf() to each element of self.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "exp",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.exp",
    "type": "method",
    "description": "Return the exponential of a square matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol, Matrix\n\n        >>> t = Symbol('t')\n        >>> m = Matrix([[0, 1], [-1, 0]]) * t\n        >>> m.exp()\n        Matrix([\n        [    exp(I*t)/2 + exp(-I*t)/2, -I*exp(I*t)/2 + I*exp(-I*t)/2],\n        [I*exp(I*t)/2 - I*exp(-I*t)/2,      exp(I*t)/2 + exp(-I*t)/2]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "expand",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.expand",
    "type": "method",
    "description": "Apply core.function.expand to each entry of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import Matrix\n        >>> Matrix(1, 1, [x*(x+1)])\n        Matrix([[x*(x + 1)]])\n        >>> _.expand()\n        Matrix([[x**2 + x]])\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "extract",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.extract",
    "type": "method",
    "description": "Return a submatrix by specifying a list of rows and columns.\n        Negative indices can be given. All indices must be in the range\n        $-n \\le i < n$ where $n$ is the number of rows or columns.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix(4, 3, range(12))\n        >>> m\n        Matrix([\n        [0,  1,  2],\n        [3,  4,  5],\n        [6,  7,  8],\n        [9, 10, 11]])\n        >>> m.extract([0, 1, 3], [0, 1])\n        Matrix([\n        [0,  1],\n        [3,  4],\n        [9, 10]])\n\n        Rows or columns can be repeated:\n\n        >>> m.extract([0, 0, 1], [-1])\n        Matrix([\n        [2],\n        [2],\n        [5]])\n\n        Every other row can be taken by using range to provide the indices:\n\n        >>> m.extract(range(0, m.rows, 2), [-1])\n        Matrix([\n        [2],\n        [8]])\n\n        RowsList or colsList can also be a list of booleans, in which case\n        the rows or columns corresponding to the True values will be selected:\n\n        >>> m.extract([0, 1, 2, 3], [True, False, True])\n        Matrix([\n        [0,  2],\n        [3,  5],\n        [6,  8],\n        [9, 11]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "eye",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.eye",
    "type": "method",
    "description": "Returns an identity matrix.\n\n        Parameters\n        ==========\n\n        rows : rows of the matrix\n        cols : cols of the matrix (if None, cols=rows)\n\n        kwargs\n        ======\n        cls : class of the returned matrix\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "flat",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.flat",
    "type": "method",
    "description": "\n        Returns a flat list of all elements in the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix([[0, 2], [3, 4]])\n        >>> m.flat()\n        [0, 2, 3, 4]\n\n        See Also\n        ========\n\n        tolist\n        values\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.free_symbols",
    "type": "property",
    "description": "Returns the free symbols within the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import Matrix\n        >>> Matrix([[x], [1]]).free_symbols\n        {x}\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "from_dok",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.from_dok",
    "type": "method",
    "description": "Create a matrix from a dictionary of keys.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> d = {(0, 0): 1, (1, 2): 3, (2, 1): 4}\n        >>> Matrix.from_dok(3, 3, d)\n        Matrix([\n        [1, 0, 0],\n        [0, 0, 3],\n        [0, 4, 0]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "gauss_jordan_solve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve",
    "type": "method",
    "description": "\n    Solves ``Ax = B`` using Gauss Jordan elimination.\n\n    There may be zero, one, or infinite solutions.  If one solution\n    exists, it will be returned. If infinite solutions exist, it will\n    be returned parametrically. If no solutions exist, It will throw\n    ValueError.\n\n    Parameters\n    ==========\n\n    B : Matrix\n        The right hand side of the equation to be solved for.  Must have\n        the same number of rows as matrix A.\n\n    freevar : boolean, optional\n        Flag, when set to `True` will return the indices of the free\n        variables in the solutions (column Matrix), for a system that is\n        undetermined (e.g. A has more columns than rows), for which\n        infinite solutions are possible, in terms of arbitrary\n        values of free variables. Default `False`.\n\n    Returns\n    =======\n\n    x : Matrix\n        The matrix that will satisfy ``Ax = B``.  Will have as many rows as\n        matrix A has columns, and as many columns as matrix B.\n\n    params : Matrix\n        If the system is underdetermined (e.g. A has more columns than\n        rows), infinite solutions are possible, in terms of arbitrary\n        parameters. These arbitrary parameters are returned as params\n        Matrix.\n\n    free_var_index : List, optional\n        If the system is underdetermined (e.g. A has more columns than\n        rows), infinite solutions are possible, in terms of arbitrary\n        values of free variables. Then the indices of the free variables\n        in the solutions (column Matrix) are returned by free_var_index,\n        if the flag `freevar` is set to `True`.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([[1, 2, 1, 1], [1, 2, 2, -1], [2, 4, 0, 6]])\n    >>> B = Matrix([7, 12, 4])\n    >>> sol, params = A.gauss_jordan_solve(B)\n    >>> sol\n    Matrix([\n    [-2*tau0 - 3*tau1 + 2],\n    [                 tau0],\n    [           2*tau1 + 5],\n    [                 tau1]])\n    >>> params\n    Matrix([\n    [tau0],\n    [tau1]])\n    >>> taus_zeroes = { tau:0 for tau in params }\n    >>> sol_unique = sol.xreplace(taus_zeroes)\n    >>> sol_unique\n        Matrix([\n    [2],\n    [0],\n    [5],\n    [0]])\n\n\n    >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\n    >>> B = Matrix([3, 6, 9])\n    >>> sol, params = A.gauss_jordan_solve(B)\n    >>> sol\n    Matrix([\n    [-1],\n    [ 2],\n    [ 0]])\n    >>> params\n    Matrix(0, 1, [])\n\n    >>> A = Matrix([[2, -7], [-1, 4]])\n    >>> B = Matrix([[-21, 3], [12, -2]])\n    >>> sol, params = A.gauss_jordan_solve(B)\n    >>> sol\n    Matrix([\n    [0, -2],\n    [3, -1]])\n    >>> params\n    Matrix(0, 2, [])\n\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([[1, 2, 1, 1], [1, 2, 2, -1], [2, 4, 0, 6]])\n    >>> B = Matrix([7, 12, 4])\n    >>> sol, params, freevars = A.gauss_jordan_solve(B, freevar=True)\n    >>> sol\n    Matrix([\n    [-2*tau0 - 3*tau1 + 2],\n    [                 tau0],\n    [           2*tau1 + 5],\n    [                 tau1]])\n    >>> params\n    Matrix([\n    [tau0],\n    [tau1]])\n    >>> freevars\n    [1, 3]\n\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.lower_triangular_solve\n    sympy.matrices.dense.DenseMatrix.upper_triangular_solve\n    cholesky_solve\n    diagonal_solve\n    LDLsolve\n    LUsolve\n    QRsolve\n    pinv\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gaussian_elimination\n\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "get_diag_blocks",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.get_diag_blocks",
    "type": "method",
    "description": "Obtains the square sub-matrices on the main diagonal of a square matrix.\n\n        Useful for inverting symbolic matrices or solving systems of\n        linear equations which may be decoupled by having a block diagonal\n        structure.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> from sympy.abc import x, y, z\n        >>> A = Matrix([[1, 3, 0, 0], [y, z*z, 0, 0], [0, 0, x, 0], [0, 0, 0, 0]])\n        >>> a1, a2, a3 = A.get_diag_blocks()\n        >>> a1\n        Matrix([\n        [1,    3],\n        [y, z**2]])\n        >>> a2\n        Matrix([[x]])\n        >>> a3\n        Matrix([[0]])\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "has",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.has",
    "type": "method",
    "description": "Test whether any subexpression matches any of the patterns.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, SparseMatrix, Float\n        >>> from sympy.abc import x, y\n        >>> A = Matrix(((1, x), (0.2, 3)))\n        >>> B = SparseMatrix(((1, x), (0.2, 3)))\n        >>> A.has(x)\n        True\n        >>> A.has(y)\n        False\n        >>> A.has(Float)\n        True\n        >>> B.has(x)\n        True\n        >>> B.has(y)\n        False\n        >>> B.has(Float)\n        True\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "hat",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.hat",
    "type": "method",
    "description": "\n        Return the skew-symmetric matrix representing the cross product,\n        so that ``self.hat() * b`` is equivalent to  ``self.cross(b)``.\n\n        Examples\n        ========\n\n        Calling ``hat`` creates a skew-symmetric 3x3 Matrix from a 3x1 Matrix:\n\n        >>> from sympy import Matrix\n        >>> a = Matrix([1, 2, 3])\n        >>> a.hat()\n        Matrix([\n        [ 0, -3,  2],\n        [ 3,  0, -1],\n        [-2,  1,  0]])\n\n        Multiplying it with another 3x1 Matrix calculates the cross product:\n\n        >>> b = Matrix([3, 2, 1])\n        >>> a.hat() * b\n        Matrix([\n        [-4],\n        [ 8],\n        [-4]])\n\n        Which is equivalent to calling the ``cross`` method:\n\n        >>> a.cross(b)\n        Matrix([\n        [-4],\n        [ 8],\n        [-4]])\n\n        See Also\n        ========\n\n        dot\n        cross\n        vee\n        multiply\n        multiply_elementwise\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "hstack",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.hstack",
    "type": "method",
    "description": "Return a matrix formed by joining args horizontally (i.e.\n        by repeated application of row_join).\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, eye\n        >>> Matrix.hstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0, 2, 0],\n        [0, 1, 0, 2]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "integrate",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.integrate",
    "type": "method",
    "description": "Integrate each element of the matrix.  ``args`` will\n        be passed to the ``integrate`` function.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> from sympy.abc import x, y\n        >>> M = Matrix([[x, y], [1, 0]])\n        >>> M.integrate((x, ))\n        Matrix([\n        [x**2/2, x*y],\n        [     x,   0]])\n        >>> M.integrate((x, 0, 2))\n        Matrix([\n        [2, 2*y],\n        [2,   0]])\n\n        See Also\n        ========\n\n        limit\n        diff\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "inv",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.inv",
    "type": "method",
    "description": "\n    Return the inverse of a matrix using the method indicated. The default\n    is DM if a suitable domain is found or otherwise GE for dense matrices\n    LDL for sparse matrices.\n\n    Parameters\n    ==========\n\n    method : ('DM', 'DMNC', 'GE', 'LU', 'ADJ', 'CH', 'LDL', 'QR')\n\n    iszerofunc : function, optional\n        Zero-testing function to use.\n\n    try_block_diag : bool, optional\n        If True then will try to form block diagonal matrices using the\n        method get_diag_blocks(), invert these individually, and then\n        reconstruct the full inverse matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import SparseMatrix, Matrix\n    >>> A = SparseMatrix([\n    ... [ 2, -1,  0],\n    ... [-1,  2, -1],\n    ... [ 0,  0,  2]])\n    >>> A.inv('CH')\n    Matrix([\n    [2/3, 1/3, 1/6],\n    [1/3, 2/3, 1/3],\n    [  0,   0, 1/2]])\n    >>> A.inv(method='LDL') # use of 'method=' is optional\n    Matrix([\n    [2/3, 1/3, 1/6],\n    [1/3, 2/3, 1/3],\n    [  0,   0, 1/2]])\n    >>> A * _\n    Matrix([\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]])\n    >>> A = Matrix(A)\n    >>> A.inv('CH')\n    Matrix([\n    [2/3, 1/3, 1/6],\n    [1/3, 2/3, 1/3],\n    [  0,   0, 1/2]])\n    >>> A.inv('ADJ') == A.inv('GE') == A.inv('LU') == A.inv('CH') == A.inv('LDL') == A.inv('QR')\n    True\n\n    Notes\n    =====\n\n    According to the ``method`` keyword, it calls the appropriate method:\n\n        DM .... Use DomainMatrix ``inv_den`` method\n        DMNC .... Use DomainMatrix ``inv_den`` method without cancellation\n        GE .... inverse_GE(); default for dense matrices\n        LU .... inverse_LU()\n        ADJ ... inverse_ADJ()\n        CH ... inverse_CH()\n        LDL ... inverse_LDL(); default for sparse matrices\n        QR ... inverse_QR()\n\n    Note, the GE and LU methods may require the matrix to be simplified\n    before it is inverted in order to properly detect zeros during\n    pivoting. In difficult cases a custom zero detection function can\n    be provided by setting the ``iszerofunc`` argument to a function that\n    should return True if its argument is zero. The ADJ routine computes\n    the determinant and uses that to detect singular matrices in addition\n    to testing for zeros on the diagonal.\n\n    See Also\n    ========\n\n    inverse_ADJ\n    inverse_GE\n    inverse_LU\n    inverse_CH\n    inverse_LDL\n\n    Raises\n    ======\n\n    ValueError\n        If the determinant of the matrix is zero.\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "inverse_ADJ",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ",
    "type": "method",
    "description": "Calculates the inverse using the adjugate matrix and a determinant.\n\n    See Also\n    ========\n\n    inv\n    inverse_GE\n    inverse_LU\n    inverse_CH\n    inverse_LDL\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "inverse_BLOCK",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.inverse_BLOCK",
    "type": "method",
    "description": "Calculates the inverse using BLOCKWISE inversion.\n\n    See Also\n    ========\n\n    inv\n    inverse_ADJ\n    inverse_GE\n    inverse_CH\n    inverse_LDL\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "inverse_CH",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.inverse_CH",
    "type": "method",
    "description": "Calculates the inverse using cholesky decomposition.\n\n    See Also\n    ========\n\n    inv\n    inverse_ADJ\n    inverse_GE\n    inverse_LU\n    inverse_LDL\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "inverse_GE",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.inverse_GE",
    "type": "method",
    "description": "Calculates the inverse using Gaussian elimination.\n\n    See Also\n    ========\n\n    inv\n    inverse_ADJ\n    inverse_LU\n    inverse_CH\n    inverse_LDL\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "inverse_LDL",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.inverse_LDL",
    "type": "method",
    "description": "Calculates the inverse using LDL decomposition.\n\n    See Also\n    ========\n\n    inv\n    inverse_ADJ\n    inverse_GE\n    inverse_LU\n    inverse_CH\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "inverse_LU",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.inverse_LU",
    "type": "method",
    "description": "Calculates the inverse using LU decomposition.\n\n    See Also\n    ========\n\n    inv\n    inverse_ADJ\n    inverse_GE\n    inverse_CH\n    inverse_LDL\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "inverse_QR",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.inverse_QR",
    "type": "method",
    "description": "Calculates the inverse using QR decomposition.\n\n    See Also\n    ========\n\n    inv\n    inverse_ADJ\n    inverse_GE\n    inverse_CH\n    inverse_LDL\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "irregular",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.irregular",
    "type": "method",
    "description": "Return a matrix filled by the given matrices which\n        are listed in order of appearance from left to right, top to\n        bottom as they first appear in the matrix. They must fill the\n        matrix completely.\n\n        Examples\n        ========\n\n        >>> from sympy import ones, Matrix\n        >>> Matrix.irregular(3, ones(2,1), ones(3,3)*2, ones(2,2)*3,\n        ...   ones(1,1)*4, ones(2,2)*5, ones(1,2)*6, ones(1,2)*7)\n        Matrix([\n          [1, 2, 2, 2, 3, 3],\n          [1, 2, 2, 2, 3, 3],\n          [4, 2, 2, 2, 5, 5],\n          [6, 6, 7, 7, 5, 5]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_anti_symmetric",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_anti_symmetric",
    "type": "method",
    "description": "Check if matrix M is an antisymmetric matrix,\n        that is, M is a square matrix with all M[i, j] == -M[j, i].\n\n        When ``simplify=True`` (default), the sum M[i, j] + M[j, i] is\n        simplified before testing to see if it is zero. By default,\n        the SymPy simplify function is used. To use a custom function\n        set simplify to a function that accepts a single argument which\n        returns a simplified expression. To skip simplification, set\n        simplify to False but note that although this will be faster,\n        it may induce false negatives.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, symbols\n        >>> m = Matrix(2, 2, [0, 1, -1, 0])\n        >>> m\n        Matrix([\n        [ 0, 1],\n        [-1, 0]])\n        >>> m.is_anti_symmetric()\n        True\n        >>> x, y = symbols('x y')\n        >>> m = Matrix(2, 3, [0, 0, x, -y, 0, 0])\n        >>> m\n        Matrix([\n        [ 0, 0, x],\n        [-y, 0, 0]])\n        >>> m.is_anti_symmetric()\n        False\n\n        >>> from sympy.abc import x, y\n        >>> m = Matrix(3, 3, [0, x**2 + 2*x + 1, y,\n        ...                   -(x + 1)**2, 0, x*y,\n        ...                   -y, -x*y, 0])\n\n        Simplification of matrix elements is done by default so even\n        though two elements which should be equal and opposite would not\n        pass an equality test, the matrix is still reported as\n        anti-symmetric:\n\n        >>> m[0, 1] == -m[1, 0]\n        False\n        >>> m.is_anti_symmetric()\n        True\n\n        If ``simplify=False`` is used for the case when a Matrix is already\n        simplified, this will speed things up. Here, we see that without\n        simplification the matrix does not appear anti-symmetric:\n\n        >>> print(m.is_anti_symmetric(simplify=False))\n        None\n\n        But if the matrix were already expanded, then it would appear\n        anti-symmetric and simplification in the is_anti_symmetric routine\n        is not needed:\n\n        >>> m = m.expand()\n        >>> m.is_anti_symmetric(simplify=False)\n        True\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_diagonal",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_diagonal",
    "type": "method",
    "description": "Check if matrix is diagonal,\n        that is matrix in which the entries outside the main diagonal are all zero.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, diag\n        >>> m = Matrix(2, 2, [1, 0, 0, 2])\n        >>> m\n        Matrix([\n        [1, 0],\n        [0, 2]])\n        >>> m.is_diagonal()\n        True\n\n        >>> m = Matrix(2, 2, [1, 1, 0, 2])\n        >>> m\n        Matrix([\n        [1, 1],\n        [0, 2]])\n        >>> m.is_diagonal()\n        False\n\n        >>> m = diag(1, 2, 3)\n        >>> m\n        Matrix([\n        [1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]])\n        >>> m.is_diagonal()\n        True\n\n        See Also\n        ========\n\n        is_lower\n        is_upper\n        sympy.matrices.matrixbase.MatrixBase.is_diagonalizable\n        diagonalize\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_diagonalizable",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_diagonalizable",
    "type": "method",
    "description": "Returns ``True`` if a matrix is diagonalizable.\n\n    Parameters\n    ==========\n\n    reals_only : bool, optional\n        If ``True``, it tests whether the matrix can be diagonalized\n        to contain only real numbers on the diagonal.\n\n\n        If ``False``, it tests whether the matrix can be diagonalized\n        at all, even with numbers that may not be real.\n\n    Examples\n    ========\n\n    Example of a diagonalizable matrix:\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[1, 2, 0], [0, 3, 0], [2, -4, 2]])\n    >>> M.is_diagonalizable()\n    True\n\n    Example of a non-diagonalizable matrix:\n\n    >>> M = Matrix([[0, 1], [0, 0]])\n    >>> M.is_diagonalizable()\n    False\n\n    Example of a matrix that is diagonalized in terms of non-real entries:\n\n    >>> M = Matrix([[0, 1], [-1, 0]])\n    >>> M.is_diagonalizable(reals_only=False)\n    True\n    >>> M.is_diagonalizable(reals_only=True)\n    False\n\n    See Also\n    ========\n\n    sympy.matrices.matrixbase.MatrixBase.is_diagonal\n    diagonalize\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_echelon",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_echelon",
    "type": "property",
    "description": "Returns `True` if the matrix is in echelon form. That is, all rows of\n    zeros are at the bottom, and below each leading non-zero in a row are\n    exclusively zeros.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_hermitian",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_hermitian",
    "type": "property",
    "description": "Checks if the matrix is Hermitian.\n\n        In a Hermitian matrix element i,j is the complex conjugate of\n        element j,i.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> from sympy import I\n        >>> from sympy.abc import x\n        >>> a = Matrix([[1, I], [-I, 1]])\n        >>> a\n        Matrix([\n        [ 1, I],\n        [-I, 1]])\n        >>> a.is_hermitian\n        True\n        >>> a[0, 0] = 2*I\n        >>> a.is_hermitian\n        False\n        >>> a[0, 0] = x\n        >>> a.is_hermitian\n        >>> a[0, 1] = a[1, 0]*I\n        >>> a.is_hermitian\n        False\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_indefinite",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_indefinite",
    "type": "property",
    "description": "Finds out the definiteness of a matrix.\n\n    Explanation\n    ===========\n\n    A square real matrix $A$ is:\n\n    - A positive definite matrix if $x^T A x > 0$\n      for all non-zero real vectors $x$.\n    - A positive semidefinite matrix if $x^T A x \\geq 0$\n      for all non-zero real vectors $x$.\n    - A negative definite matrix if $x^T A x < 0$\n      for all non-zero real vectors $x$.\n    - A negative semidefinite matrix if $x^T A x \\leq 0$\n      for all non-zero real vectors $x$.\n    - An indefinite matrix if there exists non-zero real vectors\n      $x, y$ with $x^T A x > 0 > y^T A y$.\n\n    A square complex matrix $A$ is:\n\n    - A positive definite matrix if $\\text{re}(x^H A x) > 0$\n      for all non-zero complex vectors $x$.\n    - A positive semidefinite matrix if $\\text{re}(x^H A x) \\geq 0$\n      for all non-zero complex vectors $x$.\n    - A negative definite matrix if $\\text{re}(x^H A x) < 0$\n      for all non-zero complex vectors $x$.\n    - A negative semidefinite matrix if $\\text{re}(x^H A x) \\leq 0$\n      for all non-zero complex vectors $x$.\n    - An indefinite matrix if there exists non-zero complex vectors\n      $x, y$ with $\\text{re}(x^H A x) > 0 > \\text{re}(y^H A y)$.\n\n    A matrix need not be symmetric or hermitian to be positive definite.\n\n    - A real non-symmetric matrix is positive definite if and only if\n      $\\frac{A + A^T}{2}$ is positive definite.\n    - A complex non-hermitian matrix is positive definite if and only if\n      $\\frac{A + A^H}{2}$ is positive definite.\n\n    And this extension can apply for all the definitions above.\n\n    However, for complex cases, you can restrict the definition of\n    $\\text{re}(x^H A x) > 0$ to $x^H A x > 0$ and require the matrix\n    to be hermitian.\n    But we do not present this restriction for computation because you\n    can check ``M.is_hermitian`` independently with this and use\n    the same procedure.\n\n    Examples\n    ========\n\n    An example of symmetric positive definite matrix:\n\n    .. plot::\n        :context: reset\n        :format: doctest\n        :include-source: True\n\n        >>> from sympy import Matrix, symbols\n        >>> from sympy.plotting import plot3d\n        >>> a, b = symbols('a b')\n        >>> x = Matrix([a, b])\n\n        >>> A = Matrix([[1, 0], [0, 1]])\n        >>> A.is_positive_definite\n        True\n        >>> A.is_positive_semidefinite\n        True\n\n        >>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1))\n\n    An example of symmetric positive semidefinite matrix:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> A = Matrix([[1, -1], [-1, 1]])\n        >>> A.is_positive_definite\n        False\n        >>> A.is_positive_semidefinite\n        True\n\n        >>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1))\n\n    An example of symmetric negative definite matrix:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> A = Matrix([[-1, 0], [0, -1]])\n        >>> A.is_negative_definite\n        True\n        >>> A.is_negative_semidefinite\n        True\n        >>> A.is_indefinite\n        False\n\n        >>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1))\n\n    An example of symmetric indefinite matrix:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> A = Matrix([[1, 2], [2, -1]])\n        >>> A.is_indefinite\n        True\n\n        >>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1))\n\n    An example of non-symmetric positive definite matrix.\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> A = Matrix([[1, 2], [-2, 1]])\n        >>> A.is_positive_definite\n        True\n        >>> A.is_positive_semidefinite\n        True\n\n        >>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1))\n\n    Notes\n    =====\n\n    Although some people trivialize the definition of positive definite\n    matrices only for symmetric or hermitian matrices, this restriction\n    is not correct because it does not classify all instances of\n    positive definite matrices from the definition $x^T A x > 0$ or\n    $\\text{re}(x^H A x) > 0$.\n\n    For instance, ``Matrix([[1, 2], [-2, 1]])`` presented in\n    the example above is an example of real positive definite matrix\n    that is not symmetric.\n\n    However, since the following formula holds true;\n\n    .. math::\n        \\text{re}(x^H A x) > 0 \\iff\n        \\text{re}(x^H \\frac{A + A^H}{2} x) > 0\n\n    We can classify all positive definite matrices that may or may not\n    be symmetric or hermitian by transforming the matrix to\n    $\\frac{A + A^T}{2}$ or $\\frac{A + A^H}{2}$\n    (which is guaranteed to be always real symmetric or complex\n    hermitian) and we can defer most of the studies to symmetric or\n    hermitian positive definite matrices.\n\n    But it is a different problem for the existence of Cholesky\n    decomposition. Because even though a non symmetric or a non\n    hermitian matrix can be positive definite, Cholesky or LDL\n    decomposition does not exist because the decompositions require the\n    matrix to be symmetric or hermitian.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues\n\n    .. [2] https://mathworld.wolfram.com/PositiveDefiniteMatrix.html\n\n    .. [3] Johnson, C. R. \"Positive Definite Matrices.\" Amer.\n        Math. Monthly 77, 259-264 1970.\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_lower",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_lower",
    "type": "property",
    "description": "Check if matrix is a lower triangular matrix. True can be returned\n        even if the matrix is not square.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix(2, 2, [1, 0, 0, 1])\n        >>> m\n        Matrix([\n        [1, 0],\n        [0, 1]])\n        >>> m.is_lower\n        True\n\n        >>> m = Matrix(4, 3, [0, 0, 0, 2, 0, 0, 1, 4, 0, 6, 6, 5])\n        >>> m\n        Matrix([\n        [0, 0, 0],\n        [2, 0, 0],\n        [1, 4, 0],\n        [6, 6, 5]])\n        >>> m.is_lower\n        True\n\n        >>> from sympy.abc import x, y\n        >>> m = Matrix(2, 2, [x**2 + y, y**2 + x, 0, x + y])\n        >>> m\n        Matrix([\n        [x**2 + y, x + y**2],\n        [       0,    x + y]])\n        >>> m.is_lower\n        False\n\n        See Also\n        ========\n\n        is_upper\n        is_diagonal\n        is_lower_hessenberg\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_lower_hessenberg",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_lower_hessenberg",
    "type": "property",
    "description": "Checks if the matrix is in the lower-Hessenberg form.\n\n        The lower hessenberg matrix has zero entries\n        above the first superdiagonal.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> a = Matrix([[1, 2, 0, 0], [5, 2, 3, 0], [3, 4, 3, 7], [5, 6, 1, 1]])\n        >>> a\n        Matrix([\n        [1, 2, 0, 0],\n        [5, 2, 3, 0],\n        [3, 4, 3, 7],\n        [5, 6, 1, 1]])\n        >>> a.is_lower_hessenberg\n        True\n\n        See Also\n        ========\n\n        is_upper_hessenberg\n        is_lower\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_nilpotent",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_nilpotent",
    "type": "method",
    "description": "Checks if a matrix is nilpotent.\n\n        A matrix B is nilpotent if for some integer k, B**k is\n        a zero matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> a = Matrix([[0, 0, 0], [1, 0, 0], [1, 1, 0]])\n        >>> a.is_nilpotent()\n        True\n\n        >>> a = Matrix([[1, 0, 1], [1, 0, 0], [1, 1, 0]])\n        >>> a.is_nilpotent()\n        False\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_square",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_square",
    "type": "property",
    "description": "Checks if a matrix is square.\n\n        A matrix is square if the number of rows equals the number of columns.\n        The empty matrix is square by definition, since the number of rows and\n        the number of columns are both zero.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> a = Matrix([[1, 2, 3], [4, 5, 6]])\n        >>> b = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        >>> c = Matrix([])\n        >>> a.is_square\n        False\n        >>> b.is_square\n        True\n        >>> c.is_square\n        True\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_strongly_diagonally_dominant",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_strongly_diagonally_dominant",
    "type": "property",
    "description": "Tests if the matrix is row strongly diagonally dominant.\n\n        Explanation\n        ===========\n\n        A $n, n$ matrix $A$ is row strongly diagonally dominant if\n\n        .. math::\n            \\left|A_{i, i}\\right| > \\sum_{j = 0, j \\neq i}^{n-1}\n            \\left|A_{i, j}\\right| \\quad {\\text{for all }}\n            i \\in \\{ 0, ..., n-1 \\}\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> A = Matrix([[3, -2, 1], [1, -3, 2], [-1, 2, 4]])\n        >>> A.is_strongly_diagonally_dominant\n        False\n\n        >>> A = Matrix([[-2, 2, 1], [1, 3, 2], [1, -2, 0]])\n        >>> A.is_strongly_diagonally_dominant\n        False\n\n        >>> A = Matrix([[-4, 2, 1], [1, 6, 2], [1, -2, 5]])\n        >>> A.is_strongly_diagonally_dominant\n        True\n\n        Notes\n        =====\n\n        If you want to test whether a matrix is column diagonally\n        dominant, you can apply the test after transposing the matrix.\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_symbolic",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_symbolic",
    "type": "method",
    "description": "Checks if any elements contain Symbols.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> from sympy.abc import x, y\n        >>> M = Matrix([[x, y], [1, 0]])\n        >>> M.is_symbolic()\n        True\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_symmetric",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_symmetric",
    "type": "method",
    "description": "Check if matrix is symmetric matrix,\n        that is square matrix and is equal to its transpose.\n\n        By default, simplifications occur before testing symmetry.\n        They can be skipped using 'simplify=False'; while speeding things a bit,\n        this may however induce false negatives.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix(2, 2, [0, 1, 1, 2])\n        >>> m\n        Matrix([\n        [0, 1],\n        [1, 2]])\n        >>> m.is_symmetric()\n        True\n\n        >>> m = Matrix(2, 2, [0, 1, 2, 0])\n        >>> m\n        Matrix([\n        [0, 1],\n        [2, 0]])\n        >>> m.is_symmetric()\n        False\n\n        >>> m = Matrix(2, 3, [0, 0, 0, 0, 0, 0])\n        >>> m\n        Matrix([\n        [0, 0, 0],\n        [0, 0, 0]])\n        >>> m.is_symmetric()\n        False\n\n        >>> from sympy.abc import x, y\n        >>> m = Matrix(3, 3, [1, x**2 + 2*x + 1, y, (x + 1)**2, 2, 0, y, 0, 3])\n        >>> m\n        Matrix([\n        [         1, x**2 + 2*x + 1, y],\n        [(x + 1)**2,              2, 0],\n        [         y,              0, 3]])\n        >>> m.is_symmetric()\n        True\n\n        If the matrix is already simplified, you may speed-up is_symmetric()\n        test by using 'simplify=False'.\n\n        >>> bool(m.is_symmetric(simplify=False))\n        False\n        >>> m1 = m.expand()\n        >>> m1.is_symmetric(simplify=False)\n        True\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_upper",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_upper",
    "type": "property",
    "description": "Check if matrix is an upper triangular matrix. True can be returned\n        even if the matrix is not square.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix(2, 2, [1, 0, 0, 1])\n        >>> m\n        Matrix([\n        [1, 0],\n        [0, 1]])\n        >>> m.is_upper\n        True\n\n        >>> m = Matrix(4, 3, [5, 1, 9, 0, 4, 6, 0, 0, 5, 0, 0, 0])\n        >>> m\n        Matrix([\n        [5, 1, 9],\n        [0, 4, 6],\n        [0, 0, 5],\n        [0, 0, 0]])\n        >>> m.is_upper\n        True\n\n        >>> m = Matrix(2, 3, [4, 2, 5, 6, 1, 1])\n        >>> m\n        Matrix([\n        [4, 2, 5],\n        [6, 1, 1]])\n        >>> m.is_upper\n        False\n\n        See Also\n        ========\n\n        is_lower\n        is_diagonal\n        is_upper_hessenberg\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_upper_hessenberg",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_upper_hessenberg",
    "type": "property",
    "description": "Checks if the matrix is the upper-Hessenberg form.\n\n        The upper hessenberg matrix has zero entries\n        below the first subdiagonal.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> a = Matrix([[1, 4, 2, 3], [3, 4, 1, 7], [0, 2, 3, 4], [0, 0, 1, 3]])\n        >>> a\n        Matrix([\n        [1, 4, 2, 3],\n        [3, 4, 1, 7],\n        [0, 2, 3, 4],\n        [0, 0, 1, 3]])\n        >>> a.is_upper_hessenberg\n        True\n\n        See Also\n        ========\n\n        is_lower_hessenberg\n        is_upper\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_weakly_diagonally_dominant",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_weakly_diagonally_dominant",
    "type": "property",
    "description": "Tests if the matrix is row weakly diagonally dominant.\n\n        Explanation\n        ===========\n\n        A $n, n$ matrix $A$ is row weakly diagonally dominant if\n\n        .. math::\n            \\left|A_{i, i}\\right| \\ge \\sum_{j = 0, j \\neq i}^{n-1}\n            \\left|A_{i, j}\\right| \\quad {\\text{for all }}\n            i \\in \\{ 0, ..., n-1 \\}\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> A = Matrix([[3, -2, 1], [1, -3, 2], [-1, 2, 4]])\n        >>> A.is_weakly_diagonally_dominant\n        True\n\n        >>> A = Matrix([[-2, 2, 1], [1, 3, 2], [1, -2, 0]])\n        >>> A.is_weakly_diagonally_dominant\n        False\n\n        >>> A = Matrix([[-4, 2, 1], [1, 6, 2], [1, -2, 5]])\n        >>> A.is_weakly_diagonally_dominant\n        True\n\n        Notes\n        =====\n\n        If you want to test whether a matrix is column diagonally\n        dominant, you can apply the test after transposing the matrix.\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "is_zero_matrix",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.is_zero_matrix",
    "type": "property",
    "description": "Checks if a matrix is a zero matrix.\n\n        A matrix is zero if every element is zero.  A matrix need not be square\n        to be considered zero.  The empty matrix is zero by the principle of\n        vacuous truth.  For a matrix that may or may not be zero (e.g.\n        contains a symbol), this will be None\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, zeros\n        >>> from sympy.abc import x\n        >>> a = Matrix([[0, 0], [0, 0]])\n        >>> b = zeros(3, 4)\n        >>> c = Matrix([[0, 1], [0, 0]])\n        >>> d = Matrix([])\n        >>> e = Matrix([[x, 0], [0, 0]])\n        >>> a.is_zero_matrix\n        True\n        >>> b.is_zero_matrix\n        True\n        >>> c.is_zero_matrix\n        False\n        >>> d.is_zero_matrix\n        True\n        >>> e.is_zero_matrix\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "iter_items",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.iter_items",
    "type": "method",
    "description": "Iterate over indices and values of nonzero items.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix([[0, 1], [2, 3]])\n        >>> list(m.iter_items())\n        [((0, 1), 1), ((1, 0), 2), ((1, 1), 3)]\n\n        See Also\n        ========\n\n        iter_values\n        todok\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "iter_values",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.iter_values",
    "type": "method",
    "description": "\n        Iterate over non-zero values of self.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix([[0, 1], [2, 3]])\n        >>> list(m.iter_values())\n        [1, 2, 3]\n\n        See Also\n        ========\n\n        values\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "jacobian",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.jacobian",
    "type": "method",
    "description": "Calculates the Jacobian matrix (derivative of a vector-valued function).\n\n        Parameters\n        ==========\n\n        ``self`` : vector of expressions representing functions f_i(x_1, ..., x_n).\n        X : set of x_i's in order, it can be a list or a Matrix\n\n        Both ``self`` and X can be a row or a column matrix in any order\n        (i.e., jacobian() should always work).\n\n        Examples\n        ========\n\n        >>> from sympy import sin, cos, Matrix\n        >>> from sympy.abc import rho, phi\n        >>> X = Matrix([rho*cos(phi), rho*sin(phi), rho**2])\n        >>> Y = Matrix([rho, phi])\n        >>> X.jacobian(Y)\n        Matrix([\n        [cos(phi), -rho*sin(phi)],\n        [sin(phi),  rho*cos(phi)],\n        [   2*rho,             0]])\n        >>> X = Matrix([rho*cos(phi), rho*sin(phi)])\n        >>> X.jacobian(Y)\n        Matrix([\n        [cos(phi), -rho*sin(phi)],\n        [sin(phi),  rho*cos(phi)]])\n\n        See Also\n        ========\n\n        hessian\n        wronskian\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "jordan_block",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.jordan_block",
    "type": "method",
    "description": "Returns a Jordan block\n\n        Parameters\n        ==========\n\n        size : Integer, optional\n            Specifies the shape of the Jordan block matrix.\n\n        eigenvalue : Number or Symbol\n            Specifies the value for the main diagonal of the matrix.\n\n            .. note::\n                The keyword ``eigenval`` is also specified as an alias\n                of this keyword, but it is not recommended to use.\n\n                We may deprecate the alias in later release.\n\n        band : 'upper' or 'lower', optional\n            Specifies the position of the off-diagonal to put `1` s on.\n\n        cls : Matrix, optional\n            Specifies the matrix class of the output form.\n\n            If it is not specified, the class type where the method is\n            being executed on will be returned.\n\n        Returns\n        =======\n\n        Matrix\n            A Jordan block matrix.\n\n        Raises\n        ======\n\n        ValueError\n            If insufficient arguments are given for matrix size\n            specification, or no eigenvalue is given.\n\n        Examples\n        ========\n\n        Creating a default Jordan block:\n\n        >>> from sympy import Matrix\n        >>> from sympy.abc import x\n        >>> Matrix.jordan_block(4, x)\n        Matrix([\n        [x, 1, 0, 0],\n        [0, x, 1, 0],\n        [0, 0, x, 1],\n        [0, 0, 0, x]])\n\n        Creating an alternative Jordan block matrix where `1` is on\n        lower off-diagonal:\n\n        >>> Matrix.jordan_block(4, x, band='lower')\n        Matrix([\n        [x, 0, 0, 0],\n        [1, x, 0, 0],\n        [0, 1, x, 0],\n        [0, 0, 1, x]])\n\n        Creating a Jordan block with keyword arguments\n\n        >>> Matrix.jordan_block(size=4, eigenvalue=x)\n        Matrix([\n        [x, 1, 0, 0],\n        [0, x, 1, 0],\n        [0, 0, x, 1],\n        [0, 0, 0, x]])\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Jordan_matrix\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "jordan_form",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.jordan_form",
    "type": "method",
    "description": "Return $(P, J)$ where $J$ is a Jordan block\n    matrix and $P$ is a matrix such that $M = P J P^{-1}$\n\n    Parameters\n    ==========\n\n    calc_transform : bool\n        If ``False``, then only $J$ is returned.\n\n    chop : bool\n        All matrices are converted to exact types when computing\n        eigenvalues and eigenvectors.  As a result, there may be\n        approximation errors.  If ``chop==True``, these errors\n        will be truncated.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[ 6,  5, -2, -3], [-3, -1,  3,  3], [ 2,  1, -2, -3], [-1,  1,  5,  5]])\n    >>> P, J = M.jordan_form()\n    >>> J\n    Matrix([\n    [2, 1, 0, 0],\n    [0, 2, 0, 0],\n    [0, 0, 2, 1],\n    [0, 0, 0, 2]])\n\n    See Also\n    ========\n\n    jordan_block\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "key2bounds",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.key2bounds",
    "type": "method",
    "description": "Converts a key with potentially mixed types of keys (integer and slice)\n        into a tuple of ranges and raises an error if any index is out of ``self``'s\n        range.\n\n        See Also\n        ========\n\n        key2ij\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "key2ij",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.key2ij",
    "type": "method",
    "description": "Converts key into canonical form, converting integers or indexable\n        items into valid integers for ``self``'s range or returning slices\n        unchanged.\n\n        See Also\n        ========\n\n        key2bounds\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "left_eigenvects",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.left_eigenvects",
    "type": "method",
    "description": "Returns left eigenvectors and eigenvalues.\n\n    This function returns the list of triples (eigenval, multiplicity,\n    basis) for the left eigenvectors. Options are the same as for\n    eigenvects(), i.e. the ``**flags`` arguments gets passed directly to\n    eigenvects().\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[0, 1, 1], [1, 0, 0], [1, 1, 1]])\n    >>> M.eigenvects()\n    [(-1, 1, [Matrix([\n    [-1],\n    [ 1],\n    [ 0]])]), (0, 1, [Matrix([\n    [ 0],\n    [-1],\n    [ 1]])]), (2, 1, [Matrix([\n    [2/3],\n    [1/3],\n    [  1]])])]\n    >>> M.left_eigenvects()\n    [(-1, 1, [Matrix([[-2, 1, 1]])]), (0, 1, [Matrix([[-1, -1, 1]])]), (2,\n    1, [Matrix([[1, 1, 1]])])]\n\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "limit",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.limit",
    "type": "method",
    "description": "Calculate the limit of each element in the matrix.\n        ``args`` will be passed to the ``limit`` function.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> from sympy.abc import x, y\n        >>> M = Matrix([[x, y], [1, 0]])\n        >>> M.limit(x, 2)\n        Matrix([\n        [2, y],\n        [1, 0]])\n\n        See Also\n        ========\n\n        integrate\n        diff\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "log",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.log",
    "type": "method",
    "description": "Return the logarithm of a square matrix.\n\n        Parameters\n        ==========\n\n        simplify : function, bool\n            The function to simplify the result with.\n\n            Default is ``cancel``, which is effective to reduce the\n            expression growing for taking reciprocals and inverses for\n            symbolic matrices.\n\n        Examples\n        ========\n\n        >>> from sympy import S, Matrix\n\n        Examples for positive-definite matrices:\n\n        >>> m = Matrix([[1, 1], [0, 1]])\n        >>> m.log()\n        Matrix([\n        [0, 1],\n        [0, 0]])\n\n        >>> m = Matrix([[S(5)/4, S(3)/4], [S(3)/4, S(5)/4]])\n        >>> m.log()\n        Matrix([\n        [     0, log(2)],\n        [log(2),      0]])\n\n        Examples for non positive-definite matrices:\n\n        >>> m = Matrix([[S(3)/4, S(5)/4], [S(5)/4, S(3)/4]])\n        >>> m.log()\n        Matrix([\n        [         I*pi/2, log(2) - I*pi/2],\n        [log(2) - I*pi/2,          I*pi/2]])\n\n        >>> m = Matrix(\n        ...     [[0, 0, 0, 1],\n        ...      [0, 0, 1, 0],\n        ...      [0, 1, 0, 0],\n        ...      [1, 0, 0, 0]])\n        >>> m.log()\n        Matrix([\n        [ I*pi/2,       0,       0, -I*pi/2],\n        [      0,  I*pi/2, -I*pi/2,       0],\n        [      0, -I*pi/2,  I*pi/2,       0],\n        [-I*pi/2,       0,       0,  I*pi/2]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "lower_triangular",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.lower_triangular",
    "type": "method",
    "description": "Return the elements on and below the kth diagonal of a matrix.\n        If k is not specified then simply returns lower-triangular portion\n        of a matrix\n\n        Examples\n        ========\n\n        >>> from sympy import ones\n        >>> A = ones(4)\n        >>> A.lower_triangular()\n        Matrix([\n        [1, 0, 0, 0],\n        [1, 1, 0, 0],\n        [1, 1, 1, 0],\n        [1, 1, 1, 1]])\n\n        >>> A.lower_triangular(-2)\n        Matrix([\n        [0, 0, 0, 0],\n        [0, 0, 0, 0],\n        [1, 0, 0, 0],\n        [1, 1, 0, 0]])\n\n        >>> A.lower_triangular(1)\n        Matrix([\n        [1, 1, 0, 0],\n        [1, 1, 1, 0],\n        [1, 1, 1, 1],\n        [1, 1, 1, 1]])\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "lower_triangular_solve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.lower_triangular_solve",
    "type": "method",
    "description": "Solves ``Ax = B``, where A is a lower triangular matrix.\n\n    See Also\n    ========\n\n    upper_triangular_solve\n    gauss_jordan_solve\n    cholesky_solve\n    diagonal_solve\n    LDLsolve\n    LUsolve\n    QRsolve\n    pinv_solve\n    cramer_solve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "minor",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.minor",
    "type": "method",
    "description": "Return the (i,j) minor of ``M``.  That is,\n    return the determinant of the matrix obtained by deleting\n    the `i`th row and `j`th column from ``M``.\n\n    Parameters\n    ==========\n\n    i, j : int\n        The row and column to exclude to obtain the submatrix.\n\n    method : string, optional\n        Method to use to find the determinant of the submatrix, can be\n        \"bareiss\", \"berkowitz\", \"bird\", \"laplace\" or \"lu\".\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> M.minor(1, 1)\n    -12\n\n    See Also\n    ========\n\n    minor_submatrix\n    cofactor\n    det\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "minor_submatrix",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.minor_submatrix",
    "type": "method",
    "description": "Return the submatrix obtained by removing the `i`th row\n    and `j`th column from ``M`` (works with Pythonic negative indices).\n\n    Parameters\n    ==========\n\n    i, j : int\n        The row and column to exclude to obtain the submatrix.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> M.minor_submatrix(1, 1)\n    Matrix([\n    [1, 3],\n    [7, 9]])\n\n    See Also\n    ========\n\n    minor\n    cofactor\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "multiply",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.multiply",
    "type": "method",
    "description": "Same as __mul__() but with optional simplification.\n\n        Parameters\n        ==========\n\n        dotprodsimp : bool, optional\n            Specifies whether intermediate term algebraic simplification is used\n            during matrix multiplications to control expression blowup and thus\n            speed up calculation. Default is off.\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "multiply_elementwise",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.multiply_elementwise",
    "type": "method",
    "description": "Return the Hadamard product (elementwise product) of A and B\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> A = Matrix([[0, 1, 2], [3, 4, 5]])\n        >>> B = Matrix([[1, 10, 100], [100, 10, 1]])\n        >>> A.multiply_elementwise(B)\n        Matrix([\n        [  0, 10, 200],\n        [300, 40,   5]])\n\n        See Also\n        ========\n\n        sympy.matrices.matrixbase.MatrixBase.cross\n        sympy.matrices.matrixbase.MatrixBase.dot\n        multiply\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "norm",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.norm",
    "type": "method",
    "description": "Return the Norm of a Matrix or Vector.\n\n        In the simplest case this is the geometric size of the vector\n        Other norms can be specified by the ord parameter\n\n\n        =====  ============================  ==========================\n        ord    norm for matrices             norm for vectors\n        =====  ============================  ==========================\n        None   Frobenius norm                2-norm\n        'fro'  Frobenius norm                - does not exist\n        inf    maximum row sum               max(abs(x))\n        -inf   --                            min(abs(x))\n        1      maximum column sum            as below\n        -1     --                            as below\n        2      2-norm (largest sing. value)  as below\n        -2     smallest singular value       as below\n        other  - does not exist              sum(abs(x)**ord)**(1./ord)\n        =====  ============================  ==========================\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, Symbol, trigsimp, cos, sin, oo\n        >>> x = Symbol('x', real=True)\n        >>> v = Matrix([cos(x), sin(x)])\n        >>> trigsimp( v.norm() )\n        1\n        >>> v.norm(10)\n        (sin(x)**10 + cos(x)**10)**(1/10)\n        >>> A = Matrix([[1, 1], [1, 1]])\n        >>> A.norm(1) # maximum sum of absolute values of A is 2\n        2\n        >>> A.norm(2) # Spectral norm (max of |Ax|/|x| under 2-vector-norm)\n        2\n        >>> A.norm(-2) # Inverse spectral norm (smallest singular value)\n        0\n        >>> A.norm() # Frobenius Norm\n        2\n        >>> A.norm(oo) # Infinity Norm\n        2\n        >>> Matrix([1, -2]).norm(oo)\n        2\n        >>> Matrix([-1, 2]).norm(-oo)\n        1\n\n        See Also\n        ========\n\n        normalized\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "normalized",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.normalized",
    "type": "method",
    "description": "Return the normalized version of ``self``.\n\n        Parameters\n        ==========\n\n        iszerofunc : Function, optional\n            A function to determine whether ``self`` is a zero vector.\n            The default ``_iszero`` tests to see if each element is\n            exactly zero.\n\n        Returns\n        =======\n\n        Matrix\n            Normalized vector form of ``self``.\n            It has the same length as a unit vector. However, a zero vector\n            will be returned for a vector with norm 0.\n\n        Raises\n        ======\n\n        ShapeError\n            If the matrix is not in a vector form.\n\n        See Also\n        ========\n\n        norm\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "nullspace",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.nullspace",
    "type": "method",
    "description": "Returns list of vectors (Matrix objects) that span nullspace of ``M``\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])\n    >>> M\n    Matrix([\n    [ 1,  3, 0],\n    [-2, -6, 0],\n    [ 3,  9, 6]])\n    >>> M.nullspace()\n    [Matrix([\n    [-3],\n    [ 1],\n    [ 0]])]\n\n    See Also\n    ========\n\n    columnspace\n    rowspace\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "ones",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.ones",
    "type": "method",
    "description": "Returns a matrix of ones.\n\n        Parameters\n        ==========\n\n        rows : rows of the matrix\n        cols : cols of the matrix (if None, cols=rows)\n\n        kwargs\n        ======\n        cls : class of the returned matrix\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "orthogonalize",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.orthogonalize",
    "type": "method",
    "description": "Apply the Gram-Schmidt orthogonalization procedure\n    to vectors supplied in ``vecs``.\n\n    Parameters\n    ==========\n\n    vecs\n        vectors to be made orthogonal\n\n    normalize : bool\n        If ``True``, return an orthonormal basis.\n\n    rankcheck : bool\n        If ``True``, the computation does not stop when encountering\n        linearly dependent vectors.\n\n        If ``False``, it will raise ``ValueError`` when any zero\n        or linearly dependent vectors are found.\n\n    Returns\n    =======\n\n    list\n        List of orthogonal (or orthonormal) basis vectors.\n\n    Examples\n    ========\n\n    >>> from sympy import I, Matrix\n    >>> v = [Matrix([1, I]), Matrix([1, -I])]\n    >>> Matrix.orthogonalize(*v)\n    [Matrix([\n    [1],\n    [I]]), Matrix([\n    [ 1],\n    [-I]])]\n\n    See Also\n    ========\n\n    MatrixBase.QRdecomposition\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "per",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.per",
    "type": "method",
    "description": "Returns the permanent of a matrix. Unlike determinant,\n    permanent is defined for both square and non-square matrices.\n\n    For an m x n matrix, with m less than or equal to n,\n    it is given as the sum over the permutations s of size\n    less than or equal to m on [1, 2, . . . n] of the product\n    from i = 1 to m of M[i, s[i]]. Taking the transpose will\n    not affect the value of the permanent.\n\n    In the case of a square matrix, this is the same as the permutation\n    definition of the determinant, but it does not take the sign of the\n    permutation into account. Computing the permanent with this definition\n    is quite inefficient, so here the Ryser formula is used.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> M.per()\n    450\n    >>> M = Matrix([1, 5, 7])\n    >>> M.per()\n    13\n\n    References\n    ==========\n\n    .. [1] Prof. Frank Ben's notes: https://math.berkeley.edu/~bernd/ban275.pdf\n    .. [2] Wikipedia article on Permanent: https://en.wikipedia.org/wiki/Permanent_%28mathematics%29\n    .. [3] https://reference.wolfram.com/language/ref/Permanent.html\n    .. [4] Permanent of a rectangular matrix : https://arxiv.org/pdf/0904.3251.pdf\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "permute",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.permute",
    "type": "method",
    "description": "Permute the rows or columns of a matrix by the given list of\n        swaps.\n\n        Parameters\n        ==========\n\n        perm : Permutation, list, or list of lists\n            A representation for the permutation.\n\n            If it is ``Permutation``, it is used directly with some\n            resizing with respect to the matrix size.\n\n            If it is specified as list of lists,\n            (e.g., ``[[0, 1], [0, 2]]``), then the permutation is formed\n            from applying the product of cycles. The direction how the\n            cyclic product is applied is described in below.\n\n            If it is specified as a list, the list should represent\n            an array form of a permutation. (e.g., ``[1, 2, 0]``) which\n            would would form the swapping function\n            `0 \\mapsto 1, 1 \\mapsto 2, 2\\mapsto 0`.\n\n        orientation : 'rows', 'cols'\n            A flag to control whether to permute the rows or the columns\n\n        direction : 'forward', 'backward'\n            A flag to control whether to apply the permutations from\n            the start of the list first, or from the back of the list\n            first.\n\n            For example, if the permutation specification is\n            ``[[0, 1], [0, 2]]``,\n\n            If the flag is set to ``'forward'``, the cycle would be\n            formed as `0 \\mapsto 2, 2 \\mapsto 1, 1 \\mapsto 0`.\n\n            If the flag is set to ``'backward'``, the cycle would be\n            formed as `0 \\mapsto 1, 1 \\mapsto 2, 2 \\mapsto 0`.\n\n            If the argument ``perm`` is not in a form of list of lists,\n            this flag takes no effect.\n\n        Examples\n        ========\n\n        >>> from sympy import eye\n        >>> M = eye(3)\n        >>> M.permute([[0, 1], [0, 2]], orientation='rows', direction='forward')\n        Matrix([\n        [0, 0, 1],\n        [1, 0, 0],\n        [0, 1, 0]])\n\n        >>> from sympy import eye\n        >>> M = eye(3)\n        >>> M.permute([[0, 1], [0, 2]], orientation='rows', direction='backward')\n        Matrix([\n        [0, 1, 0],\n        [0, 0, 1],\n        [1, 0, 0]])\n\n        Notes\n        =====\n\n        If a bijective function\n        `\\sigma : \\mathbb{N}_0 \\rightarrow \\mathbb{N}_0` denotes the\n        permutation.\n\n        If the matrix `A` is the matrix to permute, represented as\n        a horizontal or a vertical stack of vectors:\n\n        .. math::\n            A =\n            \\begin{bmatrix}\n            a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_{n-1}\n            \\end{bmatrix} =\n            \\begin{bmatrix}\n            \\alpha_0 & \\alpha_1 & \\cdots & \\alpha_{n-1}\n            \\end{bmatrix}\n\n        If the matrix `B` is the result, the permutation of matrix rows\n        is defined as:\n\n        .. math::\n            B := \\begin{bmatrix}\n            a_{\\sigma(0)} \\\\ a_{\\sigma(1)} \\\\ \\vdots \\\\ a_{\\sigma(n-1)}\n            \\end{bmatrix}\n\n        And the permutation of matrix columns is defined as:\n\n        .. math::\n            B := \\begin{bmatrix}\n            \\alpha_{\\sigma(0)} & \\alpha_{\\sigma(1)} &\n            \\cdots & \\alpha_{\\sigma(n-1)}\n            \\end{bmatrix}\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "permuteBkwd",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.permuteBkwd",
    "type": "method",
    "description": "Permute the rows of the matrix with the given permutation in reverse.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "permuteFwd",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.permuteFwd",
    "type": "method",
    "description": "Permute the rows of the matrix with the given permutation.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "permute_cols",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.permute_cols",
    "type": "method",
    "description": "Alias for\n        ``self.permute(swaps, orientation='cols', direction=direction)``\n\n        See Also\n        ========\n\n        permute\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "permute_rows",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.permute_rows",
    "type": "method",
    "description": "Alias for\n        ``self.permute(swaps, orientation='rows', direction=direction)``\n\n        See Also\n        ========\n\n        permute\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "pinv",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.pinv",
    "type": "method",
    "description": "Calculate the Moore-Penrose pseudoinverse of the matrix.\n\n    The Moore-Penrose pseudoinverse exists and is unique for any matrix.\n    If the matrix is invertible, the pseudoinverse is the same as the\n    inverse.\n\n    Parameters\n    ==========\n\n    method : String, optional\n        Specifies the method for computing the pseudoinverse.\n\n        If ``'RD'``, Rank-Decomposition will be used.\n\n        If ``'ED'``, Diagonalization will be used.\n\n    Examples\n    ========\n\n    Computing pseudoinverse by rank decomposition :\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([[1, 2, 3], [4, 5, 6]])\n    >>> A.pinv()\n    Matrix([\n    [-17/18,  4/9],\n    [  -1/9,  1/9],\n    [ 13/18, -2/9]])\n\n    Computing pseudoinverse by diagonalization :\n\n    >>> B = A.pinv(method='ED')\n    >>> B.simplify()\n    >>> B\n    Matrix([\n    [-17/18,  4/9],\n    [  -1/9,  1/9],\n    [ 13/18, -2/9]])\n\n    See Also\n    ========\n\n    inv\n    pinv_solve\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse\n\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "pinv_solve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.pinv_solve",
    "type": "method",
    "description": "Solve ``Ax = B`` using the Moore-Penrose pseudoinverse.\n\n    There may be zero, one, or infinite solutions.  If one solution\n    exists, it will be returned.  If infinite solutions exist, one will\n    be returned based on the value of arbitrary_matrix.  If no solutions\n    exist, the least-squares solution is returned.\n\n    Parameters\n    ==========\n\n    B : Matrix\n        The right hand side of the equation to be solved for.  Must have\n        the same number of rows as matrix A.\n    arbitrary_matrix : Matrix\n        If the system is underdetermined (e.g. A has more columns than\n        rows), infinite solutions are possible, in terms of an arbitrary\n        matrix.  This parameter may be set to a specific matrix to use\n        for that purpose; if so, it must be the same shape as x, with as\n        many rows as matrix A has columns, and as many columns as matrix\n        B.  If left as None, an appropriate matrix containing dummy\n        symbols in the form of ``wn_m`` will be used, with n and m being\n        row and column position of each symbol.\n\n    Returns\n    =======\n\n    x : Matrix\n        The matrix that will satisfy ``Ax = B``.  Will have as many rows as\n        matrix A has columns, and as many columns as matrix B.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([[1, 2, 3], [4, 5, 6]])\n    >>> B = Matrix([7, 8])\n    >>> A.pinv_solve(B)\n    Matrix([\n    [ _w0_0/6 - _w1_0/3 + _w2_0/6 - 55/18],\n    [-_w0_0/3 + 2*_w1_0/3 - _w2_0/3 + 1/9],\n    [ _w0_0/6 - _w1_0/3 + _w2_0/6 + 59/18]])\n    >>> A.pinv_solve(B, arbitrary_matrix=Matrix([0, 0, 0]))\n    Matrix([\n    [-55/18],\n    [   1/9],\n    [ 59/18]])\n\n    See Also\n    ========\n\n    sympy.matrices.dense.DenseMatrix.lower_triangular_solve\n    sympy.matrices.dense.DenseMatrix.upper_triangular_solve\n    gauss_jordan_solve\n    cholesky_solve\n    diagonal_solve\n    LDLsolve\n    LUsolve\n    QRsolve\n    pinv\n\n    Notes\n    =====\n\n    This may return either exact solutions or least squares solutions.\n    To determine which, check ``A * A.pinv() * B == B``.  It will be\n    True if exact solutions exist, and False if only a least-squares\n    solution exists.  Be aware that the left hand side of that equation\n    may need to be simplified to correctly compare to the right hand\n    side.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system\n\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "pow",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.pow",
    "type": "method",
    "description": "Return self**exp a scalar or symbol.\n\n        Parameters\n        ==========\n\n        method : multiply, mulsimp, jordan, cayley\n            If multiply then it returns exponentiation using recursion.\n            If jordan then Jordan form exponentiation will be used.\n            If cayley then the exponentiation is done using Cayley-Hamilton\n            theorem.\n            If mulsimp then the exponentiation is done using recursion\n            with dotprodsimp. This specifies whether intermediate term\n            algebraic simplification is used during naive matrix power to\n            control expression blowup and thus speed up calculation.\n            If None, then it heuristically decides which method to use.\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "print_nonzero",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.print_nonzero",
    "type": "method",
    "description": "Shows location of non-zero entries for fast shape lookup.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, eye\n        >>> m = Matrix(2, 3, lambda i, j: i*3+j)\n        >>> m\n        Matrix([\n        [0, 1, 2],\n        [3, 4, 5]])\n        >>> m.print_nonzero()\n        [ XX]\n        [XXX]\n        >>> m = eye(4)\n        >>> m.print_nonzero(\"x\")\n        [x   ]\n        [ x  ]\n        [  x ]\n        [   x]\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "project",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.project",
    "type": "method",
    "description": "Return the projection of ``self`` onto the line containing ``v``.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, S, sqrt\n        >>> V = Matrix([sqrt(3)/2, S.Half])\n        >>> x = Matrix([[1, 0]])\n        >>> V.project(x)\n        Matrix([[sqrt(3)/2, 0]])\n        >>> V.project(-x)\n        Matrix([[sqrt(3)/2, 0]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rank",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.rank",
    "type": "method",
    "description": "Returns the rank of a matrix.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> from sympy.abc import x\n    >>> m = Matrix([[1, 2], [x, 1 - 1/x]])\n    >>> m.rank()\n    2\n    >>> n = Matrix(3, 3, range(1, 10))\n    >>> n.rank()\n    2\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rank_decomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.rank_decomposition",
    "type": "method",
    "description": "Returns a pair of matrices (`C`, `F`) with matching rank\n    such that `A = C F`.\n\n    Parameters\n    ==========\n\n    iszerofunc : Function, optional\n        A function used for detecting whether an element can\n        act as a pivot.  ``lambda x: x.is_zero`` is used by default.\n\n    simplify : Bool or Function, optional\n        A function used to simplify elements when looking for a\n        pivot. By default SymPy's ``simplify`` is used.\n\n    Returns\n    =======\n\n    (C, F) : Matrices\n        `C` and `F` are full-rank matrices with rank as same as `A`,\n        whose product gives `A`.\n\n        See Notes for additional mathematical details.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([\n    ...     [1, 3, 1, 4],\n    ...     [2, 7, 3, 9],\n    ...     [1, 5, 3, 1],\n    ...     [1, 2, 0, 8]\n    ... ])\n    >>> C, F = A.rank_decomposition()\n    >>> C\n    Matrix([\n    [1, 3, 4],\n    [2, 7, 9],\n    [1, 5, 1],\n    [1, 2, 8]])\n    >>> F\n    Matrix([\n    [1, 0, -2, 0],\n    [0, 1,  1, 0],\n    [0, 0,  0, 1]])\n    >>> C * F == A\n    True\n\n    Notes\n    =====\n\n    Obtaining `F`, an RREF of `A`, is equivalent to creating a\n    product\n\n    .. math::\n        E_n E_{n-1} ... E_1 A = F\n\n    where `E_n, E_{n-1}, \\dots, E_1` are the elimination matrices or\n    permutation matrices equivalent to each row-reduction step.\n\n    The inverse of the same product of elimination matrices gives\n    `C`:\n\n    .. math::\n        C = \\left(E_n E_{n-1} \\dots E_1\\right)^{-1}\n\n    It is not necessary, however, to actually compute the inverse:\n    the columns of `C` are those from the original matrix with the\n    same column indices as the indices of the pivot columns of `F`.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Rank_factorization\n\n    .. [2] Piziak, R.; Odell, P. L. (1 June 1999).\n        \"Full Rank Factorization of Matrices\".\n        Mathematics Magazine. 72 (3): 193. doi:10.2307/2690882\n\n    See Also\n    ========\n\n    sympy.matrices.matrixbase.MatrixBase.rref\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "refine",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.refine",
    "type": "method",
    "description": "Apply refine to each element of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol, Matrix, Abs, sqrt, Q\n        >>> x = Symbol('x')\n        >>> Matrix([[Abs(x)**2, sqrt(x**2)],[sqrt(x**2), Abs(x)**2]])\n        Matrix([\n        [ Abs(x)**2, sqrt(x**2)],\n        [sqrt(x**2),  Abs(x)**2]])\n        >>> _.refine(Q.real(x))\n        Matrix([\n        [  x**2, Abs(x)],\n        [Abs(x),   x**2]])\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "replace",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.replace",
    "type": "method",
    "description": "Replaces Function F in Matrix entries with Function G.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, Function, Matrix\n        >>> F, G = symbols('F, G', cls=Function)\n        >>> M = Matrix(2, 2, lambda i, j: F(i+j)) ; M\n        Matrix([\n        [F(0), F(1)],\n        [F(1), F(2)]])\n        >>> N = M.replace(F,G)\n        >>> N\n        Matrix([\n        [G(0), G(1)],\n        [G(1), G(2)]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "reshape",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.reshape",
    "type": "method",
    "description": "Reshape the matrix. Total number of elements must remain the same.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix(2, 3, lambda i, j: 1)\n        >>> m\n        Matrix([\n        [1, 1, 1],\n        [1, 1, 1]])\n        >>> m.reshape(1, 6)\n        Matrix([[1, 1, 1, 1, 1, 1]])\n        >>> m.reshape(3, 2)\n        Matrix([\n        [1, 1],\n        [1, 1],\n        [1, 1]])\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rmultiply",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.rmultiply",
    "type": "method",
    "description": "Same as __rmul__() but with optional simplification.\n\n        Parameters\n        ==========\n\n        dotprodsimp : bool, optional\n            Specifies whether intermediate term algebraic simplification is used\n            during matrix multiplications to control expression blowup and thus\n            speed up calculation. Default is off.\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rot90",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.rot90",
    "type": "method",
    "description": "Rotates Matrix by 90 degrees\n\n        Parameters\n        ==========\n\n        k : int\n            Specifies how many times the matrix is rotated by 90 degrees\n            (clockwise when positive, counter-clockwise when negative).\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, symbols\n        >>> A = Matrix(2, 2, symbols('a:d'))\n        >>> A\n        Matrix([\n        [a, b],\n        [c, d]])\n\n        Rotating the matrix clockwise one time:\n\n        >>> A.rot90(1)\n        Matrix([\n        [c, a],\n        [d, b]])\n\n        Rotating the matrix anticlockwise two times:\n\n        >>> A.rot90(-2)\n        Matrix([\n        [d, c],\n        [b, a]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "row",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.row",
    "type": "method",
    "description": "Elementary row selector.\n\n        Examples\n        ========\n\n        >>> from sympy import eye\n        >>> eye(2).row(0)\n        Matrix([[1, 0]])\n\n        See Also\n        ========\n\n        col\n        row_del\n        row_join\n        row_insert\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "row_del",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.row_del",
    "type": "method",
    "description": "Delete the specified row.",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "row_insert",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.row_insert",
    "type": "method",
    "description": "Insert one or more rows at the given row position.\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(1, 3)\n        >>> M.row_insert(1, V)\n        Matrix([\n        [0, 0, 0],\n        [1, 1, 1],\n        [0, 0, 0],\n        [0, 0, 0]])\n\n        See Also\n        ========\n\n        row\n        col_insert\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "row_join",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.row_join",
    "type": "method",
    "description": "Concatenates two matrices along self's last and rhs's first column\n\n        Examples\n        ========\n\n        >>> from sympy import zeros, ones\n        >>> M = zeros(3)\n        >>> V = ones(3, 1)\n        >>> M.row_join(V)\n        Matrix([\n        [0, 0, 0, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 1]])\n\n        See Also\n        ========\n\n        row\n        col_join\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rowspace",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.rowspace",
    "type": "method",
    "description": "Returns a list of vectors that span the row space of ``M``.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> M = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])\n    >>> M\n    Matrix([\n    [ 1,  3, 0],\n    [-2, -6, 0],\n    [ 3,  9, 6]])\n    >>> M.rowspace()\n    [Matrix([[1, 3, 0]]), Matrix([[0, 0, 6]])]\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rref",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.rref",
    "type": "method",
    "description": "Return reduced row-echelon form of matrix and indices\n    of pivot vars.\n\n    Parameters\n    ==========\n\n    iszerofunc : Function\n        A function used for detecting whether an element can\n        act as a pivot.  ``lambda x: x.is_zero`` is used by default.\n\n    simplify : Function\n        A function used to simplify elements when looking for a pivot.\n        By default SymPy's ``simplify`` is used.\n\n    pivots : True or False\n        If ``True``, a tuple containing the row-reduced matrix and a tuple\n        of pivot columns is returned.  If ``False`` just the row-reduced\n        matrix is returned.\n\n    normalize_last : True or False\n        If ``True``, no pivots are normalized to `1` until after all\n        entries above and below each pivot are zeroed.  This means the row\n        reduction algorithm is fraction free until the very last step.\n        If ``False``, the naive row reduction procedure is used where\n        each pivot is normalized to be `1` before row operations are\n        used to zero above and below the pivot.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> from sympy.abc import x\n    >>> m = Matrix([[1, 2], [x, 1 - 1/x]])\n    >>> m.rref()\n    (Matrix([\n    [1, 0],\n    [0, 1]]), (0, 1))\n    >>> rref_matrix, rref_pivots = m.rref()\n    >>> rref_matrix\n    Matrix([\n    [1, 0],\n    [0, 1]])\n    >>> rref_pivots\n    (0, 1)\n\n    ``iszerofunc`` can correct rounding errors in matrices with float\n    values. In the following example, calling ``rref()`` leads to\n    floating point errors, incorrectly row reducing the matrix.\n    ``iszerofunc= lambda x: abs(x) < 1e-9`` sets sufficiently small numbers\n    to zero, avoiding this error.\n\n    >>> m = Matrix([[0.9, -0.1, -0.2, 0], [-0.8, 0.9, -0.4, 0], [-0.1, -0.8, 0.6, 0]])\n    >>> m.rref()\n    (Matrix([\n    [1, 0, 0, 0],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]]), (0, 1, 2))\n    >>> m.rref(iszerofunc=lambda x:abs(x)<1e-9)\n    (Matrix([\n    [1, 0, -0.301369863013699, 0],\n    [0, 1, -0.712328767123288, 0],\n    [0, 0,         0,          0]]), (0, 1))\n\n    Notes\n    =====\n\n    The default value of ``normalize_last=True`` can provide significant\n    speedup to row reduction, especially on matrices with symbols.  However,\n    if you depend on the form row reduction algorithm leaves entries\n    of the matrix, set ``normalize_last=False``\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rref_rhs",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.rref_rhs",
    "type": "method",
    "description": "Return reduced row-echelon form of matrix, matrix showing\n        rhs after reduction steps. ``rhs`` must have the same number\n        of rows as ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, symbols\n        >>> r1, r2 = symbols('r1 r2')\n        >>> Matrix([[1, 1], [2, 1]]).rref_rhs(Matrix([r1, r2]))\n        (Matrix([\n        [1, 0],\n        [0, 1]]), Matrix([\n        [ -r1 + r2],\n        [2*r1 - r2]]))\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "shape",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.shape",
    "type": "property",
    "description": "The shape (dimensions) of the matrix as the 2-tuple (rows, cols).\n\n        Examples\n        ========\n\n        >>> from sympy import zeros\n        >>> M = zeros(2, 3)\n        >>> M.shape\n        (2, 3)\n        >>> M.rows\n        2\n        >>> M.cols\n        3\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "simplify",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.simplify",
    "type": "method",
    "description": "Apply simplify to each element of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import SparseMatrix, sin, cos\n        >>> SparseMatrix(1, 1, [x*sin(y)**2 + x*cos(y)**2])\n        Matrix([[x*sin(y)**2 + x*cos(y)**2]])\n        >>> _.simplify()\n        Matrix([[x]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "singular_value_decomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.singular_value_decomposition",
    "type": "method",
    "description": "Returns a Condensed Singular Value decomposition.\n\n    Explanation\n    ===========\n\n    A Singular Value decomposition is a decomposition in the form $A = U \\Sigma V^H$\n    where\n\n    - $U, V$ are column orthogonal matrix.\n    - $\\Sigma$ is a diagonal matrix, where the main diagonal contains singular\n      values of matrix A.\n\n    A column orthogonal matrix satisfies\n    $\\mathbb{I} = U^H U$ while a full orthogonal matrix satisfies\n    relation $\\mathbb{I} = U U^H = U^H U$ where $\\mathbb{I}$ is an identity\n    matrix with matching dimensions.\n\n    For matrices which are not square or are rank-deficient, it is\n    sufficient to return a column orthogonal matrix because augmenting\n    them may introduce redundant computations.\n    In condensed Singular Value Decomposition we only return column orthogonal\n    matrices because of this reason\n\n    If you want to augment the results to return a full orthogonal\n    decomposition, you should use the following procedures.\n\n    - Augment the $U, V$ matrices with columns that are orthogonal to every\n      other columns and make it square.\n    - Augment the $\\Sigma$ matrix with zero rows to make it have the same\n      shape as the original matrix.\n\n    The procedure will be illustrated in the examples section.\n\n    Examples\n    ========\n\n    we take a full rank matrix first:\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([[1, 2],[2,1]])\n    >>> U, S, V = A.singular_value_decomposition()\n    >>> U\n    Matrix([\n    [ sqrt(2)/2, sqrt(2)/2],\n    [-sqrt(2)/2, sqrt(2)/2]])\n    >>> S\n    Matrix([\n    [1, 0],\n    [0, 3]])\n    >>> V\n    Matrix([\n    [-sqrt(2)/2, sqrt(2)/2],\n    [ sqrt(2)/2, sqrt(2)/2]])\n\n    If a matrix if square and full rank both U, V\n    are orthogonal in both directions\n\n    >>> U * U.H\n    Matrix([\n    [1, 0],\n    [0, 1]])\n    >>> U.H * U\n    Matrix([\n    [1, 0],\n    [0, 1]])\n\n    >>> V * V.H\n    Matrix([\n    [1, 0],\n    [0, 1]])\n    >>> V.H * V\n    Matrix([\n    [1, 0],\n    [0, 1]])\n    >>> A == U * S * V.H\n    True\n\n    >>> C = Matrix([\n    ...         [1, 0, 0, 0, 2],\n    ...         [0, 0, 3, 0, 0],\n    ...         [0, 0, 0, 0, 0],\n    ...         [0, 2, 0, 0, 0],\n    ...     ])\n    >>> U, S, V = C.singular_value_decomposition()\n\n    >>> V.H * V\n    Matrix([\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]])\n    >>> V * V.H\n    Matrix([\n    [1/5, 0, 0, 0, 2/5],\n    [  0, 1, 0, 0,   0],\n    [  0, 0, 1, 0,   0],\n    [  0, 0, 0, 0,   0],\n    [2/5, 0, 0, 0, 4/5]])\n\n    If you want to augment the results to be a full orthogonal\n    decomposition, you should augment $V$ with an another orthogonal\n    column.\n\n    You are able to append an arbitrary standard basis that are linearly\n    independent to every other columns and you can run the Gram-Schmidt\n    process to make them augmented as orthogonal basis.\n\n    >>> V_aug = V.row_join(Matrix([[0,0,0,0,1],\n    ... [0,0,0,1,0]]).H)\n    >>> V_aug = V_aug.QRdecomposition()[0]\n    >>> V_aug\n    Matrix([\n    [0,   sqrt(5)/5, 0, -2*sqrt(5)/5, 0],\n    [1,           0, 0,            0, 0],\n    [0,           0, 1,            0, 0],\n    [0,           0, 0,            0, 1],\n    [0, 2*sqrt(5)/5, 0,    sqrt(5)/5, 0]])\n    >>> V_aug.H * V_aug\n    Matrix([\n    [1, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 1]])\n    >>> V_aug * V_aug.H\n    Matrix([\n    [1, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 1]])\n\n    Similarly we augment U\n\n    >>> U_aug = U.row_join(Matrix([0,0,1,0]))\n    >>> U_aug = U_aug.QRdecomposition()[0]\n    >>> U_aug\n    Matrix([\n    [0, 1, 0, 0],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1],\n    [1, 0, 0, 0]])\n\n    >>> U_aug.H * U_aug\n    Matrix([\n    [1, 0, 0, 0],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1]])\n    >>> U_aug * U_aug.H\n    Matrix([\n    [1, 0, 0, 0],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1]])\n\n    We add 2 zero columns and one row to S\n\n    >>> S_aug = S.col_join(Matrix([[0,0,0]]))\n    >>> S_aug = S_aug.row_join(Matrix([[0,0,0,0],\n    ... [0,0,0,0]]).H)\n    >>> S_aug\n    Matrix([\n    [2,       0, 0, 0, 0],\n    [0, sqrt(5), 0, 0, 0],\n    [0,       0, 3, 0, 0],\n    [0,       0, 0, 0, 0]])\n\n\n\n    >>> U_aug * S_aug * V_aug.H == C\n    True\n\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "singular_values",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.singular_values",
    "type": "method",
    "description": "Compute the singular values of a Matrix\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, Symbol\n    >>> x = Symbol('x', real=True)\n    >>> M = Matrix([[0, 1, 0], [0, x, 0], [-1, 0, 0]])\n    >>> M.singular_values()\n    [sqrt(x**2 + 1), 1, 0]\n\n    See Also\n    ========\n\n    condition_number\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "solve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.solve",
    "type": "method",
    "description": "Solves linear equation where the unique solution exists.\n\n    Parameters\n    ==========\n\n    rhs : Matrix\n        Vector representing the right hand side of the linear equation.\n\n    method : string, optional\n        If set to ``'GJ'`` or ``'GE'``, the Gauss-Jordan elimination will be\n        used, which is implemented in the routine ``gauss_jordan_solve``.\n\n        If set to ``'LU'``, ``LUsolve`` routine will be used.\n\n        If set to ``'QR'``, ``QRsolve`` routine will be used.\n\n        If set to ``'PINV'``, ``pinv_solve`` routine will be used.\n\n        If set to ``'CRAMER'``, ``cramer_solve`` routine will be used.\n\n        It also supports the methods available for special linear systems\n\n        For positive definite systems:\n\n        If set to ``'CH'``, ``cholesky_solve`` routine will be used.\n\n        If set to ``'LDL'``, ``LDLsolve`` routine will be used.\n\n        To use a different method and to compute the solution via the\n        inverse, use a method defined in the .inv() docstring.\n\n    Returns\n    =======\n\n    solutions : Matrix\n        Vector representing the solution.\n\n    Raises\n    ======\n\n    ValueError\n        If there is not a unique solution then a ``ValueError`` will be\n        raised.\n\n        If ``M`` is not square, a ``ValueError`` and a different routine\n        for solving the system will be suggested.\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "solve_least_squares",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.solve_least_squares",
    "type": "method",
    "description": "Return the least-square fit to the data.\n\n    Parameters\n    ==========\n\n    rhs : Matrix\n        Vector representing the right hand side of the linear equation.\n\n    method : string or boolean, optional\n        If set to ``'CH'``, ``cholesky_solve`` routine will be used.\n\n        If set to ``'LDL'``, ``LDLsolve`` routine will be used.\n\n        If set to ``'QR'``, ``QRsolve`` routine will be used.\n\n        If set to ``'PINV'``, ``pinv_solve`` routine will be used.\n\n        Otherwise, the conjugate of ``M`` will be used to create a system\n        of equations that is passed to ``solve`` along with the hint\n        defined by ``method``.\n\n    Returns\n    =======\n\n    solutions : Matrix\n        Vector representing the solution.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, ones\n    >>> A = Matrix([1, 2, 3])\n    >>> B = Matrix([2, 3, 4])\n    >>> S = Matrix(A.row_join(B))\n    >>> S\n    Matrix([\n    [1, 2],\n    [2, 3],\n    [3, 4]])\n\n    If each line of S represent coefficients of Ax + By\n    and x and y are [2, 3] then S*xy is:\n\n    >>> r = S*Matrix([2, 3]); r\n    Matrix([\n    [ 8],\n    [13],\n    [18]])\n\n    But let's add 1 to the middle value and then solve for the\n    least-squares value of xy:\n\n    >>> xy = S.solve_least_squares(Matrix([8, 14, 18])); xy\n    Matrix([\n    [ 5/3],\n    [10/3]])\n\n    The error is given by S*xy - r:\n\n    >>> S*xy - r\n    Matrix([\n    [1/3],\n    [1/3],\n    [1/3]])\n    >>> _.norm().n(2)\n    0.58\n\n    If a different xy is used, the norm will be higher:\n\n    >>> xy += ones(2, 1)/10\n    >>> (S*xy - r).norm().n(2)\n    1.5\n\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "strongly_connected_components",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.strongly_connected_components",
    "type": "method",
    "description": "Returns the list of strongly connected vertices of the graph when\n    a square matrix is viewed as a weighted graph.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([\n    ...     [44, 0, 0, 0, 43, 0, 45, 0, 0],\n    ...     [0, 66, 62, 61, 0, 68, 0, 60, 67],\n    ...     [0, 0, 22, 21, 0, 0, 0, 20, 0],\n    ...     [0, 0, 12, 11, 0, 0, 0, 10, 0],\n    ...     [34, 0, 0, 0, 33, 0, 35, 0, 0],\n    ...     [0, 86, 82, 81, 0, 88, 0, 80, 87],\n    ...     [54, 0, 0, 0, 53, 0, 55, 0, 0],\n    ...     [0, 0, 2, 1, 0, 0, 0, 0, 0],\n    ...     [0, 76, 72, 71, 0, 78, 0, 70, 77]])\n    >>> A.strongly_connected_components()\n    [[0, 4, 6], [2, 3, 7], [1, 5, 8]]\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "strongly_connected_components_decomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.strongly_connected_components_decomposition",
    "type": "method",
    "description": "Decomposes a square matrix into block triangular form only\n    using the permutations.\n\n    Explanation\n    ===========\n\n    The decomposition is in a form of $A = P^{-1} B P$ where $P$ is a\n    permutation matrix and $B$ is a block diagonal matrix.\n\n    Parameters\n    ==========\n\n    lower : bool\n        Makes $B$ lower block triangular when ``True``.\n        Otherwise, makes $B$ upper block triangular.\n\n    Returns\n    =======\n\n    P, B : PermutationMatrix, BlockMatrix\n        *P* is a permutation matrix for the similarity transform\n        as in the explanation. And *B* is the block triangular matrix of\n        the result of the permutation.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, pprint\n    >>> A = Matrix([\n    ...     [44, 0, 0, 0, 43, 0, 45, 0, 0],\n    ...     [0, 66, 62, 61, 0, 68, 0, 60, 67],\n    ...     [0, 0, 22, 21, 0, 0, 0, 20, 0],\n    ...     [0, 0, 12, 11, 0, 0, 0, 10, 0],\n    ...     [34, 0, 0, 0, 33, 0, 35, 0, 0],\n    ...     [0, 86, 82, 81, 0, 88, 0, 80, 87],\n    ...     [54, 0, 0, 0, 53, 0, 55, 0, 0],\n    ...     [0, 0, 2, 1, 0, 0, 0, 0, 0],\n    ...     [0, 76, 72, 71, 0, 78, 0, 70, 77]])\n\n    A lower block triangular decomposition:\n\n    >>> P, B = A.strongly_connected_components_decomposition()\n    >>> pprint(P)\n    PermutationMatrix((8)(1 4 3 2 6)(5 7))\n    >>> pprint(B)\n    [[44  43  45]   [0  0  0]     [0  0  0]  ]\n    [[          ]   [       ]     [       ]  ]\n    [[34  33  35]   [0  0  0]     [0  0  0]  ]\n    [[          ]   [       ]     [       ]  ]\n    [[54  53  55]   [0  0  0]     [0  0  0]  ]\n    [                                        ]\n    [ [0  0  0]    [22  21  20]   [0  0  0]  ]\n    [ [       ]    [          ]   [       ]  ]\n    [ [0  0  0]    [12  11  10]   [0  0  0]  ]\n    [ [       ]    [          ]   [       ]  ]\n    [ [0  0  0]    [2   1   0 ]   [0  0  0]  ]\n    [                                        ]\n    [ [0  0  0]    [62  61  60]  [66  68  67]]\n    [ [       ]    [          ]  [          ]]\n    [ [0  0  0]    [82  81  80]  [86  88  87]]\n    [ [       ]    [          ]  [          ]]\n    [ [0  0  0]    [72  71  70]  [76  78  77]]\n\n    >>> P = P.as_explicit()\n    >>> B = B.as_explicit()\n    >>> P.T * B * P == A\n    True\n\n    An upper block triangular decomposition:\n\n    >>> P, B = A.strongly_connected_components_decomposition(lower=False)\n    >>> pprint(P)\n    PermutationMatrix((0 1 5 7 4 3 2 8 6))\n    >>> pprint(B)\n    [[66  68  67]  [62  61  60]   [0  0  0]  ]\n    [[          ]  [          ]   [       ]  ]\n    [[86  88  87]  [82  81  80]   [0  0  0]  ]\n    [[          ]  [          ]   [       ]  ]\n    [[76  78  77]  [72  71  70]   [0  0  0]  ]\n    [                                        ]\n    [ [0  0  0]    [22  21  20]   [0  0  0]  ]\n    [ [       ]    [          ]   [       ]  ]\n    [ [0  0  0]    [12  11  10]   [0  0  0]  ]\n    [ [       ]    [          ]   [       ]  ]\n    [ [0  0  0]    [2   1   0 ]   [0  0  0]  ]\n    [                                        ]\n    [ [0  0  0]     [0  0  0]    [44  43  45]]\n    [ [       ]     [       ]    [          ]]\n    [ [0  0  0]     [0  0  0]    [34  33  35]]\n    [ [       ]     [       ]    [          ]]\n    [ [0  0  0]     [0  0  0]    [54  53  55]]\n\n    >>> P = P.as_explicit()\n    >>> B = B.as_explicit()\n    >>> P.T * B * P == A\n    True\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "subs",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.subs",
    "type": "method",
    "description": "Return a new matrix with subs applied to each entry.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import SparseMatrix, Matrix\n        >>> SparseMatrix(1, 1, [x])\n        Matrix([[x]])\n        >>> _.subs(x, y)\n        Matrix([[y]])\n        >>> Matrix(_).subs(y, x)\n        Matrix([[x]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "table",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.table",
    "type": "method",
    "description": "\n        String form of Matrix as a table.\n\n        ``printer`` is the printer to use for on the elements (generally\n        something like StrPrinter())\n\n        ``rowstart`` is the string used to start each row (by default '[').\n\n        ``rowend`` is the string used to end each row (by default ']').\n\n        ``rowsep`` is the string used to separate rows (by default a newline).\n\n        ``colsep`` is the string used to separate columns (by default ', ').\n\n        ``align`` defines how the elements are aligned. Must be one of 'left',\n        'right', or 'center'.  You can also use '<', '>', and '^' to mean the\n        same thing, respectively.\n\n        This is used by the string printer for Matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, StrPrinter\n        >>> M = Matrix([[1, 2], [-33, 4]])\n        >>> printer = StrPrinter()\n        >>> M.table(printer)\n        '[  1, 2]\\n[-33, 4]'\n        >>> print(M.table(printer))\n        [  1, 2]\n        [-33, 4]\n        >>> print(M.table(printer, rowsep=',\\n'))\n        [  1, 2],\n        [-33, 4]\n        >>> print('[%s]' % M.table(printer, rowsep=',\\n'))\n        [[  1, 2],\n        [-33, 4]]\n        >>> print(M.table(printer, colsep=' '))\n        [  1 2]\n        [-33 4]\n        >>> print(M.table(printer, align='center'))\n        [ 1 , 2]\n        [-33, 4]\n        >>> print(M.table(printer, rowstart='{', rowend='}'))\n        {  1, 2}\n        {-33, 4}\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "todod",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.todod",
    "type": "method",
    "description": "Returns matrix as dict of dicts containing non-zero elements of the Matrix\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> A = Matrix([[0, 1],[0, 3]])\n        >>> A\n        Matrix([\n        [0, 1],\n        [0, 3]])\n        >>> A.todod()\n        {0: {1: 1}, 1: {1: 3}}\n\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "todok",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.todok",
    "type": "method",
    "description": "Return the matrix as dictionary of keys.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> M = Matrix.eye(3)\n        >>> M.todok()\n        {(0, 0): 1, (1, 1): 1, (2, 2): 1}\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "tolist",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.tolist",
    "type": "method",
    "description": "Return the Matrix as a nested Python list.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, ones\n        >>> m = Matrix(3, 3, range(9))\n        >>> m\n        Matrix([\n        [0, 1, 2],\n        [3, 4, 5],\n        [6, 7, 8]])\n        >>> m.tolist()\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n        >>> ones(3, 0).tolist()\n        [[], [], []]\n\n        When there are no rows then it will not be possible to tell how\n        many columns were in the original matrix:\n\n        >>> ones(0, 3).tolist()\n        []\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "trace",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.trace",
    "type": "method",
    "description": "\n        Returns the trace of a square matrix i.e. the sum of the\n        diagonal elements.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> A = Matrix(2, 2, [1, 2, 3, 4])\n        >>> A.trace()\n        5\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "transpose",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.transpose",
    "type": "method",
    "description": "\n        Returns the transpose of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> A = Matrix(2, 2, [1, 2, 3, 4])\n        >>> A.transpose()\n        Matrix([\n        [1, 3],\n        [2, 4]])\n\n        >>> from sympy import Matrix, I\n        >>> m=Matrix(((1, 2+I), (3, 4)))\n        >>> m\n        Matrix([\n        [1, 2 + I],\n        [3,     4]])\n        >>> m.transpose()\n        Matrix([\n        [    1, 3],\n        [2 + I, 4]])\n        >>> m.T == m.transpose()\n        True\n\n        See Also\n        ========\n\n        conjugate: By-element conjugation\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "upper_hessenberg_decomposition",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.upper_hessenberg_decomposition",
    "type": "method",
    "description": "Converts a matrix into Hessenberg matrix H.\n\n    Returns 2 matrices H, P s.t.\n    $P H P^{T} = A$, where H is an upper hessenberg matrix\n    and P is an orthogonal matrix\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> A = Matrix([\n    ...     [1,2,3],\n    ...     [-3,5,6],\n    ...     [4,-8,9],\n    ... ])\n    >>> H, P = A.upper_hessenberg_decomposition()\n    >>> H\n    Matrix([\n    [1,    6/5,    17/5],\n    [5, 213/25, -134/25],\n    [0, 216/25,  137/25]])\n    >>> P\n    Matrix([\n    [1,    0,   0],\n    [0, -3/5, 4/5],\n    [0,  4/5, 3/5]])\n    >>> P * H * P.H == A\n    True\n\n\n    References\n    ==========\n\n    .. [#] https://mathworld.wolfram.com/HessenbergDecomposition.html\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "upper_triangular",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.upper_triangular",
    "type": "method",
    "description": "Return the elements on and above the kth diagonal of a matrix.\n        If k is not specified then simply returns upper-triangular portion\n        of a matrix\n\n        Examples\n        ========\n\n        >>> from sympy import ones\n        >>> A = ones(4)\n        >>> A.upper_triangular()\n        Matrix([\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n        [0, 0, 1, 1],\n        [0, 0, 0, 1]])\n\n        >>> A.upper_triangular(2)\n        Matrix([\n        [0, 0, 1, 1],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0]])\n\n        >>> A.upper_triangular(-1)\n        Matrix([\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n        [0, 0, 1, 1]])\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "upper_triangular_solve",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.upper_triangular_solve",
    "type": "method",
    "description": "Solves ``Ax = B``, where A is an upper triangular matrix.\n\n    See Also\n    ========\n\n    lower_triangular_solve\n    gauss_jordan_solve\n    cholesky_solve\n    diagonal_solve\n    LDLsolve\n    LUsolve\n    QRsolve\n    pinv_solve\n    cramer_solve\n    ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "values",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.values",
    "type": "method",
    "description": "Return non-zero values of self.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m = Matrix([[0, 1], [2, 3]])\n        >>> m.values()\n        [1, 2, 3]\n\n        See Also\n        ========\n\n        iter_values\n        tolist\n        flat\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "vec",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.vec",
    "type": "method",
    "description": "Return the Matrix converted into a one column matrix by stacking columns\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m=Matrix([[1, 3], [2, 4]])\n        >>> m\n        Matrix([\n        [1, 3],\n        [2, 4]])\n        >>> m.vec()\n        Matrix([\n        [1],\n        [2],\n        [3],\n        [4]])\n\n        See Also\n        ========\n\n        vech\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "vech",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.vech",
    "type": "method",
    "description": "Reshapes the matrix into a column vector by stacking the\n        elements in the lower triangle.\n\n        Parameters\n        ==========\n\n        diagonal : bool, optional\n            If ``True``, it includes the diagonal elements.\n\n        check_symmetry : bool, optional\n            If ``True``, it checks whether the matrix is symmetric.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> m=Matrix([[1, 2], [2, 3]])\n        >>> m\n        Matrix([\n        [1, 2],\n        [2, 3]])\n        >>> m.vech()\n        Matrix([\n        [1],\n        [2],\n        [3]])\n        >>> m.vech(diagonal=False)\n        Matrix([[2]])\n\n        Notes\n        =====\n\n        This should work for symmetric matrices and ``vech`` can\n        represent symmetric matrices in vector form with less size than\n        ``vec``.\n\n        See Also\n        ========\n\n        vec\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "vee",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.vee",
    "type": "method",
    "description": "\n        Return a 3x1 vector from a skew-symmetric matrix representing the cross product,\n        so that ``self * b`` is equivalent to  ``self.vee().cross(b)``.\n\n        Examples\n        ========\n\n        Calling ``vee`` creates a vector from a skew-symmetric Matrix:\n\n        >>> from sympy import Matrix\n        >>> A = Matrix([[0, -3, 2], [3, 0, -1], [-2, 1, 0]])\n        >>> a = A.vee()\n        >>> a\n        Matrix([\n        [1],\n        [2],\n        [3]])\n\n        Calculating the matrix product of the original matrix with a vector\n        is equivalent to a cross product:\n\n        >>> b = Matrix([3, 2, 1])\n        >>> A * b\n        Matrix([\n        [-4],\n        [ 8],\n        [-4]])\n\n        >>> a.cross(b)\n        Matrix([\n        [-4],\n        [ 8],\n        [-4]])\n\n        ``vee`` can also be used to retrieve angular velocity expressions.\n        Defining a rotation matrix:\n\n        >>> from sympy import rot_ccw_axis3, trigsimp\n        >>> from sympy.physics.mechanics import dynamicsymbols\n        >>> theta = dynamicsymbols('theta')\n        >>> R = rot_ccw_axis3(theta)\n        >>> R\n        Matrix([\n        [cos(theta(t)), -sin(theta(t)), 0],\n        [sin(theta(t)),  cos(theta(t)), 0],\n        [            0,              0, 1]])\n\n        We can retrive the angular velocity:\n\n        >>> Omega = R.T * R.diff()\n        >>> Omega = trigsimp(Omega)\n        >>> Omega.vee()\n        Matrix([\n        [                      0],\n        [                      0],\n        [Derivative(theta(t), t)]])\n\n        See Also\n        ========\n\n        dot\n        cross\n        hat\n        multiply\n        multiply_elementwise\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "vstack",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.vstack",
    "type": "method",
    "description": "Return a matrix formed by joining args vertically (i.e.\n        by repeated application of col_join).\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, eye\n        >>> Matrix.vstack(eye(2), 2*eye(2))\n        Matrix([\n        [1, 0],\n        [0, 1],\n        [2, 0],\n        [0, 2]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "wilkinson",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.wilkinson",
    "type": "method",
    "description": "Returns two square Wilkinson Matrix of size 2*n + 1\n        $W_{2n + 1}^-, W_{2n + 1}^+ =$ Wilkinson(n)\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> wminus, wplus = Matrix.wilkinson(3)\n        >>> wminus\n        Matrix([\n        [-3,  1,  0, 0, 0, 0, 0],\n        [ 1, -2,  1, 0, 0, 0, 0],\n        [ 0,  1, -1, 1, 0, 0, 0],\n        [ 0,  0,  1, 0, 1, 0, 0],\n        [ 0,  0,  0, 1, 1, 1, 0],\n        [ 0,  0,  0, 0, 1, 2, 1],\n        [ 0,  0,  0, 0, 0, 1, 3]])\n        >>> wplus\n        Matrix([\n        [3, 1, 0, 0, 0, 0, 0],\n        [1, 2, 1, 0, 0, 0, 0],\n        [0, 1, 1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 1, 0, 0],\n        [0, 0, 0, 1, 1, 1, 0],\n        [0, 0, 0, 0, 1, 2, 1],\n        [0, 0, 0, 0, 0, 1, 3]])\n\n        References\n        ==========\n\n        .. [1] https://blogs.mathworks.com/cleve/2013/04/15/wilkinsons-matrices-2/\n        .. [2] J. H. Wilkinson, The Algebraic Eigenvalue Problem, Claredon Press, Oxford, 1965, 662 pp.\n\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "xreplace",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.xreplace",
    "type": "method",
    "description": "Return a new matrix with xreplace applied to each entry.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import SparseMatrix, Matrix\n        >>> SparseMatrix(1, 1, [x])\n        Matrix([[x]])\n        >>> _.xreplace({x: y})\n        Matrix([[y]])\n        >>> Matrix(_).xreplace({y: x})\n        Matrix([[x]])\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "zeros",
    "full_id": "sympy.matrices.matrixbase.MatrixBase.zeros",
    "type": "method",
    "description": "Returns a matrix of zeros.\n\n        Parameters\n        ==========\n\n        rows : rows of the matrix\n        cols : cols of the matrix (if None, cols=rows)\n\n        kwargs\n        ======\n        cls : class of the returned matrix\n        ",
    "section": "Matrix Base Classes",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "matrix_multiply_elementwise",
    "full_id": "sympy.matrices.dense.matrix_multiply_elementwise",
    "type": "function",
    "description": "Return the Hadamard product (elementwise product) of A and B\n\n    >>> from sympy import Matrix, matrix_multiply_elementwise\n    >>> A = Matrix([[0, 1, 2], [3, 4, 5]])\n    >>> B = Matrix([[1, 10, 100], [100, 10, 1]])\n    >>> matrix_multiply_elementwise(A, B)\n    Matrix([\n    [  0, 10, 200],\n    [300, 40,   5]])\n\n    See Also\n    ========\n\n    sympy.matrices.matrixbase.MatrixBase.__mul__\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "zeros",
    "full_id": "sympy.matrices.dense.zeros",
    "type": "function",
    "description": "Returns a matrix of zeros with ``rows`` rows and ``cols`` columns;\n    if ``cols`` is omitted a square matrix will be returned.\n\n    See Also\n    ========\n\n    ones\n    eye\n    diag\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "ones",
    "full_id": "sympy.matrices.dense.ones",
    "type": "function",
    "description": "Returns a matrix of ones with ``rows`` rows and ``cols`` columns;\n    if ``cols`` is omitted a square matrix will be returned.\n\n    See Also\n    ========\n\n    zeros\n    eye\n    diag\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "eye",
    "full_id": "sympy.matrices.dense.eye",
    "type": "function",
    "description": "Create square identity matrix n x n\n\n    See Also\n    ========\n\n    diag\n    zeros\n    ones\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "diag",
    "full_id": "sympy.matrices.dense.diag",
    "type": "function",
    "description": "Returns a matrix with the provided values placed on the\n    diagonal. If non-square matrices are included, they will\n    produce a block-diagonal matrix.\n\n    Examples\n    ========\n\n    This version of diag is a thin wrapper to Matrix.diag that differs\n    in that it treats all lists like matrices -- even when a single list\n    is given. If this is not desired, either put a `*` before the list or\n    set `unpack=True`.\n\n    >>> from sympy import diag\n\n    >>> diag([1, 2, 3], unpack=True)  # = diag(1,2,3) or diag(*[1,2,3])\n    Matrix([\n    [1, 0, 0],\n    [0, 2, 0],\n    [0, 0, 3]])\n\n    >>> diag([1, 2, 3])  # a column vector\n    Matrix([\n    [1],\n    [2],\n    [3]])\n\n    See Also\n    ========\n    .matrixbase.MatrixBase.eye\n    .matrixbase.MatrixBase.diagonal\n    .matrixbase.MatrixBase.diag\n    .expressions.blockmatrix.BlockMatrix\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "jordan_cell",
    "full_id": "sympy.matrices.dense.jordan_cell",
    "type": "function",
    "description": "\n    Create a Jordan block:\n\n    Examples\n    ========\n\n    >>> from sympy import jordan_cell\n    >>> from sympy.abc import x\n    >>> jordan_cell(x, 4)\n    Matrix([\n    [x, 1, 0, 0],\n    [0, x, 1, 0],\n    [0, 0, x, 1],\n    [0, 0, 0, x]])\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "hessian",
    "full_id": "sympy.matrices.dense.hessian",
    "type": "function",
    "description": "Compute Hessian matrix for a function f wrt parameters in varlist\n    which may be given as a sequence or a row/column vector. A list of\n    constraints may optionally be given.\n\n    Examples\n    ========\n\n    >>> from sympy import Function, hessian, pprint\n    >>> from sympy.abc import x, y\n    >>> f = Function('f')(x, y)\n    >>> g1 = Function('g')(x, y)\n    >>> g2 = x**2 + 3*y\n    >>> pprint(hessian(f, (x, y), [g1, g2]))\n    [                   d               d            ]\n    [     0        0    --(g(x, y))     --(g(x, y))  ]\n    [                   dx              dy           ]\n    [                                                ]\n    [     0        0        2*x              3       ]\n    [                                                ]\n    [                     2               2          ]\n    [d                   d               d           ]\n    [--(g(x, y))  2*x   ---(f(x, y))   -----(f(x, y))]\n    [dx                   2            dy dx         ]\n    [                   dx                           ]\n    [                                                ]\n    [                     2               2          ]\n    [d                   d               d           ]\n    [--(g(x, y))   3   -----(f(x, y))   ---(f(x, y)) ]\n    [dy                dy dx              2          ]\n    [                                   dy           ]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Hessian_matrix\n\n    See Also\n    ========\n\n    sympy.matrices.matrixbase.MatrixBase.jacobian\n    wronskian\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "GramSchmidt",
    "full_id": "sympy.matrices.dense.GramSchmidt",
    "type": "function",
    "description": "Apply the Gram-Schmidt process to a set of vectors.\n\n    Parameters\n    ==========\n\n    vlist : List of Matrix\n        Vectors to be orthogonalized for.\n\n    orthonormal : Bool, optional\n        If true, return an orthonormal basis.\n\n    Returns\n    =======\n\n    vlist : List of Matrix\n        Orthogonalized vectors\n\n    Notes\n    =====\n\n    This routine is mostly duplicate from ``Matrix.orthogonalize``,\n    except for some difference that this always raises error when\n    linearly dependent vectors are found, and the keyword ``normalize``\n    has been named as ``orthonormal`` in this function.\n\n    See Also\n    ========\n\n    .matrixbase.MatrixBase.orthogonalize\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "wronskian",
    "full_id": "sympy.matrices.dense.wronskian",
    "type": "function",
    "description": "\n    Compute Wronskian for [] of functions\n\n    ::\n\n                         | f1       f2        ...   fn      |\n                         | f1'      f2'       ...   fn'     |\n                         |  .        .        .      .      |\n        W(f1, ..., fn) = |  .        .         .     .      |\n                         |  .        .          .    .      |\n                         |  (n)      (n)            (n)     |\n                         | D   (f1) D   (f2)  ...  D   (fn) |\n\n    see: https://en.wikipedia.org/wiki/Wronskian\n\n    See Also\n    ========\n\n    sympy.matrices.matrixbase.MatrixBase.jacobian\n    hessian\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "casoratian",
    "full_id": "sympy.matrices.dense.casoratian",
    "type": "function",
    "description": "Given linear difference operator L of order 'k' and homogeneous\n    equation Ly = 0 we want to compute kernel of L, which is a set\n    of 'k' sequences: a(n), b(n), ... z(n).\n\n    Solutions of L are linearly independent iff their Casoratian,\n    denoted as C(a, b, ..., z), do not vanish for n = 0.\n\n    Casoratian is defined by k x k determinant::\n\n               +  a(n)     b(n)     . . . z(n)     +\n               |  a(n+1)   b(n+1)   . . . z(n+1)   |\n               |    .         .     .        .     |\n               |    .         .       .      .     |\n               |    .         .         .    .     |\n               +  a(n+k-1) b(n+k-1) . . . z(n+k-1) +\n\n    It proves very useful in rsolve_hyper() where it is applied\n    to a generating set of a recurrence to factor out linearly\n    dependent solutions and return a basis:\n\n    >>> from sympy import Symbol, casoratian, factorial\n    >>> n = Symbol('n', integer=True)\n\n    Exponential and factorial are linearly independent:\n\n    >>> casoratian([2**n, factorial(n)], n) != 0\n    True\n\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "randMatrix",
    "full_id": "sympy.matrices.dense.randMatrix",
    "type": "function",
    "description": "Create random matrix with dimensions ``r`` x ``c``. If ``c`` is omitted\n    the matrix will be square. If ``symmetric`` is True the matrix must be\n    square. If ``percent`` is less than 100 then only approximately the given\n    percentage of elements will be non-zero.\n\n    The pseudo-random number generator used to generate matrix is chosen in the\n    following way.\n\n    * If ``prng`` is supplied, it will be used as random number generator.\n      It should be an instance of ``random.Random``, or at least have\n      ``randint`` and ``shuffle`` methods with same signatures.\n    * if ``prng`` is not supplied but ``seed`` is supplied, then new\n      ``random.Random`` with given ``seed`` will be created;\n    * otherwise, a new ``random.Random`` with default seed will be used.\n\n    Examples\n    ========\n\n    >>> from sympy import randMatrix\n    >>> randMatrix(3) # doctest:+SKIP\n    [25, 45, 27]\n    [44, 54,  9]\n    [23, 96, 46]\n    >>> randMatrix(3, 2) # doctest:+SKIP\n    [87, 29]\n    [23, 37]\n    [90, 26]\n    >>> randMatrix(3, 3, 0, 2) # doctest:+SKIP\n    [0, 2, 0]\n    [2, 0, 1]\n    [0, 0, 1]\n    >>> randMatrix(3, symmetric=True) # doctest:+SKIP\n    [85, 26, 29]\n    [26, 71, 43]\n    [29, 43, 57]\n    >>> A = randMatrix(3, seed=1)\n    >>> B = randMatrix(3, seed=2)\n    >>> A == B\n    False\n    >>> A == randMatrix(3, seed=1)\n    True\n    >>> randMatrix(3, symmetric=True, percent=50) # doctest:+SKIP\n    [77, 70,  0],\n    [70,  0,  0],\n    [ 0,  0, 88]\n    ",
    "section": "Matrix Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rot_givens",
    "full_id": "sympy.matrices.dense.rot_givens",
    "type": "function",
    "description": "Returns a a Givens rotation matrix, a a rotation in the\n    plane spanned by two coordinates axes.\n\n    Explanation\n    ===========\n\n    The Givens rotation corresponds to a generalization of rotation\n    matrices to any number of dimensions, given by:\n\n    .. math::\n        G(i, j, \\theta) =\n            \\begin{bmatrix}\n                1   & \\cdots &    0   & \\cdots &    0   & \\cdots &    0   \\\\\n                \\vdots & \\ddots & \\vdots &        & \\vdots &        & \\vdots \\\\\n                0   & \\cdots &    c   & \\cdots &   -s   & \\cdots &    0   \\\\\n                \\vdots &        & \\vdots & \\ddots & \\vdots &        & \\vdots \\\\\n                0   & \\cdots &    s   & \\cdots &    c   & \\cdots &    0   \\\\\n                \\vdots &        & \\vdots &        & \\vdots & \\ddots & \\vdots \\\\\n                0   & \\cdots &    0   & \\cdots &    0   & \\cdots &    1\n            \\end{bmatrix}\n\n    Where $c = \\cos(\\theta)$ and $s = \\sin(\\theta)$ appear at the intersections\n    ``i``\\th and ``j``\\th rows and columns.\n\n    For fixed ``i > j``\\, the non-zero elements of a Givens matrix are\n    given by:\n\n    - $g_{kk} = 1$ for $k \\ne i,\\,j$\n    - $g_{kk} = c$ for $k = i,\\,j$\n    - $g_{ji} = -g_{ij} = -s$\n\n    Parameters\n    ==========\n\n    i : int between ``0`` and ``dim - 1``\n        Represents first axis\n    j : int between ``0`` and ``dim - 1``\n        Represents second axis\n    dim : int bigger than 1\n        Number of dimentions. Defaults to 3.\n\n    Examples\n    ========\n\n    >>> from sympy import pi, rot_givens\n\n    A counterclockwise rotation of pi/3 (60 degrees) around\n    the third axis (z-axis):\n\n    >>> rot_givens(1, 0, pi/3)\n    Matrix([\n    [      1/2, -sqrt(3)/2, 0],\n    [sqrt(3)/2,        1/2, 0],\n    [        0,          0, 1]])\n\n    If we rotate by pi/2 (90 degrees):\n\n    >>> rot_givens(1, 0, pi/2)\n    Matrix([\n    [0, -1, 0],\n    [1,  0, 0],\n    [0,  0, 1]])\n\n    This can be generalized to any number\n    of dimensions:\n\n    >>> rot_givens(1, 0, pi/2, dim=4)\n    Matrix([\n    [0, -1, 0, 0],\n    [1,  0, 0, 0],\n    [0,  0, 1, 0],\n    [0,  0, 0, 1]])\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Givens_rotation\n\n    See Also\n    ========\n\n    rot_axis1: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 1-axis (clockwise around the x axis)\n    rot_axis2: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 2-axis (clockwise around the y axis)\n    rot_axis3: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 3-axis (clockwise around the z axis)\n    rot_ccw_axis1: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 1-axis (counterclockwise around the x axis)\n    rot_ccw_axis2: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 2-axis (counterclockwise around the y axis)\n    rot_ccw_axis3: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 3-axis (counterclockwise around the z axis)\n    ",
    "section": "Rotation matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rot_axis1",
    "full_id": "sympy.matrices.dense.rot_axis1",
    "type": "function",
    "description": "Returns a rotation matrix for a rotation of theta (in radians)\n    about the 1-axis.\n\n    Explanation\n    ===========\n\n    For a right-handed coordinate system, this corresponds to a\n    clockwise rotation around the `x`-axis, given by:\n\n    .. math::\n\n        R  = \\begin{bmatrix}\n                1 &             0 &            0 \\\\\n                0 &  \\cos(\\theta) & \\sin(\\theta) \\\\\n                0 & -\\sin(\\theta) & \\cos(\\theta)\n            \\end{bmatrix}\n\n    Examples\n    ========\n\n    >>> from sympy import pi, rot_axis1\n\n    A rotation of pi/3 (60 degrees):\n\n    >>> theta = pi/3\n    >>> rot_axis1(theta)\n    Matrix([\n    [1,          0,         0],\n    [0,        1/2, sqrt(3)/2],\n    [0, -sqrt(3)/2,       1/2]])\n\n    If we rotate by pi/2 (90 degrees):\n\n    >>> rot_axis1(pi/2)\n    Matrix([\n    [1,  0, 0],\n    [0,  0, 1],\n    [0, -1, 0]])\n\n    See Also\n    ========\n\n    rot_givens: Returns a Givens rotation matrix (generalized rotation for\n        any number of dimensions)\n    rot_ccw_axis1: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 1-axis (counterclockwise around the x axis)\n    rot_axis2: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 2-axis (clockwise around the y axis)\n    rot_axis3: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 3-axis (clockwise around the z axis)\n    ",
    "section": "Rotation matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rot_axis2",
    "full_id": "sympy.matrices.dense.rot_axis2",
    "type": "function",
    "description": "Returns a rotation matrix for a rotation of theta (in radians)\n    about the 2-axis.\n\n    Explanation\n    ===========\n\n    For a right-handed coordinate system, this corresponds to a\n    clockwise rotation around the `y`-axis, given by:\n\n    .. math::\n\n        R  = \\begin{bmatrix}\n                \\cos(\\theta) & 0 & -\\sin(\\theta) \\\\\n                           0 & 1 &             0 \\\\\n                \\sin(\\theta) & 0 &  \\cos(\\theta)\n            \\end{bmatrix}\n\n    Examples\n    ========\n\n    >>> from sympy import pi, rot_axis2\n\n    A rotation of pi/3 (60 degrees):\n\n    >>> theta = pi/3\n    >>> rot_axis2(theta)\n    Matrix([\n    [      1/2, 0, -sqrt(3)/2],\n    [        0, 1,          0],\n    [sqrt(3)/2, 0,        1/2]])\n\n    If we rotate by pi/2 (90 degrees):\n\n    >>> rot_axis2(pi/2)\n    Matrix([\n    [0, 0, -1],\n    [0, 1,  0],\n    [1, 0,  0]])\n\n    See Also\n    ========\n\n    rot_givens: Returns a Givens rotation matrix (generalized rotation for\n        any number of dimensions)\n    rot_ccw_axis2: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 2-axis (clockwise around the y axis)\n    rot_axis1: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 1-axis (counterclockwise around the x axis)\n    rot_axis3: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 3-axis (counterclockwise around the z axis)\n    ",
    "section": "Rotation matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rot_axis3",
    "full_id": "sympy.matrices.dense.rot_axis3",
    "type": "function",
    "description": "Returns a rotation matrix for a rotation of theta (in radians)\n    about the 3-axis.\n\n    Explanation\n    ===========\n\n    For a right-handed coordinate system, this corresponds to a\n    clockwise rotation around the `z`-axis, given by:\n\n    .. math::\n\n        R  = \\begin{bmatrix}\n                 \\cos(\\theta) & \\sin(\\theta) & 0 \\\\\n                -\\sin(\\theta) & \\cos(\\theta) & 0 \\\\\n                            0 &            0 & 1\n            \\end{bmatrix}\n\n    Examples\n    ========\n\n    >>> from sympy import pi, rot_axis3\n\n    A rotation of pi/3 (60 degrees):\n\n    >>> theta = pi/3\n    >>> rot_axis3(theta)\n    Matrix([\n    [       1/2, sqrt(3)/2, 0],\n    [-sqrt(3)/2,       1/2, 0],\n    [         0,         0, 1]])\n\n    If we rotate by pi/2 (90 degrees):\n\n    >>> rot_axis3(pi/2)\n    Matrix([\n    [ 0, 1, 0],\n    [-1, 0, 0],\n    [ 0, 0, 1]])\n\n    See Also\n    ========\n\n    rot_givens: Returns a Givens rotation matrix (generalized rotation for\n        any number of dimensions)\n    rot_ccw_axis3: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 3-axis (counterclockwise around the z axis)\n    rot_axis1: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 1-axis (clockwise around the x axis)\n    rot_axis2: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 2-axis (clockwise around the y axis)\n    ",
    "section": "Rotation matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rot_ccw_axis1",
    "full_id": "sympy.matrices.dense.rot_ccw_axis1",
    "type": "function",
    "description": "Returns a rotation matrix for a rotation of theta (in radians)\n    about the 1-axis.\n\n    Explanation\n    ===========\n\n    For a right-handed coordinate system, this corresponds to a\n    counterclockwise rotation around the `x`-axis, given by:\n\n    .. math::\n\n        R  = \\begin{bmatrix}\n                1 &            0 &             0 \\\\\n                0 & \\cos(\\theta) & -\\sin(\\theta) \\\\\n                0 & \\sin(\\theta) &  \\cos(\\theta)\n            \\end{bmatrix}\n\n    Examples\n    ========\n\n    >>> from sympy import pi, rot_ccw_axis1\n\n    A rotation of pi/3 (60 degrees):\n\n    >>> theta = pi/3\n    >>> rot_ccw_axis1(theta)\n    Matrix([\n    [1,         0,          0],\n    [0,       1/2, -sqrt(3)/2],\n    [0, sqrt(3)/2,        1/2]])\n\n    If we rotate by pi/2 (90 degrees):\n\n    >>> rot_ccw_axis1(pi/2)\n    Matrix([\n    [1, 0,  0],\n    [0, 0, -1],\n    [0, 1,  0]])\n\n    See Also\n    ========\n\n    rot_givens: Returns a Givens rotation matrix (generalized rotation for\n        any number of dimensions)\n    rot_axis1: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 1-axis (clockwise around the x axis)\n    rot_ccw_axis2: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 2-axis (counterclockwise around the y axis)\n    rot_ccw_axis3: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 3-axis (counterclockwise around the z axis)\n    ",
    "section": "Rotation matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rot_ccw_axis2",
    "full_id": "sympy.matrices.dense.rot_ccw_axis2",
    "type": "function",
    "description": "Returns a rotation matrix for a rotation of theta (in radians)\n    about the 2-axis.\n\n    Explanation\n    ===========\n\n    For a right-handed coordinate system, this corresponds to a\n    counterclockwise rotation around the `y`-axis, given by:\n\n    .. math::\n\n        R  = \\begin{bmatrix}\n                 \\cos(\\theta) & 0 & \\sin(\\theta) \\\\\n                            0 & 1 &            0 \\\\\n                -\\sin(\\theta) & 0 & \\cos(\\theta)\n            \\end{bmatrix}\n\n    Examples\n    ========\n\n    >>> from sympy import pi, rot_ccw_axis2\n\n    A rotation of pi/3 (60 degrees):\n\n    >>> theta = pi/3\n    >>> rot_ccw_axis2(theta)\n    Matrix([\n    [       1/2, 0, sqrt(3)/2],\n    [         0, 1,         0],\n    [-sqrt(3)/2, 0,       1/2]])\n\n    If we rotate by pi/2 (90 degrees):\n\n    >>> rot_ccw_axis2(pi/2)\n    Matrix([\n    [ 0,  0,  1],\n    [ 0,  1,  0],\n    [-1,  0,  0]])\n\n    See Also\n    ========\n\n    rot_givens: Returns a Givens rotation matrix (generalized rotation for\n        any number of dimensions)\n    rot_axis2: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 2-axis (clockwise around the y axis)\n    rot_ccw_axis1: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 1-axis (counterclockwise around the x axis)\n    rot_ccw_axis3: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 3-axis (counterclockwise around the z axis)\n    ",
    "section": "Rotation matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "rot_ccw_axis3",
    "full_id": "sympy.matrices.dense.rot_ccw_axis3",
    "type": "function",
    "description": "Returns a rotation matrix for a rotation of theta (in radians)\n    about the 3-axis.\n\n    Explanation\n    ===========\n\n    For a right-handed coordinate system, this corresponds to a\n    counterclockwise rotation around the `z`-axis, given by:\n\n    .. math::\n\n        R  = \\begin{bmatrix}\n                \\cos(\\theta) & -\\sin(\\theta) & 0 \\\\\n                \\sin(\\theta) &  \\cos(\\theta) & 0 \\\\\n                           0 &             0 & 1\n            \\end{bmatrix}\n\n    Examples\n    ========\n\n    >>> from sympy import pi, rot_ccw_axis3\n\n    A rotation of pi/3 (60 degrees):\n\n    >>> theta = pi/3\n    >>> rot_ccw_axis3(theta)\n    Matrix([\n    [      1/2, -sqrt(3)/2, 0],\n    [sqrt(3)/2,        1/2, 0],\n    [        0,          0, 1]])\n\n    If we rotate by pi/2 (90 degrees):\n\n    >>> rot_ccw_axis3(pi/2)\n    Matrix([\n    [0, -1, 0],\n    [1,  0, 0],\n    [0,  0, 1]])\n\n    See Also\n    ========\n\n    rot_givens: Returns a Givens rotation matrix (generalized rotation for\n        any number of dimensions)\n    rot_axis3: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 3-axis (clockwise around the z axis)\n    rot_ccw_axis1: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 1-axis (counterclockwise around the x axis)\n    rot_ccw_axis2: Returns a rotation matrix for a rotation of theta (in radians)\n        about the 2-axis (counterclockwise around the y axis)\n    ",
    "section": "Rotation matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "list2numpy",
    "full_id": "sympy.matrices.dense.list2numpy",
    "type": "function",
    "description": "Converts Python list of SymPy expressions to a NumPy array.\n\n    See Also\n    ========\n\n    matrix2numpy\n    ",
    "section": "Numpy Utility Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "matrix2numpy",
    "full_id": "sympy.matrices.dense.matrix2numpy",
    "type": "function",
    "description": "Converts SymPy's matrix to a NumPy array.\n\n    See Also\n    ========\n\n    list2numpy\n    ",
    "section": "Numpy Utility Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "symarray",
    "full_id": "sympy.matrices.dense.symarray",
    "type": "function",
    "description": "Create a numpy ndarray of symbols (as an object array).\n\n    The created symbols are named ``prefix_i1_i2_``...  You should thus provide a\n    non-empty prefix if you want your symbols to be unique for different output\n    arrays, as SymPy symbols with identical names are the same object.\n\n    Parameters\n    ----------\n\n    prefix : string\n      A prefix prepended to the name of every symbol.\n\n    shape : int or tuple\n      Shape of the created array.  If an int, the array is one-dimensional; for\n      more than one dimension the shape must be a tuple.\n\n    \\*\\*kwargs : dict\n      keyword arguments passed on to Symbol\n\n    Examples\n    ========\n    These doctests require numpy.\n\n    >>> from sympy import symarray\n    >>> symarray('', 3)\n    [_0 _1 _2]\n\n    If you want multiple symarrays to contain distinct symbols, you *must*\n    provide unique prefixes:\n\n    >>> a = symarray('', 3)\n    >>> b = symarray('', 3)\n    >>> a[0] == b[0]\n    True\n    >>> a = symarray('a', 3)\n    >>> b = symarray('b', 3)\n    >>> a[0] == b[0]\n    False\n\n    Creating symarrays with a prefix:\n\n    >>> symarray('a', 3)\n    [a_0 a_1 a_2]\n\n    For more than one dimension, the shape must be given as a tuple:\n\n    >>> symarray('a', (2, 3))\n    [[a_0_0 a_0_1 a_0_2]\n     [a_1_0 a_1_1 a_1_2]]\n    >>> symarray('a', (2, 3, 2))\n    [[[a_0_0_0 a_0_0_1]\n      [a_0_1_0 a_0_1_1]\n      [a_0_2_0 a_0_2_1]]\n    <BLANKLINE>\n     [[a_1_0_0 a_1_0_1]\n      [a_1_1_0 a_1_1_1]\n      [a_1_2_0 a_1_2_1]]]\n\n    For setting assumptions of the underlying Symbols:\n\n    >>> [s.is_real for s in symarray('a', 2, real=True)]\n    [True, True]\n    ",
    "section": "Numpy Utility Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "a2idx",
    "full_id": "sympy.matrices.matrixbase.a2idx",
    "type": "function",
    "description": "Return integer after making positive and validating against n.",
    "section": "Numpy Utility Functions",
    "url": "https://docs.sympy.org/latest/modules/matrices/matrices.html"
  },
  {
    "name": "as_immutable",
    "full_id": "sympy.matrices.dense.DenseMatrix.as_immutable",
    "type": "method",
    "description": "Returns an Immutable version of this Matrix",
    "section": "Dense Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/dense.html"
  },
  {
    "name": "as_mutable",
    "full_id": "sympy.matrices.dense.DenseMatrix.as_mutable",
    "type": "method",
    "description": "Returns a mutable version of this matrix\n\n        Examples\n        ========\n\n        >>> from sympy import ImmutableMatrix\n        >>> X = ImmutableMatrix([[1, 2], [3, 4]])\n        >>> Y = X.as_mutable()\n        >>> Y[1, 1] = 5 # Can set values in Y\n        >>> Y\n        Matrix([\n        [1, 2],\n        [3, 5]])\n        ",
    "section": "Dense Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/dense.html"
  },
  {
    "name": "simplify",
    "full_id": "sympy.matrices.dense.MutableDenseMatrix.simplify",
    "type": "method",
    "description": "Applies simplify to the elements of a matrix in place.\n\n        This is a shortcut for M.applyfunc(lambda x: simplify(x, ratio, measure))\n\n        See Also\n        ========\n\n        sympy.simplify.simplify.simplify\n        ",
    "section": "Dense Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/dense.html"
  },
  {
    "name": "as_explicit",
    "full_id": "sympy.matrices.expressions.MatrixExpr.as_explicit",
    "type": "method",
    "description": "\n        Returns a dense Matrix with elements represented explicitly\n\n        Returns an object of type ImmutableDenseMatrix.\n\n        Examples\n        ========\n\n        >>> from sympy import Identity\n        >>> I = Identity(3)\n        >>> I\n        I\n        >>> I.as_explicit()\n        Matrix([\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]])\n\n        See Also\n        ========\n        as_mutable: returns mutable Matrix type\n\n        ",
    "section": "Matrix Expressions Core Reference",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "as_mutable",
    "full_id": "sympy.matrices.expressions.MatrixExpr.as_mutable",
    "type": "method",
    "description": "\n        Returns a dense, mutable matrix with elements represented explicitly\n\n        Examples\n        ========\n\n        >>> from sympy import Identity\n        >>> I = Identity(3)\n        >>> I\n        I\n        >>> I.shape\n        (3, 3)\n        >>> I.as_mutable()\n        Matrix([\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]])\n\n        See Also\n        ========\n        as_explicit: returns ImmutableDenseMatrix\n        ",
    "section": "Matrix Expressions Core Reference",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "equals",
    "full_id": "sympy.matrices.expressions.MatrixExpr.equals",
    "type": "method",
    "description": "\n        Test elementwise equality between matrices, potentially of different\n        types\n\n        >>> from sympy import Identity, eye\n        >>> Identity(3).equals(eye(3))\n        True\n        ",
    "section": "Matrix Expressions Core Reference",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "from_index_summation",
    "full_id": "sympy.matrices.expressions.MatrixExpr.from_index_summation",
    "type": "method",
    "description": "\n        Parse expression of matrices with explicitly summed indices into a\n        matrix expression without indices, if possible.\n\n        This transformation expressed in mathematical notation:\n\n        `\\sum_{j=0}^{N-1} A_{i,j} B_{j,k} \\Longrightarrow \\mathbf{A}\\cdot \\mathbf{B}`\n\n        Optional parameter ``first_index``: specify which free index to use as\n        the index starting the expression.\n\n        Examples\n        ========\n\n        >>> from sympy import MatrixSymbol, MatrixExpr, Sum\n        >>> from sympy.abc import i, j, k, l, N\n        >>> A = MatrixSymbol(\"A\", N, N)\n        >>> B = MatrixSymbol(\"B\", N, N)\n        >>> expr = Sum(A[i, j]*B[j, k], (j, 0, N-1))\n        >>> MatrixExpr.from_index_summation(expr)\n        A*B\n\n        Transposition is detected:\n\n        >>> expr = Sum(A[j, i]*B[j, k], (j, 0, N-1))\n        >>> MatrixExpr.from_index_summation(expr)\n        A.T*B\n\n        Detect the trace:\n\n        >>> expr = Sum(A[i, i], (i, 0, N-1))\n        >>> MatrixExpr.from_index_summation(expr)\n        Trace(A)\n\n        More complicated expressions:\n\n        >>> expr = Sum(A[i, j]*B[k, j]*A[l, k], (j, 0, N-1), (k, 0, N-1))\n        >>> MatrixExpr.from_index_summation(expr)\n        A*B.T*A.T\n        ",
    "section": "Matrix Expressions Core Reference",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "hadamard_product",
    "full_id": "sympy.matrices.expressions.hadamard_product",
    "type": "function",
    "description": "\n    Return the elementwise (aka Hadamard) product of matrices.\n\n    Examples\n    ========\n\n    >>> from sympy import hadamard_product, MatrixSymbol\n    >>> A = MatrixSymbol('A', 2, 3)\n    >>> B = MatrixSymbol('B', 2, 3)\n    >>> hadamard_product(A)\n    A\n    >>> hadamard_product(A, B)\n    HadamardProduct(A, B)\n    >>> hadamard_product(A, B)[0, 1]\n    A[0, 1]*B[0, 1]\n    ",
    "section": "Matrix Expressions Core Reference",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "LDUdecomposition",
    "full_id": "sympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition",
    "type": "method",
    "description": "Returns the Block LDU decomposition of\n        a 2x2 Block Matrix\n\n        Returns\n        =======\n\n        (L, D, U) : Matrices\n            L : Lower Diagonal Matrix\n            D : Diagonal Matrix\n            U : Upper Diagonal Matrix\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n        >>> m, n = symbols('m n')\n        >>> A = MatrixSymbol('A', n, n)\n        >>> B = MatrixSymbol('B', n, m)\n        >>> C = MatrixSymbol('C', m, n)\n        >>> D = MatrixSymbol('D', m, m)\n        >>> X = BlockMatrix([[A, B], [C, D]])\n        >>> L, D, U = X.LDUdecomposition()\n        >>> block_collapse(L*D*U)\n        Matrix([\n        [A, B],\n        [C, D]])\n\n        Raises\n        ======\n\n        ShapeError\n            If the block matrix is not a 2x2 matrix\n\n        NonInvertibleMatrixError\n            If the matrix \"A\" is non-invertible\n\n        See Also\n        ========\n        sympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition\n        sympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition\n        ",
    "section": "Block Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "LUdecomposition",
    "full_id": "sympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition",
    "type": "method",
    "description": "Returns the Block LU decomposition of\n        a 2x2 Block Matrix\n\n        Returns\n        =======\n\n        (L, U) : Matrices\n            L : Lower Diagonal Matrix\n            U : Upper Diagonal Matrix\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n        >>> m, n = symbols('m n')\n        >>> A = MatrixSymbol('A', n, n)\n        >>> B = MatrixSymbol('B', n, m)\n        >>> C = MatrixSymbol('C', m, n)\n        >>> D = MatrixSymbol('D', m, m)\n        >>> X = BlockMatrix([[A, B], [C, D]])\n        >>> L, U = X.LUdecomposition()\n        >>> block_collapse(L*U)\n        Matrix([\n        [A, B],\n        [C, D]])\n\n        Raises\n        ======\n\n        ShapeError\n            If the block matrix is not a 2x2 matrix\n\n        NonInvertibleMatrixError\n            If the matrix \"A\" is non-invertible\n\n        See Also\n        ========\n        sympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition\n        sympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition\n        ",
    "section": "Block Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "UDLdecomposition",
    "full_id": "sympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition",
    "type": "method",
    "description": "Returns the Block UDL decomposition of\n        a 2x2 Block Matrix\n\n        Returns\n        =======\n\n        (U, D, L) : Matrices\n            U : Upper Diagonal Matrix\n            D : Diagonal Matrix\n            L : Lower Diagonal Matrix\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n        >>> m, n = symbols('m n')\n        >>> A = MatrixSymbol('A', n, n)\n        >>> B = MatrixSymbol('B', n, m)\n        >>> C = MatrixSymbol('C', m, n)\n        >>> D = MatrixSymbol('D', m, m)\n        >>> X = BlockMatrix([[A, B], [C, D]])\n        >>> U, D, L = X.UDLdecomposition()\n        >>> block_collapse(U*D*L)\n        Matrix([\n        [A, B],\n        [C, D]])\n\n        Raises\n        ======\n\n        ShapeError\n            If the block matrix is not a 2x2 matrix\n\n        NonInvertibleMatrixError\n            If the matrix \"D\" is non-invertible\n\n        See Also\n        ========\n        sympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition\n        sympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition\n        ",
    "section": "Block Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "schur",
    "full_id": "sympy.matrices.expressions.blockmatrix.BlockMatrix.schur",
    "type": "method",
    "description": "Return the Schur Complement of the 2x2 BlockMatrix\n\n        Parameters\n        ==========\n\n        mat : String, optional\n            The matrix with respect to which the\n            Schur Complement is calculated. 'A' is\n            used by default\n\n        generalized : bool, optional\n            If True, returns the generalized Schur\n            Component which uses Moore-Penrose Inverse\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, MatrixSymbol, BlockMatrix\n        >>> m, n = symbols('m n')\n        >>> A = MatrixSymbol('A', n, n)\n        >>> B = MatrixSymbol('B', n, m)\n        >>> C = MatrixSymbol('C', m, n)\n        >>> D = MatrixSymbol('D', m, m)\n        >>> X = BlockMatrix([[A, B], [C, D]])\n\n        The default Schur Complement is evaluated with \"A\"\n\n        >>> X.schur()\n        -C*A**(-1)*B + D\n        >>> X.schur('D')\n        A - B*D**(-1)*C\n\n        Schur complement with non-invertible matrices is not\n        defined. Instead, the generalized Schur complement can\n        be calculated which uses the Moore-Penrose Inverse. To\n        achieve this, `generalized` must be set to `True`\n\n        >>> X.schur('B', generalized=True)\n        C - D*(B.T*B)**(-1)*B.T*A\n        >>> X.schur('C', generalized=True)\n        -A*(C.T*C)**(-1)*C.T*D + B\n\n        Returns\n        =======\n\n        M : Matrix\n            The Schur Complement Matrix\n\n        Raises\n        ======\n\n        ShapeError\n            If the block matrix is not a 2x2 matrix\n\n        NonInvertibleMatrixError\n            If given matrix is non-invertible\n\n        References\n        ==========\n\n        .. [1] Wikipedia Article on Schur Component : https://en.wikipedia.org/wiki/Schur_complement\n\n        See Also\n        ========\n\n        sympy.matrices.matrixbase.MatrixBase.pinv\n        ",
    "section": "Block Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "transpose",
    "full_id": "sympy.matrices.expressions.blockmatrix.BlockMatrix.transpose",
    "type": "method",
    "description": "Return transpose of matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import MatrixSymbol, BlockMatrix, ZeroMatrix\n        >>> from sympy.abc import m, n\n        >>> X = MatrixSymbol('X', n, n)\n        >>> Y = MatrixSymbol('Y', m, m)\n        >>> Z = MatrixSymbol('Z', n, m)\n        >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])\n        >>> B.transpose()\n        Matrix([\n        [X.T,  0],\n        [Z.T, Y.T]])\n        >>> _.transpose()\n        Matrix([\n        [X, Z],\n        [0, Y]])\n        ",
    "section": "Block Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "get_diag_blocks",
    "full_id": "sympy.matrices.expressions.blockmatrix.BlockDiagMatrix.get_diag_blocks",
    "type": "method",
    "description": "Return the list of diagonal blocks of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import BlockDiagMatrix, Matrix\n\n        >>> A = Matrix([[1, 2], [3, 4]])\n        >>> B = Matrix([[5, 6], [7, 8]])\n        >>> M = BlockDiagMatrix(A, B)\n\n        How to get diagonal blocks from the block diagonal matrix:\n\n        >>> diag_blocks = M.get_diag_blocks()\n        >>> diag_blocks[0]\n        Matrix([\n        [1, 2],\n        [3, 4]])\n        >>> diag_blocks[1]\n        Matrix([\n        [5, 6],\n        [7, 8]])\n        ",
    "section": "Block Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "block_collapse",
    "full_id": "sympy.matrices.expressions.blockmatrix.block_collapse",
    "type": "function",
    "description": "Evaluates a block matrix expression\n\n    >>> from sympy import MatrixSymbol, BlockMatrix, symbols, Identity, ZeroMatrix, block_collapse\n    >>> n,m,l = symbols('n m l')\n    >>> X = MatrixSymbol('X', n, n)\n    >>> Y = MatrixSymbol('Y', m, m)\n    >>> Z = MatrixSymbol('Z', n, m)\n    >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m, n), Y]])\n    >>> print(B)\n    Matrix([\n    [X, Z],\n    [0, Y]])\n\n    >>> C = BlockMatrix([[Identity(n), Z]])\n    >>> print(C)\n    Matrix([[I, Z]])\n\n    >>> print(block_collapse(C*B))\n    Matrix([[X, Z + Z*Y]])\n    ",
    "section": "Block Matrices",
    "url": "https://docs.sympy.org/latest/modules/matrices/expressions.html"
  },
  {
    "name": "smith_normal_form",
    "full_id": "sympy.matrices.normalforms.smith_normal_form",
    "type": "function",
    "description": "\n    Return the Smith Normal Form of a matrix `m` over the ring `domain`.\n    This will only work if the ring is a principal ideal domain.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix, ZZ\n    >>> from sympy.matrices.normalforms import smith_normal_form\n    >>> m = Matrix([[12, 6, 4], [3, 9, 6], [2, 16, 14]])\n    >>> print(smith_normal_form(m, domain=ZZ))\n    Matrix([[1, 0, 0], [0, 10, 0], [0, 0, -30]])\n\n    ",
    "section": "Matrix Normal Forms",
    "url": "https://docs.sympy.org/latest/modules/matrices/normalforms.html"
  },
  {
    "name": "hermite_normal_form",
    "full_id": "sympy.matrices.normalforms.hermite_normal_form",
    "type": "function",
    "description": "\n    Compute the Hermite Normal Form of a Matrix *A* of integers.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> from sympy.matrices.normalforms import hermite_normal_form\n    >>> m = Matrix([[12, 6, 4], [3, 9, 6], [2, 16, 14]])\n    >>> print(hermite_normal_form(m))\n    Matrix([[10, 0, 2], [0, 15, 3], [0, 0, 2]])\n\n    Parameters\n    ==========\n\n    A : $m \\times n$ ``Matrix`` of integers.\n\n    D : int, optional\n        Let $W$ be the HNF of *A*. If known in advance, a positive integer *D*\n        being any multiple of $\\det(W)$ may be provided. In this case, if *A*\n        also has rank $m$, then we may use an alternative algorithm that works\n        mod *D* in order to prevent coefficient explosion.\n\n    check_rank : boolean, optional (default=False)\n        The basic assumption is that, if you pass a value for *D*, then\n        you already believe that *A* has rank $m$, so we do not waste time\n        checking it for you. If you do want this to be checked (and the\n        ordinary, non-modulo *D* algorithm to be used if the check fails), then\n        set *check_rank* to ``True``.\n\n    Returns\n    =======\n\n    ``Matrix``\n        The HNF of matrix *A*.\n\n    Raises\n    ======\n\n    DMDomainError\n        If the domain of the matrix is not :ref:`ZZ`.\n\n    DMShapeError\n        If the mod *D* algorithm is used but the matrix has more rows than\n        columns.\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n       (See Algorithms 2.4.5 and 2.4.8.)\n\n    ",
    "section": "Matrix Normal Forms",
    "url": "https://docs.sympy.org/latest/modules/matrices/normalforms.html"
  },
  {
    "name": "derive_by_array",
    "full_id": "sympy.tensor.array.derive_by_array",
    "type": "function",
    "description": "\n    Derivative by arrays. Supports both arrays and scalars.\n\n    The equivalent operator for array expressions is ``array_derive``.\n\n    Explanation\n    ===========\n\n    Given the array `A_{i_1, \\ldots, i_N}` and the array `X_{j_1, \\ldots, j_M}`\n    this function will return a new array `B` defined by\n\n    `B_{j_1,\\ldots,j_M,i_1,\\ldots,i_N} := \\frac{\\partial A_{i_1,\\ldots,i_N}}{\\partial X_{j_1,\\ldots,j_M}}`\n\n    Examples\n    ========\n\n    >>> from sympy import derive_by_array\n    >>> from sympy.abc import x, y, z, t\n    >>> from sympy import cos\n    >>> derive_by_array(cos(x*t), x)\n    -t*sin(t*x)\n    >>> derive_by_array(cos(x*t), [x, y, z, t])\n    [-t*sin(t*x), 0, 0, -x*sin(t*x)]\n    >>> derive_by_array([x, y**2*z], [[x, y], [z, t]])\n    [[[1, 0], [0, 2*y*z]], [[0, y**2], [0, 0]]]\n\n    ",
    "section": "Functions",
    "url": "https://docs.sympy.org/latest/modules/tensor/array.html"
  },
  {
    "name": "permutedims",
    "full_id": "sympy.tensor.array.permutedims",
    "type": "function",
    "description": "\n    Permutes the indices of an array.\n\n    Parameter specifies the permutation of the indices.\n\n    The equivalent operator for array expressions is ``PermuteDims``, which can\n    be used to keep the expression unevaluated.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z, t\n    >>> from sympy import sin\n    >>> from sympy import Array, permutedims\n    >>> a = Array([[x, y, z], [t, sin(x), 0]])\n    >>> a\n    [[x, y, z], [t, sin(x), 0]]\n    >>> permutedims(a, (1, 0))\n    [[x, t], [y, sin(x)], [z, 0]]\n\n    If the array is of second order, ``transpose`` can be used:\n\n    >>> from sympy import transpose\n    >>> transpose(a)\n    [[x, t], [y, sin(x)], [z, 0]]\n\n    Examples on higher dimensions:\n\n    >>> b = Array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n    >>> permutedims(b, (2, 1, 0))\n    [[[1, 5], [3, 7]], [[2, 6], [4, 8]]]\n    >>> permutedims(b, (1, 2, 0))\n    [[[1, 5], [2, 6]], [[3, 7], [4, 8]]]\n\n    An alternative way to specify the same permutations as in the previous\n    lines involves passing the *old* and *new* indices, either as a list or as\n    a string:\n\n    >>> permutedims(b, index_order_old=\"cba\", index_order_new=\"abc\")\n    [[[1, 5], [3, 7]], [[2, 6], [4, 8]]]\n    >>> permutedims(b, index_order_old=\"cab\", index_order_new=\"abc\")\n    [[[1, 5], [2, 6]], [[3, 7], [4, 8]]]\n\n    ``Permutation`` objects are also allowed:\n\n    >>> from sympy.combinatorics import Permutation\n    >>> permutedims(b, Permutation([1, 2, 0]))\n    [[[1, 5], [2, 6]], [[3, 7], [4, 8]]]\n\n    See Also\n    ========\n\n    sympy.tensor.array.expressions.array_expressions.PermuteDims\n\n    ",
    "section": "Functions",
    "url": "https://docs.sympy.org/latest/modules/tensor/array.html"
  },
  {
    "name": "tensorcontraction",
    "full_id": "sympy.tensor.array.tensorcontraction",
    "type": "function",
    "description": "\n    Contraction of an array-like object on the specified axes.\n\n    The equivalent operator for array expressions is ``ArrayContraction``,\n    which can be used to keep the expression unevaluated.\n\n    Examples\n    ========\n\n    >>> from sympy import Array, tensorcontraction\n    >>> from sympy import Matrix, eye\n    >>> tensorcontraction(eye(3), (0, 1))\n    3\n    >>> A = Array(range(18), (3, 2, 3))\n    >>> A\n    [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]], [[12, 13, 14], [15, 16, 17]]]\n    >>> tensorcontraction(A, (0, 2))\n    [21, 30]\n\n    Matrix multiplication may be emulated with a proper combination of\n    ``tensorcontraction`` and ``tensorproduct``\n\n    >>> from sympy import tensorproduct\n    >>> from sympy.abc import a,b,c,d,e,f,g,h\n    >>> m1 = Matrix([[a, b], [c, d]])\n    >>> m2 = Matrix([[e, f], [g, h]])\n    >>> p = tensorproduct(m1, m2)\n    >>> p\n    [[[[a*e, a*f], [a*g, a*h]], [[b*e, b*f], [b*g, b*h]]], [[[c*e, c*f], [c*g, c*h]], [[d*e, d*f], [d*g, d*h]]]]\n    >>> tensorcontraction(p, (1, 2))\n    [[a*e + b*g, a*f + b*h], [c*e + d*g, c*f + d*h]]\n    >>> m1*m2\n    Matrix([\n    [a*e + b*g, a*f + b*h],\n    [c*e + d*g, c*f + d*h]])\n\n    See Also\n    ========\n\n    sympy.tensor.array.expressions.array_expressions.ArrayContraction\n\n    ",
    "section": "Functions",
    "url": "https://docs.sympy.org/latest/modules/tensor/array.html"
  },
  {
    "name": "tensorproduct",
    "full_id": "sympy.tensor.array.tensorproduct",
    "type": "function",
    "description": "\n    Tensor product among scalars or array-like objects.\n\n    The equivalent operator for array expressions is ``ArrayTensorProduct``,\n    which can be used to keep the expression unevaluated.\n\n    Examples\n    ========\n\n    >>> from sympy.tensor.array import tensorproduct, Array\n    >>> from sympy.abc import x, y, z, t\n    >>> A = Array([[1, 2], [3, 4]])\n    >>> B = Array([x, y])\n    >>> tensorproduct(A, B)\n    [[[x, y], [2*x, 2*y]], [[3*x, 3*y], [4*x, 4*y]]]\n    >>> tensorproduct(A, x)\n    [[x, 2*x], [3*x, 4*x]]\n    >>> tensorproduct(A, B, B)\n    [[[[x**2, x*y], [x*y, y**2]], [[2*x**2, 2*x*y], [2*x*y, 2*y**2]]], [[[3*x**2, 3*x*y], [3*x*y, 3*y**2]], [[4*x**2, 4*x*y], [4*x*y, 4*y**2]]]]\n\n    Applying this function on two matrices will result in a rank 4 array.\n\n    >>> from sympy import Matrix, eye\n    >>> m = Matrix([[x, y], [z, t]])\n    >>> p = tensorproduct(eye(3), m)\n    >>> p\n    [[[[x, y], [z, t]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[x, y], [z, t]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]], [[x, y], [z, t]]]]\n\n    See Also\n    ========\n\n    sympy.tensor.array.expressions.array_expressions.ArrayTensorProduct\n\n    ",
    "section": "Functions",
    "url": "https://docs.sympy.org/latest/modules/tensor/array.html"
  },
  {
    "name": "tensordiagonal",
    "full_id": "sympy.tensor.array.tensordiagonal",
    "type": "function",
    "description": "\n    Diagonalization of an array-like object on the specified axes.\n\n    This is equivalent to multiplying the expression by Kronecker deltas\n    uniting the axes.\n\n    The diagonal indices are put at the end of the axes.\n\n    The equivalent operator for array expressions is ``ArrayDiagonal``, which\n    can be used to keep the expression unevaluated.\n\n    Examples\n    ========\n\n    ``tensordiagonal`` acting on a 2-dimensional array by axes 0 and 1 is\n    equivalent to the diagonal of the matrix:\n\n    >>> from sympy import Array, tensordiagonal\n    >>> from sympy import Matrix, eye\n    >>> tensordiagonal(eye(3), (0, 1))\n    [1, 1, 1]\n\n    >>> from sympy.abc import a,b,c,d\n    >>> m1 = Matrix([[a, b], [c, d]])\n    >>> tensordiagonal(m1, [0, 1])\n    [a, d]\n\n    In case of higher dimensional arrays, the diagonalized out dimensions\n    are appended removed and appended as a single dimension at the end:\n\n    >>> A = Array(range(18), (3, 2, 3))\n    >>> A\n    [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]], [[12, 13, 14], [15, 16, 17]]]\n    >>> tensordiagonal(A, (0, 2))\n    [[0, 7, 14], [3, 10, 17]]\n    >>> from sympy import permutedims\n    >>> tensordiagonal(A, (0, 2)) == permutedims(Array([A[0, :, 0], A[1, :, 1], A[2, :, 2]]), [1, 0])\n    True\n\n    See Also\n    ========\n\n    sympy.tensor.array.expressions.array_expressions.ArrayDiagonal\n\n    ",
    "section": "Functions",
    "url": "https://docs.sympy.org/latest/modules/tensor/array.html"
  },
  {
    "name": "label",
    "full_id": "sympy.tensor.indexed.Idx.label",
    "type": "property",
    "description": "Returns the label (Integer or integer expression) of the Idx object.\n\n        Examples\n        ========\n\n        >>> from sympy import Idx, Symbol\n        >>> x = Symbol('x', integer=True)\n        >>> Idx(x).label\n        x\n        >>> j = Symbol('j', integer=True)\n        >>> Idx(j).label\n        j\n        >>> Idx(j + 1).label\n        j + 1\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "lower",
    "full_id": "sympy.tensor.indexed.Idx.lower",
    "type": "property",
    "description": "Returns the lower bound of the ``Idx``.\n\n        Examples\n        ========\n\n        >>> from sympy import Idx\n        >>> Idx('j', 2).lower\n        0\n        >>> Idx('j', 5).lower\n        0\n        >>> Idx('j').lower is None\n        True\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "upper",
    "full_id": "sympy.tensor.indexed.Idx.upper",
    "type": "property",
    "description": "Returns the upper bound of the ``Idx``.\n\n        Examples\n        ========\n\n        >>> from sympy import Idx\n        >>> Idx('j', 2).upper\n        1\n        >>> Idx('j', 5).upper\n        4\n        >>> Idx('j').upper is None\n        True\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "base",
    "full_id": "sympy.tensor.indexed.Indexed.base",
    "type": "property",
    "description": "Returns the ``IndexedBase`` of the ``Indexed`` object.\n\n        Examples\n        ========\n\n        >>> from sympy import Indexed, IndexedBase, Idx, symbols\n        >>> i, j = symbols('i j', cls=Idx)\n        >>> Indexed('A', i, j).base\n        A\n        >>> B = IndexedBase('B')\n        >>> B == B[i, j].base\n        True\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "indices",
    "full_id": "sympy.tensor.indexed.Indexed.indices",
    "type": "property",
    "description": "\n        Returns the indices of the ``Indexed`` object.\n\n        Examples\n        ========\n\n        >>> from sympy import Indexed, Idx, symbols\n        >>> i, j = symbols('i j', cls=Idx)\n        >>> Indexed('A', i, j).indices\n        (i, j)\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "ranges",
    "full_id": "sympy.tensor.indexed.Indexed.ranges",
    "type": "property",
    "description": "Returns a list of tuples with lower and upper range of each index.\n\n        If an index does not define the data members upper and lower, the\n        corresponding slot in the list contains ``None`` instead of a tuple.\n\n        Examples\n        ========\n\n        >>> from sympy import Indexed,Idx, symbols\n        >>> Indexed('A', Idx('i', 2), Idx('j', 4), Idx('k', 8)).ranges\n        [(0, 1), (0, 3), (0, 7)]\n        >>> Indexed('A', Idx('i', 3), Idx('j', 3), Idx('k', 3)).ranges\n        [(0, 2), (0, 2), (0, 2)]\n        >>> x, y, z = symbols('x y z', integer=True)\n        >>> Indexed('A', x, y, z).ranges\n        [None, None, None]\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "rank",
    "full_id": "sympy.tensor.indexed.Indexed.rank",
    "type": "property",
    "description": "\n        Returns the rank of the ``Indexed`` object.\n\n        Examples\n        ========\n\n        >>> from sympy import Indexed, Idx, symbols\n        >>> i, j, k, l, m = symbols('i:m', cls=Idx)\n        >>> Indexed('A', i, j).rank\n        2\n        >>> q = Indexed('A', i, j, k, l, m)\n        >>> q.rank\n        5\n        >>> q.rank == len(q.indices)\n        True\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "shape",
    "full_id": "sympy.tensor.indexed.Indexed.shape",
    "type": "property",
    "description": "Returns a list with dimensions of each index.\n\n        Dimensions is a property of the array, not of the indices.  Still, if\n        the ``IndexedBase`` does not define a shape attribute, it is assumed\n        that the ranges of the indices correspond to the shape of the array.\n\n        >>> from sympy import IndexedBase, Idx, symbols\n        >>> n, m = symbols('n m', integer=True)\n        >>> i = Idx('i', m)\n        >>> j = Idx('j', m)\n        >>> A = IndexedBase('A', shape=(n, n))\n        >>> B = IndexedBase('B')\n        >>> A[i, j].shape\n        (n, n)\n        >>> B[i, j].shape\n        (m, m)\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "label",
    "full_id": "sympy.tensor.indexed.IndexedBase.label",
    "type": "property",
    "description": "Returns the label of the ``IndexedBase`` object.\n\n        Examples\n        ========\n\n        >>> from sympy import IndexedBase\n        >>> from sympy.abc import x, y\n        >>> IndexedBase('A', shape=(x, y)).label\n        A\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "offset",
    "full_id": "sympy.tensor.indexed.IndexedBase.offset",
    "type": "property",
    "description": "Returns the offset for the ``IndexedBase`` object.\n\n        This is the value added to the resulting index when the\n        2D Indexed object is unrolled to a 1D form. Used in code\n        generation.\n\n        Examples\n        ==========\n        >>> from sympy.printing import ccode\n        >>> from sympy.tensor import IndexedBase, Idx\n        >>> from sympy import symbols\n        >>> l, m, n, o = symbols('l m n o', integer=True)\n        >>> A = IndexedBase('A', strides=(l, m, n), offset=o)\n        >>> i, j, k = map(Idx, 'ijk')\n        >>> ccode(A[i, j, k])\n        'A[l*i + m*j + n*k + o]'\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "shape",
    "full_id": "sympy.tensor.indexed.IndexedBase.shape",
    "type": "property",
    "description": "Returns the shape of the ``IndexedBase`` object.\n\n        Examples\n        ========\n\n        >>> from sympy import IndexedBase, Idx\n        >>> from sympy.abc import x, y\n        >>> IndexedBase('A', shape=(x, y)).shape\n        (x, y)\n\n        Note: If the shape of the ``IndexedBase`` is specified, it will override\n        any shape information given by the indices.\n\n        >>> A = IndexedBase('A', shape=(x, y))\n        >>> B = IndexedBase('B')\n        >>> i = Idx('i', 2)\n        >>> j = Idx('j', 1)\n        >>> A[i, j].shape\n        (x, y)\n        >>> B[i, j].shape\n        (2, 1)\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "strides",
    "full_id": "sympy.tensor.indexed.IndexedBase.strides",
    "type": "property",
    "description": "Returns the strided scheme for the ``IndexedBase`` object.\n\n        Normally this is a tuple denoting the number of\n        steps to take in the respective dimension when traversing\n        an array. For code generation purposes strides='C' and\n        strides='F' can also be used.\n\n        strides='C' would mean that code printer would unroll\n        in row-major order and 'F' means unroll in column major\n        order.\n\n        ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/tensor/indexed.html"
  },
  {
    "name": "get_contraction_structure",
    "full_id": "sympy.tensor.index_methods.get_contraction_structure",
    "type": "function",
    "description": "Determine dummy indices of ``expr`` and describe its structure\n\n    By *dummy* we mean indices that are summation indices.\n\n    The structure of the expression is determined and described as follows:\n\n    1) A conforming summation of Indexed objects is described with a dict where\n       the keys are summation indices and the corresponding values are sets\n       containing all terms for which the summation applies.  All Add objects\n       in the SymPy expression tree are described like this.\n\n    2) For all nodes in the SymPy expression tree that are *not* of type Add, the\n       following applies:\n\n       If a node discovers contractions in one of its arguments, the node\n       itself will be stored as a key in the dict.  For that key, the\n       corresponding value is a list of dicts, each of which is the result of a\n       recursive call to get_contraction_structure().  The list contains only\n       dicts for the non-trivial deeper contractions, omitting dicts with None\n       as the one and only key.\n\n    .. Note:: The presence of expressions among the dictionary keys indicates\n       multiple levels of index contractions.  A nested dict displays nested\n       contractions and may itself contain dicts from a deeper level.  In\n       practical calculations the summation in the deepest nested level must be\n       calculated first so that the outer expression can access the resulting\n       indexed object.\n\n    Examples\n    ========\n\n    >>> from sympy.tensor.index_methods import get_contraction_structure\n    >>> from sympy import default_sort_key\n    >>> from sympy.tensor import IndexedBase, Idx\n    >>> x, y, A = map(IndexedBase, ['x', 'y', 'A'])\n    >>> i, j, k, l = map(Idx, ['i', 'j', 'k', 'l'])\n    >>> get_contraction_structure(x[i]*y[i] + A[j, j])\n    {(i,): {x[i]*y[i]}, (j,): {A[j, j]}}\n    >>> get_contraction_structure(x[i]*y[j])\n    {None: {x[i]*y[j]}}\n\n    A multiplication of contracted factors results in nested dicts representing\n    the internal contractions.\n\n    >>> d = get_contraction_structure(x[i, i]*y[j, j])\n    >>> sorted(d.keys(), key=default_sort_key)\n    [None, x[i, i]*y[j, j]]\n\n    In this case, the product has no contractions:\n\n    >>> d[None]\n    {x[i, i]*y[j, j]}\n\n    Factors are contracted \"first\":\n\n    >>> sorted(d[x[i, i]*y[j, j]], key=default_sort_key)\n    [{(i,): {x[i, i]}}, {(j,): {y[j, j]}}]\n\n    A parenthesized Add object is also returned as a nested dictionary.  The\n    term containing the parenthesis is a Mul with a contraction among the\n    arguments, so it will be found as a key in the result.  It stores the\n    dictionary resulting from a recursive call on the Add expression.\n\n    >>> d = get_contraction_structure(x[i]*(y[i] + A[i, j]*x[j]))\n    >>> sorted(d.keys(), key=default_sort_key)\n    [(A[i, j]*x[j] + y[i])*x[i], (i,)]\n    >>> d[(i,)]\n    {(A[i, j]*x[j] + y[i])*x[i]}\n    >>> d[x[i]*(A[i, j]*x[j] + y[i])]\n    [{None: {y[i]}, (j,): {A[i, j]*x[j]}}]\n\n    Powers with contractions in either base or exponent will also be found as\n    keys in the dictionary, mapping to a list of results from recursive calls:\n\n    >>> d = get_contraction_structure(A[j, j]**A[i, i])\n    >>> d[None]\n    {A[j, j]**A[i, i]}\n    >>> nested_contractions = d[A[j, j]**A[i, i]]\n    >>> nested_contractions[0]\n    {(j,): {A[j, j]}}\n    >>> nested_contractions[1]\n    {(i,): {A[i, i]}}\n\n    The description of the contraction structure may appear complicated when\n    represented with a string in the above examples, but it is easy to iterate\n    over:\n\n    >>> from sympy import Expr\n    >>> for key in d:\n    ...     if isinstance(key, Expr):\n    ...         continue\n    ...     for term in d[key]:\n    ...         if term in d:\n    ...             # treat deepest contraction first\n    ...             pass\n    ...     # treat outermost contactions here\n\n    ",
    "section": "Methods",
    "url": "https://docs.sympy.org/latest/modules/tensor/index_methods.html"
  },
  {
    "name": "get_indices",
    "full_id": "sympy.tensor.index_methods.get_indices",
    "type": "function",
    "description": "Determine the outer indices of expression ``expr``\n\n    By *outer* we mean indices that are not summation indices.  Returns a set\n    and a dict.  The set contains outer indices and the dict contains\n    information about index symmetries.\n\n    Examples\n    ========\n\n    >>> from sympy.tensor.index_methods import get_indices\n    >>> from sympy import symbols\n    >>> from sympy.tensor import IndexedBase\n    >>> x, y, A = map(IndexedBase, ['x', 'y', 'A'])\n    >>> i, j, a, z = symbols('i j a z', integer=True)\n\n    The indices of the total expression is determined, Repeated indices imply a\n    summation, for instance the trace of a matrix A:\n\n    >>> get_indices(A[i, i])\n    (set(), {})\n\n    In the case of many terms, the terms are required to have identical\n    outer indices.  Else an IndexConformanceException is raised.\n\n    >>> get_indices(x[i] + A[i, j]*y[j])\n    ({i}, {})\n\n    :Exceptions:\n\n    An IndexConformanceException means that the terms ar not compatible, e.g.\n\n    >>> get_indices(x[i] + y[j])                #doctest: +SKIP\n            (...)\n    IndexConformanceException: Indices are not consistent: x(i) + y(j)\n\n    .. warning::\n       The concept of *outer* indices applies recursively, starting on the deepest\n       level.  This implies that dummies inside parenthesis are assumed to be\n       summed first, so that the following expression is handled gracefully:\n\n       >>> get_indices((x[i] + A[i, j]*y[j])*x[j])\n       ({i, j}, {})\n\n       This is correct and may appear convenient, but you need to be careful\n       with this as SymPy will happily .expand() the product, if requested.  The\n       resulting expression would mix the outer ``j`` with the dummies inside\n       the parenthesis, which makes it a different expression.  To be on the\n       safe side, it is best to avoid such ambiguities by using unique indices\n       for all contractions that should be held separate.\n\n    ",
    "section": "Methods",
    "url": "https://docs.sympy.org/latest/modules/tensor/index_methods.html"
  },
  {
    "name": "commutes_with",
    "full_id": "sympy.tensor.tensor.TensorHead.commutes_with",
    "type": "method",
    "description": "\n        Returns ``0`` if ``self`` and ``other`` commute, ``1`` if they anticommute.\n\n        Returns ``None`` if ``self`` and ``other`` neither commute nor anticommute.\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "tensor_heads",
    "full_id": "sympy.tensor.tensor.tensor_heads",
    "type": "function",
    "description": "\n    Returns a sequence of TensorHeads from a string `s`\n    ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "get_matrix",
    "full_id": "sympy.tensor.tensor.TensExpr.get_matrix",
    "type": "method",
    "description": "\n        DEPRECATED: do not use.\n\n        Returns ndarray components data as a matrix, if components data are\n        available and ndarray dimension does not exceed 2.\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "replace_with_arrays",
    "full_id": "sympy.tensor.tensor.TensExpr.replace_with_arrays",
    "type": "method",
    "description": "\n        Replace the tensorial expressions with arrays. The final array will\n        correspond to the N-dimensional array with indices arranged according\n        to ``indices``.\n\n        Parameters\n        ==========\n\n        replacement_dict\n            dictionary containing the replacement rules for tensors.\n        indices\n            the index order with respect to which the array is read. The\n            original index order will be used if no value is passed.\n\n        Examples\n        ========\n\n        >>> from sympy.tensor.tensor import TensorIndexType, tensor_indices\n        >>> from sympy.tensor.tensor import TensorHead\n        >>> from sympy import symbols, diag\n\n        >>> L = TensorIndexType(\"L\")\n        >>> i, j = tensor_indices(\"i j\", L)\n        >>> A = TensorHead(\"A\", [L])\n        >>> A(i).replace_with_arrays({A(i): [1, 2]}, [i])\n        [1, 2]\n\n        Since 'indices' is optional, we can also call replace_with_arrays by\n        this way if no specific index order is needed:\n\n        >>> A(i).replace_with_arrays({A(i): [1, 2]})\n        [1, 2]\n\n        >>> expr = A(i)*A(j)\n        >>> expr.replace_with_arrays({A(i): [1, 2]})\n        [[1, 2], [2, 4]]\n\n        For contractions, specify the metric of the ``TensorIndexType``, which\n        in this case is ``L``, in its covariant form:\n\n        >>> expr = A(i)*A(-i)\n        >>> expr.replace_with_arrays({A(i): [1, 2], L: diag(1, -1)})\n        -3\n\n        Symmetrization of an array:\n\n        >>> H = TensorHead(\"H\", [L, L])\n        >>> a, b, c, d = symbols(\"a b c d\")\n        >>> expr = H(i, j)/2 + H(j, i)/2\n        >>> expr.replace_with_arrays({H(i, j): [[a, b], [c, d]]})\n        [[a, b/2 + c/2], [b/2 + c/2, d]]\n\n        Anti-symmetrization of an array:\n\n        >>> expr = H(i, j)/2 - H(j, i)/2\n        >>> repl = {H(i, j): [[a, b], [c, d]]}\n        >>> expr.replace_with_arrays(repl)\n        [[0, b/2 - c/2], [-b/2 + c/2, 0]]\n\n        The same expression can be read as the transpose by inverting ``i`` and\n        ``j``:\n\n        >>> expr.replace_with_arrays(repl, [j, i])\n        [[0, -b/2 + c/2], [b/2 - c/2, 0]]\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "canon_bp",
    "full_id": "sympy.tensor.tensor.TensAdd.canon_bp",
    "type": "method",
    "description": "\n        Canonicalize using the Butler-Portugal algorithm for canonicalization\n        under monoterm symmetries.\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "contract_metric",
    "full_id": "sympy.tensor.tensor.TensAdd.contract_metric",
    "type": "method",
    "description": "\n        Raise or lower indices with the metric ``g``.\n\n        Parameters\n        ==========\n\n        g :  metric\n\n        contract_all : if True, eliminate all ``g`` which are contracted\n\n        Notes\n        =====\n\n        see the ``TensorIndexType`` docstring for the contraction conventions\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "canon_bp",
    "full_id": "sympy.tensor.tensor.TensMul.canon_bp",
    "type": "method",
    "description": "\n        Canonicalize using the Butler-Portugal algorithm for canonicalization\n        under monoterm symmetries.\n\n        Examples\n        ========\n\n        >>> from sympy.tensor.tensor import TensorIndexType, tensor_indices, TensorHead, TensorSymmetry\n        >>> Lorentz = TensorIndexType('Lorentz', dummy_name='L')\n        >>> m0, m1, m2 = tensor_indices('m0,m1,m2', Lorentz)\n        >>> A = TensorHead('A', [Lorentz]*2, TensorSymmetry.fully_symmetric(-2))\n        >>> t = A(m0,-m1)*A(m1,-m0)\n        >>> t.canon_bp()\n        -A(L_0, L_1)*A(-L_0, -L_1)\n        >>> t = A(m0,-m1)*A(m1,-m2)*A(m2,-m0)\n        >>> t.canon_bp()\n        0\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "contract_metric",
    "full_id": "sympy.tensor.tensor.TensMul.contract_metric",
    "type": "method",
    "description": "\n        Raise or lower indices with the metric ``g``.\n\n        Parameters\n        ==========\n\n        g : metric\n\n        Notes\n        =====\n\n        See the ``TensorIndexType`` docstring for the contraction conventions.\n\n        Examples\n        ========\n\n        >>> from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensor_heads\n        >>> Lorentz = TensorIndexType('Lorentz', dummy_name='L')\n        >>> m0, m1, m2 = tensor_indices('m0,m1,m2', Lorentz)\n        >>> g = Lorentz.metric\n        >>> p, q = tensor_heads('p,q', [Lorentz])\n        >>> t = p(m0)*q(m1)*g(-m0, -m1)\n        >>> t.canon_bp()\n        metric(L_0, L_1)*p(-L_0)*q(-L_1)\n        >>> t.contract_metric(g).canon_bp()\n        p(L_0)*q(-L_0)\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "get_free_indices",
    "full_id": "sympy.tensor.tensor.TensMul.get_free_indices",
    "type": "method",
    "description": "\n        Returns the list of free indices of the tensor.\n\n        Explanation\n        ===========\n\n        The indices are listed in the order in which they appear in the\n        component tensors.\n\n        Examples\n        ========\n\n        >>> from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensor_heads\n        >>> Lorentz = TensorIndexType('Lorentz', dummy_name='L')\n        >>> m0, m1, m2 = tensor_indices('m0,m1,m2', Lorentz)\n        >>> g = Lorentz.metric\n        >>> p, q = tensor_heads('p,q', [Lorentz])\n        >>> t = p(m1)*g(m0,m2)\n        >>> t.get_free_indices()\n        [m1, m0, m2]\n        >>> t2 = p(m1)*g(-m1, m2)\n        >>> t2.get_free_indices()\n        [m2]\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "get_indices",
    "full_id": "sympy.tensor.tensor.TensMul.get_indices",
    "type": "method",
    "description": "\n        Returns the list of indices of the tensor.\n\n        Explanation\n        ===========\n\n        The indices are listed in the order in which they appear in the\n        component tensors.\n        The dummy indices are given a name which does not collide with\n        the names of the free indices.\n\n        Examples\n        ========\n\n        >>> from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensor_heads\n        >>> Lorentz = TensorIndexType('Lorentz', dummy_name='L')\n        >>> m0, m1, m2 = tensor_indices('m0,m1,m2', Lorentz)\n        >>> g = Lorentz.metric\n        >>> p, q = tensor_heads('p,q', [Lorentz])\n        >>> t = p(m1)*g(m0,m2)\n        >>> t.get_indices()\n        [m1, m0, m2]\n        >>> t2 = p(m1)*g(-m1, m2)\n        >>> t2.get_indices()\n        [L_0, -L_0, m2]\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "perm2tensor",
    "full_id": "sympy.tensor.tensor.TensMul.perm2tensor",
    "type": "method",
    "description": "\n        Returns the tensor corresponding to the permutation ``g``\n\n        For further details, see the method in ``TIDS`` with the same name.\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "sorted_components",
    "full_id": "sympy.tensor.tensor.TensMul.sorted_components",
    "type": "method",
    "description": "\n        Returns a tensor product with sorted components.\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "split",
    "full_id": "sympy.tensor.tensor.TensMul.split",
    "type": "method",
    "description": "\n        Returns a list of tensors, whose product is ``self``.\n\n        Explanation\n        ===========\n\n        Dummy indices contracted among different tensor components\n        become free indices with the same name as the one used to\n        represent the dummy indices.\n\n        Examples\n        ========\n\n        >>> from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensor_heads, TensorSymmetry\n        >>> Lorentz = TensorIndexType('Lorentz', dummy_name='L')\n        >>> a, b, c, d = tensor_indices('a,b,c,d', Lorentz)\n        >>> A, B = tensor_heads('A,B', [Lorentz]*2, TensorSymmetry.fully_symmetric(2))\n        >>> t = A(a,b)*B(-b,c)\n        >>> t\n        A(a, L_0)*B(-L_0, c)\n        >>> t.split()\n        [A(a, L_0), B(-L_0, c)]\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "canon_bp",
    "full_id": "sympy.tensor.tensor.canon_bp",
    "type": "function",
    "description": "\n    Butler-Portugal canonicalization. See ``tensor_can.py`` from the\n    combinatorics module for the details.\n    ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "riemann_cyclic_replace",
    "full_id": "sympy.tensor.tensor.riemann_cyclic_replace",
    "type": "function",
    "description": "\n    replace Riemann tensor with an equivalent expression\n\n    ``R(m,n,p,q) -> 2/3*R(m,n,p,q) - 1/3*R(m,q,n,p) + 1/3*R(m,p,n,q)``\n\n    ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "riemann_cyclic",
    "full_id": "sympy.tensor.tensor.riemann_cyclic",
    "type": "function",
    "description": "\n    Replace each Riemann tensor with an equivalent expression\n    satisfying the cyclic identity.\n\n    This trick is discussed in the reference guide to Cadabra.\n\n    Examples\n    ========\n\n    >>> from sympy.tensor.tensor import TensorIndexType, tensor_indices, TensorHead, riemann_cyclic, TensorSymmetry\n    >>> Lorentz = TensorIndexType('Lorentz', dummy_name='L')\n    >>> i, j, k, l = tensor_indices('i,j,k,l', Lorentz)\n    >>> R = TensorHead('R', [Lorentz]*4, TensorSymmetry.riemann())\n    >>> t = R(i,j,k,l)*(R(-i,-j,-k,-l) - 2*R(-i,-k,-j,-l))\n    >>> riemann_cyclic(t)\n    0\n    ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "direct_product",
    "full_id": "sympy.tensor.tensor.TensorSymmetry.direct_product",
    "type": "method",
    "description": "\n        Returns a TensorSymmetry object that is being a direct product of\n        fully (anti-)symmetric index permutation groups.\n\n        Notes\n        =====\n\n        Some examples for different values of ``(*args)``:\n        ``(1)``         vector, equivalent to ``TensorSymmetry.fully_symmetric(1)``\n        ``(2)``         tensor with 2 symmetric indices, equivalent to ``.fully_symmetric(2)``\n        ``(-2)``        tensor with 2 antisymmetric indices, equivalent to ``.fully_symmetric(-2)``\n        ``(2, -2)``     tensor with the first 2 indices commuting and the last 2 anticommuting\n        ``(1, 1, 1)``   tensor with 3 indices without any symmetry\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "fully_symmetric",
    "full_id": "sympy.tensor.tensor.TensorSymmetry.fully_symmetric",
    "type": "method",
    "description": "\n        Returns a fully symmetric (antisymmetric if ``rank``<0)\n        TensorSymmetry object for ``abs(rank)`` indices.\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "no_symmetry",
    "full_id": "sympy.tensor.tensor.TensorSymmetry.no_symmetry",
    "type": "method",
    "description": "\n        TensorSymmetry object for ``rank`` indices with no symmetry\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "riemann",
    "full_id": "sympy.tensor.tensor.TensorSymmetry.riemann",
    "type": "method",
    "description": "\n        Returns a monotorem symmetry of the Riemann tensor\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "tensorsymmetry",
    "full_id": "sympy.tensor.tensor.tensorsymmetry",
    "type": "function",
    "description": "\n    Returns a ``TensorSymmetry`` object. This method is deprecated, use\n    ``TensorSymmetry.direct_product()`` or ``.riemann()`` instead.\n\n    Explanation\n    ===========\n\n    One can represent a tensor with any monoterm slot symmetry group\n    using a BSGS.\n\n    ``args`` can be a BSGS\n    ``args[0]``    base\n    ``args[1]``    sgs\n\n    Usually tensors are in (direct products of) representations\n    of the symmetric group;\n    ``args`` can be a list of lists representing the shapes of Young tableaux\n\n    Notes\n    =====\n\n    For instance:\n    ``[[1]]``       vector\n    ``[[1]*n]``     symmetric tensor of rank ``n``\n    ``[[n]]``       antisymmetric tensor of rank ``n``\n    ``[[2, 2]]``    monoterm slot symmetry of the Riemann tensor\n    ``[[1],[1]]``   vector*vector\n    ``[[2],[1],[1]`` (antisymmetric tensor)*vector*vector\n\n    Notice that with the shape ``[2, 2]`` we associate only the monoterm\n    symmetries of the Riemann tensor; this is an abuse of notation,\n    since the shape ``[2, 2]`` corresponds usually to the irreducible\n    representation characterized by the monoterm symmetries and by the\n    cyclic symmetry.\n    ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "clear",
    "full_id": "sympy.tensor.tensor._TensorManager.clear",
    "type": "method",
    "description": "\n        Clear the TensorManager.\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "comm_i2symbol",
    "full_id": "sympy.tensor.tensor._TensorManager.comm_i2symbol",
    "type": "method",
    "description": "\n        Returns the symbol corresponding to the commutation group number.\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "comm_symbols2i",
    "full_id": "sympy.tensor.tensor._TensorManager.comm_symbols2i",
    "type": "method",
    "description": "\n        Get the commutation group number corresponding to ``i``.\n\n        ``i`` can be a symbol or a number or a string.\n\n        If ``i`` is not already defined its commutation group number\n        is set.\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "get_comm",
    "full_id": "sympy.tensor.tensor._TensorManager.get_comm",
    "type": "method",
    "description": "\n        Return the commutation parameter for commutation group numbers ``i, j``\n\n        see ``_TensorManager.set_comm``\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "set_comm",
    "full_id": "sympy.tensor.tensor._TensorManager.set_comm",
    "type": "method",
    "description": "\n        Set the commutation parameter ``c`` for commutation groups ``i, j``.\n\n        Parameters\n        ==========\n\n        i, j : symbols representing commutation groups\n\n        c  :  group commutation number\n\n        Notes\n        =====\n\n        ``i, j`` can be symbols, strings or numbers,\n        apart from ``0, 1`` and ``2`` which are reserved respectively\n        for commuting, anticommuting tensors and tensors not commuting\n        with any other group apart with the commuting tensors.\n        For the remaining cases, use this method to set the commutation rules;\n        by default ``c=None``.\n\n        The group commutation number ``c`` is assigned in correspondence\n        to the group commutation symbols; it can be\n\n        0        commuting\n\n        1        anticommuting\n\n        None     no commutation property\n\n        Examples\n        ========\n\n        ``G`` and ``GH`` do not commute with themselves and commute with\n        each other; A is commuting.\n\n        >>> from sympy.tensor.tensor import TensorIndexType, tensor_indices, TensorHead, TensorManager, TensorSymmetry\n        >>> Lorentz = TensorIndexType('Lorentz')\n        >>> i0,i1,i2,i3,i4 = tensor_indices('i0:5', Lorentz)\n        >>> A = TensorHead('A', [Lorentz])\n        >>> G = TensorHead('G', [Lorentz], TensorSymmetry.no_symmetry(1), 'Gcomm')\n        >>> GH = TensorHead('GH', [Lorentz], TensorSymmetry.no_symmetry(1), 'GHcomm')\n        >>> TensorManager.set_comm('Gcomm', 'GHcomm', 0)\n        >>> (GH(i1)*G(i0)).canon_bp()\n        G(i0)*GH(i1)\n        >>> (G(i1)*G(i0)).canon_bp()\n        G(i1)*G(i0)\n        >>> (G(i1)*A(i0)).canon_bp()\n        A(i0)*G(i1)\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "set_comms",
    "full_id": "sympy.tensor.tensor._TensorManager.set_comms",
    "type": "method",
    "description": "\n        Set the commutation group numbers ``c`` for symbols ``i, j``.\n\n        Parameters\n        ==========\n\n        args : sequence of ``(i, j, c)``\n        ",
    "section": "Tensor",
    "url": "https://docs.sympy.org/latest/modules/tensor/tensor.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.__init__",
    "type": "method",
    "description": "\n        The orientation/location parameters are necessary if this system\n        is being defined at a certain orientation or location wrt another.\n\n        Parameters\n        ==========\n\n        name : str\n            The name of the new CoordSys3D instance.\n\n        transformation : Lambda, Tuple, str\n            Transformation defined by transformation equations or chosen\n            from predefined ones.\n\n        location : Vector\n            The position vector of the new system's origin wrt the parent\n            instance.\n\n        rotation_matrix : SymPy ImmutableMatrix\n            The rotation matrix of the new coordinate system with respect\n            to the parent. In other words, the output of\n            new_system.rotation_matrix(parent).\n\n        parent : CoordSys3D\n            The coordinate system wrt which the orientation/location\n            (or both) is being defined.\n\n        vector_names, variable_names : iterable(optional)\n            Iterables of 3 strings each, with custom names for base\n            vectors and base scalars of the new system respectively.\n            Used for simple str printing.\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "create_new",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.create_new",
    "type": "method",
    "description": "\n        Returns a CoordSys3D which is connected to self by transformation.\n\n        Parameters\n        ==========\n\n        name : str\n            The name of the new CoordSys3D instance.\n\n        transformation : Lambda, Tuple, str\n            Transformation defined by transformation equations or chosen\n            from predefined ones.\n\n        vector_names, variable_names : iterable(optional)\n            Iterables of 3 strings each, with custom names for base\n            vectors and base scalars of the new system respectively.\n            Used for simple str printing.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> a = CoordSys3D('a')\n        >>> b = a.create_new('b', transformation='spherical')\n        >>> b.transformation_to_parent()\n        (b.r*sin(b.theta)*cos(b.phi), b.r*sin(b.phi)*sin(b.theta), b.r*cos(b.theta))\n        >>> b.transformation_from_parent()\n        (sqrt(a.x**2 + a.y**2 + a.z**2), acos(a.z/sqrt(a.x**2 + a.y**2 + a.z**2)), atan2(a.y, a.x))\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "locate_new",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.locate_new",
    "type": "method",
    "description": "\n        Returns a CoordSys3D with its origin located at the given\n        position wrt this coordinate system's origin.\n\n        Parameters\n        ==========\n\n        name : str\n            The name of the new CoordSys3D instance.\n\n        position : Vector\n            The position vector of the new system's origin wrt this\n            one.\n\n        vector_names, variable_names : iterable(optional)\n            Iterables of 3 strings each, with custom names for base\n            vectors and base scalars of the new system respectively.\n            Used for simple str printing.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> A = CoordSys3D('A')\n        >>> B = A.locate_new('B', 10 * A.i)\n        >>> B.origin.position_wrt(A.origin)\n        10*A.i\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "orient_new",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.orient_new",
    "type": "method",
    "description": "\n        Creates a new CoordSys3D oriented in the user-specified way\n        with respect to this system.\n\n        Please refer to the documentation of the orienter classes\n        for more information about the orientation procedure.\n\n        Parameters\n        ==========\n\n        name : str\n            The name of the new CoordSys3D instance.\n\n        orienters : iterable/Orienter\n            An Orienter or an iterable of Orienters for orienting the\n            new coordinate system.\n            If an Orienter is provided, it is applied to get the new\n            system.\n            If an iterable is provided, the orienters will be applied\n            in the order in which they appear in the iterable.\n\n        location : Vector(optional)\n            The location of the new coordinate system's origin wrt this\n            system's origin. If not specified, the origins are taken to\n            be coincident.\n\n        vector_names, variable_names : iterable(optional)\n            Iterables of 3 strings each, with custom names for base\n            vectors and base scalars of the new system respectively.\n            Used for simple str printing.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n        >>> N = CoordSys3D('N')\n\n        Using an AxisOrienter\n\n        >>> from sympy.vector import AxisOrienter\n        >>> axis_orienter = AxisOrienter(q1, N.i + 2 * N.j)\n        >>> A = N.orient_new('A', (axis_orienter, ))\n\n        Using a BodyOrienter\n\n        >>> from sympy.vector import BodyOrienter\n        >>> body_orienter = BodyOrienter(q1, q2, q3, '123')\n        >>> B = N.orient_new('B', (body_orienter, ))\n\n        Using a SpaceOrienter\n\n        >>> from sympy.vector import SpaceOrienter\n        >>> space_orienter = SpaceOrienter(q1, q2, q3, '312')\n        >>> C = N.orient_new('C', (space_orienter, ))\n\n        Using a QuaternionOrienter\n\n        >>> from sympy.vector import QuaternionOrienter\n        >>> q_orienter = QuaternionOrienter(q0, q1, q2, q3)\n        >>> D = N.orient_new('D', (q_orienter, ))\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "orient_new_axis",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.orient_new_axis",
    "type": "method",
    "description": "\n        Axis rotation is a rotation about an arbitrary axis by\n        some angle. The angle is supplied as a SymPy expr scalar, and\n        the axis is supplied as a Vector.\n\n        Parameters\n        ==========\n\n        name : string\n            The name of the new coordinate system\n\n        angle : Expr\n            The angle by which the new system is to be rotated\n\n        axis : Vector\n            The axis around which the rotation has to be performed\n\n        location : Vector(optional)\n            The location of the new coordinate system's origin wrt this\n            system's origin. If not specified, the origins are taken to\n            be coincident.\n\n        vector_names, variable_names : iterable(optional)\n            Iterables of 3 strings each, with custom names for base\n            vectors and base scalars of the new system respectively.\n            Used for simple str printing.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q1 = symbols('q1')\n        >>> N = CoordSys3D('N')\n        >>> B = N.orient_new_axis('B', q1, N.i + 2 * N.j)\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "orient_new_body",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.orient_new_body",
    "type": "method",
    "description": "\n        Body orientation takes this coordinate system through three\n        successive simple rotations.\n\n        Body fixed rotations include both Euler Angles and\n        Tait-Bryan Angles, see https://en.wikipedia.org/wiki/Euler_angles.\n\n        Parameters\n        ==========\n\n        name : string\n            The name of the new coordinate system\n\n        angle1, angle2, angle3 : Expr\n            Three successive angles to rotate the coordinate system by\n\n        rotation_order : string\n            String defining the order of axes for rotation\n\n        location : Vector(optional)\n            The location of the new coordinate system's origin wrt this\n            system's origin. If not specified, the origins are taken to\n            be coincident.\n\n        vector_names, variable_names : iterable(optional)\n            Iterables of 3 strings each, with custom names for base\n            vectors and base scalars of the new system respectively.\n            Used for simple str printing.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q1, q2, q3 = symbols('q1 q2 q3')\n        >>> N = CoordSys3D('N')\n\n        A 'Body' fixed rotation is described by three angles and\n        three body-fixed rotation axes. To orient a coordinate system D\n        with respect to N, each sequential rotation is always about\n        the orthogonal unit vectors fixed to D. For example, a '123'\n        rotation will specify rotations about N.i, then D.j, then\n        D.k. (Initially, D.i is same as N.i)\n        Therefore,\n\n        >>> D = N.orient_new_body('D', q1, q2, q3, '123')\n\n        is same as\n\n        >>> D = N.orient_new_axis('D', q1, N.i)\n        >>> D = D.orient_new_axis('D', q2, D.j)\n        >>> D = D.orient_new_axis('D', q3, D.k)\n\n        Acceptable rotation orders are of length 3, expressed in XYZ or\n        123, and cannot have a rotation about about an axis twice in a row.\n\n        >>> B = N.orient_new_body('B', q1, q2, q3, '123')\n        >>> B = N.orient_new_body('B', q1, q2, 0, 'ZXZ')\n        >>> B = N.orient_new_body('B', 0, 0, 0, 'XYX')\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "orient_new_quaternion",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.orient_new_quaternion",
    "type": "method",
    "description": "\n        Quaternion orientation orients the new CoordSys3D with\n        Quaternions, defined as a finite rotation about lambda, a unit\n        vector, by some amount theta.\n\n        This orientation is described by four parameters:\n\n        q0 = cos(theta/2)\n\n        q1 = lambda_x sin(theta/2)\n\n        q2 = lambda_y sin(theta/2)\n\n        q3 = lambda_z sin(theta/2)\n\n        Quaternion does not take in a rotation order.\n\n        Parameters\n        ==========\n\n        name : string\n            The name of the new coordinate system\n\n        q0, q1, q2, q3 : Expr\n            The quaternions to rotate the coordinate system by\n\n        location : Vector(optional)\n            The location of the new coordinate system's origin wrt this\n            system's origin. If not specified, the origins are taken to\n            be coincident.\n\n        vector_names, variable_names : iterable(optional)\n            Iterables of 3 strings each, with custom names for base\n            vectors and base scalars of the new system respectively.\n            Used for simple str printing.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n        >>> N = CoordSys3D('N')\n        >>> B = N.orient_new_quaternion('B', q0, q1, q2, q3)\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "orient_new_space",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.orient_new_space",
    "type": "method",
    "description": "\n        Space rotation is similar to Body rotation, but the rotations\n        are applied in the opposite order.\n\n        Parameters\n        ==========\n\n        name : string\n            The name of the new coordinate system\n\n        angle1, angle2, angle3 : Expr\n            Three successive angles to rotate the coordinate system by\n\n        rotation_order : string\n            String defining the order of axes for rotation\n\n        location : Vector(optional)\n            The location of the new coordinate system's origin wrt this\n            system's origin. If not specified, the origins are taken to\n            be coincident.\n\n        vector_names, variable_names : iterable(optional)\n            Iterables of 3 strings each, with custom names for base\n            vectors and base scalars of the new system respectively.\n            Used for simple str printing.\n\n        See Also\n        ========\n\n        CoordSys3D.orient_new_body : method to orient via Euler\n            angles\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q1, q2, q3 = symbols('q1 q2 q3')\n        >>> N = CoordSys3D('N')\n\n        To orient a coordinate system D with respect to N, each\n        sequential rotation is always about N's orthogonal unit vectors.\n        For example, a '123' rotation will specify rotations about\n        N.i, then N.j, then N.k.\n        Therefore,\n\n        >>> D = N.orient_new_space('D', q1, q2, q3, '312')\n\n        is same as\n\n        >>> B = N.orient_new_axis('B', q1, N.i)\n        >>> C = B.orient_new_axis('C', q2, N.j)\n        >>> D = C.orient_new_axis('D', q3, N.k)\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "position_wrt",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.position_wrt",
    "type": "method",
    "description": "\n        Returns the position vector of the origin of this coordinate\n        system with respect to another Point/CoordSys3D.\n\n        Parameters\n        ==========\n\n        other : Point/CoordSys3D\n            If other is a Point, the position of this system's origin\n            wrt it is returned. If its an instance of CoordSyRect,\n            the position wrt its origin is returned.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> N = CoordSys3D('N')\n        >>> N1 = N.locate_new('N1', 10 * N.i)\n        >>> N.position_wrt(N1)\n        (-10)*N.i\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "rotation_matrix",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.rotation_matrix",
    "type": "method",
    "description": "\n        Returns the direction cosine matrix(DCM), also known as the\n        'rotation matrix' of this coordinate system with respect to\n        another system.\n\n        If v_a is a vector defined in system 'A' (in matrix format)\n        and v_b is the same vector defined in system 'B', then\n        v_a = A.rotation_matrix(B) * v_b.\n\n        A SymPy Matrix is returned.\n\n        Parameters\n        ==========\n\n        other : CoordSys3D\n            The system which the DCM is generated to.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q1 = symbols('q1')\n        >>> N = CoordSys3D('N')\n        >>> A = N.orient_new_axis('A', q1, N.i)\n        >>> N.rotation_matrix(A)\n        Matrix([\n        [1,       0,        0],\n        [0, cos(q1), -sin(q1)],\n        [0, sin(q1),  cos(q1)]])\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "scalar_map",
    "full_id": "sympy.vector.coordsysrect.CoordSys3D.scalar_map",
    "type": "method",
    "description": "\n        Returns a dictionary which expresses the coordinate variables\n        (base scalars) of this frame in terms of the variables of\n        otherframe.\n\n        Parameters\n        ==========\n\n        otherframe : CoordSys3D\n            The other system to map the variables to.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import Symbol\n        >>> A = CoordSys3D('A')\n        >>> q = Symbol('q')\n        >>> B = A.orient_new_axis('B', q, A.k)\n        >>> A.scalar_map(B)\n        {A.x: B.x*cos(q) - B.y*sin(q), A.y: B.x*sin(q) + B.y*cos(q), A.z: B.z}\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "components",
    "full_id": "sympy.vector.vector.Vector.components",
    "type": "property",
    "description": "\n        Returns the components of this vector in the form of a\n        Python dictionary mapping BaseVector instances to the\n        corresponding measure numbers.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> C = CoordSys3D('C')\n        >>> v = 3*C.i + 4*C.j + 5*C.k\n        >>> v.components\n        {C.i: 3, C.j: 4, C.k: 5}\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "cross",
    "full_id": "sympy.vector.vector.Vector.cross",
    "type": "method",
    "description": "\n        Returns the cross product of this Vector with another Vector or\n        Dyadic instance.\n        The cross product is a Vector, if 'other' is a Vector. If 'other'\n        is a Dyadic, this returns a Dyadic instance.\n\n        Parameters\n        ==========\n\n        other: Vector/Dyadic\n            The Vector or Dyadic we are crossing with.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> C = CoordSys3D('C')\n        >>> C.i.cross(C.j)\n        C.k\n        >>> C.i ^ C.i\n        0\n        >>> v = 3*C.i + 4*C.j + 5*C.k\n        >>> v ^ C.i\n        5*C.j + (-4)*C.k\n        >>> d = C.i.outer(C.i)\n        >>> C.j.cross(d)\n        (-1)*(C.k|C.i)\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "dot",
    "full_id": "sympy.vector.vector.Vector.dot",
    "type": "method",
    "description": "\n        Returns the dot product of this Vector, either with another\n        Vector, or a Dyadic, or a Del operator.\n        If 'other' is a Vector, returns the dot product scalar (SymPy\n        expression).\n        If 'other' is a Dyadic, the dot product is returned as a Vector.\n        If 'other' is an instance of Del, returns the directional\n        derivative operator as a Python function. If this function is\n        applied to a scalar expression, it returns the directional\n        derivative of the scalar field wrt this Vector.\n\n        Parameters\n        ==========\n\n        other: Vector/Dyadic/Del\n            The Vector or Dyadic we are dotting with, or a Del operator .\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D, Del\n        >>> C = CoordSys3D('C')\n        >>> delop = Del()\n        >>> C.i.dot(C.j)\n        0\n        >>> C.i & C.i\n        1\n        >>> v = 3*C.i + 4*C.j + 5*C.k\n        >>> v.dot(C.k)\n        5\n        >>> (C.i & delop)(C.x*C.y*C.z)\n        C.y*C.z\n        >>> d = C.i.outer(C.i)\n        >>> C.i.dot(d)\n        C.i\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "magnitude",
    "full_id": "sympy.vector.vector.Vector.magnitude",
    "type": "method",
    "description": "\n        Returns the magnitude of this vector.\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "normalize",
    "full_id": "sympy.vector.vector.Vector.normalize",
    "type": "method",
    "description": "\n        Returns the normalized version of this vector.\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "outer",
    "full_id": "sympy.vector.vector.Vector.outer",
    "type": "method",
    "description": "\n        Returns the outer product of this vector with another, in the\n        form of a Dyadic instance.\n\n        Parameters\n        ==========\n\n        other : Vector\n            The Vector with respect to which the outer product is to\n            be computed.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> N = CoordSys3D('N')\n        >>> N.i.outer(N.j)\n        (N.i|N.j)\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "projection",
    "full_id": "sympy.vector.vector.Vector.projection",
    "type": "method",
    "description": "\n        Returns the vector or scalar projection of the 'other' on 'self'.\n\n        Examples\n        ========\n\n        >>> from sympy.vector.coordsysrect import CoordSys3D\n        >>> C = CoordSys3D('C')\n        >>> i, j, k = C.base_vectors()\n        >>> v1 = i + j + k\n        >>> v2 = 3*i + 4*j\n        >>> v1.projection(v2)\n        7/3*C.i + 7/3*C.j + 7/3*C.k\n        >>> v1.projection(v2, scalar=True)\n        7/3\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "separate",
    "full_id": "sympy.vector.vector.Vector.separate",
    "type": "method",
    "description": "\n        The constituents of this vector in different coordinate systems,\n        as per its definition.\n\n        Returns a dict mapping each CoordSys3D to the corresponding\n        constituent Vector.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> R1 = CoordSys3D('R1')\n        >>> R2 = CoordSys3D('R2')\n        >>> v = R1.i + R2.i\n        >>> v.separate() == {R1: R1.i, R2: R2.i}\n        True\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "to_matrix",
    "full_id": "sympy.vector.vector.Vector.to_matrix",
    "type": "method",
    "description": "\n        Returns the matrix form of this vector with respect to the\n        specified coordinate system.\n\n        Parameters\n        ==========\n\n        system : CoordSys3D\n            The system wrt which the matrix form is to be computed\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> C = CoordSys3D('C')\n        >>> from sympy.abc import a, b, c\n        >>> v = a*C.i + b*C.j + c*C.k\n        >>> v.to_matrix(C)\n        Matrix([\n        [a],\n        [b],\n        [c]])\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "components",
    "full_id": "sympy.vector.dyadic.Dyadic.components",
    "type": "property",
    "description": "\n        Returns the components of this dyadic in the form of a\n        Python dictionary mapping BaseDyadic instances to the\n        corresponding measure numbers.\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "cross",
    "full_id": "sympy.vector.dyadic.Dyadic.cross",
    "type": "method",
    "description": "\n        Returns the cross product between this Dyadic, and a Vector, as a\n        Vector instance.\n\n        Parameters\n        ==========\n\n        other : Vector\n            The Vector that we are crossing this Dyadic with\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> N = CoordSys3D('N')\n        >>> d = N.i.outer(N.i)\n        >>> d.cross(N.j)\n        (N.i|N.k)\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "dot",
    "full_id": "sympy.vector.dyadic.Dyadic.dot",
    "type": "method",
    "description": "\n        Returns the dot product(also called inner product) of this\n        Dyadic, with another Dyadic or Vector.\n        If 'other' is a Dyadic, this returns a Dyadic. Else, it returns\n        a Vector (unless an error is encountered).\n\n        Parameters\n        ==========\n\n        other : Dyadic/Vector\n            The other Dyadic or Vector to take the inner product with\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> N = CoordSys3D('N')\n        >>> D1 = N.i.outer(N.j)\n        >>> D2 = N.j.outer(N.j)\n        >>> D1.dot(D2)\n        (N.i|N.j)\n        >>> D1.dot(N.j)\n        N.i\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "to_matrix",
    "full_id": "sympy.vector.dyadic.Dyadic.to_matrix",
    "type": "method",
    "description": "\n        Returns the matrix form of the dyadic with respect to one or two\n        coordinate systems.\n\n        Parameters\n        ==========\n\n        system : CoordSys3D\n            The coordinate system that the rows and columns of the matrix\n            correspond to. If a second system is provided, this\n            only corresponds to the rows of the matrix.\n        second_system : CoordSys3D, optional, default=None\n            The coordinate system that the columns of the matrix correspond\n            to.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> N = CoordSys3D('N')\n        >>> v = N.i + 2*N.j\n        >>> d = v.outer(N.i)\n        >>> d.to_matrix(N)\n        Matrix([\n        [1, 0, 0],\n        [2, 0, 0],\n        [0, 0, 0]])\n        >>> from sympy import Symbol\n        >>> q = Symbol('q')\n        >>> P = N.orient_new_axis('P', q, N.k)\n        >>> d.to_matrix(N, P)\n        Matrix([\n        [  cos(q),   -sin(q), 0],\n        [2*cos(q), -2*sin(q), 0],\n        [       0,         0, 0]])\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "cross",
    "full_id": "sympy.vector.deloperator.Del.cross",
    "type": "method",
    "description": "\n        Represents the cross product between this operator and a given\n        vector - equal to the curl of the vector field.\n\n        Parameters\n        ==========\n\n        vect : Vector\n            The vector whose curl is to be calculated.\n\n        doit : bool\n            If True, the result is returned after calling .doit() on\n            each component. Else, the returned expression contains\n            Derivative instances\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D, Del\n        >>> C = CoordSys3D('C')\n        >>> delop = Del()\n        >>> v = C.x*C.y*C.z * (C.i + C.j + C.k)\n        >>> delop.cross(v, doit = True)\n        (-C.x*C.y + C.x*C.z)*C.i + (C.x*C.y - C.y*C.z)*C.j +\n            (-C.x*C.z + C.y*C.z)*C.k\n        >>> (delop ^ C.i).doit()\n        0\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "dot",
    "full_id": "sympy.vector.deloperator.Del.dot",
    "type": "method",
    "description": "\n        Represents the dot product between this operator and a given\n        vector - equal to the divergence of the vector field.\n\n        Parameters\n        ==========\n\n        vect : Vector\n            The vector whose divergence is to be calculated.\n\n        doit : bool\n            If True, the result is returned after calling .doit() on\n            each component. Else, the returned expression contains\n            Derivative instances\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D, Del\n        >>> delop = Del()\n        >>> C = CoordSys3D('C')\n        >>> delop.dot(C.x*C.i)\n        Derivative(C.x, C.x)\n        >>> v = C.x*C.y*C.z * (C.i + C.j + C.k)\n        >>> (delop & v).doit()\n        C.x*C.y + C.x*C.z + C.y*C.z\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "gradient",
    "full_id": "sympy.vector.deloperator.Del.gradient",
    "type": "method",
    "description": "\n        Returns the gradient of the given scalar field, as a\n        Vector instance.\n\n        Parameters\n        ==========\n\n        scalar_field : SymPy expression\n            The scalar field to calculate the gradient of.\n\n        doit : bool\n            If True, the result is returned after calling .doit() on\n            each component. Else, the returned expression contains\n            Derivative instances\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D, Del\n        >>> C = CoordSys3D('C')\n        >>> delop = Del()\n        >>> delop.gradient(9)\n        0\n        >>> delop(C.x*C.y*C.z).doit()\n        C.y*C.z*C.i + C.x*C.z*C.j + C.x*C.y*C.k\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "multiplicity",
    "full_id": "sympy.vector.implicitregion.ImplicitRegion.multiplicity",
    "type": "method",
    "description": "\n        Returns the multiplicity of a singular point on the region.\n\n        A singular point (x,y) of region is said to be of multiplicity m\n        if all the partial derivatives off to order m - 1 vanish there.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y, z\n        >>> from sympy.vector import ImplicitRegion\n        >>> I = ImplicitRegion((x, y, z), x**2 + y**3 - z**4)\n        >>> I.singular_points()\n        {(0, 0, 0)}\n        >>> I.multiplicity((0, 0, 0))\n        2\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "rational_parametrization",
    "full_id": "sympy.vector.implicitregion.ImplicitRegion.rational_parametrization",
    "type": "method",
    "description": "\n        Returns the rational parametrization of implicit region.\n\n        Examples\n        ========\n\n        >>> from sympy import Eq\n        >>> from sympy.abc import x, y, z, s, t\n        >>> from sympy.vector import ImplicitRegion\n\n        >>> parabola = ImplicitRegion((x, y), y**2 - 4*x)\n        >>> parabola.rational_parametrization()\n        (4/t**2, 4/t)\n\n        >>> circle = ImplicitRegion((x, y), Eq(x**2 + y**2, 4))\n        >>> circle.rational_parametrization()\n        (4*t/(t**2 + 1), 4*t**2/(t**2 + 1) - 2)\n\n        >>> I = ImplicitRegion((x, y), x**3 + x**2 - y**2)\n        >>> I.rational_parametrization()\n        (t**2 - 1, t*(t**2 - 1))\n\n        >>> cubic_curve = ImplicitRegion((x, y), x**3 + x**2 - y**2)\n        >>> cubic_curve.rational_parametrization(parameters=(t))\n        (t**2 - 1, t*(t**2 - 1))\n\n        >>> sphere = ImplicitRegion((x, y, z), x**2 + y**2 + z**2 - 4)\n        >>> sphere.rational_parametrization(parameters=(t, s))\n        (-2 + 4/(s**2 + t**2 + 1), 4*s/(s**2 + t**2 + 1), 4*t/(s**2 + t**2 + 1))\n\n        For some conics, regular_points() is unable to find a point on curve.\n        To calulcate the parametric representation in such cases, user need\n        to determine a point on the region and pass it using reg_point.\n\n        >>> c = ImplicitRegion((x, y), (x  - 1/2)**2 + (y)**2 - (1/4)**2)\n        >>> c.rational_parametrization(reg_point=(3/4, 0))\n        (0.75 - 0.5/(t**2 + 1), -0.5*t/(t**2 + 1))\n\n        References\n        ==========\n\n        - Christoph M. Hoffmann, \"Conversion Methods between Parametric and\n          Implicit Curves and Surfaces\", Purdue e-Pubs, 1990. Available:\n          https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1827&context=cstech\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "regular_point",
    "full_id": "sympy.vector.implicitregion.ImplicitRegion.regular_point",
    "type": "method",
    "description": "\n        Returns a point on the implicit region.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y, z\n        >>> from sympy.vector import ImplicitRegion\n        >>> circle = ImplicitRegion((x, y), (x + 2)**2 + (y - 3)**2 - 16)\n        >>> circle.regular_point()\n        (-2, -1)\n        >>> parabola = ImplicitRegion((x, y), x**2 - 4*y)\n        >>> parabola.regular_point()\n        (0, 0)\n        >>> r = ImplicitRegion((x, y, z), (x + y + z)**4)\n        >>> r.regular_point()\n        (-10, -10, 20)\n\n        References\n        ==========\n\n        - Erik Hillgarter, \"Rational Points on Conics\", Diploma Thesis, RISC-Linz,\n          J. Kepler Universitat Linz, 1996. Available:\n          https://www3.risc.jku.at/publications/download/risc_1355/Rational%20Points%20on%20Conics.pdf\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "singular_points",
    "full_id": "sympy.vector.implicitregion.ImplicitRegion.singular_points",
    "type": "method",
    "description": "\n        Returns a set of singular points of the region.\n\n        The singular points are those points on the region\n        where all partial derivatives vanish.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy.vector import ImplicitRegion\n        >>> I = ImplicitRegion((x, y), (y-1)**2 -x**3 + 2*x**2 -x)\n        >>> I.singular_points()\n        {(1, 1)}\n\n        ",
    "section": "Essential Classes in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/classes.html"
  },
  {
    "name": "rotation_matrix",
    "full_id": "sympy.vector.orienters.Orienter.rotation_matrix",
    "type": "method",
    "description": "\n        The rotation matrix corresponding to this orienter\n        instance.\n        ",
    "section": "Orienter classes (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/orienterclasses.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.vector.orienters.AxisOrienter.__init__",
    "type": "method",
    "description": "\n        Axis rotation is a rotation about an arbitrary axis by\n        some angle. The angle is supplied as a SymPy expr scalar, and\n        the axis is supplied as a Vector.\n\n        Parameters\n        ==========\n\n        angle : Expr\n            The angle by which the new system is to be rotated\n\n        axis : Vector\n            The axis around which the rotation has to be performed\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q1 = symbols('q1')\n        >>> N = CoordSys3D('N')\n        >>> from sympy.vector import AxisOrienter\n        >>> orienter = AxisOrienter(q1, N.i + 2 * N.j)\n        >>> B = N.orient_new('B', (orienter, ))\n\n        ",
    "section": "Orienter classes (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/orienterclasses.html"
  },
  {
    "name": "rotation_matrix",
    "full_id": "sympy.vector.orienters.AxisOrienter.rotation_matrix",
    "type": "method",
    "description": "\n        The rotation matrix corresponding to this orienter\n        instance.\n\n        Parameters\n        ==========\n\n        system : CoordSys3D\n            The coordinate system wrt which the rotation matrix\n            is to be computed\n        ",
    "section": "Orienter classes (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/orienterclasses.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.vector.orienters.BodyOrienter.__init__",
    "type": "method",
    "description": "\n        Body orientation takes this coordinate system through three\n        successive simple rotations.\n\n        Body fixed rotations include both Euler Angles and\n        Tait-Bryan Angles, see https://en.wikipedia.org/wiki/Euler_angles.\n\n        Parameters\n        ==========\n\n        angle1, angle2, angle3 : Expr\n            Three successive angles to rotate the coordinate system by\n\n        rotation_order : string\n            String defining the order of axes for rotation\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D, BodyOrienter\n        >>> from sympy import symbols\n        >>> q1, q2, q3 = symbols('q1 q2 q3')\n        >>> N = CoordSys3D('N')\n\n        A 'Body' fixed rotation is described by three angles and\n        three body-fixed rotation axes. To orient a coordinate system D\n        with respect to N, each sequential rotation is always about\n        the orthogonal unit vectors fixed to D. For example, a '123'\n        rotation will specify rotations about N.i, then D.j, then\n        D.k. (Initially, D.i is same as N.i)\n        Therefore,\n\n        >>> body_orienter = BodyOrienter(q1, q2, q3, '123')\n        >>> D = N.orient_new('D', (body_orienter, ))\n\n        is same as\n\n        >>> from sympy.vector import AxisOrienter\n        >>> axis_orienter1 = AxisOrienter(q1, N.i)\n        >>> D = N.orient_new('D', (axis_orienter1, ))\n        >>> axis_orienter2 = AxisOrienter(q2, D.j)\n        >>> D = D.orient_new('D', (axis_orienter2, ))\n        >>> axis_orienter3 = AxisOrienter(q3, D.k)\n        >>> D = D.orient_new('D', (axis_orienter3, ))\n\n        Acceptable rotation orders are of length 3, expressed in XYZ or\n        123, and cannot have a rotation about about an axis twice in a row.\n\n        >>> body_orienter1 = BodyOrienter(q1, q2, q3, '123')\n        >>> body_orienter2 = BodyOrienter(q1, q2, 0, 'ZXZ')\n        >>> body_orienter3 = BodyOrienter(0, 0, 0, 'XYX')\n\n        ",
    "section": "Orienter classes (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/orienterclasses.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.vector.orienters.SpaceOrienter.__init__",
    "type": "method",
    "description": "\n        Space rotation is similar to Body rotation, but the rotations\n        are applied in the opposite order.\n\n        Parameters\n        ==========\n\n        angle1, angle2, angle3 : Expr\n            Three successive angles to rotate the coordinate system by\n\n        rotation_order : string\n            String defining the order of axes for rotation\n\n        See Also\n        ========\n\n        BodyOrienter : Orienter to orient systems wrt Euler angles.\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D, SpaceOrienter\n        >>> from sympy import symbols\n        >>> q1, q2, q3 = symbols('q1 q2 q3')\n        >>> N = CoordSys3D('N')\n\n        To orient a coordinate system D with respect to N, each\n        sequential rotation is always about N's orthogonal unit vectors.\n        For example, a '123' rotation will specify rotations about\n        N.i, then N.j, then N.k.\n        Therefore,\n\n        >>> space_orienter = SpaceOrienter(q1, q2, q3, '312')\n        >>> D = N.orient_new('D', (space_orienter, ))\n\n        is same as\n\n        >>> from sympy.vector import AxisOrienter\n        >>> axis_orienter1 = AxisOrienter(q1, N.i)\n        >>> B = N.orient_new('B', (axis_orienter1, ))\n        >>> axis_orienter2 = AxisOrienter(q2, N.j)\n        >>> C = B.orient_new('C', (axis_orienter2, ))\n        >>> axis_orienter3 = AxisOrienter(q3, N.k)\n        >>> D = C.orient_new('C', (axis_orienter3, ))\n\n        ",
    "section": "Orienter classes (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/orienterclasses.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.vector.orienters.QuaternionOrienter.__init__",
    "type": "method",
    "description": "\n        Quaternion orientation orients the new CoordSys3D with\n        Quaternions, defined as a finite rotation about lambda, a unit\n        vector, by some amount theta.\n\n        This orientation is described by four parameters:\n\n        q0 = cos(theta/2)\n\n        q1 = lambda_x sin(theta/2)\n\n        q2 = lambda_y sin(theta/2)\n\n        q3 = lambda_z sin(theta/2)\n\n        Quaternion does not take in a rotation order.\n\n        Parameters\n        ==========\n\n        q0, q1, q2, q3 : Expr\n            The quaternions to rotate the coordinate system by\n\n        Examples\n        ========\n\n        >>> from sympy.vector import CoordSys3D\n        >>> from sympy import symbols\n        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n        >>> N = CoordSys3D('N')\n        >>> from sympy.vector import QuaternionOrienter\n        >>> q_orienter = QuaternionOrienter(q0, q1, q2, q3)\n        >>> B = N.orient_new('B', (q_orienter, ))\n\n        ",
    "section": "Orienter classes (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/orienterclasses.html"
  },
  {
    "name": "matrix_to_vector",
    "full_id": "sympy.vector.matrix_to_vector",
    "type": "function",
    "description": "\n    Converts a vector in matrix form to a Vector instance.\n\n    It is assumed that the elements of the Matrix represent the\n    measure numbers of the components of the vector along basis\n    vectors of 'system'.\n\n    Parameters\n    ==========\n\n    matrix : SymPy Matrix, Dimensions: (3, 1)\n        The matrix to be converted to a vector\n\n    system : CoordSys3D\n        The coordinate system the vector is to be defined in\n\n    Examples\n    ========\n\n    >>> from sympy import ImmutableMatrix as Matrix\n    >>> m = Matrix([1, 2, 3])\n    >>> from sympy.vector import CoordSys3D, matrix_to_vector\n    >>> C = CoordSys3D('C')\n    >>> v = matrix_to_vector(m, C)\n    >>> v\n    C.i + 2*C.j + 3*C.k\n    >>> v.to_matrix(C) == m\n    True\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "express",
    "full_id": "sympy.vector.express",
    "type": "function",
    "description": "\n    Global function for 'express' functionality.\n\n    Re-expresses a Vector, Dyadic or scalar(sympyfiable) in the given\n    coordinate system.\n\n    If 'variables' is True, then the coordinate variables (base scalars)\n    of other coordinate systems present in the vector/scalar field or\n    dyadic are also substituted in terms of the base scalars of the\n    given system.\n\n    Parameters\n    ==========\n\n    expr : Vector/Dyadic/scalar(sympyfiable)\n        The expression to re-express in CoordSys3D 'system'\n\n    system: CoordSys3D\n        The coordinate system the expr is to be expressed in\n\n    system2: CoordSys3D\n        The other coordinate system required for re-expression\n        (only for a Dyadic Expr)\n\n    variables : boolean\n        Specifies whether to substitute the coordinate variables present\n        in expr, in terms of those of parameter system\n\n    Examples\n    ========\n\n    >>> from sympy.vector import CoordSys3D\n    >>> from sympy import Symbol, cos, sin\n    >>> N = CoordSys3D('N')\n    >>> q = Symbol('q')\n    >>> B = N.orient_new_axis('B', q, N.k)\n    >>> from sympy.vector import express\n    >>> express(B.i, N)\n    (cos(q))*N.i + (sin(q))*N.j\n    >>> express(N.x, B, variables=True)\n    B.x*cos(q) - B.y*sin(q)\n    >>> d = N.i.outer(N.i)\n    >>> express(d, B, N) == (cos(q))*(B.i|N.i) + (-sin(q))*(B.j|N.i)\n    True\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "curl",
    "full_id": "sympy.vector.curl",
    "type": "function",
    "description": "\n    Returns the curl of a vector field computed wrt the base scalars\n    of the given coordinate system.\n\n    Parameters\n    ==========\n\n    vect : Vector\n        The vector operand\n\n    doit : bool\n        If True, the result is returned after calling .doit() on\n        each component. Else, the returned expression contains\n        Derivative instances\n\n    Examples\n    ========\n\n    >>> from sympy.vector import CoordSys3D, curl\n    >>> R = CoordSys3D('R')\n    >>> v1 = R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k\n    >>> curl(v1)\n    0\n    >>> v2 = R.x*R.y*R.z*R.i\n    >>> curl(v2)\n    R.x*R.y*R.j + (-R.x*R.z)*R.k\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "divergence",
    "full_id": "sympy.vector.divergence",
    "type": "function",
    "description": "\n    Returns the divergence of a vector field computed wrt the base\n    scalars of the given coordinate system.\n\n    Parameters\n    ==========\n\n    vector : Vector\n        The vector operand\n\n    doit : bool\n        If True, the result is returned after calling .doit() on\n        each component. Else, the returned expression contains\n        Derivative instances\n\n    Examples\n    ========\n\n    >>> from sympy.vector import CoordSys3D, divergence\n    >>> R = CoordSys3D('R')\n    >>> v1 = R.x*R.y*R.z * (R.i+R.j+R.k)\n\n    >>> divergence(v1)\n    R.x*R.y + R.x*R.z + R.y*R.z\n    >>> v2 = 2*R.y*R.z*R.j\n    >>> divergence(v2)\n    2*R.z\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "gradient",
    "full_id": "sympy.vector.gradient",
    "type": "function",
    "description": "\n    Returns the vector gradient of a scalar field computed wrt the\n    base scalars of the given coordinate system.\n\n    Parameters\n    ==========\n\n    scalar_field : SymPy Expr\n        The scalar field to compute the gradient of\n\n    doit : bool\n        If True, the result is returned after calling .doit() on\n        each component. Else, the returned expression contains\n        Derivative instances\n\n    Examples\n    ========\n\n    >>> from sympy.vector import CoordSys3D, gradient\n    >>> R = CoordSys3D('R')\n    >>> s1 = R.x*R.y*R.z\n    >>> gradient(s1)\n    R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k\n    >>> s2 = 5*R.x**2*R.z\n    >>> gradient(s2)\n    10*R.x*R.z*R.i + 5*R.x**2*R.k\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "is_conservative",
    "full_id": "sympy.vector.is_conservative",
    "type": "function",
    "description": "\n    Checks if a field is conservative.\n\n    Parameters\n    ==========\n\n    field : Vector\n        The field to check for conservative property\n\n    Examples\n    ========\n\n    >>> from sympy.vector import CoordSys3D\n    >>> from sympy.vector import is_conservative\n    >>> R = CoordSys3D('R')\n    >>> is_conservative(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)\n    True\n    >>> is_conservative(R.z*R.j)\n    False\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "is_solenoidal",
    "full_id": "sympy.vector.is_solenoidal",
    "type": "function",
    "description": "\n    Checks if a field is solenoidal.\n\n    Parameters\n    ==========\n\n    field : Vector\n        The field to check for solenoidal property\n\n    Examples\n    ========\n\n    >>> from sympy.vector import CoordSys3D\n    >>> from sympy.vector import is_solenoidal\n    >>> R = CoordSys3D('R')\n    >>> is_solenoidal(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)\n    True\n    >>> is_solenoidal(R.y * R.j)\n    False\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "scalar_potential",
    "full_id": "sympy.vector.scalar_potential",
    "type": "function",
    "description": "\n    Returns the scalar potential function of a field in a given\n    coordinate system (without the added integration constant).\n\n    Parameters\n    ==========\n\n    field : Vector\n        The vector field whose scalar potential function is to be\n        calculated\n\n    coord_sys : CoordSys3D\n        The coordinate system to do the calculation in\n\n    Examples\n    ========\n\n    >>> from sympy.vector import CoordSys3D\n    >>> from sympy.vector import scalar_potential, gradient\n    >>> R = CoordSys3D('R')\n    >>> scalar_potential(R.k, R) == R.z\n    True\n    >>> scalar_field = 2*R.x**2*R.y*R.z\n    >>> grad_field = gradient(scalar_field)\n    >>> scalar_potential(grad_field, R)\n    2*R.x**2*R.y*R.z\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "scalar_potential_difference",
    "full_id": "sympy.vector.scalar_potential_difference",
    "type": "function",
    "description": "\n    Returns the scalar potential difference between two points in a\n    certain coordinate system, wrt a given field.\n\n    If a scalar field is provided, its values at the two points are\n    considered. If a conservative vector field is provided, the values\n    of its scalar potential function at the two points are used.\n\n    Returns (potential at point2) - (potential at point1)\n\n    The position vectors of the two Points are calculated wrt the\n    origin of the coordinate system provided.\n\n    Parameters\n    ==========\n\n    field : Vector/Expr\n        The field to calculate wrt\n\n    coord_sys : CoordSys3D\n        The coordinate system to do the calculations in\n\n    point1 : Point\n        The initial Point in given coordinate system\n\n    position2 : Point\n        The second Point in the given coordinate system\n\n    Examples\n    ========\n\n    >>> from sympy.vector import CoordSys3D\n    >>> from sympy.vector import scalar_potential_difference\n    >>> R = CoordSys3D('R')\n    >>> P = R.origin.locate_new('P', R.x*R.i + R.y*R.j + R.z*R.k)\n    >>> vectfield = 4*R.x*R.y*R.i + 2*R.x**2*R.j\n    >>> scalar_potential_difference(vectfield, R, R.origin, P)\n    2*R.x**2*R.y\n    >>> Q = R.origin.locate_new('O', 3*R.i + R.j + 2*R.k)\n    >>> scalar_potential_difference(vectfield, R, P, Q)\n    -2*R.x**2*R.y + 18\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "vector_integrate",
    "full_id": "sympy.vector.integrals.vector_integrate",
    "type": "function",
    "description": "\n    Compute the integral of a vector/scalar field\n    over a a region or a set of parameters.\n\n    Examples\n    ========\n    >>> from sympy.vector import CoordSys3D, ParametricRegion, vector_integrate\n    >>> from sympy.abc import x, y, t\n    >>> C = CoordSys3D('C')\n\n    >>> region = ParametricRegion((t, t**2), (t, 1, 5))\n    >>> vector_integrate(C.x*C.i, region)\n    12\n\n    Integrals over some objects of geometry module can also be calculated.\n\n    >>> from sympy.geometry import Point, Circle, Triangle\n    >>> c = Circle(Point(0, 2), 5)\n    >>> vector_integrate(C.x**2 + C.y**2, c)\n    290*pi\n    >>> triangle = Triangle(Point(-2, 3), Point(2, 3), Point(0, 5))\n    >>> vector_integrate(3*C.x**2*C.y*C.i + C.j, triangle)\n    -8\n\n    Integrals over some simple implicit regions can be computed. But in most cases,\n    it takes too long to compute over them. This is due to the expressions of parametric\n    representation becoming large.\n\n    >>> from sympy.vector import ImplicitRegion\n    >>> c2 = ImplicitRegion((x, y), (x - 2)**2 + (y - 1)**2 - 9)\n    >>> vector_integrate(1, c2)\n    6*pi\n\n    Integral of fields with respect to base scalars:\n\n    >>> vector_integrate(12*C.y**3, (C.y, 1, 3))\n    240\n    >>> vector_integrate(C.x**2*C.z, C.x)\n    C.x**3*C.z/3\n    >>> vector_integrate(C.x*C.i - C.y*C.k, C.x)\n    (Integral(C.x, C.x))*C.i + (Integral(-C.y, C.x))*C.k\n    >>> _.doit()\n    C.x**2/2*C.i + (-C.x*C.y)*C.k\n\n    ",
    "section": "Essential Functions in sympy.vector (docstrings)",
    "url": "https://docs.sympy.org/latest/modules/vector/api/vectorfunctions.html"
  },
  {
    "name": "extend",
    "full_id": "sympy.ntheory.generate.Sieve.extend",
    "type": "method",
    "description": "Grow the sieve to cover all primes <= n.\n\n        Examples\n        ========\n\n        >>> from sympy import sieve\n        >>> sieve._reset() # this line for doctest only\n        >>> sieve.extend(30)\n        >>> sieve[10] == 29\n        True\n        ",
    "section": "Ntheory Class Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "extend_to_no",
    "full_id": "sympy.ntheory.generate.Sieve.extend_to_no",
    "type": "method",
    "description": "Extend to include the ith prime number.\n\n        Parameters\n        ==========\n\n        i : integer\n\n        Examples\n        ========\n\n        >>> from sympy import sieve\n        >>> sieve._reset() # this line for doctest only\n        >>> sieve.extend_to_no(9)\n        >>> sieve._list\n        array('L', [2, 3, 5, 7, 11, 13, 17, 19, 23])\n\n        Notes\n        =====\n\n        The list is extended by 50% if it is too short, so it is\n        likely that it will be longer than requested.\n        ",
    "section": "Ntheory Class Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "mobiusrange",
    "full_id": "sympy.ntheory.generate.Sieve.mobiusrange",
    "type": "method",
    "description": "Generate all mobius numbers for the range [a, b).\n\n        Parameters\n        ==========\n\n        a : integer\n            First number in range\n\n        b : integer\n            First number outside of range\n\n        Examples\n        ========\n\n        >>> from sympy import sieve\n        >>> print([i for i in sieve.mobiusrange(7, 18)])\n        [-1, 0, 0, 1, -1, 0, -1, 1, 1, 0, -1]\n        ",
    "section": "Ntheory Class Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "primerange",
    "full_id": "sympy.ntheory.generate.Sieve.primerange",
    "type": "method",
    "description": "Generate all prime numbers in the range [2, a) or [a, b).\n\n        Examples\n        ========\n\n        >>> from sympy import sieve, prime\n\n        All primes less than 19:\n\n        >>> print([i for i in sieve.primerange(19)])\n        [2, 3, 5, 7, 11, 13, 17]\n\n        All primes greater than or equal to 7 and less than 19:\n\n        >>> print([i for i in sieve.primerange(7, 19)])\n        [7, 11, 13, 17]\n\n        All primes through the 10th prime\n\n        >>> list(sieve.primerange(prime(10) + 1))\n        [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n        ",
    "section": "Ntheory Class Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "search",
    "full_id": "sympy.ntheory.generate.Sieve.search",
    "type": "method",
    "description": "Return the indices i, j of the primes that bound n.\n\n        If n is prime then i == j.\n\n        Although n can be an expression, if ceiling cannot convert\n        it to an integer then an n error will be raised.\n\n        Examples\n        ========\n\n        >>> from sympy import sieve\n        >>> sieve.search(25)\n        (9, 10)\n        >>> sieve.search(23)\n        (9, 9)\n        ",
    "section": "Ntheory Class Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "totientrange",
    "full_id": "sympy.ntheory.generate.Sieve.totientrange",
    "type": "method",
    "description": "Generate all totient numbers for the range [a, b).\n\n        Examples\n        ========\n\n        >>> from sympy import sieve\n        >>> print([i for i in sieve.totientrange(7, 18)])\n        [6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16]\n        ",
    "section": "Ntheory Class Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "prime",
    "full_id": "sympy.ntheory.generate.prime",
    "type": "function",
    "description": "Return the nth prime, with the primes indexed as prime(1) = 2,\n    prime(2) = 3, etc.... The nth prime is approximately $n\\log(n)$.\n\n    Logarithmic integral of $x$ is a pretty nice approximation for number of\n    primes $\\le x$, i.e.\n    li(x) ~ pi(x)\n    In fact, for the numbers we are concerned about( x<1e11 ),\n    li(x) - pi(x) < 50000\n\n    Also,\n    li(x) > pi(x) can be safely assumed for the numbers which\n    can be evaluated by this function.\n\n    Here, we find the least integer m such that li(m) > n using binary search.\n    Now pi(m-1) < li(m-1) <= n,\n\n    We find pi(m - 1) using primepi function.\n\n    Starting from m, we have to find n - pi(m-1) more primes.\n\n    For the inputs this implementation can handle, we will have to test\n    primality for at max about 10**5 numbers, to get our answer.\n\n    Examples\n    ========\n\n    >>> from sympy import prime\n    >>> prime(10)\n    29\n    >>> prime(1)\n    2\n    >>> prime(100000)\n    1299709\n\n    See Also\n    ========\n\n    sympy.ntheory.primetest.isprime : Test if n is prime\n    primerange : Generate all primes in a given range\n    primepi : Return the number of primes less than or equal to n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29\n    .. [2] https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number\n    .. [3] https://en.wikipedia.org/wiki/Skewes%27_number\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "primepi",
    "full_id": "sympy.ntheory.generate.primepi",
    "type": "function",
    "description": "Represents the prime counting function pi(n) = the number\n    of prime numbers less than or equal to n.\n\n    .. deprecated:: 1.13\n\n        The ``primepi`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.primepi`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    Algorithm Description:\n\n    In sieve method, we remove all multiples of prime p\n    except p itself.\n\n    Let phi(i,j) be the number of integers 2 <= k <= i\n    which remain after sieving from primes less than\n    or equal to j.\n    Clearly, pi(n) = phi(n, sqrt(n))\n\n    If j is not a prime,\n    phi(i,j) = phi(i, j - 1)\n\n    if j is a prime,\n    We remove all numbers(except j) whose\n    smallest prime factor is j.\n\n    Let $x= j \\times a$ be such a number, where $2 \\le a \\le i / j$\n    Now, after sieving from primes $\\le j - 1$,\n    a must remain\n    (because x, and hence a has no prime factor $\\le j - 1$)\n    Clearly, there are phi(i / j, j - 1) such a\n    which remain on sieving from primes $\\le j - 1$\n\n    Now, if a is a prime less than equal to j - 1,\n    $x= j \\times a$ has smallest prime factor = a, and\n    has already been removed(by sieving from a).\n    So, we do not need to remove it again.\n    (Note: there will be pi(j - 1) such x)\n\n    Thus, number of x, that will be removed are:\n    phi(i / j, j - 1) - phi(j - 1, j - 1)\n    (Note that pi(j - 1) = phi(j - 1, j - 1))\n\n    $\\Rightarrow$ phi(i,j) = phi(i, j - 1) - phi(i / j, j - 1) + phi(j - 1, j - 1)\n\n    So,following recursion is used and implemented as dp:\n\n    phi(a, b) = phi(a, b - 1), if b is not a prime\n    phi(a, b) = phi(a, b-1)-phi(a / b, b-1) + phi(b-1, b-1), if b is prime\n\n    Clearly a is always of the form floor(n / k),\n    which can take at most $2\\sqrt{n}$ values.\n    Two arrays arr1,arr2 are maintained\n    arr1[i] = phi(i, j),\n    arr2[i] = phi(n // i, j)\n\n    Finally the answer is arr2[1]\n\n    Examples\n    ========\n\n    >>> from sympy import primepi, prime, prevprime, isprime\n    >>> primepi(25)\n    9\n\n    So there are 9 primes less than or equal to 25. Is 25 prime?\n\n    >>> isprime(25)\n    False\n\n    It is not. So the first prime less than 25 must be the\n    9th prime:\n\n    >>> prevprime(25) == prime(9)\n    True\n\n    See Also\n    ========\n\n    sympy.ntheory.primetest.isprime : Test if n is prime\n    primerange : Generate all primes in a given range\n    prime : Return the nth prime\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "nextprime",
    "full_id": "sympy.ntheory.generate.nextprime",
    "type": "function",
    "description": "Return the ith prime greater than n.\n\n    Parameters\n    ==========\n\n    n : integer\n    ith : positive integer\n\n    Returns\n    =======\n\n    int : Return the ith prime greater than n\n\n    Raises\n    ======\n\n    ValueError\n        If ``ith <= 0``.\n        If ``n`` or ``ith`` is not an integer.\n\n    Notes\n    =====\n\n    Potential primes are located at 6*j +/- 1. This\n    property is used during searching.\n\n    >>> from sympy import nextprime\n    >>> [(i, nextprime(i)) for i in range(10, 15)]\n    [(10, 11), (11, 13), (12, 13), (13, 17), (14, 17)]\n    >>> nextprime(2, ith=2) # the 2nd prime after 2\n    5\n\n    See Also\n    ========\n\n    prevprime : Return the largest prime smaller than n\n    primerange : Generate all primes in a given range\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "prevprime",
    "full_id": "sympy.ntheory.generate.prevprime",
    "type": "function",
    "description": "Return the largest prime smaller than n.\n\n    Notes\n    =====\n\n    Potential primes are located at 6*j +/- 1. This\n    property is used during searching.\n\n    >>> from sympy import prevprime\n    >>> [(i, prevprime(i)) for i in range(10, 15)]\n    [(10, 7), (11, 7), (12, 11), (13, 11), (14, 13)]\n\n    See Also\n    ========\n\n    nextprime : Return the ith prime greater than n\n    primerange : Generates all primes in a given range\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "primerange",
    "full_id": "sympy.ntheory.generate.primerange",
    "type": "function",
    "description": "Generate a list of all prime numbers in the range [2, a),\n    or [a, b).\n\n    If the range exists in the default sieve, the values will\n    be returned from there; otherwise values will be returned\n    but will not modify the sieve.\n\n    Examples\n    ========\n\n    >>> from sympy import primerange, prime\n\n    All primes less than 19:\n\n    >>> list(primerange(19))\n    [2, 3, 5, 7, 11, 13, 17]\n\n    All primes greater than or equal to 7 and less than 19:\n\n    >>> list(primerange(7, 19))\n    [7, 11, 13, 17]\n\n    All primes through the 10th prime\n\n    >>> list(primerange(prime(10) + 1))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    The Sieve method, primerange, is generally faster but it will\n    occupy more memory as the sieve stores values. The default\n    instance of Sieve, named sieve, can be used:\n\n    >>> from sympy import sieve\n    >>> list(sieve.primerange(1, 30))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    Notes\n    =====\n\n    Some famous conjectures about the occurrence of primes in a given\n    range are [1]:\n\n    - Twin primes: though often not, the following will give 2 primes\n                an infinite number of times:\n                    primerange(6*n - 1, 6*n + 2)\n    - Legendre's: the following always yields at least one prime\n                    primerange(n**2, (n+1)**2+1)\n    - Bertrand's (proven): there is always a prime in the range\n                    primerange(n, 2*n)\n    - Brocard's: there are at least four primes in the range\n                    primerange(prime(n)**2, prime(n+1)**2)\n\n    The average gap between primes is log(n) [2]; the gap between\n    primes can be arbitrarily large since sequences of composite\n    numbers are arbitrarily large, e.g. the numbers in the sequence\n    n! + 2, n! + 3 ... n! + n are all composite.\n\n    See Also\n    ========\n\n    prime : Return the nth prime\n    nextprime : Return the ith prime greater than n\n    prevprime : Return the largest prime smaller than n\n    randprime : Returns a random prime in a given range\n    primorial : Returns the product of primes based on condition\n    Sieve.primerange : return range from already computed primes\n                       or extend the sieve to contain the requested\n                       range.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Prime_number\n    .. [2] https://primes.utm.edu/notes/gaps.html\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "randprime",
    "full_id": "sympy.ntheory.generate.randprime",
    "type": "function",
    "description": "Return a random prime number in the range [a, b).\n\n    Bertrand's postulate assures that\n    randprime(a, 2*a) will always succeed for a > 1.\n\n    Note that due to implementation difficulties,\n    the prime numbers chosen are not uniformly random.\n    For example, there are two primes in the range [112, 128),\n    ``113`` and ``127``, but ``randprime(112, 128)`` returns ``127``\n    with a probability of 15/17.\n\n    Examples\n    ========\n\n    >>> from sympy import randprime, isprime\n    >>> randprime(1, 30) #doctest: +SKIP\n    13\n    >>> isprime(randprime(1, 30))\n    True\n\n    See Also\n    ========\n\n    primerange : Generate all primes in a given range\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Bertrand's_postulate\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "primorial",
    "full_id": "sympy.ntheory.generate.primorial",
    "type": "function",
    "description": "\n    Returns the product of the first n primes (default) or\n    the primes less than or equal to n (when ``nth=False``).\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.generate import primorial, primerange\n    >>> from sympy import factorint, Mul, primefactors, sqrt\n    >>> primorial(4) # the first 4 primes are 2, 3, 5, 7\n    210\n    >>> primorial(4, nth=False) # primes <= 4 are 2 and 3\n    6\n    >>> primorial(1)\n    2\n    >>> primorial(1, nth=False)\n    1\n    >>> primorial(sqrt(101), nth=False)\n    210\n\n    One can argue that the primes are infinite since if you take\n    a set of primes and multiply them together (e.g. the primorial) and\n    then add or subtract 1, the result cannot be divided by any of the\n    original factors, hence either 1 or more new primes must divide this\n    product of primes.\n\n    In this case, the number itself is a new prime:\n\n    >>> factorint(primorial(4) + 1)\n    {211: 1}\n\n    In this case two new primes are the factors:\n\n    >>> factorint(primorial(4) - 1)\n    {11: 1, 19: 1}\n\n    Here, some primes smaller and larger than the primes multiplied together\n    are obtained:\n\n    >>> p = list(primerange(10, 20))\n    >>> sorted(set(primefactors(Mul(*p) + 1)).difference(set(p)))\n    [2, 5, 31, 149]\n\n    See Also\n    ========\n\n    primerange : Generate all primes in a given range\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "cycle_length",
    "full_id": "sympy.ntheory.generate.cycle_length",
    "type": "function",
    "description": "For a given iterated sequence, return a generator that gives\n    the length of the iterated cycle (lambda) and the length of terms\n    before the cycle begins (mu); if ``values`` is True then the\n    terms of the sequence will be returned instead. The sequence is\n    started with value ``x0``.\n\n    Note: more than the first lambda + mu terms may be returned and this\n    is the cost of cycle detection with Brent's method; there are, however,\n    generally less terms calculated than would have been calculated if the\n    proper ending point were determined, e.g. by using Floyd's method.\n\n    >>> from sympy.ntheory.generate import cycle_length\n\n    This will yield successive values of i <-- func(i):\n\n        >>> def gen(func, i):\n        ...     while 1:\n        ...         yield i\n        ...         i = func(i)\n        ...\n\n    A function is defined:\n\n        >>> func = lambda i: (i**2 + 1) % 51\n\n    and given a seed of 4 and the mu and lambda terms calculated:\n\n        >>> next(cycle_length(func, 4))\n        (6, 3)\n\n    We can see what is meant by looking at the output:\n\n        >>> iter = cycle_length(func, 4, values=True)\n        >>> list(iter)\n        [4, 17, 35, 2, 5, 26, 14, 44, 50, 2, 5, 26, 14]\n\n    There are 6 repeating values after the first 3.\n\n    If a sequence is suspected of being longer than you might wish, ``nmax``\n    can be used to exit early (and mu will be returned as None):\n\n        >>> next(cycle_length(func, 4, nmax = 4))\n        (4, None)\n        >>> list(cycle_length(func, 4, nmax = 4, values=True))\n        [4, 17, 35, 2]\n\n    Code modified from:\n        https://en.wikipedia.org/wiki/Cycle_detection.\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "composite",
    "full_id": "sympy.ntheory.generate.composite",
    "type": "function",
    "description": "Return the nth composite number, with the composite numbers indexed as\n    composite(1) = 4, composite(2) = 6, etc....\n\n    Examples\n    ========\n\n    >>> from sympy import composite\n    >>> composite(36)\n    52\n    >>> composite(1)\n    4\n    >>> composite(17737)\n    20000\n\n    See Also\n    ========\n\n    sympy.ntheory.primetest.isprime : Test if n is prime\n    primerange : Generate all primes in a given range\n    primepi : Return the number of primes less than or equal to n\n    prime : Return the nth prime\n    compositepi : Return the number of positive composite numbers less than or equal to n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "compositepi",
    "full_id": "sympy.ntheory.generate.compositepi",
    "type": "function",
    "description": "Return the number of positive composite numbers less than or equal to n.\n    The first positive composite is 4, i.e. compositepi(4) = 1.\n\n    Examples\n    ========\n\n    >>> from sympy import compositepi\n    >>> compositepi(25)\n    15\n    >>> compositepi(1000)\n    831\n\n    See Also\n    ========\n\n    sympy.ntheory.primetest.isprime : Test if n is prime\n    primerange : Generate all primes in a given range\n    prime : Return the nth prime\n    primepi : Return the number of primes less than or equal to n\n    composite : Return the nth composite number\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "smoothness",
    "full_id": "sympy.ntheory.factor_.smoothness",
    "type": "function",
    "description": "\n    Return the B-smooth and B-power smooth values of n.\n\n    The smoothness of n is the largest prime factor of n; the power-\n    smoothness is the largest divisor raised to its multiplicity.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import smoothness\n    >>> smoothness(2**7*3**2)\n    (3, 128)\n    >>> smoothness(2**4*13)\n    (13, 16)\n    >>> smoothness(2)\n    (2, 2)\n\n    See Also\n    ========\n\n    factorint, smoothness_p\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "smoothness_p",
    "full_id": "sympy.ntheory.factor_.smoothness_p",
    "type": "function",
    "description": "\n    Return a list of [m, (p, (M, sm(p + m), psm(p + m)))...]\n    where:\n\n    1. p**M is the base-p divisor of n\n    2. sm(p + m) is the smoothness of p + m (m = -1 by default)\n    3. psm(p + m) is the power smoothness of p + m\n\n    The list is sorted according to smoothness (default) or by power smoothness\n    if power=1.\n\n    The smoothness of the numbers to the left (m = -1) or right (m = 1) of a\n    factor govern the results that are obtained from the p +/- 1 type factoring\n    methods.\n\n        >>> from sympy.ntheory.factor_ import smoothness_p, factorint\n        >>> smoothness_p(10431, m=1)\n        (1, [(3, (2, 2, 4)), (19, (1, 5, 5)), (61, (1, 31, 31))])\n        >>> smoothness_p(10431)\n        (-1, [(3, (2, 2, 2)), (19, (1, 3, 9)), (61, (1, 5, 5))])\n        >>> smoothness_p(10431, power=1)\n        (-1, [(3, (2, 2, 2)), (61, (1, 5, 5)), (19, (1, 3, 9))])\n\n    If visual=True then an annotated string will be returned:\n\n        >>> print(smoothness_p(21477639576571, visual=1))\n        p**i=4410317**1 has p-1 B=1787, B-pow=1787\n        p**i=4869863**1 has p-1 B=2434931, B-pow=2434931\n\n    This string can also be generated directly from a factorization dictionary\n    and vice versa:\n\n        >>> factorint(17*9)\n        {3: 2, 17: 1}\n        >>> smoothness_p(_)\n        'p**i=3**2 has p-1 B=2, B-pow=2\\np**i=17**1 has p-1 B=2, B-pow=16'\n        >>> smoothness_p(_)\n        {3: 2, 17: 1}\n\n    The table of the output logic is:\n\n        ====== ====== ======= =======\n        |              Visual\n        ------ ----------------------\n        Input  True   False   other\n        ====== ====== ======= =======\n        dict    str    tuple   str\n        str     str    tuple   dict\n        tuple   str    tuple   str\n        n       str    tuple   tuple\n        mul     str    tuple   tuple\n        ====== ====== ======= =======\n\n    See Also\n    ========\n\n    factorint, smoothness\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "multiplicity",
    "full_id": "sympy.ntheory.factor_.multiplicity",
    "type": "function",
    "description": "\n    Find the greatest integer m such that p**m divides n.\n\n    Examples\n    ========\n\n    >>> from sympy import multiplicity, Rational\n    >>> [multiplicity(5, n) for n in [8, 5, 25, 125, 250]]\n    [0, 1, 2, 3, 3]\n    >>> multiplicity(3, Rational(1, 9))\n    -2\n\n    Note: when checking for the multiplicity of a number in a\n    large factorial it is most efficient to send it as an unevaluated\n    factorial or to call ``multiplicity_in_factorial`` directly:\n\n    >>> from sympy.ntheory import multiplicity_in_factorial\n    >>> from sympy import factorial\n    >>> p = factorial(25)\n    >>> n = 2**100\n    >>> nfac = factorial(n, evaluate=False)\n    >>> multiplicity(p, nfac)\n    52818775009509558395695966887\n    >>> _ == multiplicity_in_factorial(p, n)\n    True\n\n    See Also\n    ========\n\n    trailing\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "perfect_power",
    "full_id": "sympy.ntheory.factor_.perfect_power",
    "type": "function",
    "description": "\n    Return ``(b, e)`` such that ``n`` == ``b**e`` if ``n`` is a unique\n    perfect power with ``e > 1``, else ``False`` (e.g. 1 is not a\n    perfect power). A ValueError is raised if ``n`` is not Rational.\n\n    By default, the base is recursively decomposed and the exponents\n    collected so the largest possible ``e`` is sought. If ``big=False``\n    then the smallest possible ``e`` (thus prime) will be chosen.\n\n    If ``factor=True`` then simultaneous factorization of ``n`` is\n    attempted since finding a factor indicates the only possible root\n    for ``n``. This is True by default since only a few small factors will\n    be tested in the course of searching for the perfect power.\n\n    The use of ``candidates`` is primarily for internal use; if provided,\n    False will be returned if ``n`` cannot be written as a power with one\n    of the candidates as an exponent and factoring (beyond testing for\n    a factor of 2) will not be attempted.\n\n    Examples\n    ========\n\n    >>> from sympy import perfect_power, Rational\n    >>> perfect_power(16)\n    (2, 4)\n    >>> perfect_power(16, big=False)\n    (4, 2)\n\n    Negative numbers can only have odd perfect powers:\n\n    >>> perfect_power(-4)\n    False\n    >>> perfect_power(-8)\n    (-2, 3)\n\n    Rationals are also recognized:\n\n    >>> perfect_power(Rational(1, 2)**3)\n    (1/2, 3)\n    >>> perfect_power(Rational(-3, 2)**3)\n    (-3/2, 3)\n\n    Notes\n    =====\n\n    To know whether an integer is a perfect power of 2 use\n\n        >>> is2pow = lambda n: bool(n and not n & (n - 1))\n        >>> [(i, is2pow(i)) for i in range(5)]\n        [(0, False), (1, True), (2, True), (3, False), (4, True)]\n\n    It is not necessary to provide ``candidates``. When provided\n    it will be assumed that they are ints. The first one that is\n    larger than the computed maximum possible exponent will signal\n    failure for the routine.\n\n        >>> perfect_power(3**8, [9])\n        False\n        >>> perfect_power(3**8, [2, 4, 8])\n        (3, 8)\n        >>> perfect_power(3**8, [4, 8], big=False)\n        (9, 4)\n\n    See Also\n    ========\n    sympy.core.intfunc.integer_nthroot\n    sympy.ntheory.primetest.is_square\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "pollard_rho",
    "full_id": "sympy.ntheory.factor_.pollard_rho",
    "type": "function",
    "description": "\n    Use Pollard's rho method to try to extract a nontrivial factor\n    of ``n``. The returned factor may be a composite number. If no\n    factor is found, ``None`` is returned.\n\n    The algorithm generates pseudo-random values of x with a generator\n    function, replacing x with F(x). If F is not supplied then the\n    function x**2 + ``a`` is used. The first value supplied to F(x) is ``s``.\n    Upon failure (if ``retries`` is > 0) a new ``a`` and ``s`` will be\n    supplied; the ``a`` will be ignored if F was supplied.\n\n    The sequence of numbers generated by such functions generally have a\n    a lead-up to some number and then loop around back to that number and\n    begin to repeat the sequence, e.g. 1, 2, 3, 4, 5, 3, 4, 5 -- this leader\n    and loop look a bit like the Greek letter rho, and thus the name, 'rho'.\n\n    For a given function, very different leader-loop values can be obtained\n    so it is a good idea to allow for retries:\n\n    >>> from sympy.ntheory.generate import cycle_length\n    >>> n = 16843009\n    >>> F = lambda x:(2048*pow(x, 2, n) + 32767) % n\n    >>> for s in range(5):\n    ...     print('loop length = %4i; leader length = %3i' % next(cycle_length(F, s)))\n    ...\n    loop length = 2489; leader length =  43\n    loop length =   78; leader length = 121\n    loop length = 1482; leader length = 100\n    loop length = 1482; leader length = 286\n    loop length = 1482; leader length = 101\n\n    Here is an explicit example where there is a three element leadup to\n    a sequence of 3 numbers (11, 14, 4) that then repeat:\n\n    >>> x=2\n    >>> for i in range(9):\n    ...     print(x)\n    ...     x=(x**2+12)%17\n    ...\n    2\n    16\n    13\n    11\n    14\n    4\n    11\n    14\n    4\n    >>> next(cycle_length(lambda x: (x**2+12)%17, 2))\n    (3, 3)\n    >>> list(cycle_length(lambda x: (x**2+12)%17, 2, values=True))\n    [2, 16, 13, 11, 14, 4]\n\n    Instead of checking the differences of all generated values for a gcd\n    with n, only the kth and 2*kth numbers are checked, e.g. 1st and 2nd,\n    2nd and 4th, 3rd and 6th until it has been detected that the loop has been\n    traversed. Loops may be many thousands of steps long before rho finds a\n    factor or reports failure. If ``max_steps`` is specified, the iteration\n    is cancelled with a failure after the specified number of steps.\n\n    Examples\n    ========\n\n    >>> from sympy import pollard_rho\n    >>> n=16843009\n    >>> F=lambda x:(2048*pow(x,2,n) + 32767) % n\n    >>> pollard_rho(n, F=F)\n    257\n\n    Use the default setting with a bad value of ``a`` and no retries:\n\n    >>> pollard_rho(n, a=n-2, retries=0)\n\n    If retries is > 0 then perhaps the problem will correct itself when\n    new values are generated for a:\n\n    >>> pollard_rho(n, a=n-2, retries=1)\n    257\n\n    References\n    ==========\n\n    .. [1] Richard Crandall & Carl Pomerance (2005), \"Prime Numbers:\n           A Computational Perspective\", Springer, 2nd edition, 229-231\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "pollard_pm1",
    "full_id": "sympy.ntheory.factor_.pollard_pm1",
    "type": "function",
    "description": "\n    Use Pollard's p-1 method to try to extract a nontrivial factor\n    of ``n``. Either a divisor (perhaps composite) or ``None`` is returned.\n\n    The value of ``a`` is the base that is used in the test gcd(a**M - 1, n).\n    The default is 2.  If ``retries`` > 0 then if no factor is found after the\n    first attempt, a new ``a`` will be generated randomly (using the ``seed``)\n    and the process repeated.\n\n    Note: the value of M is lcm(1..B) = reduce(ilcm, range(2, B + 1)).\n\n    A search is made for factors next to even numbers having a power smoothness\n    less than ``B``. Choosing a larger B increases the likelihood of finding a\n    larger factor but takes longer. Whether a factor of n is found or not\n    depends on ``a`` and the power smoothness of the even number just less than\n    the factor p (hence the name p - 1).\n\n    Although some discussion of what constitutes a good ``a`` some\n    descriptions are hard to interpret. At the modular.math site referenced\n    below it is stated that if gcd(a**M - 1, n) = N then a**M % q**r is 1\n    for every prime power divisor of N. But consider the following:\n\n        >>> from sympy.ntheory.factor_ import smoothness_p, pollard_pm1\n        >>> n=257*1009\n        >>> smoothness_p(n)\n        (-1, [(257, (1, 2, 256)), (1009, (1, 7, 16))])\n\n    So we should (and can) find a root with B=16:\n\n        >>> pollard_pm1(n, B=16, a=3)\n        1009\n\n    If we attempt to increase B to 256 we find that it does not work:\n\n        >>> pollard_pm1(n, B=256)\n        >>>\n\n    But if the value of ``a`` is changed we find that only multiples of\n    257 work, e.g.:\n\n        >>> pollard_pm1(n, B=256, a=257)\n        1009\n\n    Checking different ``a`` values shows that all the ones that did not\n    work had a gcd value not equal to ``n`` but equal to one of the\n    factors:\n\n        >>> from sympy import ilcm, igcd, factorint, Pow\n        >>> M = 1\n        >>> for i in range(2, 256):\n        ...     M = ilcm(M, i)\n        ...\n        >>> set([igcd(pow(a, M, n) - 1, n) for a in range(2, 256) if\n        ...      igcd(pow(a, M, n) - 1, n) != n])\n        {1009}\n\n    But does aM % d for every divisor of n give 1?\n\n        >>> aM = pow(255, M, n)\n        >>> [(d, aM%Pow(*d.args)) for d in factorint(n, visual=True).args]\n        [(257**1, 1), (1009**1, 1)]\n\n    No, only one of them. So perhaps the principle is that a root will\n    be found for a given value of B provided that:\n\n    1) the power smoothness of the p - 1 value next to the root\n       does not exceed B\n    2) a**M % p != 1 for any of the divisors of n.\n\n    By trying more than one ``a`` it is possible that one of them\n    will yield a factor.\n\n    Examples\n    ========\n\n    With the default smoothness bound, this number cannot be cracked:\n\n        >>> from sympy.ntheory import pollard_pm1\n        >>> pollard_pm1(21477639576571)\n\n    Increasing the smoothness bound helps:\n\n        >>> pollard_pm1(21477639576571, B=2000)\n        4410317\n\n    Looking at the smoothness of the factors of this number we find:\n\n        >>> from sympy.ntheory.factor_ import smoothness_p, factorint\n        >>> print(smoothness_p(21477639576571, visual=1))\n        p**i=4410317**1 has p-1 B=1787, B-pow=1787\n        p**i=4869863**1 has p-1 B=2434931, B-pow=2434931\n\n    The B and B-pow are the same for the p - 1 factorizations of the divisors\n    because those factorizations had a very large prime factor:\n\n        >>> factorint(4410317 - 1)\n        {2: 2, 617: 1, 1787: 1}\n        >>> factorint(4869863-1)\n        {2: 1, 2434931: 1}\n\n    Note that until B reaches the B-pow value of 1787, the number is not cracked;\n\n        >>> pollard_pm1(21477639576571, B=1786)\n        >>> pollard_pm1(21477639576571, B=1787)\n        4410317\n\n    The B value has to do with the factors of the number next to the divisor,\n    not the divisors themselves. A worst case scenario is that the number next\n    to the factor p has a large prime divisisor or is a perfect power. If these\n    conditions apply then the power-smoothness will be about p/2 or p. The more\n    realistic is that there will be a large prime factor next to p requiring\n    a B value on the order of p/2. Although primes may have been searched for\n    up to this level, the p/2 is a factor of p - 1, something that we do not\n    know. The modular.math reference below states that 15% of numbers in the\n    range of 10**15 to 15**15 + 10**4 are 10**6 power smooth so a B of 10**6\n    will fail 85% of the time in that range. From 10**8 to 10**8 + 10**3 the\n    percentages are nearly reversed...but in that range the simple trial\n    division is quite fast.\n\n    References\n    ==========\n\n    .. [1] Richard Crandall & Carl Pomerance (2005), \"Prime Numbers:\n           A Computational Perspective\", Springer, 2nd edition, 236-238\n    .. [2] https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html\n    .. [3] https://www.cs.toronto.edu/~yuvalf/Factorization.pdf\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "factorint",
    "full_id": "sympy.ntheory.factor_.factorint",
    "type": "function",
    "description": "\n    Given a positive integer ``n``, ``factorint(n)`` returns a dict containing\n    the prime factors of ``n`` as keys and their respective multiplicities\n    as values. For example:\n\n    >>> from sympy.ntheory import factorint\n    >>> factorint(2000)    # 2000 = (2**4) * (5**3)\n    {2: 4, 5: 3}\n    >>> factorint(65537)   # This number is prime\n    {65537: 1}\n\n    For input less than 2, factorint behaves as follows:\n\n        - ``factorint(1)`` returns the empty factorization, ``{}``\n        - ``factorint(0)`` returns ``{0:1}``\n        - ``factorint(-n)`` adds ``-1:1`` to the factors and then factors ``n``\n\n    Partial Factorization:\n\n    If ``limit`` (> 3) is specified, the search is stopped after performing\n    trial division up to (and including) the limit (or taking a\n    corresponding number of rho/p-1 steps). This is useful if one has\n    a large number and only is interested in finding small factors (if\n    any). Note that setting a limit does not prevent larger factors\n    from being found early; it simply means that the largest factor may\n    be composite. Since checking for perfect power is relatively cheap, it is\n    done regardless of the limit setting.\n\n    This number, for example, has two small factors and a huge\n    semi-prime factor that cannot be reduced easily:\n\n    >>> from sympy.ntheory import isprime\n    >>> a = 1407633717262338957430697921446883\n    >>> f = factorint(a, limit=10000)\n    >>> f == {991: 1, int(202916782076162456022877024859): 1, 7: 1}\n    True\n    >>> isprime(max(f))\n    False\n\n    This number has a small factor and a residual perfect power whose\n    base is greater than the limit:\n\n    >>> factorint(3*101**7, limit=5)\n    {3: 1, 101: 7}\n\n    List of Factors:\n\n    If ``multiple`` is set to ``True`` then a list containing the\n    prime factors including multiplicities is returned.\n\n    >>> factorint(24, multiple=True)\n    [2, 2, 2, 3]\n\n    Visual Factorization:\n\n    If ``visual`` is set to ``True``, then it will return a visual\n    factorization of the integer.  For example:\n\n    >>> from sympy import pprint\n    >>> pprint(factorint(4200, visual=True))\n     3  1  2  1\n    2 *3 *5 *7\n\n    Note that this is achieved by using the evaluate=False flag in Mul\n    and Pow. If you do other manipulations with an expression where\n    evaluate=False, it may evaluate.  Therefore, you should use the\n    visual option only for visualization, and use the normal dictionary\n    returned by visual=False if you want to perform operations on the\n    factors.\n\n    You can easily switch between the two forms by sending them back to\n    factorint:\n\n    >>> from sympy import Mul\n    >>> regular = factorint(1764); regular\n    {2: 2, 3: 2, 7: 2}\n    >>> pprint(factorint(regular))\n     2  2  2\n    2 *3 *7\n\n    >>> visual = factorint(1764, visual=True); pprint(visual)\n     2  2  2\n    2 *3 *7\n    >>> print(factorint(visual))\n    {2: 2, 3: 2, 7: 2}\n\n    If you want to send a number to be factored in a partially factored form\n    you can do so with a dictionary or unevaluated expression:\n\n    >>> factorint(factorint({4: 2, 12: 3})) # twice to toggle to dict form\n    {2: 10, 3: 3}\n    >>> factorint(Mul(4, 12, evaluate=False))\n    {2: 4, 3: 1}\n\n    The table of the output logic is:\n\n        ====== ====== ======= =======\n                       Visual\n        ------ ----------------------\n        Input  True   False   other\n        ====== ====== ======= =======\n        dict    mul    dict    mul\n        n       mul    dict    dict\n        mul     mul    dict    dict\n        ====== ====== ======= =======\n\n    Notes\n    =====\n\n    Algorithm:\n\n    The function switches between multiple algorithms. Trial division\n    quickly finds small factors (of the order 1-5 digits), and finds\n    all large factors if given enough time. The Pollard rho and p-1\n    algorithms are used to find large factors ahead of time; they\n    will often find factors of the order of 10 digits within a few\n    seconds:\n\n    >>> factors = factorint(12345678910111213141516)\n    >>> for base, exp in sorted(factors.items()):\n    ...     print('%s %s' % (base, exp))\n    ...\n    2 2\n    2507191691 1\n    1231026625769 1\n\n    Any of these methods can optionally be disabled with the following\n    boolean parameters:\n\n        - ``use_trial``: Toggle use of trial division\n        - ``use_rho``: Toggle use of Pollard's rho method\n        - ``use_pm1``: Toggle use of Pollard's p-1 method\n\n    ``factorint`` also periodically checks if the remaining part is\n    a prime number or a perfect power, and in those cases stops.\n\n    For unevaluated factorial, it uses Legendre's formula(theorem).\n\n\n    If ``verbose`` is set to ``True``, detailed progress is printed.\n\n    See Also\n    ========\n\n    smoothness, smoothness_p, divisors\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "factorrat",
    "full_id": "sympy.ntheory.factor_.factorrat",
    "type": "function",
    "description": "\n    Given a Rational ``r``, ``factorrat(r)`` returns a dict containing\n    the prime factors of ``r`` as keys and their respective multiplicities\n    as values. For example:\n\n    >>> from sympy import factorrat, S\n    >>> factorrat(S(8)/9)    # 8/9 = (2**3) * (3**-2)\n    {2: 3, 3: -2}\n    >>> factorrat(S(-1)/987)    # -1/789 = -1 * (3**-1) * (7**-1) * (47**-1)\n    {-1: 1, 3: -1, 7: -1, 47: -1}\n\n    Please see the docstring for ``factorint`` for detailed explanations\n    and examples of the following keywords:\n\n        - ``limit``: Integer limit up to which trial division is done\n        - ``use_trial``: Toggle use of trial division\n        - ``use_rho``: Toggle use of Pollard's rho method\n        - ``use_pm1``: Toggle use of Pollard's p-1 method\n        - ``verbose``: Toggle detailed printing of progress\n        - ``multiple``: Toggle returning a list of factors or dict\n        - ``visual``: Toggle product form of output\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "primefactors",
    "full_id": "sympy.ntheory.factor_.primefactors",
    "type": "function",
    "description": "Return a sorted list of n's prime factors, ignoring multiplicity\n    and any composite factor that remains if the limit was set too low\n    for complete factorization. Unlike factorint(), primefactors() does\n    not return -1 or 0.\n\n    Parameters\n    ==========\n\n    n : integer\n    limit, verbose, **kwargs :\n        Additional keyword arguments to be passed to ``factorint``.\n        Since ``kwargs`` is new in version 1.13,\n        ``limit`` and ``verbose`` are retained for compatibility purposes.\n\n    Returns\n    =======\n\n    list(int) : List of prime numbers dividing ``n``\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import primefactors, factorint, isprime\n    >>> primefactors(6)\n    [2, 3]\n    >>> primefactors(-5)\n    [5]\n\n    >>> sorted(factorint(123456).items())\n    [(2, 6), (3, 1), (643, 1)]\n    >>> primefactors(123456)\n    [2, 3, 643]\n\n    >>> sorted(factorint(10000000001, limit=200).items())\n    [(101, 1), (99009901, 1)]\n    >>> isprime(99009901)\n    False\n    >>> primefactors(10000000001, limit=300)\n    [101]\n\n    See Also\n    ========\n\n    factorint, divisors\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "divisors",
    "full_id": "sympy.ntheory.factor_.divisors",
    "type": "function",
    "description": "\n    Return all divisors of n sorted from 1..n by default.\n    If generator is ``True`` an unordered generator is returned.\n\n    The number of divisors of n can be quite large if there are many\n    prime factors (counting repeated factors). If only the number of\n    factors is desired use divisor_count(n).\n\n    Examples\n    ========\n\n    >>> from sympy import divisors, divisor_count\n    >>> divisors(24)\n    [1, 2, 3, 4, 6, 8, 12, 24]\n    >>> divisor_count(24)\n    8\n\n    >>> list(divisors(120, generator=True))\n    [1, 2, 4, 8, 3, 6, 12, 24, 5, 10, 20, 40, 15, 30, 60, 120]\n\n    Notes\n    =====\n\n    This is a slightly modified version of Tim Peters referenced at:\n    https://stackoverflow.com/questions/1010381/python-factorization\n\n    See Also\n    ========\n\n    primefactors, factorint, divisor_count\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "proper_divisors",
    "full_id": "sympy.ntheory.factor_.proper_divisors",
    "type": "function",
    "description": "\n    Return all divisors of n except n, sorted by default.\n    If generator is ``True`` an unordered generator is returned.\n\n    Examples\n    ========\n\n    >>> from sympy import proper_divisors, proper_divisor_count\n    >>> proper_divisors(24)\n    [1, 2, 3, 4, 6, 8, 12]\n    >>> proper_divisor_count(24)\n    7\n    >>> list(proper_divisors(120, generator=True))\n    [1, 2, 4, 8, 3, 6, 12, 24, 5, 10, 20, 40, 15, 30, 60]\n\n    See Also\n    ========\n\n    factorint, divisors, proper_divisor_count\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "divisor_count",
    "full_id": "sympy.ntheory.factor_.divisor_count",
    "type": "function",
    "description": "\n    Return the number of divisors of ``n``. If ``modulus`` is not 1 then only\n    those that are divisible by ``modulus`` are counted. If ``proper`` is True\n    then the divisor of ``n`` will not be counted.\n\n    Examples\n    ========\n\n    >>> from sympy import divisor_count\n    >>> divisor_count(6)\n    4\n    >>> divisor_count(6, 2)\n    2\n    >>> divisor_count(6, proper=True)\n    3\n\n    See Also\n    ========\n\n    factorint, divisors, totient, proper_divisor_count\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "proper_divisor_count",
    "full_id": "sympy.ntheory.factor_.proper_divisor_count",
    "type": "function",
    "description": "\n    Return the number of proper divisors of ``n``.\n\n    Examples\n    ========\n\n    >>> from sympy import proper_divisor_count\n    >>> proper_divisor_count(6)\n    3\n    >>> proper_divisor_count(6, modulus=2)\n    1\n\n    See Also\n    ========\n\n    divisors, proper_divisors, divisor_count\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "udivisors",
    "full_id": "sympy.ntheory.factor_.udivisors",
    "type": "function",
    "description": "\n    Return all unitary divisors of n sorted from 1..n by default.\n    If generator is ``True`` an unordered generator is returned.\n\n    The number of unitary divisors of n can be quite large if there are many\n    prime factors. If only the number of unitary divisors is desired use\n    udivisor_count(n).\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import udivisors, udivisor_count\n    >>> udivisors(15)\n    [1, 3, 5, 15]\n    >>> udivisor_count(15)\n    4\n\n    >>> sorted(udivisors(120, generator=True))\n    [1, 3, 5, 8, 15, 24, 40, 120]\n\n    See Also\n    ========\n\n    primefactors, factorint, divisors, divisor_count, udivisor_count\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Unitary_divisor\n    .. [2] https://mathworld.wolfram.com/UnitaryDivisor.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "udivisor_count",
    "full_id": "sympy.ntheory.factor_.udivisor_count",
    "type": "function",
    "description": "\n    Return the number of unitary divisors of ``n``.\n\n    Parameters\n    ==========\n\n    n : integer\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import udivisor_count\n    >>> udivisor_count(120)\n    8\n\n    See Also\n    ========\n\n    factorint, divisors, udivisors, divisor_count, totient\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/UnitaryDivisorFunction.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "antidivisors",
    "full_id": "sympy.ntheory.factor_.antidivisors",
    "type": "function",
    "description": "\n    Return all antidivisors of n sorted from 1..n by default.\n\n    Antidivisors [1]_ of n are numbers that do not divide n by the largest\n    possible margin.  If generator is True an unordered generator is returned.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import antidivisors\n    >>> antidivisors(24)\n    [7, 16]\n\n    >>> sorted(antidivisors(128, generator=True))\n    [3, 5, 15, 17, 51, 85]\n\n    See Also\n    ========\n\n    primefactors, factorint, divisors, divisor_count, antidivisor_count\n\n    References\n    ==========\n\n    .. [1] definition is described in https://oeis.org/A066272/a066272a.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "antidivisor_count",
    "full_id": "sympy.ntheory.factor_.antidivisor_count",
    "type": "function",
    "description": "\n    Return the number of antidivisors [1]_ of ``n``.\n\n    Parameters\n    ==========\n\n    n : integer\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import antidivisor_count\n    >>> antidivisor_count(13)\n    4\n    >>> antidivisor_count(27)\n    5\n\n    See Also\n    ========\n\n    factorint, divisors, antidivisors, divisor_count, totient\n\n    References\n    ==========\n\n    .. [1] formula from https://oeis.org/A066272\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "totient",
    "full_id": "sympy.ntheory.factor_.totient",
    "type": "function",
    "description": "\n    Calculate the Euler totient function phi(n)\n\n    .. deprecated:: 1.13\n\n        The ``totient`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.totient`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    ``totient(n)`` or `\\phi(n)` is the number of positive integers `\\leq` n\n    that are relatively prime to n.\n\n    Parameters\n    ==========\n\n    n : integer\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import totient\n    >>> totient(1)\n    1\n    >>> totient(25)\n    20\n    >>> totient(45) == totient(5)*totient(9)\n    True\n\n    See Also\n    ========\n\n    divisor_count\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Euler%27s_totient_function\n    .. [2] https://mathworld.wolfram.com/TotientFunction.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "reduced_totient",
    "full_id": "sympy.ntheory.factor_.reduced_totient",
    "type": "function",
    "description": "\n    Calculate the Carmichael reduced totient function lambda(n)\n\n    .. deprecated:: 1.13\n\n        The ``reduced_totient`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.reduced_totient`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    ``reduced_totient(n)`` or `\\lambda(n)` is the smallest m > 0 such that\n    `k^m \\equiv 1 \\mod n` for all k relatively prime to n.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import reduced_totient\n    >>> reduced_totient(1)\n    1\n    >>> reduced_totient(8)\n    2\n    >>> reduced_totient(30)\n    4\n\n    See Also\n    ========\n\n    totient\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Carmichael_function\n    .. [2] https://mathworld.wolfram.com/CarmichaelFunction.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "divisor_sigma",
    "full_id": "sympy.ntheory.factor_.divisor_sigma",
    "type": "function",
    "description": "\n    Calculate the divisor function `\\sigma_k(n)` for positive integer n\n\n    .. deprecated:: 1.13\n\n        The ``divisor_sigma`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.divisor_sigma`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    ``divisor_sigma(n, k)`` is equal to ``sum([x**k for x in divisors(n)])``\n\n    If n's prime factorization is:\n\n    .. math ::\n        n = \\prod_{i=1}^\\omega p_i^{m_i},\n\n    then\n\n    .. math ::\n        \\sigma_k(n) = \\prod_{i=1}^\\omega (1+p_i^k+p_i^{2k}+\\cdots\n        + p_i^{m_ik}).\n\n    Parameters\n    ==========\n\n    n : integer\n\n    k : integer, optional\n        power of divisors in the sum\n\n        for k = 0, 1:\n        ``divisor_sigma(n, 0)`` is equal to ``divisor_count(n)``\n        ``divisor_sigma(n, 1)`` is equal to ``sum(divisors(n))``\n\n        Default for k is 1.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import divisor_sigma\n    >>> divisor_sigma(18, 0)\n    6\n    >>> divisor_sigma(39, 1)\n    56\n    >>> divisor_sigma(12, 2)\n    210\n    >>> divisor_sigma(37)\n    38\n\n    See Also\n    ========\n\n    divisor_count, totient, divisors, factorint\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Divisor_function\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "udivisor_sigma",
    "full_id": "sympy.ntheory.factor_.udivisor_sigma",
    "type": "function",
    "description": "\n    Calculate the unitary divisor function `\\sigma_k^*(n)` for positive integer n\n\n    .. deprecated:: 1.13\n\n        The ``udivisor_sigma`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.udivisor_sigma`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    ``udivisor_sigma(n, k)`` is equal to ``sum([x**k for x in udivisors(n)])``\n\n    If n's prime factorization is:\n\n    .. math ::\n        n = \\prod_{i=1}^\\omega p_i^{m_i},\n\n    then\n\n    .. math ::\n        \\sigma_k^*(n) = \\prod_{i=1}^\\omega (1+ p_i^{m_ik}).\n\n    Parameters\n    ==========\n\n    k : power of divisors in the sum\n\n        for k = 0, 1:\n        ``udivisor_sigma(n, 0)`` is equal to ``udivisor_count(n)``\n        ``udivisor_sigma(n, 1)`` is equal to ``sum(udivisors(n))``\n\n        Default for k is 1.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import udivisor_sigma\n    >>> udivisor_sigma(18, 0)\n    4\n    >>> udivisor_sigma(74, 1)\n    114\n    >>> udivisor_sigma(36, 3)\n    47450\n    >>> udivisor_sigma(111)\n    152\n\n    See Also\n    ========\n\n    divisor_count, totient, divisors, udivisors, udivisor_count, divisor_sigma,\n    factorint\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/UnitaryDivisorFunction.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "core",
    "full_id": "sympy.ntheory.factor_.core",
    "type": "function",
    "description": "\n    Calculate core(n, t) = `core_t(n)` of a positive integer n\n\n    ``core_2(n)`` is equal to the squarefree part of n\n\n    If n's prime factorization is:\n\n    .. math ::\n        n = \\prod_{i=1}^\\omega p_i^{m_i},\n\n    then\n\n    .. math ::\n        core_t(n) = \\prod_{i=1}^\\omega p_i^{m_i \\mod t}.\n\n    Parameters\n    ==========\n\n    n : integer\n\n    t : integer\n        core(n, t) calculates the t-th power free part of n\n\n        ``core(n, 2)`` is the squarefree part of ``n``\n        ``core(n, 3)`` is the cubefree part of ``n``\n\n        Default for t is 2.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import core\n    >>> core(24, 2)\n    6\n    >>> core(9424, 3)\n    1178\n    >>> core(379238)\n    379238\n    >>> core(15**11, 10)\n    15\n\n    See Also\n    ========\n\n    factorint, sympy.solvers.diophantine.diophantine.square_factor\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "digits",
    "full_id": "sympy.ntheory.factor_.digits",
    "type": "function",
    "description": "\n    Return a list of the digits of ``n`` in base ``b``. The first\n    element in the list is ``b`` (or ``-b`` if ``n`` is negative).\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.digits import digits\n    >>> digits(35)\n    [10, 3, 5]\n\n    If the number is negative, the negative sign will be placed on the\n    base (which is the first element in the returned list):\n\n    >>> digits(-35)\n    [-10, 3, 5]\n\n    Bases other than 10 (and greater than 1) can be selected with ``b``:\n\n    >>> digits(27, b=2)\n    [2, 1, 1, 0, 1, 1]\n\n    Use the ``digits`` keyword if a certain number of digits is desired:\n\n    >>> digits(35, digits=4)\n    [10, 0, 0, 3, 5]\n\n    Parameters\n    ==========\n\n    n: integer\n        The number whose digits are returned.\n\n    b: integer\n        The base in which digits are computed.\n\n    digits: integer (or None for all digits)\n        The number of digits to be returned (padded with zeros, if\n        necessary).\n\n    See Also\n    ========\n    sympy.core.intfunc.num_digits, count_digits\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "primenu",
    "full_id": "sympy.ntheory.factor_.primenu",
    "type": "function",
    "description": "\n    Calculate the number of distinct prime factors for a positive integer n.\n\n    .. deprecated:: 1.13\n\n        The ``primenu`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.primenu`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    If n's prime factorization is:\n\n    .. math ::\n        n = \\prod_{i=1}^k p_i^{m_i},\n\n    then ``primenu(n)`` or `\\nu(n)` is:\n\n    .. math ::\n        \\nu(n) = k.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import primenu\n    >>> primenu(1)\n    0\n    >>> primenu(30)\n    3\n\n    See Also\n    ========\n\n    factorint\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/PrimeFactor.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "primeomega",
    "full_id": "sympy.ntheory.factor_.primeomega",
    "type": "function",
    "description": "\n    Calculate the number of prime factors counting multiplicities for a\n    positive integer n.\n\n    .. deprecated:: 1.13\n\n        The ``primeomega`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.primeomega`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    If n's prime factorization is:\n\n    .. math ::\n        n = \\prod_{i=1}^k p_i^{m_i},\n\n    then ``primeomega(n)``  or `\\Omega(n)` is:\n\n    .. math ::\n        \\Omega(n) = \\sum_{i=1}^k m_i.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import primeomega\n    >>> primeomega(1)\n    0\n    >>> primeomega(20)\n    3\n\n    See Also\n    ========\n\n    factorint\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/PrimeFactor.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "mersenne_prime_exponent",
    "full_id": "sympy.ntheory.factor_.mersenne_prime_exponent",
    "type": "function",
    "description": "Returns the exponent ``i`` for the nth Mersenne prime (which\n    has the form `2^i - 1`).\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import mersenne_prime_exponent\n    >>> mersenne_prime_exponent(1)\n    2\n    >>> mersenne_prime_exponent(20)\n    4423\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_perfect",
    "full_id": "sympy.ntheory.factor_.is_perfect",
    "type": "function",
    "description": "Returns True if ``n`` is a perfect number, else False.\n\n    A perfect number is equal to the sum of its positive, proper divisors.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import divisor_sigma\n    >>> from sympy.ntheory.factor_ import is_perfect, divisors\n    >>> is_perfect(20)\n    False\n    >>> is_perfect(6)\n    True\n    >>> 6 == divisor_sigma(6) - 6 == sum(divisors(6)[:-1])\n    True\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/PerfectNumber.html\n    .. [2] https://en.wikipedia.org/wiki/Perfect_number\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "abundance",
    "full_id": "sympy.ntheory.factor_.abundance",
    "type": "function",
    "description": "Returns the difference between the sum of the positive\n    proper divisors of a number and the number.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import abundance, is_perfect, is_abundant\n    >>> abundance(6)\n    0\n    >>> is_perfect(6)\n    True\n    >>> abundance(10)\n    -2\n    >>> is_abundant(10)\n    False\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_abundant",
    "full_id": "sympy.ntheory.factor_.is_abundant",
    "type": "function",
    "description": "Returns True if ``n`` is an abundant number, else False.\n\n    A abundant number is smaller than the sum of its positive proper divisors.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import is_abundant\n    >>> is_abundant(20)\n    True\n    >>> is_abundant(15)\n    False\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/AbundantNumber.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_deficient",
    "full_id": "sympy.ntheory.factor_.is_deficient",
    "type": "function",
    "description": "Returns True if ``n`` is a deficient number, else False.\n\n    A deficient number is greater than the sum of its positive proper divisors.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import is_deficient\n    >>> is_deficient(20)\n    False\n    >>> is_deficient(15)\n    True\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/DeficientNumber.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_amicable",
    "full_id": "sympy.ntheory.factor_.is_amicable",
    "type": "function",
    "description": "Returns True if the numbers `m` and `n` are \"amicable\", else False.\n\n    Amicable numbers are two different numbers so related that the sum\n    of the proper divisors of each is equal to that of the other.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import divisor_sigma\n    >>> from sympy.ntheory.factor_ import is_amicable\n    >>> is_amicable(220, 284)\n    True\n    >>> divisor_sigma(220) == divisor_sigma(284)\n    True\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Amicable_numbers\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_carmichael",
    "full_id": "sympy.ntheory.factor_.is_carmichael",
    "type": "function",
    "description": "Returns True if the numbers `n` is Carmichael number, else False.\n\n    Parameters\n    ==========\n\n    n : Integer\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Carmichael_number\n    .. [2] https://oeis.org/A002997\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "find_carmichael_numbers_in_range",
    "full_id": "sympy.ntheory.factor_.find_carmichael_numbers_in_range",
    "type": "function",
    "description": "Returns a list of the number of Carmichael in the range\n\n    See Also\n    ========\n\n    is_carmichael\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "find_first_n_carmichaels",
    "full_id": "sympy.ntheory.factor_.find_first_n_carmichaels",
    "type": "function",
    "description": "Returns the first n Carmichael numbers.\n\n    Parameters\n    ==========\n\n    n : Integer\n\n    See Also\n    ========\n\n    is_carmichael\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "symmetric_residue",
    "full_id": "sympy.ntheory.modular.symmetric_residue",
    "type": "function",
    "description": "Return the residual mod m such that it is within half of the modulus.\n\n    >>> from sympy.ntheory.modular import symmetric_residue\n    >>> symmetric_residue(1, 6)\n    1\n    >>> symmetric_residue(4, 6)\n    -2\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "crt",
    "full_id": "sympy.ntheory.modular.crt",
    "type": "function",
    "description": "Chinese Remainder Theorem.\n\n    The moduli in m are assumed to be pairwise coprime.  The output\n    is then an integer f, such that f = v_i mod m_i for each pair out\n    of v and m. If ``symmetric`` is False a positive integer will be\n    returned, else \\|f\\| will be less than or equal to the LCM of the\n    moduli, and thus f may be negative.\n\n    If the moduli are not co-prime the correct result will be returned\n    if/when the test of the result is found to be incorrect. This result\n    will be None if there is no solution.\n\n    The keyword ``check`` can be set to False if it is known that the moduli\n    are coprime.\n\n    Examples\n    ========\n\n    As an example consider a set of residues ``U = [49, 76, 65]``\n    and a set of moduli ``M = [99, 97, 95]``. Then we have::\n\n       >>> from sympy.ntheory.modular import crt\n\n       >>> crt([99, 97, 95], [49, 76, 65])\n       (639985, 912285)\n\n    This is the correct result because::\n\n       >>> [639985 % m for m in [99, 97, 95]]\n       [49, 76, 65]\n\n    If the moduli are not co-prime, you may receive an incorrect result\n    if you use ``check=False``:\n\n       >>> crt([12, 6, 17], [3, 4, 2], check=False)\n       (954, 1224)\n       >>> [954 % m for m in [12, 6, 17]]\n       [6, 0, 2]\n       >>> crt([12, 6, 17], [3, 4, 2]) is None\n       True\n       >>> crt([3, 6], [2, 5])\n       (5, 6)\n\n    Note: the order of gf_crt's arguments is reversed relative to crt,\n    and that solve_congruence takes residue, modulus pairs.\n\n    Programmer's note: rather than checking that all pairs of moduli share\n    no GCD (an O(n**2) test) and rather than factoring all moduli and seeing\n    that there is no factor in common, a check that the result gives the\n    indicated residuals is performed -- an O(n) operation.\n\n    See Also\n    ========\n\n    solve_congruence\n    sympy.polys.galoistools.gf_crt : low level crt routine used by this routine\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "crt1",
    "full_id": "sympy.ntheory.modular.crt1",
    "type": "function",
    "description": "First part of Chinese Remainder Theorem, for multiple application.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.modular import crt, crt1, crt2\n    >>> m = [99, 97, 95]\n    >>> v = [49, 76, 65]\n\n    The following two codes have the same result.\n\n    >>> crt(m, v)\n    (639985, 912285)\n\n    >>> mm, e, s = crt1(m)\n    >>> crt2(m, v, mm, e, s)\n    (639985, 912285)\n\n    However, it is faster when we want to fix ``m`` and\n    compute for multiple ``v``, i.e. the following cases:\n\n    >>> mm, e, s = crt1(m)\n    >>> vs = [[52, 21, 37], [19, 46, 76]]\n    >>> for v in vs:\n    ...     print(crt2(m, v, mm, e, s))\n    (397042, 912285)\n    (803206, 912285)\n\n    See Also\n    ========\n\n    sympy.polys.galoistools.gf_crt1 : low level crt routine used by this routine\n    sympy.ntheory.modular.crt\n    sympy.ntheory.modular.crt2\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "crt2",
    "full_id": "sympy.ntheory.modular.crt2",
    "type": "function",
    "description": "Second part of Chinese Remainder Theorem, for multiple application.\n\n    See ``crt1`` for usage.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.modular import crt1, crt2\n    >>> mm, e, s = crt1([18, 42, 6])\n    >>> crt2([18, 42, 6], [0, 0, 0], mm, e, s)\n    (0, 4536)\n\n    See Also\n    ========\n\n    sympy.polys.galoistools.gf_crt2 : low level crt routine used by this routine\n    sympy.ntheory.modular.crt\n    sympy.ntheory.modular.crt1\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "solve_congruence",
    "full_id": "sympy.ntheory.modular.solve_congruence",
    "type": "function",
    "description": "Compute the integer ``n`` that has the residual ``ai`` when it is\n    divided by ``mi`` where the ``ai`` and ``mi`` are given as pairs to\n    this function: ((a1, m1), (a2, m2), ...). If there is no solution,\n    return None. Otherwise return ``n`` and its modulus.\n\n    The ``mi`` values need not be co-prime. If it is known that the moduli are\n    not co-prime then the hint ``check`` can be set to False (default=True) and\n    the check for a quicker solution via crt() (valid when the moduli are\n    co-prime) will be skipped.\n\n    If the hint ``symmetric`` is True (default is False), the value of ``n``\n    will be within 1/2 of the modulus, possibly negative.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.modular import solve_congruence\n\n    What number is 2 mod 3, 3 mod 5 and 2 mod 7?\n\n    >>> solve_congruence((2, 3), (3, 5), (2, 7))\n    (23, 105)\n    >>> [23 % m for m in [3, 5, 7]]\n    [2, 3, 2]\n\n    If you prefer to work with all remainder in one list and\n    all moduli in another, send the arguments like this:\n\n    >>> solve_congruence(*zip((2, 3, 2), (3, 5, 7)))\n    (23, 105)\n\n    The moduli need not be co-prime; in this case there may or\n    may not be a solution:\n\n    >>> solve_congruence((2, 3), (4, 6)) is None\n    True\n\n    >>> solve_congruence((2, 3), (5, 6))\n    (5, 6)\n\n    The symmetric flag will make the result be within 1/2 of the modulus:\n\n    >>> solve_congruence((2, 3), (5, 6), symmetric=True)\n    (-1, 6)\n\n    See Also\n    ========\n\n    crt : high level routine implementing the Chinese Remainder Theorem\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "binomial_coefficients",
    "full_id": "sympy.ntheory.multinomial.binomial_coefficients",
    "type": "function",
    "description": "Return a dictionary containing pairs :math:`{(k1,k2) : C_kn}` where\n    :math:`C_kn` are binomial coefficients and :math:`n=k1+k2`.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import binomial_coefficients\n    >>> binomial_coefficients(9)\n    {(0, 9): 1, (1, 8): 9, (2, 7): 36, (3, 6): 84,\n     (4, 5): 126, (5, 4): 126, (6, 3): 84, (7, 2): 36, (8, 1): 9, (9, 0): 1}\n\n    See Also\n    ========\n\n    binomial_coefficients_list, multinomial_coefficients\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "binomial_coefficients_list",
    "full_id": "sympy.ntheory.multinomial.binomial_coefficients_list",
    "type": "function",
    "description": "Return a list of binomial coefficients as rows of the Pascal's\n    triangle.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import binomial_coefficients_list\n    >>> binomial_coefficients_list(9)\n    [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\n\n    See Also\n    ========\n\n    binomial_coefficients, multinomial_coefficients\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "multinomial_coefficients",
    "full_id": "sympy.ntheory.multinomial.multinomial_coefficients",
    "type": "function",
    "description": "Return a dictionary containing pairs ``{(k1,k2,..,km) : C_kn}``\n    where ``C_kn`` are multinomial coefficients such that\n    ``n=k1+k2+..+km``.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import multinomial_coefficients\n    >>> multinomial_coefficients(2, 5) # indirect doctest\n    {(0, 5): 1, (1, 4): 5, (2, 3): 10, (3, 2): 10, (4, 1): 5, (5, 0): 1}\n\n    Notes\n    =====\n\n    The algorithm is based on the following result:\n\n    .. math::\n        \\binom{n}{k_1, \\ldots, k_m} =\n        \\frac{k_1 + 1}{n - k_1} \\sum_{i=2}^m \\binom{n}{k_1 + 1, \\ldots, k_i - 1, \\ldots}\n\n    Code contributed to Sage by Yann Laigle-Chapuy, copied with permission\n    of the author.\n\n    See Also\n    ========\n\n    binomial_coefficients_list, binomial_coefficients\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "multinomial_coefficients_iterator",
    "full_id": "sympy.ntheory.multinomial.multinomial_coefficients_iterator",
    "type": "function",
    "description": "multinomial coefficient iterator\n\n    This routine has been optimized for `m` large with respect to `n` by taking\n    advantage of the fact that when the monomial tuples `t` are stripped of\n    zeros, their coefficient is the same as that of the monomial tuples from\n    ``multinomial_coefficients(n, n)``. Therefore, the latter coefficients are\n    precomputed to save memory and time.\n\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients\n    >>> m53, m33 = multinomial_coefficients(5,3), multinomial_coefficients(3,3)\n    >>> m53[(0,0,0,1,2)] == m53[(0,0,1,0,2)] == m53[(1,0,2,0,0)] == m33[(0,1,2)]\n    True\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.multinomial import multinomial_coefficients_iterator\n    >>> it = multinomial_coefficients_iterator(20,3)\n    >>> next(it)\n    ((3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 1)\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "npartitions",
    "full_id": "sympy.ntheory.partitions_.npartitions",
    "type": "function",
    "description": "\n    Calculate the partition function P(n), i.e. the number of ways that\n    n can be written as a sum of positive integers.\n\n    .. deprecated:: 1.13\n\n        The ``npartitions`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.partition`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    P(n) is computed using the Hardy-Ramanujan-Rademacher formula [1]_.\n\n\n    The correctness of this implementation has been tested through $10^{10}$.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import partition\n    >>> partition(25)\n    1958\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/PartitionFunctionP.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_fermat_pseudoprime",
    "full_id": "sympy.ntheory.primetest.is_fermat_pseudoprime",
    "type": "function",
    "description": "Returns True if ``n`` is prime or is an odd composite integer that\n    is coprime to ``a`` and satisfy the modular arithmetic congruence relation:\n\n    .. math ::\n        a^{n-1} \\equiv 1 \\pmod{n}\n\n    (where mod refers to the modulo operation).\n\n    Parameters\n    ==========\n\n    n : Integer\n        ``n`` is a positive integer.\n    a : Integer\n        ``a`` is a positive integer.\n        ``a`` and ``n`` should be relatively prime.\n\n    Returns\n    =======\n\n    bool : If ``n`` is prime, it always returns ``True``.\n           The composite number that returns ``True`` is called an Fermat pseudoprime.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import is_fermat_pseudoprime\n    >>> from sympy.ntheory.factor_ import isprime\n    >>> for n in range(1, 1000):\n    ...     if is_fermat_pseudoprime(n, 2) and not isprime(n):\n    ...         print(n)\n    341\n    561\n    645\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Fermat_pseudoprime\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_euler_pseudoprime",
    "full_id": "sympy.ntheory.primetest.is_euler_pseudoprime",
    "type": "function",
    "description": "Returns True if ``n`` is prime or is an odd composite integer that\n    is coprime to ``a`` and satisfy the modular arithmetic congruence relation:\n\n    .. math ::\n        a^{(n-1)/2} \\equiv \\pm 1 \\pmod{n}\n\n    (where mod refers to the modulo operation).\n\n    Parameters\n    ==========\n\n    n : Integer\n        ``n`` is a positive integer.\n    a : Integer\n        ``a`` is a positive integer.\n        ``a`` and ``n`` should be relatively prime.\n\n    Returns\n    =======\n\n    bool : If ``n`` is prime, it always returns ``True``.\n           The composite number that returns ``True`` is called an Euler pseudoprime.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import is_euler_pseudoprime\n    >>> from sympy.ntheory.factor_ import isprime\n    >>> for n in range(1, 1000):\n    ...     if is_euler_pseudoprime(n, 2) and not isprime(n):\n    ...         print(n)\n    341\n    561\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Euler_pseudoprime\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_euler_jacobi_pseudoprime",
    "full_id": "sympy.ntheory.primetest.is_euler_jacobi_pseudoprime",
    "type": "function",
    "description": "Returns True if ``n`` is prime or is an odd composite integer that\n    is coprime to ``a`` and satisfy the modular arithmetic congruence relation:\n\n    .. math ::\n        a^{(n-1)/2} \\equiv \\left(\\frac{a}{n}\\right) \\pmod{n}\n\n    (where mod refers to the modulo operation).\n\n    Parameters\n    ==========\n\n    n : Integer\n        ``n`` is a positive integer.\n    a : Integer\n        ``a`` is a positive integer.\n        ``a`` and ``n`` should be relatively prime.\n\n    Returns\n    =======\n\n    bool : If ``n`` is prime, it always returns ``True``.\n           The composite number that returns ``True`` is called an Euler-Jacobi pseudoprime.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import is_euler_jacobi_pseudoprime\n    >>> from sympy.ntheory.factor_ import isprime\n    >>> for n in range(1, 1000):\n    ...     if is_euler_jacobi_pseudoprime(n, 2) and not isprime(n):\n    ...         print(n)\n    561\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Jacobi_pseudoprime\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_square",
    "full_id": "sympy.ntheory.primetest.is_square",
    "type": "function",
    "description": "Return True if n == a * a for some integer a, else False.\n    If n is suspected of *not* being a square then this is a\n    quick method of confirming that it is not.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import is_square\n    >>> is_square(25)\n    True\n    >>> is_square(2)\n    False\n\n    References\n    ==========\n\n    .. [1]  https://mersenneforum.org/showpost.php?p=110896\n\n    See Also\n    ========\n    sympy.core.intfunc.isqrt\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "mr",
    "full_id": "sympy.ntheory.primetest.mr",
    "type": "function",
    "description": "Perform a Miller-Rabin strong pseudoprime test on n using a\n    given list of bases/witnesses.\n\n    References\n    ==========\n\n    .. [1] Richard Crandall & Carl Pomerance (2005), \"Prime Numbers:\n           A Computational Perspective\", Springer, 2nd edition, 135-138\n\n    A list of thresholds and the bases they require are here:\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import mr\n    >>> mr(1373651, [2, 3])\n    False\n    >>> mr(479001599, [31, 73])\n    True\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_lucas_prp",
    "full_id": "sympy.ntheory.primetest.is_lucas_prp",
    "type": "function",
    "description": "Standard Lucas compositeness test with Selfridge parameters.  Returns\n    False if n is definitely composite, and True if n is a Lucas probable\n    prime.\n\n    This is typically used in combination with the Miller-Rabin test.\n\n    References\n    ==========\n    .. [1] Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes,\n           Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417,\n           https://doi.org/10.1090%2FS0025-5718-1980-0583518-6\n           http://mpqs.free.fr/LucasPseudoprimes.pdf\n    .. [2] OEIS A217120: Lucas Pseudoprimes\n           https://oeis.org/A217120\n    .. [3] https://en.wikipedia.org/wiki/Lucas_pseudoprime\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import isprime, is_lucas_prp\n    >>> for i in range(10000):\n    ...     if is_lucas_prp(i) and not isprime(i):\n    ...         print(i)\n    323\n    377\n    1159\n    1829\n    3827\n    5459\n    5777\n    9071\n    9179\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_strong_lucas_prp",
    "full_id": "sympy.ntheory.primetest.is_strong_lucas_prp",
    "type": "function",
    "description": "Strong Lucas compositeness test with Selfridge parameters.  Returns\n    False if n is definitely composite, and True if n is a strong Lucas\n    probable prime.\n\n    This is often used in combination with the Miller-Rabin test, and\n    in particular, when combined with M-R base 2 creates the strong BPSW test.\n\n    References\n    ==========\n    .. [1] Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes,\n           Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417,\n           https://doi.org/10.1090%2FS0025-5718-1980-0583518-6\n           http://mpqs.free.fr/LucasPseudoprimes.pdf\n    .. [2] OEIS A217255: Strong Lucas Pseudoprimes\n           https://oeis.org/A217255\n    .. [3] https://en.wikipedia.org/wiki/Lucas_pseudoprime\n    .. [4] https://en.wikipedia.org/wiki/Baillie-PSW_primality_test\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import isprime, is_strong_lucas_prp\n    >>> for i in range(20000):\n    ...     if is_strong_lucas_prp(i) and not isprime(i):\n    ...        print(i)\n    5459\n    5777\n    10877\n    16109\n    18971\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_extra_strong_lucas_prp",
    "full_id": "sympy.ntheory.primetest.is_extra_strong_lucas_prp",
    "type": "function",
    "description": "Extra Strong Lucas compositeness test.  Returns False if n is\n    definitely composite, and True if n is an \"extra strong\" Lucas probable\n    prime.\n\n    The parameters are selected using P = 3, Q = 1, then incrementing P until\n    (D|n) == -1.  The test itself is as defined in [1]_, from the\n    Mo and Jones preprint.  The parameter selection and test are the same as\n    used in OEIS A217719, Perl's Math::Prime::Util, and the Lucas pseudoprime\n    page on Wikipedia.\n\n    It is 20-50% faster than the strong test.\n\n    Because of the different parameters selected, there is no relationship\n    between the strong Lucas pseudoprimes and extra strong Lucas pseudoprimes.\n    In particular, one is not a subset of the other.\n\n    References\n    ==========\n    .. [1] Jon Grantham, Frobenius Pseudoprimes,\n           Math. Comp. Vol 70, Number 234 (2001), pp. 873-891,\n           https://doi.org/10.1090%2FS0025-5718-00-01197-2\n    .. [2] OEIS A217719: Extra Strong Lucas Pseudoprimes\n           https://oeis.org/A217719\n    .. [3] https://en.wikipedia.org/wiki/Lucas_pseudoprime\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import isprime, is_extra_strong_lucas_prp\n    >>> for i in range(20000):\n    ...     if is_extra_strong_lucas_prp(i) and not isprime(i):\n    ...        print(i)\n    989\n    3239\n    5777\n    10877\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "proth_test",
    "full_id": "sympy.ntheory.primetest.proth_test",
    "type": "function",
    "description": "Test if the Proth number `n = k2^m + 1` is prime. where k is a positive odd number and `2^m > k`.\n\n    Parameters\n    ==========\n\n    n : Integer\n        ``n`` is Proth number\n\n    Returns\n    =======\n\n    bool : If ``True``, then ``n`` is the Proth prime\n\n    Raises\n    ======\n\n    ValueError\n        If ``n`` is not Proth number.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.primetest import proth_test\n    >>> proth_test(41)\n    True\n    >>> proth_test(57)\n    False\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Proth_prime\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_mersenne_prime",
    "full_id": "sympy.ntheory.primetest.is_mersenne_prime",
    "type": "function",
    "description": "Returns True if  ``n`` is a Mersenne prime, else False.\n\n    A Mersenne prime is a prime number having the form `2^i - 1`.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.factor_ import is_mersenne_prime\n    >>> is_mersenne_prime(6)\n    False\n    >>> is_mersenne_prime(127)\n    True\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/MersennePrime.html\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "isprime",
    "full_id": "sympy.ntheory.primetest.isprime",
    "type": "function",
    "description": "\n    Test if n is a prime number (True) or not (False). For n < 2^64 the\n    answer is definitive; larger n values have a small probability of actually\n    being pseudoprimes.\n\n    Negative numbers (e.g. -2) are not considered prime.\n\n    The first step is looking for trivial factors, which if found enables\n    a quick return.  Next, if the sieve is large enough, use bisection search\n    on the sieve.  For small numbers, a set of deterministic Miller-Rabin\n    tests are performed with bases that are known to have no counterexamples\n    in their range.  Finally if the number is larger than 2^64, a strong\n    BPSW test is performed.  While this is a probable prime test and we\n    believe counterexamples exist, there are no known counterexamples.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import isprime\n    >>> isprime(13)\n    True\n    >>> isprime(15)\n    False\n\n    Notes\n    =====\n\n    This routine is intended only for integer input, not numerical\n    expressions which may represent numbers. Floats are also\n    rejected as input because they represent numbers of limited\n    precision. While it is tempting to permit 7.0 to represent an\n    integer there are errors that may \"pass silently\" if this is\n    allowed:\n\n    >>> from sympy import Float, S\n    >>> int(1e3) == 1e3 == 10**3\n    True\n    >>> int(1e23) == 1e23\n    True\n    >>> int(1e23) == 10**23\n    False\n\n    >>> near_int = 1 + S(1)/10**19\n    >>> near_int == int(near_int)\n    False\n    >>> n = Float(near_int, 10)  # truncated by precision\n    >>> n % 1 == 0\n    True\n    >>> n = Float(near_int, 20)\n    >>> n % 1 == 0\n    False\n\n    See Also\n    ========\n\n    sympy.ntheory.generate.primerange : Generates all primes in a given range\n    sympy.functions.combinatorial.numbers.primepi : Return the number of primes less than or equal to n\n    sympy.ntheory.generate.prime : Return the nth prime\n\n    References\n    ==========\n    .. [1] https://en.wikipedia.org/wiki/Strong_pseudoprime\n    .. [2] Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes,\n           Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417,\n           https://doi.org/10.1090%2FS0025-5718-1980-0583518-6\n           http://mpqs.free.fr/LucasPseudoprimes.pdf\n    .. [3] https://en.wikipedia.org/wiki/Baillie-PSW_primality_test\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_gaussian_prime",
    "full_id": "sympy.ntheory.primetest.is_gaussian_prime",
    "type": "function",
    "description": "Test if num is a Gaussian prime number.\n\n    References\n    ==========\n\n    .. [1] https://oeis.org/wiki/Gaussian_primes\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "n_order",
    "full_id": "sympy.ntheory.residue_ntheory.n_order",
    "type": "function",
    "description": "Returns the order of ``a`` modulo ``n``.\n\n    Explanation\n    ===========\n\n    The order of ``a`` modulo ``n`` is the smallest integer\n    ``k`` such that `a^k` leaves a remainder of 1 with ``n``.\n\n    Parameters\n    ==========\n\n    a : integer\n    n : integer, n > 1. a and n should be relatively prime\n\n    Returns\n    =======\n\n    int : the order of ``a`` modulo ``n``\n\n    Raises\n    ======\n\n    ValueError\n        If `n \\le 1` or `\\gcd(a, n) \\neq 1`.\n        If ``a`` or ``n`` is not an integer.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import n_order\n    >>> n_order(3, 7)\n    6\n    >>> n_order(4, 7)\n    3\n\n    See Also\n    ========\n\n    is_primitive_root\n        We say that ``a`` is a primitive root of ``n``\n        when the order of ``a`` modulo ``n`` equals ``totient(n)``\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_primitive_root",
    "full_id": "sympy.ntheory.residue_ntheory.is_primitive_root",
    "type": "function",
    "description": "Returns True if ``a`` is a primitive root of ``p``.\n\n    Explanation\n    ===========\n\n    ``a`` is said to be the primitive root of ``p`` if `\\gcd(a, p) = 1` and\n    `\\phi(p)` is the smallest positive number s.t.\n\n        `a^{\\phi(p)} \\equiv 1 \\pmod{p}`.\n\n    where `\\phi(p)` is Euler's totient function.\n\n    The primitive root of ``p`` exist only for\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\n    Hence, if it is not such a ``p``, it returns False.\n    To determine the primitive root, we need to know\n    the prime factorization of ``q-1``.\n    The hardness of the determination depends on this complexity.\n\n    Parameters\n    ==========\n\n    a : integer\n    p : integer, ``p`` > 1. ``a`` and ``p`` should be relatively prime\n\n    Returns\n    =======\n\n    bool : If True, ``a`` is the primitive root of ``p``.\n\n    Raises\n    ======\n\n    ValueError\n        If `p \\le 1` or `\\gcd(a, p) \\neq 1`.\n        If ``a`` or ``p`` is not an integer.\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import totient\n    >>> from sympy.ntheory import is_primitive_root, n_order\n    >>> is_primitive_root(3, 10)\n    True\n    >>> is_primitive_root(9, 10)\n    False\n    >>> n_order(3, 10) == totient(10)\n    True\n    >>> n_order(9, 10) == totient(10)\n    False\n\n    See Also\n    ========\n\n    primitive_root\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "primitive_root",
    "full_id": "sympy.ntheory.residue_ntheory.primitive_root",
    "type": "function",
    "description": "Returns a primitive root of ``p`` or None.\n\n    Explanation\n    ===========\n\n    For the definition of primitive root,\n    see the explanation of ``is_primitive_root``.\n\n    The primitive root of ``p`` exist only for\n    `p = 2, 4, q^e, 2q^e` (``q`` is an odd prime).\n    Now, if we know the primitive root of ``q``,\n    we can calculate the primitive root of `q^e`,\n    and if we know the primitive root of `q^e`,\n    we can calculate the primitive root of `2q^e`.\n    When there is no need to find the smallest primitive root,\n    this property can be used to obtain a fast primitive root.\n    On the other hand, when we want the smallest primitive root,\n    we naively determine whether it is a primitive root or not.\n\n    Parameters\n    ==========\n\n    p : integer, p > 1\n    smallest : if True the smallest primitive root is returned or None\n\n    Returns\n    =======\n\n    int | None :\n        If the primitive root exists, return the primitive root of ``p``.\n        If not, return None.\n\n    Raises\n    ======\n\n    ValueError\n        If `p \\le 1` or ``p`` is not an integer.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import primitive_root\n    >>> primitive_root(19)\n    2\n    >>> primitive_root(21) is None\n    True\n    >>> primitive_root(50, smallest=False)\n    27\n\n    See Also\n    ========\n\n    is_primitive_root\n\n    References\n    ==========\n\n    .. [1] W. Stein \"Elementary Number Theory\" (2011), page 44\n    .. [2] P. Hackman \"Elementary Number Theory\" (2009), Chapter C\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "sqrt_mod",
    "full_id": "sympy.ntheory.residue_ntheory.sqrt_mod",
    "type": "function",
    "description": "\n    Find a root of ``x**2 = a mod p``.\n\n    Parameters\n    ==========\n\n    a : integer\n    p : positive integer\n    all_roots : if True the list of roots is returned or None\n\n    Notes\n    =====\n\n    If there is no root it is returned None; else the returned root\n    is less or equal to ``p // 2``; in general is not the smallest one.\n    It is returned ``p // 2`` only if it is the only root.\n\n    Use ``all_roots`` only when it is expected that all the roots fit\n    in memory; otherwise use ``sqrt_mod_iter``.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import sqrt_mod\n    >>> sqrt_mod(11, 43)\n    21\n    >>> sqrt_mod(17, 32, True)\n    [7, 9, 23, 25]\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "sqrt_mod_iter",
    "full_id": "sympy.ntheory.residue_ntheory.sqrt_mod_iter",
    "type": "function",
    "description": "\n    Iterate over solutions to ``x**2 = a mod p``.\n\n    Parameters\n    ==========\n\n    a : integer\n    p : positive integer\n    domain : integer domain, ``int``, ``ZZ`` or ``Integer``\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter\n    >>> list(sqrt_mod_iter(11, 43))\n    [21, 22]\n\n    See Also\n    ========\n\n    sqrt_mod : Same functionality, but you want a sorted list or only one solution.\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "quadratic_residues",
    "full_id": "sympy.ntheory.residue_ntheory.quadratic_residues",
    "type": "function",
    "description": "\n    Returns the list of quadratic residues.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import quadratic_residues\n    >>> quadratic_residues(7)\n    [0, 1, 2, 4]\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "nthroot_mod",
    "full_id": "sympy.ntheory.residue_ntheory.nthroot_mod",
    "type": "function",
    "description": "\n    Find the solutions to ``x**n = a mod p``.\n\n    Parameters\n    ==========\n\n    a : integer\n    n : positive integer\n    p : positive integer\n    all_roots : if False returns the smallest root, else the list of roots\n\n    Returns\n    =======\n\n        list[int] | int | None :\n            solutions to ``x**n = a mod p``.\n            The table of the output type is:\n\n            ========== ========== ==========\n            all_roots  has roots  Returns\n            ========== ========== ==========\n            True       Yes        list[int]\n            True       No         []\n            False      Yes        int\n            False      No         None\n            ========== ========== ==========\n\n    Raises\n    ======\n\n        ValueError\n            If ``a``, ``n`` or ``p`` is not integer.\n            If ``n`` or ``p`` is not positive.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import nthroot_mod\n    >>> nthroot_mod(11, 4, 19)\n    8\n    >>> nthroot_mod(11, 4, 19, True)\n    [8, 11]\n    >>> nthroot_mod(68, 3, 109)\n    23\n\n    References\n    ==========\n\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_nthpow_residue",
    "full_id": "sympy.ntheory.residue_ntheory.is_nthpow_residue",
    "type": "function",
    "description": "\n    Returns True if ``x**n == a (mod m)`` has solutions.\n\n    References\n    ==========\n\n    .. [1] P. Hackman \"Elementary Number Theory\" (2009), page 76\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_quad_residue",
    "full_id": "sympy.ntheory.residue_ntheory.is_quad_residue",
    "type": "function",
    "description": "\n    Returns True if ``a`` (mod ``p``) is in the set of squares mod ``p``,\n    i.e a % p in set([i**2 % p for i in range(p)]).\n\n    Parameters\n    ==========\n\n    a : integer\n    p : positive integer\n\n    Returns\n    =======\n\n    bool : If True, ``x**2 == a (mod p)`` has solution.\n\n    Raises\n    ======\n\n    ValueError\n        If ``a``, ``p`` is not integer.\n        If ``p`` is not positive.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import is_quad_residue\n    >>> is_quad_residue(21, 100)\n    True\n\n    Indeed, ``pow(39, 2, 100)`` would be 21.\n\n    >>> is_quad_residue(21, 120)\n    False\n\n    That is, for any integer ``x``, ``pow(x, 2, 120)`` is not 21.\n\n    If ``p`` is an odd\n    prime, an iterative method is used to make the determination:\n\n    >>> from sympy.ntheory import is_quad_residue\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\n    [0, 1, 2, 4]\n    >>> [j for j in range(7) if is_quad_residue(j, 7)]\n    [0, 1, 2, 4]\n\n    See Also\n    ========\n\n    legendre_symbol, jacobi_symbol, sqrt_mod\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "legendre_symbol",
    "full_id": "sympy.ntheory.residue_ntheory.legendre_symbol",
    "type": "function",
    "description": "\n    Returns the Legendre symbol `(a / p)`.\n\n    .. deprecated:: 1.13\n\n        The ``legendre_symbol`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.legendre_symbol`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    For an integer ``a`` and an odd prime ``p``, the Legendre symbol is\n    defined as\n\n    .. math ::\n        \\genfrac(){}{}{a}{p} = \\begin{cases}\n             0 & \\text{if } p \\text{ divides } a\\\\\n             1 & \\text{if } a \\text{ is a quadratic residue modulo } p\\\\\n            -1 & \\text{if } a \\text{ is a quadratic nonresidue modulo } p\n        \\end{cases}\n\n    Parameters\n    ==========\n\n    a : integer\n    p : odd prime\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import legendre_symbol\n    >>> [legendre_symbol(i, 7) for i in range(7)]\n    [0, 1, 1, -1, 1, -1, -1]\n    >>> sorted(set([i**2 % 7 for i in range(7)]))\n    [0, 1, 2, 4]\n\n    See Also\n    ========\n\n    is_quad_residue, jacobi_symbol\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "jacobi_symbol",
    "full_id": "sympy.ntheory.residue_ntheory.jacobi_symbol",
    "type": "function",
    "description": "\n    Returns the Jacobi symbol `(m / n)`.\n\n    .. deprecated:: 1.13\n\n        The ``jacobi_symbol`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.jacobi_symbol`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    For any integer ``m`` and any positive odd integer ``n`` the Jacobi symbol\n    is defined as the product of the Legendre symbols corresponding to the\n    prime factors of ``n``:\n\n    .. math ::\n        \\genfrac(){}{}{m}{n} =\n            \\genfrac(){}{}{m}{p^{1}}^{\\alpha_1}\n            \\genfrac(){}{}{m}{p^{2}}^{\\alpha_2}\n            ...\n            \\genfrac(){}{}{m}{p^{k}}^{\\alpha_k}\n            \\text{ where } n =\n                p_1^{\\alpha_1}\n                p_2^{\\alpha_2}\n                ...\n                p_k^{\\alpha_k}\n\n    Like the Legendre symbol, if the Jacobi symbol `\\genfrac(){}{}{m}{n} = -1`\n    then ``m`` is a quadratic nonresidue modulo ``n``.\n\n    But, unlike the Legendre symbol, if the Jacobi symbol\n    `\\genfrac(){}{}{m}{n} = 1` then ``m`` may or may not be a quadratic residue\n    modulo ``n``.\n\n    Parameters\n    ==========\n\n    m : integer\n    n : odd positive integer\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import jacobi_symbol, legendre_symbol\n    >>> from sympy import S\n    >>> jacobi_symbol(45, 77)\n    -1\n    >>> jacobi_symbol(60, 121)\n    1\n\n    The relationship between the ``jacobi_symbol`` and ``legendre_symbol`` can\n    be demonstrated as follows:\n\n    >>> L = legendre_symbol\n    >>> S(45).factors()\n    {3: 2, 5: 1}\n    >>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1\n    True\n\n    See Also\n    ========\n\n    is_quad_residue, legendre_symbol\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "mobius",
    "full_id": "sympy.ntheory.residue_ntheory.mobius",
    "type": "function",
    "description": "\n    Mobius function maps natural number to {-1, 0, 1}\n\n    .. deprecated:: 1.13\n\n        The ``mobius`` function is deprecated. Use :class:`sympy.functions.combinatorial.numbers.mobius`\n        instead. See its documentation for more information. See\n        :ref:`deprecated-ntheory-symbolic-functions` for details.\n\n    It is defined as follows:\n        1) `1` if `n = 1`.\n        2) `0` if `n` has a squared prime factor.\n        3) `(-1)^k` if `n` is a square-free positive integer with `k`\n           number of prime factors.\n\n    It is an important multiplicative function in number theory\n    and combinatorics.  It has applications in mathematical series,\n    algebraic number theory and also physics (Fermion operator has very\n    concrete realization with Mobius Function model).\n\n    Parameters\n    ==========\n\n    n : positive integer\n\n    Examples\n    ========\n\n    >>> from sympy.functions.combinatorial.numbers import mobius\n    >>> mobius(13*7)\n    1\n    >>> mobius(1)\n    1\n    >>> mobius(13*7*5)\n    -1\n    >>> mobius(13**2)\n    0\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/M%C3%B6bius_function\n    .. [2] Thomas Koshy \"Elementary Number Theory with Applications\"\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "discrete_log",
    "full_id": "sympy.ntheory.residue_ntheory.discrete_log",
    "type": "function",
    "description": "\n    Compute the discrete logarithm of ``a`` to the base ``b`` modulo ``n``.\n\n    This is a recursive function to reduce the discrete logarithm problem in\n    cyclic groups of composite order to the problem in cyclic groups of prime\n    order.\n\n    It employs different algorithms depending on the problem (subgroup order\n    size, prime order or not):\n\n        * Trial multiplication\n        * Baby-step giant-step\n        * Pollard's Rho\n        * Index Calculus\n        * Pohlig-Hellman\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import discrete_log\n    >>> discrete_log(41, 15, 7)\n    3\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/DiscreteLogarithm.html\n    .. [2] \"Handbook of applied cryptography\", Menezes, A. J., Van, O. P. C., &\n        Vanstone, S. A. (1997).\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "quadratic_congruence",
    "full_id": "sympy.ntheory.residue_ntheory.quadratic_congruence",
    "type": "function",
    "description": "\n    Find the solutions to `a x^2 + b x + c \\equiv 0 \\pmod{n}`.\n\n    Parameters\n    ==========\n\n    a : int\n    b : int\n    c : int\n    n : int\n        A positive integer.\n\n    Returns\n    =======\n\n    list[int] :\n        A sorted list of solutions. If no solution exists, ``[]``.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import quadratic_congruence\n    >>> quadratic_congruence(2, 5, 3, 7) # 2x^2 + 5x + 3 = 0 (mod 7)\n    [2, 6]\n    >>> quadratic_congruence(8, 6, 4, 15) # No solution\n    []\n\n    See Also\n    ========\n\n    polynomial_congruence : Solve the polynomial congruence\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "polynomial_congruence",
    "full_id": "sympy.ntheory.residue_ntheory.polynomial_congruence",
    "type": "function",
    "description": "\n    Find the solutions to a polynomial congruence equation modulo m.\n\n    Parameters\n    ==========\n\n    expr : integer coefficient polynomial\n    m : positive integer\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import polynomial_congruence\n    >>> from sympy.abc import x\n    >>> expr = x**6 - 2*x**5 -35\n    >>> polynomial_congruence(expr, 6125)\n    [3257]\n\n    See Also\n    ========\n\n    sympy.polys.galoistools.gf_csolve : low level solving routine used by this routine\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "binomial_mod",
    "full_id": "sympy.ntheory.residue_ntheory.binomial_mod",
    "type": "function",
    "description": "Compute ``binomial(n, m) % k``.\n\n    Explanation\n    ===========\n\n    Returns ``binomial(n, m) % k`` using a generalization of Lucas'\n    Theorem for prime powers given by Granville [1]_, in conjunction with\n    the Chinese Remainder Theorem.  The residue for each prime power\n    is calculated in time O(log^2(n) + q^4*log(n)log(p) + q^4*p*log^3(p)).\n\n    Parameters\n    ==========\n\n    n : an integer\n    m : an integer\n    k : a positive integer\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.residue_ntheory import binomial_mod\n    >>> binomial_mod(10, 2, 6)  # binomial(10, 2) = 45\n    3\n    >>> binomial_mod(17, 9, 10)  # binomial(17, 9) = 24310\n    0\n\n    References\n    ==========\n\n    .. [1] Binomial coefficients modulo prime powers, Andrew Granville,\n        Available: https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "continued_fraction",
    "full_id": "sympy.ntheory.continued_fraction.continued_fraction",
    "type": "function",
    "description": "Return the continued fraction representation of a Rational or\n    quadratic irrational.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.continued_fraction import continued_fraction\n    >>> from sympy import sqrt\n    >>> continued_fraction((1 + 2*sqrt(3))/5)\n    [0, 1, [8, 3, 34, 3]]\n\n    See Also\n    ========\n    continued_fraction_periodic, continued_fraction_reduce, continued_fraction_convergents\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "continued_fraction_convergents",
    "full_id": "sympy.ntheory.continued_fraction.continued_fraction_convergents",
    "type": "function",
    "description": "\n    Return an iterator over the convergents of a continued fraction (cf).\n\n    The parameter should be in either of the following to forms:\n    - A list of partial quotients, possibly with the last element being a list\n    of repeating partial quotients, such as might be returned by\n    continued_fraction and continued_fraction_periodic.\n    - An iterable returning successive partial quotients of the continued\n    fraction, such as might be returned by continued_fraction_iterator.\n\n    In computing the convergents, the continued fraction need not be strictly\n    in canonical form (all integers, all but the first positive).\n    Rational and negative elements may be present in the expansion.\n\n    Examples\n    ========\n\n    >>> from sympy.core import pi\n    >>> from sympy import S\n    >>> from sympy.ntheory.continued_fraction import             continued_fraction_convergents, continued_fraction_iterator\n\n    >>> list(continued_fraction_convergents([0, 2, 1, 2]))\n    [0, 1/2, 1/3, 3/8]\n\n    >>> list(continued_fraction_convergents([1, S('1/2'), -7, S('1/4')]))\n    [1, 3, 19/5, 7]\n\n    >>> it = continued_fraction_convergents(continued_fraction_iterator(pi))\n    >>> for n in range(7):\n    ...     print(next(it))\n    3\n    22/7\n    333/106\n    355/113\n    103993/33102\n    104348/33215\n    208341/66317\n\n    >>> it = continued_fraction_convergents([1, [1, 2]])  # sqrt(3)\n    >>> for n in range(7):\n    ...     print(next(it))\n    1\n    2\n    5/3\n    7/4\n    19/11\n    26/15\n    71/41\n\n    See Also\n    ========\n\n    continued_fraction_iterator, continued_fraction, continued_fraction_periodic\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "continued_fraction_iterator",
    "full_id": "sympy.ntheory.continued_fraction.continued_fraction_iterator",
    "type": "function",
    "description": "\n    Return continued fraction expansion of x as iterator.\n\n    Examples\n    ========\n\n    >>> from sympy import Rational, pi\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_iterator\n\n    >>> list(continued_fraction_iterator(Rational(3, 8)))\n    [0, 2, 1, 2]\n    >>> list(continued_fraction_iterator(Rational(-3, 8)))\n    [-1, 1, 1, 1, 2]\n\n    >>> for i, v in enumerate(continued_fraction_iterator(pi)):\n    ...     if i > 7:\n    ...         break\n    ...     print(v)\n    3\n    7\n    15\n    1\n    292\n    1\n    1\n    1\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Continued_fraction\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "continued_fraction_periodic",
    "full_id": "sympy.ntheory.continued_fraction.continued_fraction_periodic",
    "type": "function",
    "description": "\n    Find the periodic continued fraction expansion of a quadratic irrational.\n\n    Compute the continued fraction expansion of a rational or a\n    quadratic irrational number, i.e. `\\frac{p + s\\sqrt{d}}{q}`, where\n    `p`, `q \\ne 0` and `d \\ge 0` are integers.\n\n    Returns the continued fraction representation (canonical form) as\n    a list of integers, optionally ending (for quadratic irrationals)\n    with list of integers representing the repeating digits.\n\n    Parameters\n    ==========\n\n    p : int\n        the rational part of the number's numerator\n    q : int\n        the denominator of the number\n    d : int, optional\n        the irrational part (discriminator) of the number's numerator\n    s : int, optional\n        the coefficient of the irrational part\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\n    >>> continued_fraction_periodic(3, 2, 7)\n    [2, [1, 4, 1, 1]]\n\n    Golden ratio has the simplest continued fraction expansion:\n\n    >>> continued_fraction_periodic(1, 2, 5)\n    [[1]]\n\n    If the discriminator is zero or a perfect square then the number will be a\n    rational number:\n\n    >>> continued_fraction_periodic(4, 3, 0)\n    [1, 3]\n    >>> continued_fraction_periodic(4, 3, 49)\n    [3, 1, 2]\n\n    See Also\n    ========\n\n    continued_fraction_iterator, continued_fraction_reduce\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Periodic_continued_fraction\n    .. [2] K. Rosen. Elementary Number theory and its applications.\n           Addison-Wesley, 3 Sub edition, pages 379-381, January 1992.\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "continued_fraction_reduce",
    "full_id": "sympy.ntheory.continued_fraction.continued_fraction_reduce",
    "type": "function",
    "description": "\n    Reduce a continued fraction to a rational or quadratic irrational.\n\n    Compute the rational or quadratic irrational number from its\n    terminating or periodic continued fraction expansion.  The\n    continued fraction expansion (cf) should be supplied as a\n    terminating iterator supplying the terms of the expansion.  For\n    terminating continued fractions, this is equivalent to\n    ``list(continued_fraction_convergents(cf))[-1]``, only a little more\n    efficient.  If the expansion has a repeating part, a list of the\n    repeating terms should be returned as the last element from the\n    iterator.  This is the format returned by\n    continued_fraction_periodic.\n\n    For quadratic irrationals, returns the largest solution found,\n    which is generally the one sought, if the fraction is in canonical\n    form (all terms positive except possibly the first).\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_reduce\n    >>> continued_fraction_reduce([1, 2, 3, 4, 5])\n    225/157\n    >>> continued_fraction_reduce([-2, 1, 9, 7, 1, 2])\n    -256/233\n    >>> continued_fraction_reduce([2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8]).n(10)\n    2.718281835\n    >>> continued_fraction_reduce([1, 4, 2, [3, 1]])\n    (sqrt(21) + 287)/238\n    >>> continued_fraction_reduce([[1]])\n    (1 + sqrt(5))/2\n    >>> from sympy.ntheory.continued_fraction import continued_fraction_periodic\n    >>> continued_fraction_reduce(continued_fraction_periodic(8, 5, 13))\n    (sqrt(13) + 8)/5\n\n    See Also\n    ========\n\n    continued_fraction_periodic\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "count_digits",
    "full_id": "sympy.ntheory.digits.count_digits",
    "type": "function",
    "description": "\n    Return a dictionary whose keys are the digits of ``n`` in the\n    given base, ``b``, with keys indicating the digits appearing in the\n    number and values indicating how many times that digit appeared.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import count_digits\n\n    >>> count_digits(1111339)\n    {1: 4, 3: 2, 9: 1}\n\n    The digits returned are always represented in base-10\n    but the number itself can be entered in any format that is\n    understood by Python; the base of the number can also be\n    given if it is different than 10:\n\n    >>> n = 0xFA; n\n    250\n    >>> count_digits(_)\n    {0: 1, 2: 1, 5: 1}\n    >>> count_digits(n, 16)\n    {10: 1, 15: 1}\n\n    The default dictionary will return a 0 for any digit that did\n    not appear in the number. For example, which digits appear 7\n    times in ``77!``:\n\n    >>> from sympy import factorial\n    >>> c77 = count_digits(factorial(77))\n    >>> [i for i in range(10) if c77[i] == 7]\n    [1, 3, 7, 9]\n\n    See Also\n    ========\n    sympy.core.intfunc.num_digits, digits\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "is_palindromic",
    "full_id": "sympy.ntheory.digits.is_palindromic",
    "type": "function",
    "description": "return True if ``n`` is the same when read from left to right\n    or right to left in the given base, ``b``.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import is_palindromic\n\n    >>> all(is_palindromic(i) for i in (-11, 1, 22, 121))\n    True\n\n    The second argument allows you to test numbers in other\n    bases. For example, 88 is palindromic in base-10 but not\n    in base-8:\n\n    >>> is_palindromic(88, 8)\n    False\n\n    On the other hand, a number can be palindromic in base-8 but\n    not in base-10:\n\n    >>> 0o121, is_palindromic(0o121)\n    (81, False)\n\n    Or it might be palindromic in both bases:\n\n    >>> oct(121), is_palindromic(121, 8) and is_palindromic(121)\n    ('0o171', True)\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "egyptian_fraction",
    "full_id": "sympy.ntheory.egyptian_fraction.egyptian_fraction",
    "type": "function",
    "description": "\n    Return the list of denominators of an Egyptian fraction\n    expansion [1]_ of the said rational `r`.\n\n    Parameters\n    ==========\n\n    r : Rational or (p, q)\n        a positive rational number, ``p/q``.\n    algorithm : { \"Greedy\", \"Graham Jewett\", \"Takenouchi\", \"Golomb\" }, optional\n        Denotes the algorithm to be used (the default is \"Greedy\").\n\n    Examples\n    ========\n\n    >>> from sympy import Rational\n    >>> from sympy.ntheory.egyptian_fraction import egyptian_fraction\n    >>> egyptian_fraction(Rational(3, 7))\n    [3, 11, 231]\n    >>> egyptian_fraction((3, 7), \"Graham Jewett\")\n    [7, 8, 9, 56, 57, 72, 3192]\n    >>> egyptian_fraction((3, 7), \"Takenouchi\")\n    [4, 7, 28]\n    >>> egyptian_fraction((3, 7), \"Golomb\")\n    [3, 15, 35]\n    >>> egyptian_fraction((11, 5), \"Golomb\")\n    [1, 2, 3, 4, 9, 234, 1118, 2580]\n\n    See Also\n    ========\n\n    sympy.core.numbers.Rational\n\n    Notes\n    =====\n\n    Currently the following algorithms are supported:\n\n    1) Greedy Algorithm\n\n       Also called the Fibonacci-Sylvester algorithm [2]_.\n       At each step, extract the largest unit fraction less\n       than the target and replace the target with the remainder.\n\n       It has some distinct properties:\n\n       a) Given `p/q` in lowest terms, generates an expansion of maximum\n          length `p`. Even as the numerators get large, the number of\n          terms is seldom more than a handful.\n\n       b) Uses minimal memory.\n\n       c) The terms can blow up (standard examples of this are 5/121 and\n          31/311).  The denominator is at most squared at each step\n          (doubly-exponential growth) and typically exhibits\n          singly-exponential growth.\n\n    2) Graham Jewett Algorithm\n\n       The algorithm suggested by the result of Graham and Jewett.\n       Note that this has a tendency to blow up: the length of the\n       resulting expansion is always ``2**(x/gcd(x, y)) - 1``.  See [3]_.\n\n    3) Takenouchi Algorithm\n\n       The algorithm suggested by Takenouchi (1921).\n       Differs from the Graham-Jewett algorithm only in the handling\n       of duplicates.  See [3]_.\n\n    4) Golomb's Algorithm\n\n       A method given by Golumb (1962), using modular arithmetic and\n       inverses.  It yields the same results as a method using continued\n       fractions proposed by Bleicher (1972).  See [4]_.\n\n    If the given rational is greater than or equal to 1, a greedy algorithm\n    of summing the harmonic sequence 1/1 + 1/2 + 1/3 + ... is used, taking\n    all the unit fractions of this sequence until adding one more would be\n    greater than the given number.  This list of denominators is prefixed\n    to the result from the requested algorithm used on the remainder.  For\n    example, if r is 8/3, using the Greedy algorithm, we get [1, 2, 3, 4,\n    5, 6, 7, 14, 420], where the beginning of the sequence, [1, 2, 3, 4, 5,\n    6, 7] is part of the harmonic sequence summing to 363/140, leaving a\n    remainder of 31/420, which yields [14, 420] by the Greedy algorithm.\n    The result of egyptian_fraction(Rational(8, 3), \"Golomb\") is [1, 2, 3,\n    4, 5, 6, 7, 14, 574, 2788, 6460, 11590, 33062, 113820], and so on.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Egyptian_fraction\n    .. [2] https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions\n    .. [3] https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html\n    .. [4] https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf\n\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "pi_hex_digits",
    "full_id": "sympy.ntheory.bbp_pi.pi_hex_digits",
    "type": "function",
    "description": "Returns a string containing ``prec`` (default 14) digits\n    starting at the nth digit of pi in hex. Counting of digits\n    starts at 0 and the decimal is not counted, so for n = 0 the\n    returned value starts with 3; n = 1 corresponds to the first\n    digit past the decimal point (which in hex is 2).\n\n    Parameters\n    ==========\n\n    n : non-negative integer\n    prec : non-negative integer. default = 14\n\n    Returns\n    =======\n\n    str : Returns a string containing ``prec`` digits\n          starting at the nth digit of pi in hex.\n          If ``prec`` = 0, returns empty string.\n\n    Raises\n    ======\n\n    ValueError\n        If ``n`` < 0 or ``prec`` < 0.\n        Or ``n`` or ``prec`` is not an integer.\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory.bbp_pi import pi_hex_digits\n    >>> pi_hex_digits(0)\n    '3243f6a8885a30'\n    >>> pi_hex_digits(0, 3)\n    '324'\n\n    These are consistent with the following results\n\n    >>> import math\n    >>> hex(int(math.pi * 2**((14-1)*4)))\n    '0x3243f6a8885a30'\n    >>> hex(int(math.pi * 2**((3-1)*4)))\n    '0x324'\n\n    References\n    ==========\n\n    .. [1] http://www.numberworld.org/digits/Pi/\n    ",
    "section": "Ntheory Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "ecm",
    "full_id": "sympy.ntheory.ecm.ecm",
    "type": "function",
    "description": "Performs factorization using Lenstra's Elliptic curve method.\n\n    This function repeatedly calls ``_ecm_one_factor`` to compute the factors\n    of n. First all the small factors are taken out using trial division.\n    Then ``_ecm_one_factor`` is used to compute one factor at a time.\n\n    Parameters\n    ==========\n\n    n : Number to be Factored\n    B1 : Stage 1 Bound. Must be an even number.\n    B2 : Stage 2 Bound. Must be an even number.\n    max_curve : Maximum number of curves generated\n    seed : Initialize pseudorandom generator\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import ecm\n    >>> ecm(25645121643901801)\n    {5394769, 4753701529}\n    >>> ecm(9804659461513846513)\n    {4641991, 2112166839943}\n    ",
    "section": "ECM function",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "qs",
    "full_id": "sympy.ntheory.qs.qs",
    "type": "function",
    "description": "Performs factorization using Self-Initializing Quadratic Sieve.\n    In SIQS, let N be a number to be factored, and this N should not be a\n    perfect power. If we find two integers such that ``X**2 = Y**2 modN`` and\n    ``X != +-Y modN``, then `gcd(X + Y, N)` will reveal a proper factor of N.\n    In order to find these integers X and Y we try to find relations of form\n    t**2 = u modN where u is a product of small primes. If we have enough of\n    these relations then we can form ``(t1*t2...ti)**2 = u1*u2...ui modN`` such that\n    the right hand side is a square, thus we found a relation of ``X**2 = Y**2 modN``.\n\n    Here, several optimizations are done like using multiple polynomials for\n    sieving, fast changing between polynomials and using partial relations.\n    The use of partial relations can speeds up the factoring by 2 times.\n\n    Parameters\n    ==========\n\n    N : Number to be Factored\n    prime_bound : upper bound for primes in the factor base\n    M : Sieve Interval\n    ERROR_TERM : Error term for checking smoothness\n    threshold : Extra smooth relations for factorization\n    seed : generate pseudo prime numbers\n\n    Examples\n    ========\n\n    >>> from sympy.ntheory import qs\n    >>> qs(25645121643901801, 2000, 10000)\n    {5394769, 4753701529}\n    >>> qs(9804659461513846513, 2000, 10000)\n    {4641991, 2112166839943}\n\n    References\n    ==========\n\n    .. [1] https://pdfs.semanticscholar.org/5c52/8a975c1405bd35c65993abf5a4edb667c1db.pdf\n    .. [2] https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve\n    ",
    "section": "QS function",
    "url": "https://docs.sympy.org/latest/modules/ntheory.html"
  },
  {
    "name": "E_nl",
    "full_id": "sympy.physics.hydrogen.E_nl",
    "type": "function",
    "description": "\n    Returns the energy of the state (n, l) in Hartree atomic units.\n\n    The energy does not depend on \"l\".\n\n    Parameters\n    ==========\n\n    n : integer\n        Principal Quantum Number which is\n        an integer with possible values as 1, 2, 3, 4,...\n    Z :\n        Atomic number (1 for Hydrogen, 2 for Helium, ...)\n\n    Examples\n    ========\n\n    >>> from sympy.physics.hydrogen import E_nl\n    >>> from sympy.abc import n, Z\n    >>> E_nl(n, Z)\n    -Z**2/(2*n**2)\n    >>> E_nl(1)\n    -1/2\n    >>> E_nl(2)\n    -1/8\n    >>> E_nl(3)\n    -1/18\n    >>> E_nl(3, 47)\n    -2209/18\n\n    ",
    "section": "Hydrogen Wavefunctions",
    "url": "https://docs.sympy.org/latest/modules/physics/hydrogen.html"
  },
  {
    "name": "E_nl_dirac",
    "full_id": "sympy.physics.hydrogen.E_nl_dirac",
    "type": "function",
    "description": "\n    Returns the relativistic energy of the state (n, l, spin) in Hartree atomic\n    units.\n\n    The energy is calculated from the Dirac equation. The rest mass energy is\n    *not* included.\n\n    Parameters\n    ==========\n\n    n : integer\n        Principal Quantum Number which is\n        an integer with possible values as 1, 2, 3, 4,...\n    l : integer\n        ``l`` is the Angular Momentum Quantum Number with\n        values ranging from 0 to ``n-1``.\n    spin_up :\n        True if the electron spin is up (default), otherwise down\n    Z :\n        Atomic number (1 for Hydrogen, 2 for Helium, ...)\n    c :\n        Speed of light in atomic units. Default value is 137.035999037,\n        taken from https://arxiv.org/abs/1012.3627\n\n    Examples\n    ========\n\n    >>> from sympy.physics.hydrogen import E_nl_dirac\n    >>> E_nl_dirac(1, 0)\n    -0.500006656595360\n\n    >>> E_nl_dirac(2, 0)\n    -0.125002080189006\n    >>> E_nl_dirac(2, 1)\n    -0.125000416028342\n    >>> E_nl_dirac(2, 1, False)\n    -0.125002080189006\n\n    >>> E_nl_dirac(3, 0)\n    -0.0555562951740285\n    >>> E_nl_dirac(3, 1)\n    -0.0555558020932949\n    >>> E_nl_dirac(3, 1, False)\n    -0.0555562951740285\n    >>> E_nl_dirac(3, 2)\n    -0.0555556377366884\n    >>> E_nl_dirac(3, 2, False)\n    -0.0555558020932949\n\n    ",
    "section": "Hydrogen Wavefunctions",
    "url": "https://docs.sympy.org/latest/modules/physics/hydrogen.html"
  },
  {
    "name": "Psi_nlm",
    "full_id": "sympy.physics.hydrogen.Psi_nlm",
    "type": "function",
    "description": "\n    Returns the Hydrogen wave function psi_{nlm}. It's the product of\n    the radial wavefunction R_{nl} and the spherical harmonic Y_{l}^{m}.\n\n    Parameters\n    ==========\n\n    n : integer\n        Principal Quantum Number which is\n        an integer with possible values as 1, 2, 3, 4,...\n    l : integer\n        ``l`` is the Angular Momentum Quantum Number with\n        values ranging from 0 to ``n-1``.\n    m : integer\n        ``m`` is the Magnetic Quantum Number with values\n        ranging from ``-l`` to ``l``.\n    r :\n        radial coordinate\n    phi :\n        azimuthal angle\n    theta :\n        polar angle\n    Z :\n        atomic number (1 for Hydrogen, 2 for Helium, ...)\n\n    Everything is in Hartree atomic units.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.hydrogen import Psi_nlm\n    >>> from sympy import Symbol\n    >>> r=Symbol(\"r\", positive=True)\n    >>> phi=Symbol(\"phi\", real=True)\n    >>> theta=Symbol(\"theta\", real=True)\n    >>> Z=Symbol(\"Z\", positive=True, integer=True, nonzero=True)\n    >>> Psi_nlm(1,0,0,r,phi,theta,Z)\n    Z**(3/2)*exp(-Z*r)/sqrt(pi)\n    >>> Psi_nlm(2,1,1,r,phi,theta,Z)\n    -Z**(5/2)*r*exp(I*phi)*exp(-Z*r/2)*sin(theta)/(8*sqrt(pi))\n\n    Integrating the absolute square of a hydrogen wavefunction psi_{nlm}\n    over the whole space leads 1.\n\n    The normalization of the hydrogen wavefunctions Psi_nlm is:\n\n    >>> from sympy import integrate, conjugate, pi, oo, sin\n    >>> wf=Psi_nlm(2,1,1,r,phi,theta,Z)\n    >>> abs_sqrd=wf*conjugate(wf)\n    >>> jacobi=r**2*sin(theta)\n    >>> integrate(abs_sqrd*jacobi, (r,0,oo), (phi,0,2*pi), (theta,0,pi))\n    1\n    ",
    "section": "Hydrogen Wavefunctions",
    "url": "https://docs.sympy.org/latest/modules/physics/hydrogen.html"
  },
  {
    "name": "R_nl",
    "full_id": "sympy.physics.hydrogen.R_nl",
    "type": "function",
    "description": "\n    Returns the Hydrogen radial wavefunction R_{nl}.\n\n    Parameters\n    ==========\n\n    n : integer\n        Principal Quantum Number which is\n        an integer with possible values as 1, 2, 3, 4,...\n    l : integer\n        ``l`` is the Angular Momentum Quantum Number with\n        values ranging from 0 to ``n-1``.\n    r :\n        Radial coordinate.\n    Z :\n        Atomic number (1 for Hydrogen, 2 for Helium, ...)\n\n    Everything is in Hartree atomic units.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.hydrogen import R_nl\n    >>> from sympy.abc import r, Z\n    >>> R_nl(1, 0, r, Z)\n    2*sqrt(Z**3)*exp(-Z*r)\n    >>> R_nl(2, 0, r, Z)\n    sqrt(2)*(-Z*r + 2)*sqrt(Z**3)*exp(-Z*r/2)/4\n    >>> R_nl(2, 1, r, Z)\n    sqrt(6)*Z*r*sqrt(Z**3)*exp(-Z*r/2)/12\n\n    For Hydrogen atom, you can just use the default value of Z=1:\n\n    >>> R_nl(1, 0, r)\n    2*exp(-r)\n    >>> R_nl(2, 0, r)\n    sqrt(2)*(2 - r)*exp(-r/2)/4\n    >>> R_nl(3, 0, r)\n    2*sqrt(3)*(2*r**2/9 - 2*r + 3)*exp(-r/3)/27\n\n    For Silver atom, you would use Z=47:\n\n    >>> R_nl(1, 0, r, Z=47)\n    94*sqrt(47)*exp(-47*r)\n    >>> R_nl(2, 0, r, Z=47)\n    47*sqrt(94)*(2 - 47*r)*exp(-47*r/2)/4\n    >>> R_nl(3, 0, r, Z=47)\n    94*sqrt(141)*(4418*r**2/9 - 94*r + 3)*exp(-47*r/3)/27\n\n    The normalization of the radial wavefunction is:\n\n    >>> from sympy import integrate, oo\n    >>> integrate(R_nl(1, 0, r)**2 * r**2, (r, 0, oo))\n    1\n    >>> integrate(R_nl(2, 0, r)**2 * r**2, (r, 0, oo))\n    1\n    >>> integrate(R_nl(2, 1, r)**2 * r**2, (r, 0, oo))\n    1\n\n    It holds for any atomic number:\n\n    >>> integrate(R_nl(1, 0, r, Z=2)**2 * r**2, (r, 0, oo))\n    1\n    >>> integrate(R_nl(2, 0, r, Z=3)**2 * r**2, (r, 0, oo))\n    1\n    >>> integrate(R_nl(2, 1, r, Z=4)**2 * r**2, (r, 0, oo))\n    1\n\n    ",
    "section": "Hydrogen Wavefunctions",
    "url": "https://docs.sympy.org/latest/modules/physics/hydrogen.html"
  },
  {
    "name": "mdft",
    "full_id": "sympy.physics.matrices.mdft",
    "type": "function",
    "description": "\n    .. deprecated:: 1.9\n\n       Use DFT from sympy.matrices.expressions.fourier instead.\n\n       To get identical behavior to ``mdft(n)``, use ``DFT(n).as_explicit()``.\n    ",
    "section": "Matrices",
    "url": "https://docs.sympy.org/latest/modules/physics/matrices.html"
  },
  {
    "name": "mgamma",
    "full_id": "sympy.physics.matrices.mgamma",
    "type": "function",
    "description": "Returns a Dirac gamma matrix `\\gamma^\\mu` in the standard\n    (Dirac) representation.\n\n    Explanation\n    ===========\n\n    If you want `\\gamma_\\mu`, use ``gamma(mu, True)``.\n\n    We use a convention:\n\n    `\\gamma^5 = i \\cdot \\gamma^0 \\cdot \\gamma^1 \\cdot \\gamma^2 \\cdot \\gamma^3`\n\n    `\\gamma_5 = i \\cdot \\gamma_0 \\cdot \\gamma_1 \\cdot \\gamma_2 \\cdot \\gamma_3 = - \\gamma^5`\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gamma_matrices\n\n    Examples\n    ========\n\n    >>> from sympy.physics.matrices import mgamma\n    >>> mgamma(1)\n    Matrix([\n    [ 0,  0, 0, 1],\n    [ 0,  0, 1, 0],\n    [ 0, -1, 0, 0],\n    [-1,  0, 0, 0]])\n    ",
    "section": "Matrices",
    "url": "https://docs.sympy.org/latest/modules/physics/matrices.html"
  },
  {
    "name": "msigma",
    "full_id": "sympy.physics.matrices.msigma",
    "type": "function",
    "description": "Returns a Pauli matrix `\\sigma_i` with `i=1,2,3`.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Pauli_matrices\n\n    Examples\n    ========\n\n    >>> from sympy.physics.matrices import msigma\n    >>> msigma(1)\n    Matrix([\n    [0, 1],\n    [1, 0]])\n    ",
    "section": "Matrices",
    "url": "https://docs.sympy.org/latest/modules/physics/matrices.html"
  },
  {
    "name": "pat_matrix",
    "full_id": "sympy.physics.matrices.pat_matrix",
    "type": "function",
    "description": "Returns the Parallel Axis Theorem matrix to translate the inertia\n    matrix a distance of `(dx, dy, dz)` for a body of mass m.\n\n    Examples\n    ========\n\n    To translate a body having a mass of 2 units a distance of 1 unit along\n    the `x`-axis we get:\n\n    >>> from sympy.physics.matrices import pat_matrix\n    >>> pat_matrix(2, 1, 0, 0)\n    Matrix([\n    [0, 0, 0],\n    [0, 2, 0],\n    [0, 0, 2]])\n\n    ",
    "section": "Matrices",
    "url": "https://docs.sympy.org/latest/modules/physics/matrices.html"
  },
  {
    "name": "evaluate_pauli_product",
    "full_id": "sympy.physics.paulialgebra.evaluate_pauli_product",
    "type": "function",
    "description": "Help function to evaluate Pauli matrices product\n    with symbolic objects.\n\n    Parameters\n    ==========\n\n    arg: symbolic expression that contains Paulimatrices\n\n    Examples\n    ========\n\n    >>> from sympy.physics.paulialgebra import Pauli, evaluate_pauli_product\n    >>> from sympy import I\n    >>> evaluate_pauli_product(I*Pauli(1)*Pauli(2))\n    -sigma3\n\n    >>> from sympy.abc import x\n    >>> evaluate_pauli_product(x**2*Pauli(2)*Pauli(1))\n    -I*x**2*sigma3\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/paulialgebra.html"
  },
  {
    "name": "E_n",
    "full_id": "sympy.physics.qho_1d.E_n",
    "type": "function",
    "description": "\n    Returns the Energy of the One-dimensional harmonic oscillator.\n\n    Parameters\n    ==========\n\n    n :\n        The \"nodal\" quantum number.\n    omega :\n        The harmonic oscillator angular frequency.\n\n    Notes\n    =====\n\n    The unit of the returned value matches the unit of hw, since the energy is\n    calculated as:\n\n        E_n = hbar * omega*(n + 1/2)\n\n    Examples\n    ========\n\n    >>> from sympy.physics.qho_1d import E_n\n    >>> from sympy.abc import x, omega\n    >>> E_n(x, omega)\n    hbar*omega*(x + 1/2)\n    ",
    "section": "Quantum Harmonic Oscillator in 1-D",
    "url": "https://docs.sympy.org/latest/modules/physics/qho_1d.html"
  },
  {
    "name": "coherent_state",
    "full_id": "sympy.physics.qho_1d.coherent_state",
    "type": "function",
    "description": "\n    Returns <n|alpha> for the coherent states of 1D harmonic oscillator.\n    See https://en.wikipedia.org/wiki/Coherent_states\n\n    Parameters\n    ==========\n\n    n :\n        The \"nodal\" quantum number.\n    alpha :\n        The eigen value of annihilation operator.\n    ",
    "section": "Quantum Harmonic Oscillator in 1-D",
    "url": "https://docs.sympy.org/latest/modules/physics/qho_1d.html"
  },
  {
    "name": "psi_n",
    "full_id": "sympy.physics.qho_1d.psi_n",
    "type": "function",
    "description": "\n    Returns the wavefunction psi_{n} for the One-dimensional harmonic oscillator.\n\n    Parameters\n    ==========\n\n    n :\n        the \"nodal\" quantum number.  Corresponds to the number of nodes in the\n        wavefunction.  ``n >= 0``\n    x :\n        x coordinate.\n    m :\n        Mass of the particle.\n    omega :\n        Angular frequency of the oscillator.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.qho_1d import psi_n\n    >>> from sympy.abc import m, x, omega\n    >>> psi_n(0, x, m, omega)\n    (m*omega)**(1/4)*exp(-m*omega*x**2/(2*hbar))/(hbar**(1/4)*pi**(1/4))\n\n    ",
    "section": "Quantum Harmonic Oscillator in 1-D",
    "url": "https://docs.sympy.org/latest/modules/physics/qho_1d.html"
  },
  {
    "name": "E_nl",
    "full_id": "sympy.physics.sho.E_nl",
    "type": "function",
    "description": "\n    Returns the Energy of an isotropic harmonic oscillator.\n\n    Parameters\n    ==========\n\n    n :\n        The \"nodal\" quantum number.\n    l :\n        The orbital angular momentum.\n    hw :\n        The harmonic oscillator parameter.\n\n    Notes\n    =====\n\n    The unit of the returned value matches the unit of hw, since the energy is\n    calculated as:\n\n        E_nl = (2*n + l + 3/2)*hw\n\n    Examples\n    ========\n\n    >>> from sympy.physics.sho import E_nl\n    >>> from sympy import symbols\n    >>> x, y, z = symbols('x, y, z')\n    >>> E_nl(x, y, z)\n    z*(2*x + y + 3/2)\n    ",
    "section": "Quantum Harmonic Oscillator in 3-D",
    "url": "https://docs.sympy.org/latest/modules/physics/sho.html"
  },
  {
    "name": "R_nl",
    "full_id": "sympy.physics.sho.R_nl",
    "type": "function",
    "description": "\n    Returns the radial wavefunction R_{nl} for a 3d isotropic harmonic\n    oscillator.\n\n    Parameters\n    ==========\n\n    n :\n        The \"nodal\" quantum number.  Corresponds to the number of nodes in\n        the wavefunction.  ``n >= 0``\n    l :\n        The quantum number for orbital angular momentum.\n    nu :\n        mass-scaled frequency: nu = m*omega/(2*hbar) where `m` is the mass\n        and `omega` the frequency of the oscillator.\n        (in atomic units ``nu == omega/2``)\n    r :\n        Radial coordinate.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.sho import R_nl\n    >>> from sympy.abc import r, nu, l\n    >>> R_nl(0, 0, 1, r)\n    2*2**(3/4)*exp(-r**2)/pi**(1/4)\n    >>> R_nl(1, 0, 1, r)\n    4*2**(1/4)*sqrt(3)*(3/2 - 2*r**2)*exp(-r**2)/(3*pi**(1/4))\n\n    l, nu and r may be symbolic:\n\n    >>> R_nl(0, 0, nu, r)\n    2*2**(3/4)*sqrt(nu**(3/2))*exp(-nu*r**2)/pi**(1/4)\n    >>> R_nl(0, l, 1, r)\n    r**l*sqrt(2**(l + 3/2)*2**(l + 2)/factorial2(2*l + 1))*exp(-r**2)/pi**(1/4)\n\n    The normalization of the radial wavefunction is:\n\n    >>> from sympy import Integral, oo\n    >>> Integral(R_nl(0, 0, 1, r)**2*r**2, (r, 0, oo)).n()\n    1.00000000000000\n    >>> Integral(R_nl(1, 0, 1, r)**2*r**2, (r, 0, oo)).n()\n    1.00000000000000\n    >>> Integral(R_nl(1, 1, 1, r)**2*r**2, (r, 0, oo)).n()\n    1.00000000000000\n\n    ",
    "section": "Quantum Harmonic Oscillator in 3-D",
    "url": "https://docs.sympy.org/latest/modules/physics/sho.html"
  },
  {
    "name": "apply_operator",
    "full_id": "sympy.physics.secondquant.AnnihilateBoson.apply_operator",
    "type": "method",
    "description": "\n        Apply state to self if self is not symbolic and state is a FockStateKet, else\n        multiply self by state.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.secondquant import B, BKet\n        >>> from sympy.abc import x, y, n\n        >>> B(x).apply_operator(y)\n        y*AnnihilateBoson(x)\n        >>> B(0).apply_operator(BKet((n,)))\n        sqrt(n)*FockStateBosonKet((n - 1,))\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "apply_operator",
    "full_id": "sympy.physics.secondquant.AnnihilateFermion.apply_operator",
    "type": "method",
    "description": "\n        Apply state to self if self is not symbolic and state is a FockStateKet, else\n        multiply self by state.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.secondquant import B, Dagger, BKet\n        >>> from sympy.abc import x, y, n\n        >>> Dagger(B(x)).apply_operator(y)\n        y*CreateBoson(x)\n        >>> B(0).apply_operator(BKet((n,)))\n        sqrt(n)*FockStateBosonKet((n - 1,))\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "is_only_q_annihilator",
    "full_id": "sympy.physics.secondquant.AnnihilateFermion.is_only_q_annihilator",
    "type": "property",
    "description": "\n        Always destroy a quasi-particle?  (annihilate hole or annihilate particle)\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.physics.secondquant import F\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n\n        >>> F(a).is_only_q_annihilator\n        True\n        >>> F(i).is_only_q_annihilator\n        False\n        >>> F(p).is_only_q_annihilator\n        False\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "is_only_q_creator",
    "full_id": "sympy.physics.secondquant.AnnihilateFermion.is_only_q_creator",
    "type": "property",
    "description": "\n        Always create a quasi-particle?  (create hole or create particle)\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.physics.secondquant import F\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n\n        >>> F(a).is_only_q_creator\n        False\n        >>> F(i).is_only_q_creator\n        True\n        >>> F(p).is_only_q_creator\n        False\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "is_q_annihilator",
    "full_id": "sympy.physics.secondquant.AnnihilateFermion.is_q_annihilator",
    "type": "property",
    "description": "\n        Can we destroy a quasi-particle?  (annihilate hole or annihilate particle)\n        If so, would that be above or below the fermi surface?\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.physics.secondquant import F\n        >>> a = Symbol('a', above_fermi=1)\n        >>> i = Symbol('i', below_fermi=1)\n        >>> p = Symbol('p')\n\n        >>> F(a).is_q_annihilator\n        1\n        >>> F(i).is_q_annihilator\n        0\n        >>> F(p).is_q_annihilator\n        1\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "is_q_creator",
    "full_id": "sympy.physics.secondquant.AnnihilateFermion.is_q_creator",
    "type": "property",
    "description": "\n        Can we create a quasi-particle?  (create hole or create particle)\n        If so, would that be above or below the fermi surface?\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.physics.secondquant import F\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n\n        >>> F(a).is_q_creator\n        0\n        >>> F(i).is_q_creator\n        -1\n        >>> F(p).is_q_creator\n        -1\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "lower",
    "full_id": "sympy.physics.secondquant.AntiSymmetricTensor.lower",
    "type": "property",
    "description": "\n        Returns the lower indices.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.secondquant import AntiSymmetricTensor\n        >>> i, j = symbols('i,j', below_fermi=True)\n        >>> a, b = symbols('a,b', above_fermi=True)\n        >>> AntiSymmetricTensor('v', (a, i), (b, j))\n        AntiSymmetricTensor(v, (a, i), (b, j))\n        >>> AntiSymmetricTensor('v', (a, i), (b, j)).lower\n        (b, j)\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "symbol",
    "full_id": "sympy.physics.secondquant.AntiSymmetricTensor.symbol",
    "type": "property",
    "description": "\n        Returns the symbol of the tensor.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.secondquant import AntiSymmetricTensor\n        >>> i, j = symbols('i,j', below_fermi=True)\n        >>> a, b = symbols('a,b', above_fermi=True)\n        >>> AntiSymmetricTensor('v', (a, i), (b, j))\n        AntiSymmetricTensor(v, (a, i), (b, j))\n        >>> AntiSymmetricTensor('v', (a, i), (b, j)).symbol\n        v\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "upper",
    "full_id": "sympy.physics.secondquant.AntiSymmetricTensor.upper",
    "type": "property",
    "description": "\n        Returns the upper indices.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.secondquant import AntiSymmetricTensor\n        >>> i, j = symbols('i,j', below_fermi=True)\n        >>> a, b = symbols('a,b', above_fermi=True)\n        >>> AntiSymmetricTensor('v', (a, i), (b, j))\n        AntiSymmetricTensor(v, (a, i), (b, j))\n        >>> AntiSymmetricTensor('v', (a, i), (b, j)).upper\n        (a, i)\n\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.secondquant.Commutator.doit",
    "type": "method",
    "description": "\n        Enables the computation of complex expressions.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.secondquant import Commutator, F, Fd\n        >>> from sympy import symbols\n        >>> i, j = symbols('i,j', below_fermi=True)\n        >>> a, b = symbols('a,b', above_fermi=True)\n        >>> c = Commutator(Fd(a)*F(i),Fd(b)*F(j))\n        >>> c.doit(wicks=True)\n        0\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.secondquant.Commutator.eval",
    "type": "method",
    "description": "\n        The Commutator [A,B] is on canonical form if A < B.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.secondquant import Commutator, F, Fd\n        >>> from sympy.abc import x\n        >>> c1 = Commutator(F(x), Fd(x))\n        >>> c2 = Commutator(Fd(x), F(x))\n        >>> Commutator.eval(c1, c2)\n        0\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "is_only_q_annihilator",
    "full_id": "sympy.physics.secondquant.CreateFermion.is_only_q_annihilator",
    "type": "property",
    "description": "\n        Always destroy a quasi-particle?  (annihilate hole or annihilate particle)\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.physics.secondquant import Fd\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n\n        >>> Fd(a).is_only_q_annihilator\n        False\n        >>> Fd(i).is_only_q_annihilator\n        True\n        >>> Fd(p).is_only_q_annihilator\n        False\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "is_only_q_creator",
    "full_id": "sympy.physics.secondquant.CreateFermion.is_only_q_creator",
    "type": "property",
    "description": "\n        Always create a quasi-particle?  (create hole or create particle)\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.physics.secondquant import Fd\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n\n        >>> Fd(a).is_only_q_creator\n        True\n        >>> Fd(i).is_only_q_creator\n        False\n        >>> Fd(p).is_only_q_creator\n        False\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "is_q_annihilator",
    "full_id": "sympy.physics.secondquant.CreateFermion.is_q_annihilator",
    "type": "property",
    "description": "\n        Can we destroy a quasi-particle?  (annihilate hole or annihilate particle)\n        If so, would that be above or below the fermi surface?\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.physics.secondquant import Fd\n        >>> a = Symbol('a', above_fermi=1)\n        >>> i = Symbol('i', below_fermi=1)\n        >>> p = Symbol('p')\n\n        >>> Fd(a).is_q_annihilator\n        0\n        >>> Fd(i).is_q_annihilator\n        -1\n        >>> Fd(p).is_q_annihilator\n        -1\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "is_q_creator",
    "full_id": "sympy.physics.secondquant.CreateFermion.is_q_creator",
    "type": "property",
    "description": "\n        Can we create a quasi-particle?  (create hole or create particle)\n        If so, would that be above or below the fermi surface?\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.physics.secondquant import Fd\n        >>> a = Symbol('a', above_fermi=True)\n        >>> i = Symbol('i', below_fermi=True)\n        >>> p = Symbol('p')\n\n        >>> Fd(a).is_q_creator\n        1\n        >>> Fd(i).is_q_creator\n        0\n        >>> Fd(p).is_q_creator\n        1\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.secondquant.Dagger.eval",
    "type": "method",
    "description": "\n        Evaluates the Dagger instance.\n\n        Examples\n        ========\n\n        >>> from sympy import I\n        >>> from sympy.physics.secondquant import Dagger, B, Bd\n        >>> Dagger(2*I)\n        -2*I\n        >>> Dagger(B(0))\n        CreateBoson(0)\n        >>> Dagger(Bd(0))\n        AnnihilateBoson(0)\n\n        The eval() method is called automatically.\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "index",
    "full_id": "sympy.physics.secondquant.FixedBosonicBasis.index",
    "type": "method",
    "description": "Returns the index of state in basis.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.secondquant import FixedBosonicBasis\n        >>> b = FixedBosonicBasis(2, 3)\n        >>> b.index(b.state(3))\n        3\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "state",
    "full_id": "sympy.physics.secondquant.FixedBosonicBasis.state",
    "type": "method",
    "description": "Returns the state that lies at index i of the basis\n\n        Examples\n        ========\n\n        >>> from sympy.physics.secondquant import FixedBosonicBasis\n        >>> b = FixedBosonicBasis(2, 3)\n        >>> b.state(3)\n        FockStateBosonKet((1, 0, 1))\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "bra",
    "full_id": "sympy.physics.secondquant.InnerProduct.bra",
    "type": "property",
    "description": "Returns the bra part of the state",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "ket",
    "full_id": "sympy.physics.secondquant.InnerProduct.ket",
    "type": "property",
    "description": "Returns the ket part of the state",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.secondquant.NO.doit",
    "type": "method",
    "description": "\n        Either removes the brackets or enables complex computations\n        in its arguments.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.secondquant import NO, Fd, F\n        >>> from textwrap import fill\n        >>> from sympy import symbols, Dummy\n        >>> p,q = symbols('p,q', cls=Dummy)\n        >>> print(fill(str(NO(Fd(p)*F(q)).doit())))\n        KroneckerDelta(_a, _p)*KroneckerDelta(_a,\n        _q)*CreateFermion(_a)*AnnihilateFermion(_a) + KroneckerDelta(_a,\n        _p)*KroneckerDelta(_i, _q)*CreateFermion(_a)*AnnihilateFermion(_i) -\n        KroneckerDelta(_a, _q)*KroneckerDelta(_i,\n        _p)*AnnihilateFermion(_a)*CreateFermion(_i) - KroneckerDelta(_i,\n        _p)*KroneckerDelta(_i, _q)*AnnihilateFermion(_i)*CreateFermion(_i)\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "get_subNO",
    "full_id": "sympy.physics.secondquant.NO.get_subNO",
    "type": "method",
    "description": "\n        Returns a NO() without FermionicOperator at index i.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.secondquant import F, NO\n        >>> p, q, r = symbols('p,q,r')\n\n        >>> NO(F(p)*F(q)*F(r)).get_subNO(1)\n        NO(AnnihilateFermion(p)*AnnihilateFermion(r))\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "has_q_annihilators",
    "full_id": "sympy.physics.secondquant.NO.has_q_annihilators",
    "type": "property",
    "description": "\n        Return 0 if the rightmost argument of the first argument is a not a\n        q_annihilator, else 1 if it is above fermi or -1 if it is below fermi.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.secondquant import NO, F, Fd\n\n        >>> a = symbols('a', above_fermi=True)\n        >>> i = symbols('i', below_fermi=True)\n        >>> NO(Fd(a)*Fd(i)).has_q_annihilators\n        -1\n        >>> NO(F(i)*F(a)).has_q_annihilators\n        1\n        >>> NO(Fd(a)*F(i)).has_q_annihilators\n        0\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "has_q_creators",
    "full_id": "sympy.physics.secondquant.NO.has_q_creators",
    "type": "property",
    "description": "\n        Return 0 if the leftmost argument of the first argument is a not a\n        q_creator, else 1 if it is above fermi or -1 if it is below fermi.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.secondquant import NO, F, Fd\n\n        >>> a = symbols('a', above_fermi=True)\n        >>> i = symbols('i', below_fermi=True)\n        >>> NO(Fd(a)*Fd(i)).has_q_creators\n        1\n        >>> NO(F(i)*F(a)).has_q_creators\n        -1\n        >>> NO(Fd(i)*F(a)).has_q_creators           #doctest: +SKIP\n        0\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "iter_q_annihilators",
    "full_id": "sympy.physics.secondquant.NO.iter_q_annihilators",
    "type": "method",
    "description": "\n        Iterates over the annihilation operators.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> i, j = symbols('i j', below_fermi=True)\n        >>> a, b = symbols('a b', above_fermi=True)\n        >>> from sympy.physics.secondquant import NO, F, Fd\n        >>> no = NO(Fd(a)*F(i)*F(b)*Fd(j))\n\n        >>> no.iter_q_creators()\n        <generator object... at 0x...>\n        >>> list(no.iter_q_creators())\n        [0, 1]\n        >>> list(no.iter_q_annihilators())\n        [3, 2]\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "iter_q_creators",
    "full_id": "sympy.physics.secondquant.NO.iter_q_creators",
    "type": "method",
    "description": "\n        Iterates over the creation operators.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> i, j = symbols('i j', below_fermi=True)\n        >>> a, b = symbols('a b', above_fermi=True)\n        >>> from sympy.physics.secondquant import NO, F, Fd\n        >>> no = NO(Fd(a)*F(i)*F(b)*Fd(j))\n\n        >>> no.iter_q_creators()\n        <generator object... at 0x...>\n        >>> list(no.iter_q_creators())\n        [0, 1]\n        >>> list(no.iter_q_annihilators())\n        [3, 2]\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "get_permuted",
    "full_id": "sympy.physics.secondquant.PermutationOperator.get_permuted",
    "type": "method",
    "description": "\n        Returns -expr with permuted indices.\n\n        Explanation\n        ===========\n\n        >>> from sympy import symbols, Function\n        >>> from sympy.physics.secondquant import PermutationOperator\n        >>> p,q = symbols('p,q')\n        >>> f = Function('f')\n        >>> PermutationOperator(p,q).get_permuted(f(p,q))\n        -f(q, p)\n\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "index",
    "full_id": "sympy.physics.secondquant.VarBosonicBasis.index",
    "type": "method",
    "description": "\n        Returns the index of state in basis.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.secondquant import VarBosonicBasis\n        >>> b = VarBosonicBasis(3)\n        >>> state = b.state(1)\n        >>> b\n        [FockState((0,)), FockState((1,)), FockState((2,))]\n        >>> state\n        FockStateBosonKet((1,))\n        >>> b.index(state)\n        1\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "state",
    "full_id": "sympy.physics.secondquant.VarBosonicBasis.state",
    "type": "method",
    "description": "\n        The state of a single basis.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.secondquant import VarBosonicBasis\n        >>> b = VarBosonicBasis(5)\n        >>> b.state(3)\n        FockStateBosonKet((3,))\n        ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "apply_operators",
    "full_id": "sympy.physics.secondquant.apply_operators",
    "type": "function",
    "description": "\n    Take a SymPy expression with operators and states and apply the operators.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.secondquant import apply_operators\n    >>> from sympy import sympify\n    >>> apply_operators(sympify(3)+4)\n    7\n    ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "contraction",
    "full_id": "sympy.physics.secondquant.contraction",
    "type": "function",
    "description": "\n    Calculates contraction of Fermionic operators a and b.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.physics.secondquant import F, Fd, contraction\n    >>> p, q = symbols('p,q')\n    >>> a, b = symbols('a,b', above_fermi=True)\n    >>> i, j = symbols('i,j', below_fermi=True)\n\n    A contraction is non-zero only if a quasi-creator is to the right of a\n    quasi-annihilator:\n\n    >>> contraction(F(a),Fd(b))\n    KroneckerDelta(a, b)\n    >>> contraction(Fd(i),F(j))\n    KroneckerDelta(i, j)\n\n    For general indices a non-zero result restricts the indices to below/above\n    the fermi surface:\n\n    >>> contraction(Fd(p),F(q))\n    KroneckerDelta(_i, q)*KroneckerDelta(p, q)\n    >>> contraction(F(p),Fd(q))\n    KroneckerDelta(_a, q)*KroneckerDelta(p, q)\n\n    Two creators or two annihilators always vanishes:\n\n    >>> contraction(F(p),F(q))\n    0\n    >>> contraction(Fd(p),Fd(q))\n    0\n\n    ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "evaluate_deltas",
    "full_id": "sympy.physics.secondquant.evaluate_deltas",
    "type": "function",
    "description": "\n    We evaluate KroneckerDelta symbols in the expression assuming Einstein summation.\n\n    Explanation\n    ===========\n\n    If one index is repeated it is summed over and in effect substituted with\n    the other one. If both indices are repeated we substitute according to what\n    is the preferred index.  this is determined by\n    KroneckerDelta.preferred_index and KroneckerDelta.killable_index.\n\n    In case there are no possible substitutions or if a substitution would\n    imply a loss of information, nothing is done.\n\n    In case an index appears in more than one KroneckerDelta, the resulting\n    substitution depends on the order of the factors.  Since the ordering is platform\n    dependent, the literal expression resulting from this function may be hard to\n    predict.\n\n    Examples\n    ========\n\n    We assume the following:\n\n    >>> from sympy import symbols, Function, Dummy, KroneckerDelta\n    >>> from sympy.physics.secondquant import evaluate_deltas\n    >>> i,j = symbols('i j', below_fermi=True, cls=Dummy)\n    >>> a,b = symbols('a b', above_fermi=True, cls=Dummy)\n    >>> p,q = symbols('p q', cls=Dummy)\n    >>> f = Function('f')\n    >>> t = Function('t')\n\n    The order of preference for these indices according to KroneckerDelta is\n    (a, b, i, j, p, q).\n\n    Trivial cases:\n\n    >>> evaluate_deltas(KroneckerDelta(i,j)*f(i))       # d_ij f(i) -> f(j)\n    f(_j)\n    >>> evaluate_deltas(KroneckerDelta(i,j)*f(j))       # d_ij f(j) -> f(i)\n    f(_i)\n    >>> evaluate_deltas(KroneckerDelta(i,p)*f(p))       # d_ip f(p) -> f(i)\n    f(_i)\n    >>> evaluate_deltas(KroneckerDelta(q,p)*f(p))       # d_qp f(p) -> f(q)\n    f(_q)\n    >>> evaluate_deltas(KroneckerDelta(q,p)*f(q))       # d_qp f(q) -> f(p)\n    f(_p)\n\n    More interesting cases:\n\n    >>> evaluate_deltas(KroneckerDelta(i,p)*t(a,i)*f(p,q))\n    f(_i, _q)*t(_a, _i)\n    >>> evaluate_deltas(KroneckerDelta(a,p)*t(a,i)*f(p,q))\n    f(_a, _q)*t(_a, _i)\n    >>> evaluate_deltas(KroneckerDelta(p,q)*f(p,q))\n    f(_p, _p)\n\n    Finally, here are some cases where nothing is done, because that would\n    imply a loss of information:\n\n    >>> evaluate_deltas(KroneckerDelta(i,p)*f(q))\n    f(_q)*KroneckerDelta(_i, _p)\n    >>> evaluate_deltas(KroneckerDelta(i,p)*f(i))\n    f(_i)*KroneckerDelta(_i, _p)\n    ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "matrix_rep",
    "full_id": "sympy.physics.secondquant.matrix_rep",
    "type": "function",
    "description": "\n    Find the representation of an operator in a basis.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.secondquant import VarBosonicBasis, B, matrix_rep\n    >>> b = VarBosonicBasis(5)\n    >>> o = B(0)\n    >>> matrix_rep(o, b)\n    Matrix([\n    [0, 1,       0,       0, 0],\n    [0, 0, sqrt(2),       0, 0],\n    [0, 0,       0, sqrt(3), 0],\n    [0, 0,       0,       0, 2],\n    [0, 0,       0,       0, 0]])\n    ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "simplify_index_permutations",
    "full_id": "sympy.physics.secondquant.simplify_index_permutations",
    "type": "function",
    "description": "\n    Performs simplification by introducing PermutationOperators where appropriate.\n\n    Explanation\n    ===========\n\n    Schematically:\n        [abij] - [abji] - [baij] + [baji] ->  P(ab)*P(ij)*[abij]\n\n    permutation_operators is a list of PermutationOperators to consider.\n\n    If permutation_operators=[P(ab),P(ij)] we will try to introduce the\n    permutation operators P(ij) and P(ab) in the expression.  If there are other\n    possible simplifications, we ignore them.\n\n    >>> from sympy import symbols, Function\n    >>> from sympy.physics.secondquant import simplify_index_permutations\n    >>> from sympy.physics.secondquant import PermutationOperator\n    >>> p,q,r,s = symbols('p,q,r,s')\n    >>> f = Function('f')\n    >>> g = Function('g')\n\n    >>> expr = f(p)*g(q) - f(q)*g(p); expr\n    f(p)*g(q) - f(q)*g(p)\n    >>> simplify_index_permutations(expr,[PermutationOperator(p,q)])\n    f(p)*g(q)*PermutationOperator(p, q)\n\n    >>> PermutList = [PermutationOperator(p,q),PermutationOperator(r,s)]\n    >>> expr = f(p,r)*g(q,s) - f(q,r)*g(p,s) + f(q,s)*g(p,r) - f(p,s)*g(q,r)\n    >>> simplify_index_permutations(expr,PermutList)\n    f(p, r)*g(q, s)*PermutationOperator(p, q)*PermutationOperator(r, s)\n\n    ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "substitute_dummies",
    "full_id": "sympy.physics.secondquant.substitute_dummies",
    "type": "function",
    "description": "\n    Collect terms by substitution of dummy variables.\n\n    Explanation\n    ===========\n\n    This routine allows simplification of Add expressions containing terms\n    which differ only due to dummy variables.\n\n    The idea is to substitute all dummy variables consistently depending on\n    the structure of the term.  For each term, we obtain a sequence of all\n    dummy variables, where the order is determined by the index range, what\n    factors the index belongs to and its position in each factor.  See\n    _get_ordered_dummies() for more information about the sorting of dummies.\n    The index sequence is then substituted consistently in each term.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, Function, Dummy\n    >>> from sympy.physics.secondquant import substitute_dummies\n    >>> a,b,c,d = symbols('a b c d', above_fermi=True, cls=Dummy)\n    >>> i,j = symbols('i j', below_fermi=True, cls=Dummy)\n    >>> f = Function('f')\n\n    >>> expr = f(a,b) + f(c,d); expr\n    f(_a, _b) + f(_c, _d)\n\n    Since a, b, c and d are equivalent summation indices, the expression can be\n    simplified to a single term (for which the dummy indices are still summed over)\n\n    >>> substitute_dummies(expr)\n    2*f(_a, _b)\n\n\n    Controlling output:\n\n    By default the dummy symbols that are already present in the expression\n    will be reused in a different permutation.  However, if new_indices=True,\n    new dummies will be generated and inserted.  The keyword 'pretty_indices'\n    can be used to control this generation of new symbols.\n\n    By default the new dummies will be generated on the form i_1, i_2, a_1,\n    etc.  If you supply a dictionary with key:value pairs in the form:\n\n        { index_group: string_of_letters }\n\n    The letters will be used as labels for the new dummy symbols.  The\n    index_groups must be one of 'above', 'below' or 'general'.\n\n    >>> expr = f(a,b,i,j)\n    >>> my_dummies = { 'above':'st', 'below':'uv' }\n    >>> substitute_dummies(expr, new_indices=True, pretty_indices=my_dummies)\n    f(_s, _t, _u, _v)\n\n    If we run out of letters, or if there is no keyword for some index_group\n    the default dummy generator will be used as a fallback:\n\n    >>> p,q = symbols('p q', cls=Dummy)  # general indices\n    >>> expr = f(p,q)\n    >>> substitute_dummies(expr, new_indices=True, pretty_indices=my_dummies)\n    f(_p_0, _p_1)\n\n    ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "wicks",
    "full_id": "sympy.physics.secondquant.wicks",
    "type": "function",
    "description": "\n    Returns the normal ordered equivalent of an expression using Wicks Theorem.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, Dummy\n    >>> from sympy.physics.secondquant import wicks, F, Fd\n    >>> p, q, r = symbols('p,q,r')\n    >>> wicks(Fd(p)*F(q))\n    KroneckerDelta(_i, q)*KroneckerDelta(p, q) + NO(CreateFermion(p)*AnnihilateFermion(q))\n\n    By default, the expression is expanded:\n\n    >>> wicks(F(p)*(F(q)+F(r)))\n    NO(AnnihilateFermion(p)*AnnihilateFermion(q)) + NO(AnnihilateFermion(p)*AnnihilateFermion(r))\n\n    With the keyword 'keep_only_fully_contracted=True', only fully contracted\n    terms are returned.\n\n    By request, the result can be simplified in the following order:\n     -- KroneckerDelta functions are evaluated\n     -- Dummy variables are substituted consistently across terms\n\n    >>> p, q, r = symbols('p q r', cls=Dummy)\n    >>> wicks(Fd(p)*(F(q)+F(r)), keep_only_fully_contracted=True)\n    KroneckerDelta(_i, _q)*KroneckerDelta(_p, _q) + KroneckerDelta(_i, _r)*KroneckerDelta(_p, _r)\n\n    ",
    "section": "Second Quantization",
    "url": "https://docs.sympy.org/latest/modules/physics/secondquant.html"
  },
  {
    "name": "clebsch_gordan",
    "full_id": "sympy.physics.wigner.clebsch_gordan",
    "type": "function",
    "description": "\n    Calculates the Clebsch-Gordan coefficient.\n    `\\left\\langle j_1 m_1 \\; j_2 m_2 | j_3 m_3 \\right\\rangle`.\n\n    The reference for this function is [Edmonds74]_.\n\n    Parameters\n    ==========\n\n    j_1, j_2, j_3, m_1, m_2, m_3 :\n        Integer or half integer.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> from sympy.physics.wigner import clebsch_gordan\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 2, S(3)/2, S(1)/2, 2)\n    1\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, S(3)/2, -S(1)/2, 1)\n    sqrt(3)/2\n    >>> clebsch_gordan(S(3)/2, S(1)/2, 1, -S(1)/2, S(1)/2, 0)\n    -sqrt(2)/2\n\n    Notes\n    =====\n\n    The Clebsch-Gordan coefficient will be evaluated via its relation\n    to Wigner 3j symbols:\n\n    .. math::\n\n        \\left\\langle j_1 m_1 \\; j_2 m_2 | j_3 m_3 \\right\\rangle\n        =(-1)^{j_1-j_2+m_3} \\sqrt{2j_3+1}\n        \\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,-m_3)\n\n    See also the documentation on Wigner 3j symbols which exhibit much\n    higher symmetry relations than the Clebsch-Gordan coefficient.\n\n    Authors\n    =======\n\n    - Jens Rasch (2009-03-24): initial version\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "dot_rot_grad_Ynm",
    "full_id": "sympy.physics.wigner.dot_rot_grad_Ynm",
    "type": "function",
    "description": "\n    Returns dot product of rotational gradients of spherical harmonics.\n\n    Explanation\n    ===========\n\n    This function returns the right hand side of the following expression:\n\n    .. math ::\n        \\vec{R}Y{_j^{p}} \\cdot \\vec{R}Y{_l^{m}} = (-1)^{m+p}\n        \\sum\\limits_{k=|l-j|}^{l+j}Y{_k^{m+p}}  * \\alpha_{l,m,j,p,k} *\n        \\frac{1}{2} (k^2-j^2-l^2+k-j-l)\n\n\n    Arguments\n    =========\n\n    j, p, l, m .... indices in spherical harmonics (expressions or integers)\n    theta, phi .... angle arguments in spherical harmonics\n\n    Example\n    =======\n\n    >>> from sympy import symbols\n    >>> from sympy.physics.wigner import dot_rot_grad_Ynm\n    >>> theta, phi = symbols(\"theta phi\")\n    >>> dot_rot_grad_Ynm(3, 2, 2, 0, theta, phi).doit()\n    3*sqrt(55)*Ynm(5, 2, theta, phi)/(11*sqrt(pi))\n\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "gaunt",
    "full_id": "sympy.physics.wigner.gaunt",
    "type": "function",
    "description": "\n    Calculate the Gaunt coefficient.\n\n    Explanation\n    ===========\n\n    The Gaunt coefficient is defined as the integral over three\n    spherical harmonics:\n\n    .. math::\n\n        \\begin{aligned}\n        \\operatorname{Gaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\n        &=\\int Y_{l_1,m_1}(\\Omega)\n         Y_{l_2,m_2}(\\Omega) Y_{l_3,m_3}(\\Omega) \\,d\\Omega \\\\\n        &=\\sqrt{\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\pi}}\n         \\operatorname{Wigner3j}(l_1,l_2,l_3,0,0,0)\n         \\operatorname{Wigner3j}(l_1,l_2,l_3,m_1,m_2,m_3)\n        \\end{aligned}\n\n    Parameters\n    ==========\n\n    l_1, l_2, l_3, m_1, m_2, m_3 :\n        Integer.\n    prec - precision, default: ``None``.\n        Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number\n    (if ``prec=None``), or real number if a precision is given.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import gaunt\n    >>> gaunt(1,0,1,1,0,-1)\n    -1/(2*sqrt(pi))\n    >>> gaunt(1000,1000,1200,9,3,-12).n(64)\n    0.006895004219221134484332976156744208248842039317638217822322799675\n\n    It is an error to use non-integer values for `l` and `m`::\n\n        sage: gaunt(1.2,0,1.2,0,0,0)\n        Traceback (most recent call last):\n        ...\n        ValueError: l values must be integer\n        sage: gaunt(1,0,1,1.1,0,-1.1)\n        Traceback (most recent call last):\n        ...\n        ValueError: m values must be integer\n\n    Notes\n    =====\n\n    The Gaunt coefficient obeys the following symmetry rules:\n\n    - invariant under any permutation of the columns\n\n      .. math::\n        \\begin{aligned}\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\n          &=Y(l_3,l_1,l_2,m_3,m_1,m_2) \\\\\n          &=Y(l_2,l_3,l_1,m_2,m_3,m_1) \\\\\n          &=Y(l_3,l_2,l_1,m_3,m_2,m_1) \\\\\n          &=Y(l_1,l_3,l_2,m_1,m_3,m_2) \\\\\n          &=Y(l_2,l_1,l_3,m_2,m_1,m_3)\n        \\end{aligned}\n\n    - invariant under space inflection, i.e.\n\n      .. math::\n          Y(l_1,l_2,l_3,m_1,m_2,m_3)\n          =Y(l_1,l_2,l_3,-m_1,-m_2,-m_3)\n\n    - symmetric with respect to the 72 Regge symmetries as inherited\n      for the `3j` symbols [Regge58]_\n\n    - zero for `l_1`, `l_2`, `l_3` not fulfilling triangle relation\n\n    - zero for violating any one of the conditions: `l_1 \\ge |m_1|`,\n      `l_2 \\ge |m_2|`, `l_3 \\ge |m_3|`\n\n    - non-zero only for an even sum of the `l_i`, i.e.\n      `L = l_1 + l_2 + l_3 = 2n` for `n` in `\\mathbb{N}`\n\n    Algorithms\n    ==========\n\n    This function uses the algorithm of [Liberatodebrito82]_ to\n    calculate the value of the Gaunt coefficient exactly. Note that\n    the formula contains alternating sums over large factorials and is\n    therefore unsuitable for finite precision arithmetic and only\n    useful for a computer algebra system [Rasch03]_.\n\n    Authors\n    =======\n\n    Jens Rasch (2009-03-24): initial version for Sage.\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "racah",
    "full_id": "sympy.physics.wigner.racah",
    "type": "function",
    "description": "\n    Calculate the Racah symbol `W(a,b,c,d;e,f)`.\n\n    Parameters\n    ==========\n\n    a, ..., f :\n        Integer or half integer.\n    prec :\n        Precision, default: ``None``. Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number\n    (if ``prec=None``), or real number if a precision is given.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import racah\n    >>> racah(3,3,3,3,3,3)\n    -1/14\n\n    Notes\n    =====\n\n    The Racah symbol is related to the Wigner 6j symbol:\n\n    .. math::\n\n       \\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\n       =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\n\n    Please see the 6j symbol for its much richer symmetries and for\n    additional properties.\n\n    Algorithm\n    =========\n\n    This function uses the algorithm of [Edmonds74]_ to calculate the\n    value of the 6j symbol exactly. Note that the formula contains\n    alternating sums over large factorials and is therefore unsuitable\n    for finite precision arithmetic and only useful for a computer\n    algebra system [Rasch03]_.\n\n    Authors\n    =======\n\n    - Jens Rasch (2009-03-24): initial version\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "real_gaunt",
    "full_id": "sympy.physics.wigner.real_gaunt",
    "type": "function",
    "description": "\n    Calculate the real Gaunt coefficient.\n\n    Explanation\n    ===========\n\n    The real Gaunt coefficient is defined as the integral over three\n    real spherical harmonics:\n\n    .. math::\n        \\begin{aligned}\n        \\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\n        &=\\int Z^{m_1}_{l_1}(\\Omega)\n         Z^{m_2}_{l_2}(\\Omega) Z^{m_3}_{l_3}(\\Omega) \\,d\\Omega \\\\\n        \\end{aligned}\n\n    Alternatively, it can be defined in terms of the standard Gaunt\n    coefficient by relating the real spherical harmonics to the standard\n    spherical harmonics via a unitary transformation `U`, i.e.\n    `Z^{m}_{l}(\\Omega)=\\sum_{m'}U^{m}_{m'}Y^{m'}_{l}(\\Omega)` [Homeier96]_.\n    The real Gaunt coefficient is then defined as\n\n    .. math::\n        \\begin{aligned}\n        \\operatorname{RealGaunt}(l_1,l_2,l_3,m_1,m_2,m_3)\n        &=\\int Z^{m_1}_{l_1}(\\Omega)\n         Z^{m_2}_{l_2}(\\Omega) Z^{m_3}_{l_3}(\\Omega) \\,d\\Omega \\\\\n        &=\\sum_{m'_1 m'_2 m'_3} U^{m_1}_{m'_1}U^{m_2}_{m'_2}U^{m_3}_{m'_3}\n         \\operatorname{Gaunt}(l_1,l_2,l_3,m'_1,m'_2,m'_3)\n        \\end{aligned}\n\n    The unitary matrix `U` has components\n\n    .. math::\n        \\begin{aligned}\n        U^m_{m'} = \\delta_{|m||m'|}*(\\delta_{m'0}\\delta_{m0} + \\frac{1}{\\sqrt{2}}\\big[\\Theta(m)\n        \\big(\\delta_{m'm}+(-1)^{m'}\\delta_{m'-m}\\big)+i\\Theta(-m)\\big((-1)^{-m}\n        \\delta_{m'-m}-\\delta_{m'm}*(-1)^{m'-m}\\big)\\big])\n        \\end{aligned}\n\n    where `\\delta_{ij}` is the Kronecker delta symbol and `\\Theta` is a step\n    function defined as\n\n    .. math::\n        \\begin{aligned}\n        \\Theta(x) = \\begin{cases} 1 \\,\\text{for}\\, x > 0 \\\\ 0 \\,\\text{for}\\, x \\leq 0 \\end{cases}\n        \\end{aligned}\n\n    Parameters\n    ==========\n\n    l_1, l_2, l_3, m_1, m_2, m_3 :\n        Integer.\n\n    prec - precision, default: ``None``.\n        Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import real_gaunt\n    >>> real_gaunt(2,2,4,-1,-1,0)\n    -2/(7*sqrt(pi))\n    >>> real_gaunt(10,10,20,-9,-9,0).n(64)\n    -0.00002480019791932209313156167176797577821140084216297395518482071448\n\n    It is an error to use non-integer values for `l` and `m`::\n        real_gaunt(2.8,0.5,1.3,0,0,0)\n        Traceback (most recent call last):\n        ...\n        ValueError: l values must be integer\n        real_gaunt(2,2,4,0.7,1,-3.4)\n        Traceback (most recent call last):\n        ...\n        ValueError: m values must be integer\n\n    Notes\n    =====\n\n    The real Gaunt coefficient inherits from the standard Gaunt coefficient,\n    the invariance under any permutation of the pairs `(l_i, m_i)` and the\n    requirement that the sum of the `l_i` be even to yield a non-zero value.\n    It also obeys the following symmetry rules:\n\n    - zero for `l_1`, `l_2`, `l_3` not fulfiling the condition\n      `l_1 \\in \\{l_{\\text{max}}, l_{\\text{max}}-2, \\ldots, l_{\\text{min}}\\}`,\n      where `l_{\\text{max}} = l_2+l_3`,\n\n      .. math::\n          \\begin{aligned}\n          l_{\\text{min}} = \\begin{cases} \\kappa(l_2, l_3, m_2, m_3) & \\text{if}\\,\n          \\kappa(l_2, l_3, m_2, m_3) + l_{\\text{max}}\\, \\text{is even} \\\\\n          \\kappa(l_2, l_3, m_2, m_3)+1 & \\text{if}\\, \\kappa(l_2, l_3, m_2, m_3) +\n          l_{\\text{max}}\\, \\text{is odd}\\end{cases}\n          \\end{aligned}\n\n      and `\\kappa(l_2, l_3, m_2, m_3) = \\max{\\big(|l_2-l_3|, \\min{\\big(|m_2+m_3|,\n      |m_2-m_3|\\big)}\\big)}`\n\n    - zero for an odd number of negative `m_i`\n\n    Algorithms\n    ==========\n\n    This function uses the algorithms of [Homeier96]_ and [Rasch03]_ to\n    calculate the value of the real Gaunt coefficient exactly. Note that\n    the formula used in [Rasch03]_ contains alternating sums over large\n    factorials and is therefore unsuitable for finite precision arithmetic\n    and only useful for a computer algebra system [Rasch03]_. However, this\n    function can in principle use any algorithm that computes the Gaunt\n    coefficient, so it is suitable for finite precision arithmetic in so far\n    as the algorithm which computes the Gaunt coefficient is.\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "wigner_3j",
    "full_id": "sympy.physics.wigner.wigner_3j",
    "type": "function",
    "description": "\n    Calculate the Wigner 3j symbol `\\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)`.\n\n    Parameters\n    ==========\n\n    j_1, j_2, j_3, m_1, m_2, m_3 :\n        Integer or half integer.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import wigner_3j\n    >>> wigner_3j(2, 6, 4, 0, 0, 0)\n    sqrt(715)/143\n    >>> wigner_3j(2, 6, 4, 0, 0, 1)\n    0\n\n    It is an error to have arguments that are not integer or half\n    integer values::\n\n        sage: wigner_3j(2.1, 6, 4, 0, 0, 0)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer\n        sage: wigner_3j(2, 6, 4, 1, 0, -1.1)\n        Traceback (most recent call last):\n        ...\n        ValueError: m values must be integer or half integer\n\n    Notes\n    =====\n\n    The Wigner 3j symbol obeys the following symmetry rules:\n\n    - invariant under any permutation of the columns (with the\n      exception of a sign change where `J:=j_1+j_2+j_3`):\n\n      .. math::\n\n         \\begin{aligned}\n         \\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\n          &=\\operatorname{Wigner3j}(j_3,j_1,j_2,m_3,m_1,m_2) \\\\\n          &=\\operatorname{Wigner3j}(j_2,j_3,j_1,m_2,m_3,m_1) \\\\\n          &=(-1)^J \\operatorname{Wigner3j}(j_3,j_2,j_1,m_3,m_2,m_1) \\\\\n          &=(-1)^J \\operatorname{Wigner3j}(j_1,j_3,j_2,m_1,m_3,m_2) \\\\\n          &=(-1)^J \\operatorname{Wigner3j}(j_2,j_1,j_3,m_2,m_1,m_3)\n         \\end{aligned}\n\n    - invariant under space inflection, i.e.\n\n      .. math::\n\n         \\operatorname{Wigner3j}(j_1,j_2,j_3,m_1,m_2,m_3)\n         =(-1)^J \\operatorname{Wigner3j}(j_1,j_2,j_3,-m_1,-m_2,-m_3)\n\n    - symmetric with respect to the 72 additional symmetries based on\n      the work by [Regge58]_\n\n    - zero for `j_1`, `j_2`, `j_3` not fulfilling triangle relation\n\n    - zero for `m_1 + m_2 + m_3 \\neq 0`\n\n    - zero for violating any one of the conditions\n         `m_1  \\in \\{-|j_1|, \\ldots, |j_1|\\}`,\n         `m_2  \\in \\{-|j_2|, \\ldots, |j_2|\\}`,\n         `m_3  \\in \\{-|j_3|, \\ldots, |j_3|\\}`\n\n    Algorithm\n    =========\n\n    This function uses the algorithm of [Edmonds74]_ to calculate the\n    value of the 3j symbol exactly. Note that the formula contains\n    alternating sums over large factorials and is therefore unsuitable\n    for finite precision arithmetic and only useful for a computer\n    algebra system [Rasch03]_.\n\n    Authors\n    =======\n\n    - Jens Rasch (2009-03-24): initial version\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "wigner_6j",
    "full_id": "sympy.physics.wigner.wigner_6j",
    "type": "function",
    "description": "\n    Calculate the Wigner 6j symbol `\\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)`.\n\n    Parameters\n    ==========\n\n    j_1, ..., j_6 :\n        Integer or half integer.\n    prec :\n        Precision, default: ``None``. Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number\n    (if ``prec=None``), or real number if a precision is given.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import wigner_6j\n    >>> wigner_6j(3,3,3,3,3,3)\n    -1/14\n    >>> wigner_6j(5,5,5,5,5,5)\n    1/52\n\n    It is an error to have arguments that are not integer or half\n    integer values or do not fulfill the triangle relation::\n\n        sage: wigner_6j(2.5,2.5,2.5,2.5,2.5,2.5)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\n        sage: wigner_6j(0.5,0.5,1.1,0.5,0.5,1.1)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\n\n    Notes\n    =====\n\n    The Wigner 6j symbol is related to the Racah symbol but exhibits\n    more symmetries as detailed below.\n\n    .. math::\n\n       \\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\n        =(-1)^{j_1+j_2+j_4+j_5} W(j_1,j_2,j_5,j_4,j_3,j_6)\n\n    The Wigner 6j symbol obeys the following symmetry rules:\n\n    - Wigner 6j symbols are left invariant under any permutation of\n      the columns:\n\n      .. math::\n\n         \\begin{aligned}\n         \\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\n          &=\\operatorname{Wigner6j}(j_3,j_1,j_2,j_6,j_4,j_5) \\\\\n          &=\\operatorname{Wigner6j}(j_2,j_3,j_1,j_5,j_6,j_4) \\\\\n          &=\\operatorname{Wigner6j}(j_3,j_2,j_1,j_6,j_5,j_4) \\\\\n          &=\\operatorname{Wigner6j}(j_1,j_3,j_2,j_4,j_6,j_5) \\\\\n          &=\\operatorname{Wigner6j}(j_2,j_1,j_3,j_5,j_4,j_6)\n         \\end{aligned}\n\n    - They are invariant under the exchange of the upper and lower\n      arguments in each of any two columns, i.e.\n\n      .. math::\n\n         \\operatorname{Wigner6j}(j_1,j_2,j_3,j_4,j_5,j_6)\n          =\\operatorname{Wigner6j}(j_1,j_5,j_6,j_4,j_2,j_3)\n          =\\operatorname{Wigner6j}(j_4,j_2,j_6,j_1,j_5,j_3)\n          =\\operatorname{Wigner6j}(j_4,j_5,j_3,j_1,j_2,j_6)\n\n    - additional 6 symmetries [Regge59]_ giving rise to 144 symmetries\n      in total\n\n    - only non-zero if any triple of `j`'s fulfill a triangle relation\n\n    Algorithm\n    =========\n\n    This function uses the algorithm of [Edmonds74]_ to calculate the\n    value of the 6j symbol exactly. Note that the formula contains\n    alternating sums over large factorials and is therefore unsuitable\n    for finite precision arithmetic and only useful for a computer\n    algebra system [Rasch03]_.\n\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "wigner_9j",
    "full_id": "sympy.physics.wigner.wigner_9j",
    "type": "function",
    "description": "\n    Calculate the Wigner 9j symbol\n    `\\operatorname{Wigner9j}(j_1,j_2,j_3,j_4,j_5,j_6,j_7,j_8,j_9)`.\n\n    Parameters\n    ==========\n\n    j_1, ..., j_9 :\n        Integer or half integer.\n    prec : precision, default\n        ``None``. Providing a precision can\n        drastically speed up the calculation.\n\n    Returns\n    =======\n\n    Rational number times the square root of a rational number\n    (if ``prec=None``), or real number if a precision is given.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.wigner import wigner_9j\n    >>> wigner_9j(1,1,1, 1,1,1, 1,1,0, prec=64)\n    0.05555555555555555555555555555555555555555555555555555555555555555\n\n    >>> wigner_9j(1/2,1/2,0, 1/2,3/2,1, 0,1,1, prec=64)\n    0.1666666666666666666666666666666666666666666666666666666666666667\n\n    It is an error to have arguments that are not integer or half\n    integer values or do not fulfill the triangle relation::\n\n        sage: wigner_9j(0.5,0.5,0.5, 0.5,0.5,0.5, 0.5,0.5,0.5,prec=64)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\n        sage: wigner_9j(1,1,1, 0.5,1,1.5, 0.5,1,2.5,prec=64)\n        Traceback (most recent call last):\n        ...\n        ValueError: j values must be integer or half integer and fulfill the triangle relation\n\n    Algorithm\n    =========\n\n    This function uses the algorithm of [Edmonds74]_ to calculate the\n    value of the 3j symbol exactly. Note that the formula contains\n    alternating sums over large factorials and is therefore unsuitable\n    for finite precision arithmetic and only useful for a computer\n    algebra system [Rasch03]_.\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "wigner_d",
    "full_id": "sympy.physics.wigner.wigner_d",
    "type": "function",
    "description": "Return the Wigner D matrix for angular momentum J.\n\n    Explanation\n    ===========\n\n    J :\n        An integer, half-integer, or SymPy symbol for the total angular\n        momentum of the angular momentum space being rotated.\n    alpha, beta, gamma - Real numbers representing the Euler.\n        Angles of rotation about the so-called vertical, line of nodes, and\n        figure axes. See [Edmonds74]_.\n\n    Returns\n    =======\n\n    A matrix representing the corresponding Euler angle rotation( in the basis\n    of eigenvectors of `J_z`).\n\n    .. math ::\n        \\mathcal{D}_{\\alpha \\beta \\gamma} =\n        \\exp\\big( \\frac{i\\alpha}{\\hbar} J_z\\big)\n        \\exp\\big( \\frac{i\\beta}{\\hbar} J_y\\big)\n        \\exp\\big( \\frac{i\\gamma}{\\hbar} J_z\\big)\n\n    The components are calculated using the general form [Edmonds74]_,\n    equation 4.1.12.\n\n    Examples\n    ========\n\n    The simplest possible example:\n\n    >>> from sympy.physics.wigner import wigner_d\n    >>> from sympy import Integer, symbols, pprint\n    >>> half = 1/Integer(2)\n    >>> alpha, beta, gamma = symbols(\"alpha, beta, gamma\", real=True)\n    >>> pprint(wigner_d(half, alpha, beta, gamma), use_unicode=True)\n    \u23a1  \u2148\u22c5\u03b1  \u2148\u22c5\u03b3             \u2148\u22c5\u03b1  -\u2148\u22c5\u03b3         \u23a4\n    \u23a2  \u2500\u2500\u2500  \u2500\u2500\u2500             \u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500        \u23a5\n    \u23a2   2    2     \u239b\u03b2\u239e       2     2      \u239b\u03b2\u239e \u23a5\n    \u23a2 \u212f   \u22c5\u212f   \u22c5cos\u239c\u2500\u239f     \u212f   \u22c5\u212f     \u22c5sin\u239c\u2500\u239f \u23a5\n    \u23a2              \u239d2\u23a0                    \u239d2\u23a0 \u23a5\n    \u23a2                                         \u23a5\n    \u23a2  -\u2148\u22c5\u03b1   \u2148\u22c5\u03b3          -\u2148\u22c5\u03b1   -\u2148\u22c5\u03b3        \u23a5\n    \u23a2  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500          \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500       \u23a5\n    \u23a2    2     2     \u239b\u03b2\u239e     2      2      \u239b\u03b2\u239e\u23a5\n    \u23a2-\u212f     \u22c5\u212f   \u22c5sin\u239c\u2500\u239f  \u212f     \u22c5\u212f     \u22c5cos\u239c\u2500\u239f\u23a5\n    \u23a3                \u239d2\u23a0                   \u239d2\u23a0\u23a6\n\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "wigner_d_small",
    "full_id": "sympy.physics.wigner.wigner_d_small",
    "type": "function",
    "description": "Return the small Wigner d matrix for angular momentum J.\n\n    Explanation\n    ===========\n\n    J : An integer, half-integer, or SymPy symbol for the total angular\n        momentum of the angular momentum space being rotated.\n    beta : A real number representing the Euler angle of rotation about\n        the so-called line of nodes. See [Edmonds74]_.\n\n    Returns\n    =======\n\n    A matrix representing the corresponding Euler angle rotation( in the basis\n    of eigenvectors of `J_z`).\n\n    .. math ::\n        \\mathcal{d}_{\\beta} = \\exp\\big( \\frac{i\\beta}{\\hbar} J_y\\big)\n\n    The components are calculated using the general form [Edmonds74]_,\n    equation 4.1.15.\n\n    Examples\n    ========\n\n    >>> from sympy import Integer, symbols, pi, pprint\n    >>> from sympy.physics.wigner import wigner_d_small\n    >>> half = 1/Integer(2)\n    >>> beta = symbols(\"beta\", real=True)\n    >>> pprint(wigner_d_small(half, beta), use_unicode=True)\n    \u23a1   \u239b\u03b2\u239e      \u239b\u03b2\u239e\u23a4\n    \u23a2cos\u239c\u2500\u239f   sin\u239c\u2500\u239f\u23a5\n    \u23a2   \u239d2\u23a0      \u239d2\u23a0\u23a5\n    \u23a2               \u23a5\n    \u23a2    \u239b\u03b2\u239e     \u239b\u03b2\u239e\u23a5\n    \u23a2-sin\u239c\u2500\u239f  cos\u239c\u2500\u239f\u23a5\n    \u23a3    \u239d2\u23a0     \u239d2\u23a0\u23a6\n\n    >>> pprint(wigner_d_small(2*half, beta), use_unicode=True)\n    \u23a1        2\u239b\u03b2\u239e              \u239b\u03b2\u239e    \u239b\u03b2\u239e           2\u239b\u03b2\u239e     \u23a4\n    \u23a2     cos \u239c\u2500\u239f        \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f        sin \u239c\u2500\u239f     \u23a5\n    \u23a2         \u239d2\u23a0              \u239d2\u23a0    \u239d2\u23a0            \u239d2\u23a0     \u23a5\n    \u23a2                                                        \u23a5\n    \u23a2       \u239b\u03b2\u239e    \u239b\u03b2\u239e       2\u239b\u03b2\u239e      2\u239b\u03b2\u239e        \u239b\u03b2\u239e    \u239b\u03b2\u239e\u23a5\n    \u23a2-\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f  - sin \u239c\u2500\u239f + cos \u239c\u2500\u239f  \u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f\u23a5\n    \u23a2       \u239d2\u23a0    \u239d2\u23a0        \u239d2\u23a0       \u239d2\u23a0        \u239d2\u23a0    \u239d2\u23a0\u23a5\n    \u23a2                                                        \u23a5\n    \u23a2        2\u239b\u03b2\u239e               \u239b\u03b2\u239e    \u239b\u03b2\u239e          2\u239b\u03b2\u239e     \u23a5\n    \u23a2     sin \u239c\u2500\u239f        -\u221a2\u22c5sin\u239c\u2500\u239f\u22c5cos\u239c\u2500\u239f       cos \u239c\u2500\u239f     \u23a5\n    \u23a3         \u239d2\u23a0               \u239d2\u23a0    \u239d2\u23a0           \u239d2\u23a0     \u23a6\n\n    From table 4 in [Edmonds74]_\n\n    >>> pprint(wigner_d_small(half, beta).subs({beta:pi/2}), use_unicode=True)\n    \u23a1 \u221a2   \u221a2\u23a4\n    \u23a2 \u2500\u2500   \u2500\u2500\u23a5\n    \u23a2 2    2 \u23a5\n    \u23a2        \u23a5\n    \u23a2-\u221a2   \u221a2\u23a5\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\n    \u23a3 2    2 \u23a6\n\n    >>> pprint(wigner_d_small(2*half, beta).subs({beta:pi/2}),\n    ... use_unicode=True)\n    \u23a1       \u221a2      \u23a4\n    \u23a21/2    \u2500\u2500   1/2\u23a5\n    \u23a2       2       \u23a5\n    \u23a2               \u23a5\n    \u23a2-\u221a2         \u221a2 \u23a5\n    \u23a2\u2500\u2500\u2500\u2500   0    \u2500\u2500 \u23a5\n    \u23a2 2          2  \u23a5\n    \u23a2               \u23a5\n    \u23a2      -\u221a2      \u23a5\n    \u23a21/2   \u2500\u2500\u2500\u2500  1/2\u23a5\n    \u23a3       2       \u23a6\n\n    >>> pprint(wigner_d_small(3*half, beta).subs({beta:pi/2}),\n    ... use_unicode=True)\n    \u23a1 \u221a2    \u221a6    \u221a6   \u221a2\u23a4\n    \u23a2 \u2500\u2500    \u2500\u2500    \u2500\u2500   \u2500\u2500\u23a5\n    \u23a2 4     4     4    4 \u23a5\n    \u23a2                    \u23a5\n    \u23a2-\u221a6   -\u221a2    \u221a2   \u221a6\u23a5\n    \u23a2\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u23a5\n    \u23a2 4     4     4    4 \u23a5\n    \u23a2                    \u23a5\n    \u23a2 \u221a6   -\u221a2   -\u221a2   \u221a6\u23a5\n    \u23a2 \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\n    \u23a2 4     4     4    4 \u23a5\n    \u23a2                    \u23a5\n    \u23a2-\u221a2    \u221a6   -\u221a6   \u221a2\u23a5\n    \u23a2\u2500\u2500\u2500\u2500   \u2500\u2500   \u2500\u2500\u2500\u2500  \u2500\u2500\u23a5\n    \u23a3 4     4     4    4 \u23a6\n\n    >>> pprint(wigner_d_small(4*half, beta).subs({beta:pi/2}),\n    ... use_unicode=True)\n    \u23a1             \u221a6            \u23a4\n    \u23a21/4   1/2    \u2500\u2500   1/2   1/4\u23a5\n    \u23a2             4             \u23a5\n    \u23a2                           \u23a5\n    \u23a2-1/2  -1/2   0    1/2   1/2\u23a5\n    \u23a2                           \u23a5\n    \u23a2 \u221a6                     \u221a6 \u23a5\n    \u23a2 \u2500\u2500    0    -1/2   0    \u2500\u2500 \u23a5\n    \u23a2 4                      4  \u23a5\n    \u23a2                           \u23a5\n    \u23a2-1/2  1/2    0    -1/2  1/2\u23a5\n    \u23a2                           \u23a5\n    \u23a2             \u221a6            \u23a5\n    \u23a21/4   -1/2   \u2500\u2500   -1/2  1/4\u23a5\n    \u23a3             4             \u23a6\n\n    ",
    "section": "Authors",
    "url": "https://docs.sympy.org/latest/modules/physics/wigner.html"
  },
  {
    "name": "has_integer_powers",
    "full_id": "sympy.physics.units.dimensions.Dimension.has_integer_powers",
    "type": "method",
    "description": "\n        Check if the dimension object has only integer powers.\n\n        All the dimension powers should be integers, but rational powers may\n        appear in intermediate steps. This method may be used to check that the\n        final result is well-defined.\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "can_transf_matrix",
    "full_id": "sympy.physics.units.dimensions.DimensionSystem.can_transf_matrix",
    "type": "property",
    "description": "\n        Useless method, kept for compatibility with previous versions.\n\n        DO NOT USE.\n\n        Return the canonical transformation matrix from the canonical to the\n        base dimension basis.\n\n        It is the inverse of the matrix computed with inv_can_transf_matrix().\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "dim",
    "full_id": "sympy.physics.units.dimensions.DimensionSystem.dim",
    "type": "property",
    "description": "\n        Useless method, kept for compatibility with previous versions.\n\n        DO NOT USE.\n\n        Give the dimension of the system.\n\n        That is return the number of dimensions forming the basis.\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "dim_can_vector",
    "full_id": "sympy.physics.units.dimensions.DimensionSystem.dim_can_vector",
    "type": "method",
    "description": "\n        Useless method, kept for compatibility with previous versions.\n\n        DO NOT USE.\n\n        Dimensional representation in terms of the canonical base dimensions.\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "dim_vector",
    "full_id": "sympy.physics.units.dimensions.DimensionSystem.dim_vector",
    "type": "method",
    "description": "\n        Useless method, kept for compatibility with previous versions.\n\n        DO NOT USE.\n\n\n        Vector representation in terms of the base dimensions.\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "inv_can_transf_matrix",
    "full_id": "sympy.physics.units.dimensions.DimensionSystem.inv_can_transf_matrix",
    "type": "property",
    "description": "\n        Useless method, kept for compatibility with previous versions.\n\n        DO NOT USE.\n\n        Compute the inverse transformation matrix from the base to the\n        canonical dimension basis.\n\n        It corresponds to the matrix where columns are the vector of base\n        dimensions in canonical basis.\n\n        This matrix will almost never be used because dimensions are always\n        defined with respect to the canonical basis, so no work has to be done\n        to get them in this basis. Nonetheless if this matrix is not square\n        (or not invertible) it means that we have chosen a bad basis.\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "is_consistent",
    "full_id": "sympy.physics.units.dimensions.DimensionSystem.is_consistent",
    "type": "property",
    "description": "\n        Useless method, kept for compatibility with previous versions.\n\n        DO NOT USE.\n\n        Check if the system is well defined.\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "is_dimensionless",
    "full_id": "sympy.physics.units.dimensions.DimensionSystem.is_dimensionless",
    "type": "method",
    "description": "\n        Check if the dimension object really has a dimension.\n\n        A dimension should have at least one component with non-zero power.\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "list_can_dims",
    "full_id": "sympy.physics.units.dimensions.DimensionSystem.list_can_dims",
    "type": "property",
    "description": "\n        Useless method, kept for compatibility with previous versions.\n\n        DO NOT USE.\n\n        List all canonical dimension names.\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "print_dim_base",
    "full_id": "sympy.physics.units.dimensions.DimensionSystem.print_dim_base",
    "type": "method",
    "description": "\n        Give the string expression of a dimension in term of the basis symbols.\n        ",
    "section": "Dimensions and dimension systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/dimensions.html"
  },
  {
    "name": "dim",
    "full_id": "sympy.physics.units.unitsystem.UnitSystem.dim",
    "type": "property",
    "description": "\n        Give the dimension of the system.\n\n        That is return the number of units forming the basis.\n        ",
    "section": "Units and unit systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/unitsystem.html"
  },
  {
    "name": "extend",
    "full_id": "sympy.physics.units.unitsystem.UnitSystem.extend",
    "type": "method",
    "description": "Extend the current system into a new one.\n\n        Take the base and normal units of the current system to merge\n        them to the base and normal units given in argument.\n        If not provided, name and description are overridden by empty strings.\n        ",
    "section": "Units and unit systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/unitsystem.html"
  },
  {
    "name": "get_units_non_prefixed",
    "full_id": "sympy.physics.units.unitsystem.UnitSystem.get_units_non_prefixed",
    "type": "method",
    "description": "\n        Return the units of the system that do not have a prefix.\n        ",
    "section": "Units and unit systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/unitsystem.html"
  },
  {
    "name": "is_consistent",
    "full_id": "sympy.physics.units.unitsystem.UnitSystem.is_consistent",
    "type": "property",
    "description": "\n        Check if the underlying dimension system is consistent.\n        ",
    "section": "Units and unit systems",
    "url": "https://docs.sympy.org/latest/modules/physics/units/unitsystem.html"
  },
  {
    "name": "abbrev",
    "full_id": "sympy.physics.units.quantities.Quantity.abbrev",
    "type": "property",
    "description": "\n        Symbol representing the unit name.\n\n        Prepend the abbreviation with the prefix symbol if it is defines.\n        ",
    "section": "Physical quantities",
    "url": "https://docs.sympy.org/latest/modules/physics/units/quantities.html"
  },
  {
    "name": "convert_to",
    "full_id": "sympy.physics.units.quantities.Quantity.convert_to",
    "type": "method",
    "description": "\n        Convert the quantity to another quantity of same dimensions.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.units import speed_of_light, meter, second\n        >>> speed_of_light\n        speed_of_light\n        >>> speed_of_light.convert_to(meter/second)\n        299792458*meter/second\n\n        >>> from sympy.physics.units import liter\n        >>> liter.convert_to(meter**3)\n        meter**3/1000\n        ",
    "section": "Physical quantities",
    "url": "https://docs.sympy.org/latest/modules/physics/units/quantities.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.physics.units.quantities.Quantity.free_symbols",
    "type": "property",
    "description": "Return free symbols from quantity.",
    "section": "Physical quantities",
    "url": "https://docs.sympy.org/latest/modules/physics/units/quantities.html"
  },
  {
    "name": "is_prefixed",
    "full_id": "sympy.physics.units.quantities.Quantity.is_prefixed",
    "type": "property",
    "description": "Whether or not the quantity is prefixed. Eg. `kilogram` is prefixed, but `gram` is not.",
    "section": "Physical quantities",
    "url": "https://docs.sympy.org/latest/modules/physics/units/quantities.html"
  },
  {
    "name": "scale_factor",
    "full_id": "sympy.physics.units.quantities.Quantity.scale_factor",
    "type": "property",
    "description": "\n        Overall magnitude of the quantity as compared to the canonical units.\n        ",
    "section": "Physical quantities",
    "url": "https://docs.sympy.org/latest/modules/physics/units/quantities.html"
  },
  {
    "name": "set_global_relative_scale_factor",
    "full_id": "sympy.physics.units.quantities.Quantity.set_global_relative_scale_factor",
    "type": "method",
    "description": "\n        Setting a scale factor that is valid across all unit system.\n        ",
    "section": "Physical quantities",
    "url": "https://docs.sympy.org/latest/modules/physics/units/quantities.html"
  },
  {
    "name": "convert_to",
    "full_id": "sympy.physics.units.util.convert_to",
    "type": "function",
    "description": "\n    Convert ``expr`` to the same expression with all of its units and quantities\n    represented as factors of ``target_units``, whenever the dimension is compatible.\n\n    ``target_units`` may be a single unit/quantity, or a collection of\n    units/quantities.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.units import speed_of_light, meter, gram, second, day\n    >>> from sympy.physics.units import mile, newton, kilogram, atomic_mass_constant\n    >>> from sympy.physics.units import kilometer, centimeter\n    >>> from sympy.physics.units import gravitational_constant, hbar\n    >>> from sympy.physics.units import convert_to\n    >>> convert_to(mile, kilometer)\n    25146*kilometer/15625\n    >>> convert_to(mile, kilometer).n()\n    1.609344*kilometer\n    >>> convert_to(speed_of_light, meter/second)\n    299792458*meter/second\n    >>> convert_to(day, second)\n    86400*second\n    >>> 3*newton\n    3*newton\n    >>> convert_to(3*newton, kilogram*meter/second**2)\n    3*kilogram*meter/second**2\n    >>> convert_to(atomic_mass_constant, gram)\n    1.660539060e-24*gram\n\n    Conversion to multiple units:\n\n    >>> convert_to(speed_of_light, [meter, second])\n    299792458*meter/second\n    >>> convert_to(3*newton, [centimeter, gram, second])\n    300000*centimeter*gram/second**2\n\n    Conversion to Planck units:\n\n    >>> convert_to(atomic_mass_constant, [gravitational_constant, speed_of_light, hbar]).n()\n    7.62963087839509e-20*hbar**0.5*speed_of_light**0.5/gravitational_constant**0.5\n\n    ",
    "section": "Conversion between quantities",
    "url": "https://docs.sympy.org/latest/modules/physics/units/quantities.html"
  },
  {
    "name": "extract_type_tens",
    "full_id": "sympy.physics.hep.gamma_matrices.extract_type_tens",
    "type": "function",
    "description": "\n    Extract from a ``TensExpr`` all tensors with `component`.\n\n    Returns two tensor expressions:\n\n    * the first contains all ``Tensor`` of having `component`.\n    * the second contains all remaining.\n\n\n    ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/physics/hep/index.html"
  },
  {
    "name": "gamma_trace",
    "full_id": "sympy.physics.hep.gamma_matrices.gamma_trace",
    "type": "function",
    "description": "\n    trace of a single line of gamma matrices\n\n    Examples\n    ========\n\n    >>> from sympy.physics.hep.gamma_matrices import GammaMatrix as G,         gamma_trace, LorentzIndex\n    >>> from sympy.tensor.tensor import tensor_indices, tensor_heads\n    >>> p, q = tensor_heads('p, q', [LorentzIndex])\n    >>> i0,i1,i2,i3,i4,i5 = tensor_indices('i0:6', LorentzIndex)\n    >>> ps = p(i0)*G(-i0)\n    >>> qs = q(i0)*G(-i0)\n    >>> gamma_trace(G(i0)*G(i1))\n    4*metric(i0, i1)\n    >>> gamma_trace(ps*ps) - 4*p(i0)*p(-i0)\n    0\n    >>> gamma_trace(ps*qs + ps*ps) - 4*p(i0)*p(-i0) - 4*p(i0)*q(-i0)\n    0\n\n    ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/physics/hep/index.html"
  },
  {
    "name": "kahane_simplify",
    "full_id": "sympy.physics.hep.gamma_matrices.kahane_simplify",
    "type": "function",
    "description": "\n    This function cancels contracted elements in a product of four\n    dimensional gamma matrices, resulting in an expression equal to the given\n    one, without the contracted gamma matrices.\n\n    Parameters\n    ==========\n\n    `expression`    the tensor expression containing the gamma matrices to simplify.\n\n    Notes\n    =====\n\n    If spinor indices are given, the matrices must be given in\n    the order given in the product.\n\n    Algorithm\n    =========\n\n    The idea behind the algorithm is to use some well-known identities,\n    i.e., for contractions enclosing an even number of `\\gamma` matrices\n\n    `\\gamma^\\mu \\gamma_{a_1} \\cdots \\gamma_{a_{2N}} \\gamma_\\mu = 2 (\\gamma_{a_{2N}} \\gamma_{a_1} \\cdots \\gamma_{a_{2N-1}} + \\gamma_{a_{2N-1}} \\cdots \\gamma_{a_1} \\gamma_{a_{2N}} )`\n\n    for an odd number of `\\gamma` matrices\n\n    `\\gamma^\\mu \\gamma_{a_1} \\cdots \\gamma_{a_{2N+1}} \\gamma_\\mu = -2 \\gamma_{a_{2N+1}} \\gamma_{a_{2N}} \\cdots \\gamma_{a_{1}}`\n\n    Instead of repeatedly applying these identities to cancel out all contracted indices,\n    it is possible to recognize the links that would result from such an operation,\n    the problem is thus reduced to a simple rearrangement of free gamma matrices.\n\n    Examples\n    ========\n\n    When using, always remember that the original expression coefficient\n    has to be handled separately\n\n    >>> from sympy.physics.hep.gamma_matrices import GammaMatrix as G, LorentzIndex\n    >>> from sympy.physics.hep.gamma_matrices import kahane_simplify\n    >>> from sympy.tensor.tensor import tensor_indices\n    >>> i0, i1, i2 = tensor_indices('i0:3', LorentzIndex)\n    >>> ta = G(i0)*G(-i0)\n    >>> kahane_simplify(ta)\n    Matrix([\n    [4, 0, 0, 0],\n    [0, 4, 0, 0],\n    [0, 0, 4, 0],\n    [0, 0, 0, 4]])\n    >>> tb = G(i0)*G(i1)*G(-i0)\n    >>> kahane_simplify(tb)\n    -2*GammaMatrix(i1)\n    >>> t = G(i0)*G(-i0)\n    >>> kahane_simplify(t)\n    Matrix([\n    [4, 0, 0, 0],\n    [0, 4, 0, 0],\n    [0, 0, 4, 0],\n    [0, 0, 0, 4]])\n    >>> t = G(i0)*G(-i0)\n    >>> kahane_simplify(t)\n    Matrix([\n    [4, 0, 0, 0],\n    [0, 4, 0, 0],\n    [0, 0, 4, 0],\n    [0, 0, 0, 4]])\n\n    If there are no contractions, the same expression is returned\n\n    >>> tc = G(i0)*G(i1)\n    >>> kahane_simplify(tc)\n    GammaMatrix(i0)*GammaMatrix(i1)\n\n    References\n    ==========\n\n    [1] Algorithm for Reducing Contracted Products of gamma Matrices,\n    Joseph Kahane, Journal of Mathematical Physics, Vol. 9, No. 10, October 1968.\n    ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/physics/hep/index.html"
  },
  {
    "name": "simplify_gpgp",
    "full_id": "sympy.physics.hep.gamma_matrices.simplify_gpgp",
    "type": "function",
    "description": "\n    simplify products ``G(i)*p(-i)*G(j)*p(-j) -> p(i)*p(-i)``\n\n    Examples\n    ========\n\n    >>> from sympy.physics.hep.gamma_matrices import GammaMatrix as G,         LorentzIndex, simplify_gpgp\n    >>> from sympy.tensor.tensor import tensor_indices, tensor_heads\n    >>> p, q = tensor_heads('p, q', [LorentzIndex])\n    >>> i0,i1,i2,i3,i4,i5 = tensor_indices('i0:6', LorentzIndex)\n    >>> ps = p(i0)*G(-i0)\n    >>> qs = q(i0)*G(-i0)\n    >>> simplify_gpgp(ps*qs*qs)\n    GammaMatrix(-L_0)*p(L_0)*q(L_1)*q(-L_1)\n    ",
    "section": "Examples",
    "url": "https://docs.sympy.org/latest/modules/physics/hep/index.html"
  },
  {
    "name": "ang_acc_in",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.ang_acc_in",
    "type": "method",
    "description": "Returns the angular acceleration Vector of the ReferenceFrame.\n\n        Effectively returns the Vector:\n\n        ``N_alpha_B``\n\n        which represent the angular acceleration of B in N, where B is self,\n        and N is otherframe.\n\n        Parameters\n        ==========\n\n        otherframe : ReferenceFrame\n            The ReferenceFrame which the angular acceleration is returned in.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> N = ReferenceFrame('N')\n        >>> A = ReferenceFrame('A')\n        >>> V = 10 * N.x\n        >>> A.set_ang_acc(N, V)\n        >>> A.ang_acc_in(N)\n        10*N.x\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "ang_vel_in",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.ang_vel_in",
    "type": "method",
    "description": "Returns the angular velocity Vector of the ReferenceFrame.\n\n        Effectively returns the Vector:\n\n        ^N omega ^B\n\n        which represent the angular velocity of B in N, where B is self, and\n        N is otherframe.\n\n        Parameters\n        ==========\n\n        otherframe : ReferenceFrame\n            The ReferenceFrame which the angular velocity is returned in.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> N = ReferenceFrame('N')\n        >>> A = ReferenceFrame('A')\n        >>> V = 10 * N.x\n        >>> A.set_ang_vel(N, V)\n        >>> A.ang_vel_in(N)\n        10*N.x\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "dcm",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.dcm",
    "type": "method",
    "description": "Returns the direction cosine matrix of this reference frame\n        relative to the provided reference frame.\n\n        The returned matrix can be used to express the orthogonal unit vectors\n        of this frame in terms of the orthogonal unit vectors of\n        ``otherframe``.\n\n        Parameters\n        ==========\n\n        otherframe : ReferenceFrame\n            The reference frame which the direction cosine matrix of this frame\n            is formed relative to.\n\n        Examples\n        ========\n\n        The following example rotates the reference frame A relative to N by a\n        simple rotation and then calculates the direction cosine matrix of N\n        relative to A.\n\n        >>> from sympy import symbols, sin, cos\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> q1 = symbols('q1')\n        >>> N = ReferenceFrame('N')\n        >>> A = ReferenceFrame('A')\n        >>> A.orient_axis(N, q1, N.x)\n        >>> N.dcm(A)\n        Matrix([\n        [1,       0,        0],\n        [0, cos(q1), -sin(q1)],\n        [0, sin(q1),  cos(q1)]])\n\n        The second row of the above direction cosine matrix represents the\n        ``N.y`` unit vector in N expressed in A. Like so:\n\n        >>> Ny = 0*A.x + cos(q1)*A.y - sin(q1)*A.z\n\n        Thus, expressing ``N.y`` in A should return the same result:\n\n        >>> N.y.express(A)\n        cos(q1)*A.y - sin(q1)*A.z\n\n        Notes\n        =====\n\n        It is important to know what form of the direction cosine matrix is\n        returned. If ``B.dcm(A)`` is called, it means the \"direction cosine\n        matrix of B rotated relative to A\". This is the matrix\n        :math:`{}^B\\mathbf{C}^A` shown in the following relationship:\n\n        .. math::\n\n           \\begin{bmatrix}\n             \\hat{\\mathbf{b}}_1 \\\\\n             \\hat{\\mathbf{b}}_2 \\\\\n             \\hat{\\mathbf{b}}_3\n           \\end{bmatrix}\n           =\n           {}^B\\mathbf{C}^A\n           \\begin{bmatrix}\n             \\hat{\\mathbf{a}}_1 \\\\\n             \\hat{\\mathbf{a}}_2 \\\\\n             \\hat{\\mathbf{a}}_3\n           \\end{bmatrix}.\n\n        :math:`{}^B\\mathbf{C}^A` is the matrix that expresses the B unit\n        vectors in terms of the A unit vectors.\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "orient",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.orient",
    "type": "method",
    "description": "Sets the orientation of this reference frame relative to another\n        (parent) reference frame.\n\n        .. note:: It is now recommended to use the ``.orient_axis,\n           .orient_body_fixed, .orient_space_fixed, .orient_quaternion``\n           methods for the different rotation types.\n\n        Parameters\n        ==========\n\n        parent : ReferenceFrame\n            Reference frame that this reference frame will be rotated relative\n            to.\n        rot_type : str\n            The method used to generate the direction cosine matrix. Supported\n            methods are:\n\n            - ``'Axis'``: simple rotations about a single common axis\n            - ``'DCM'``: for setting the direction cosine matrix directly\n            - ``'Body'``: three successive rotations about new intermediate\n              axes, also called \"Euler and Tait-Bryan angles\"\n            - ``'Space'``: three successive rotations about the parent\n              frames' unit vectors\n            - ``'Quaternion'``: rotations defined by four parameters which\n              result in a singularity free direction cosine matrix\n\n        amounts :\n            Expressions defining the rotation angles or direction cosine\n            matrix. These must match the ``rot_type``. See examples below for\n            details. The input types are:\n\n            - ``'Axis'``: 2-tuple (expr/sym/func, Vector)\n            - ``'DCM'``: Matrix, shape(3,3)\n            - ``'Body'``: 3-tuple of expressions, symbols, or functions\n            - ``'Space'``: 3-tuple of expressions, symbols, or functions\n            - ``'Quaternion'``: 4-tuple of expressions, symbols, or\n              functions\n\n        rot_order : str or int, optional\n            If applicable, the order of the successive of rotations. The string\n            ``'123'`` and integer ``123`` are equivalent, for example. Required\n            for ``'Body'`` and ``'Space'``.\n\n        Warns\n        ======\n\n        UserWarning\n            If the orientation creates a kinematic loop.\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "orient_axis",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.orient_axis",
    "type": "method",
    "description": "Sets the orientation of this reference frame with respect to a\n        parent reference frame by rotating through an angle about an axis fixed\n        in the parent reference frame.\n\n        Parameters\n        ==========\n\n        parent : ReferenceFrame\n            Reference frame that this reference frame will be rotated relative\n            to.\n        axis : Vector\n            Vector fixed in the parent frame about about which this frame is\n            rotated. It need not be a unit vector and the rotation follows the\n            right hand rule.\n        angle : sympifiable\n            Angle in radians by which it the frame is to be rotated.\n\n        Warns\n        ======\n\n        UserWarning\n            If the orientation creates a kinematic loop.\n\n        Examples\n        ========\n\n        Setup variables for the examples:\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> q1 = symbols('q1')\n        >>> N = ReferenceFrame('N')\n        >>> B = ReferenceFrame('B')\n        >>> B.orient_axis(N, N.x, q1)\n\n        The ``orient_axis()`` method generates a direction cosine matrix and\n        its transpose which defines the orientation of B relative to N and vice\n        versa. Once orient is called, ``dcm()`` outputs the appropriate\n        direction cosine matrix:\n\n        >>> B.dcm(N)\n        Matrix([\n        [1,       0,      0],\n        [0,  cos(q1), sin(q1)],\n        [0, -sin(q1), cos(q1)]])\n        >>> N.dcm(B)\n        Matrix([\n        [1,       0,        0],\n        [0, cos(q1), -sin(q1)],\n        [0, sin(q1),  cos(q1)]])\n\n        The following two lines show that the sense of the rotation can be\n        defined by negating the vector direction or the angle. Both lines\n        produce the same result.\n\n        >>> B.orient_axis(N, -N.x, q1)\n        >>> B.orient_axis(N, N.x, -q1)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "orient_body_fixed",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.orient_body_fixed",
    "type": "method",
    "description": "Rotates this reference frame relative to the parent reference frame\n        by right hand rotating through three successive body fixed simple axis\n        rotations. Each subsequent axis of rotation is about the \"body fixed\"\n        unit vectors of a new intermediate reference frame. This type of\n        rotation is also referred to rotating through the `Euler and Tait-Bryan\n        Angles`_.\n\n        .. _Euler and Tait-Bryan Angles: https://en.wikipedia.org/wiki/Euler_angles\n\n        The computed angular velocity in this method is by default expressed in\n        the child's frame, so it is most preferable to use ``u1 * child.x + u2 *\n        child.y + u3 * child.z`` as generalized speeds.\n\n        Parameters\n        ==========\n\n        parent : ReferenceFrame\n            Reference frame that this reference frame will be rotated relative\n            to.\n        angles : 3-tuple of sympifiable\n            Three angles in radians used for the successive rotations.\n        rotation_order : 3 character string or 3 digit integer\n            Order of the rotations about each intermediate reference frames'\n            unit vectors. The Euler rotation about the X, Z', X'' axes can be\n            specified by the strings ``'XZX'``, ``'131'``, or the integer\n            ``131``. There are 12 unique valid rotation orders (6 Euler and 6\n            Tait-Bryan): zxz, xyx, yzy, zyz, xzx, yxy, xyz, yzx, zxy, xzy, zyx,\n            and yxz.\n\n        Warns\n        ======\n\n        UserWarning\n            If the orientation creates a kinematic loop.\n\n        Examples\n        ========\n\n        Setup variables for the examples:\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> q1, q2, q3 = symbols('q1, q2, q3')\n        >>> N = ReferenceFrame('N')\n        >>> B = ReferenceFrame('B')\n        >>> B1 = ReferenceFrame('B1')\n        >>> B2 = ReferenceFrame('B2')\n        >>> B3 = ReferenceFrame('B3')\n\n        For example, a classic Euler Angle rotation can be done by:\n\n        >>> B.orient_body_fixed(N, (q1, q2, q3), 'XYX')\n        >>> B.dcm(N)\n        Matrix([\n        [        cos(q2),                            sin(q1)*sin(q2),                           -sin(q2)*cos(q1)],\n        [sin(q2)*sin(q3), -sin(q1)*sin(q3)*cos(q2) + cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q3)*cos(q1)*cos(q2)],\n        [sin(q2)*cos(q3), -sin(q1)*cos(q2)*cos(q3) - sin(q3)*cos(q1), -sin(q1)*sin(q3) + cos(q1)*cos(q2)*cos(q3)]])\n\n        This rotates reference frame B relative to reference frame N through\n        ``q1`` about ``N.x``, then rotates B again through ``q2`` about\n        ``B.y``, and finally through ``q3`` about ``B.x``. It is equivalent to\n        three successive ``orient_axis()`` calls:\n\n        >>> B1.orient_axis(N, N.x, q1)\n        >>> B2.orient_axis(B1, B1.y, q2)\n        >>> B3.orient_axis(B2, B2.x, q3)\n        >>> B3.dcm(N)\n        Matrix([\n        [        cos(q2),                            sin(q1)*sin(q2),                           -sin(q2)*cos(q1)],\n        [sin(q2)*sin(q3), -sin(q1)*sin(q3)*cos(q2) + cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q3)*cos(q1)*cos(q2)],\n        [sin(q2)*cos(q3), -sin(q1)*cos(q2)*cos(q3) - sin(q3)*cos(q1), -sin(q1)*sin(q3) + cos(q1)*cos(q2)*cos(q3)]])\n\n        Acceptable rotation orders are of length 3, expressed in as a string\n        ``'XYZ'`` or ``'123'`` or integer ``123``. Rotations about an axis\n        twice in a row are prohibited.\n\n        >>> B.orient_body_fixed(N, (q1, q2, 0), 'ZXZ')\n        >>> B.orient_body_fixed(N, (q1, q2, 0), '121')\n        >>> B.orient_body_fixed(N, (q1, q2, q3), 123)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "orient_dcm",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.orient_dcm",
    "type": "method",
    "description": "Sets the orientation of this reference frame relative to another (parent) reference frame\n        using a direction cosine matrix that describes the rotation from the child to the parent.\n\n        Parameters\n        ==========\n\n        parent : ReferenceFrame\n            Reference frame that this reference frame will be rotated relative\n            to.\n        dcm : Matrix, shape(3, 3)\n            Direction cosine matrix that specifies the relative rotation\n            between the two reference frames.\n\n        Warns\n        ======\n\n        UserWarning\n            If the orientation creates a kinematic loop.\n\n        Examples\n        ========\n\n        Setup variables for the examples:\n\n        >>> from sympy import symbols, Matrix, sin, cos\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> q1 = symbols('q1')\n        >>> A = ReferenceFrame('A')\n        >>> B = ReferenceFrame('B')\n        >>> N = ReferenceFrame('N')\n\n        A simple rotation of ``A`` relative to ``N`` about ``N.x`` is defined\n        by the following direction cosine matrix:\n\n        >>> dcm = Matrix([[1, 0, 0],\n        ...               [0,  cos(q1), sin(q1)],\n        ...               [0, -sin(q1), cos(q1)]])\n        >>> A.orient_dcm(N, dcm)\n        >>> A.dcm(N)\n        Matrix([\n        [1,       0,      0],\n        [0,  cos(q1), sin(q1)],\n        [0, -sin(q1), cos(q1)]])\n\n        This is equivalent to using ``orient_axis()``:\n\n        >>> B.orient_axis(N, N.x, q1)\n        >>> B.dcm(N)\n        Matrix([\n        [1,       0,      0],\n        [0,  cos(q1), sin(q1)],\n        [0, -sin(q1), cos(q1)]])\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "orient_quaternion",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.orient_quaternion",
    "type": "method",
    "description": "Sets the orientation of this reference frame relative to a parent\n        reference frame via an orientation quaternion. An orientation\n        quaternion is defined as a finite rotation a unit vector, ``(lambda_x,\n        lambda_y, lambda_z)``, by an angle ``theta``. The orientation\n        quaternion is described by four parameters:\n\n        - ``q0 = cos(theta/2)``\n        - ``q1 = lambda_x*sin(theta/2)``\n        - ``q2 = lambda_y*sin(theta/2)``\n        - ``q3 = lambda_z*sin(theta/2)``\n\n        See `Quaternions and Spatial Rotation\n        <https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation>`_ on\n        Wikipedia for more information.\n\n        Parameters\n        ==========\n        parent : ReferenceFrame\n            Reference frame that this reference frame will be rotated relative\n            to.\n        numbers : 4-tuple of sympifiable\n            The four quaternion scalar numbers as defined above: ``q0``,\n            ``q1``, ``q2``, ``q3``.\n\n        Warns\n        ======\n\n        UserWarning\n            If the orientation creates a kinematic loop.\n\n        Examples\n        ========\n\n        Setup variables for the examples:\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n        >>> N = ReferenceFrame('N')\n        >>> B = ReferenceFrame('B')\n\n        Set the orientation:\n\n        >>> B.orient_quaternion(N, (q0, q1, q2, q3))\n        >>> B.dcm(N)\n        Matrix([\n        [q0**2 + q1**2 - q2**2 - q3**2,             2*q0*q3 + 2*q1*q2,            -2*q0*q2 + 2*q1*q3],\n        [           -2*q0*q3 + 2*q1*q2, q0**2 - q1**2 + q2**2 - q3**2,             2*q0*q1 + 2*q2*q3],\n        [            2*q0*q2 + 2*q1*q3,            -2*q0*q1 + 2*q2*q3, q0**2 - q1**2 - q2**2 + q3**2]])\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "orient_space_fixed",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.orient_space_fixed",
    "type": "method",
    "description": "Rotates this reference frame relative to the parent reference frame\n        by right hand rotating through three successive space fixed simple axis\n        rotations. Each subsequent axis of rotation is about the \"space fixed\"\n        unit vectors of the parent reference frame.\n\n        The computed angular velocity in this method is by default expressed in\n        the child's frame, so it is most preferable to use ``u1 * child.x + u2 *\n        child.y + u3 * child.z`` as generalized speeds.\n\n        Parameters\n        ==========\n        parent : ReferenceFrame\n            Reference frame that this reference frame will be rotated relative\n            to.\n        angles : 3-tuple of sympifiable\n            Three angles in radians used for the successive rotations.\n        rotation_order : 3 character string or 3 digit integer\n            Order of the rotations about the parent reference frame's unit\n            vectors. The order can be specified by the strings ``'XZX'``,\n            ``'131'``, or the integer ``131``. There are 12 unique valid\n            rotation orders.\n\n        Warns\n        ======\n\n        UserWarning\n            If the orientation creates a kinematic loop.\n\n        Examples\n        ========\n\n        Setup variables for the examples:\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> q1, q2, q3 = symbols('q1, q2, q3')\n        >>> N = ReferenceFrame('N')\n        >>> B = ReferenceFrame('B')\n        >>> B1 = ReferenceFrame('B1')\n        >>> B2 = ReferenceFrame('B2')\n        >>> B3 = ReferenceFrame('B3')\n\n        >>> B.orient_space_fixed(N, (q1, q2, q3), '312')\n        >>> B.dcm(N)\n        Matrix([\n        [ sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1)],\n        [-sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3)],\n        [                           sin(q3)*cos(q2),        -sin(q2),                           cos(q2)*cos(q3)]])\n\n        is equivalent to:\n\n        >>> B1.orient_axis(N, N.z, q1)\n        >>> B2.orient_axis(B1, N.x, q2)\n        >>> B3.orient_axis(B2, N.y, q3)\n        >>> B3.dcm(N).simplify()\n        Matrix([\n        [ sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1)],\n        [-sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3)],\n        [                           sin(q3)*cos(q2),        -sin(q2),                           cos(q2)*cos(q3)]])\n\n        It is worth noting that space-fixed and body-fixed rotations are\n        related by the order of the rotations, i.e. the reverse order of body\n        fixed will give space fixed and vice versa.\n\n        >>> B.orient_space_fixed(N, (q1, q2, q3), '231')\n        >>> B.dcm(N)\n        Matrix([\n        [cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), -sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],\n        [       -sin(q2),                           cos(q2)*cos(q3),                            sin(q3)*cos(q2)],\n        [sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1),  sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3)]])\n\n        >>> B.orient_body_fixed(N, (q3, q2, q1), '132')\n        >>> B.dcm(N)\n        Matrix([\n        [cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), -sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],\n        [       -sin(q2),                           cos(q2)*cos(q3),                            sin(q3)*cos(q2)],\n        [sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1),  sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3)]])\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "orientnew",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.orientnew",
    "type": "method",
    "description": "Returns a new reference frame oriented with respect to this\n        reference frame.\n\n        See ``ReferenceFrame.orient()`` for detailed examples of how to orient\n        reference frames.\n\n        Parameters\n        ==========\n\n        newname : str\n            Name for the new reference frame.\n        rot_type : str\n            The method used to generate the direction cosine matrix. Supported\n            methods are:\n\n            - ``'Axis'``: simple rotations about a single common axis\n            - ``'DCM'``: for setting the direction cosine matrix directly\n            - ``'Body'``: three successive rotations about new intermediate\n              axes, also called \"Euler and Tait-Bryan angles\"\n            - ``'Space'``: three successive rotations about the parent\n              frames' unit vectors\n            - ``'Quaternion'``: rotations defined by four parameters which\n              result in a singularity free direction cosine matrix\n\n        amounts :\n            Expressions defining the rotation angles or direction cosine\n            matrix. These must match the ``rot_type``. See examples below for\n            details. The input types are:\n\n            - ``'Axis'``: 2-tuple (expr/sym/func, Vector)\n            - ``'DCM'``: Matrix, shape(3,3)\n            - ``'Body'``: 3-tuple of expressions, symbols, or functions\n            - ``'Space'``: 3-tuple of expressions, symbols, or functions\n            - ``'Quaternion'``: 4-tuple of expressions, symbols, or\n              functions\n\n        rot_order : str or int, optional\n            If applicable, the order of the successive of rotations. The string\n            ``'123'`` and integer ``123`` are equivalent, for example. Required\n            for ``'Body'`` and ``'Space'``.\n        indices : tuple of str\n            Enables the reference frame's basis unit vectors to be accessed by\n            Python's square bracket indexing notation using the provided three\n            indice strings and alters the printing of the unit vectors to\n            reflect this choice.\n        latexs : tuple of str\n            Alters the LaTeX printing of the reference frame's basis unit\n            vectors to the provided three valid LaTeX strings.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame, vlatex\n        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n        >>> N = ReferenceFrame('N')\n\n        Create a new reference frame A rotated relative to N through a simple\n        rotation.\n\n        >>> A = N.orientnew('A', 'Axis', (q0, N.x))\n\n        Create a new reference frame B rotated relative to N through body-fixed\n        rotations.\n\n        >>> B = N.orientnew('B', 'Body', (q1, q2, q3), '123')\n\n        Create a new reference frame C rotated relative to N through a simple\n        rotation with unique indices and LaTeX printing.\n\n        >>> C = N.orientnew('C', 'Axis', (q0, N.x), indices=('1', '2', '3'),\n        ... latexs=(r'\\hat{\\mathbf{c}}_1',r'\\hat{\\mathbf{c}}_2',\n        ... r'\\hat{\\mathbf{c}}_3'))\n        >>> C['1']\n        C['1']\n        >>> print(vlatex(C['1']))\n        \\hat{\\mathbf{c}}_1\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "partial_velocity",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.partial_velocity",
    "type": "method",
    "description": "Returns the partial angular velocities of this frame in the given\n        frame with respect to one or more provided generalized speeds.\n\n        Parameters\n        ==========\n        frame : ReferenceFrame\n            The frame with which the angular velocity is defined in.\n        gen_speeds : functions of time\n            The generalized speeds.\n\n        Returns\n        =======\n        partial_velocities : tuple of Vector\n            The partial angular velocity vectors corresponding to the provided\n            generalized speeds.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, dynamicsymbols\n        >>> N = ReferenceFrame('N')\n        >>> A = ReferenceFrame('A')\n        >>> u1, u2 = dynamicsymbols('u1, u2')\n        >>> A.set_ang_vel(N, u1 * A.x + u2 * N.y)\n        >>> A.partial_velocity(N, u1)\n        A.x\n        >>> A.partial_velocity(N, u1, u2)\n        (A.x, N.y)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "set_ang_acc",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.set_ang_acc",
    "type": "method",
    "description": "Define the angular acceleration Vector in a ReferenceFrame.\n\n        Defines the angular acceleration of this ReferenceFrame, in another.\n        Angular acceleration can be defined with respect to multiple different\n        ReferenceFrames. Care must be taken to not create loops which are\n        inconsistent.\n\n        Parameters\n        ==========\n\n        otherframe : ReferenceFrame\n            A ReferenceFrame to define the angular acceleration in\n        value : Vector\n            The Vector representing angular acceleration\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> N = ReferenceFrame('N')\n        >>> A = ReferenceFrame('A')\n        >>> V = 10 * N.x\n        >>> A.set_ang_acc(N, V)\n        >>> A.ang_acc_in(N)\n        10*N.x\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "set_ang_vel",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.set_ang_vel",
    "type": "method",
    "description": "Define the angular velocity vector in a ReferenceFrame.\n\n        Defines the angular velocity of this ReferenceFrame, in another.\n        Angular velocity can be defined with respect to multiple different\n        ReferenceFrames. Care must be taken to not create loops which are\n        inconsistent.\n\n        Parameters\n        ==========\n\n        otherframe : ReferenceFrame\n            A ReferenceFrame to define the angular velocity in\n        value : Vector\n            The Vector representing angular velocity\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> N = ReferenceFrame('N')\n        >>> A = ReferenceFrame('A')\n        >>> V = 10 * N.x\n        >>> A.set_ang_vel(N, V)\n        >>> A.ang_vel_in(N)\n        10*N.x\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "u",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.u",
    "type": "property",
    "description": "Unit dyadic for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "variable_map",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.variable_map",
    "type": "method",
    "description": "\n        Returns a dictionary which expresses the coordinate variables\n        of this frame in terms of the variables of otherframe.\n\n        If Vector.simp is True, returns a simplified version of the mapped\n        values. Else, returns them without simplification.\n\n        Simplification of the expressions may take time.\n\n        Parameters\n        ==========\n\n        otherframe : ReferenceFrame\n            The other frame to map the variables to\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, dynamicsymbols\n        >>> A = ReferenceFrame('A')\n        >>> q = dynamicsymbols('q')\n        >>> B = A.orientnew('B', 'Axis', [q, A.z])\n        >>> A.variable_map(B)\n        {A_x: B_x*cos(q(t)) - B_y*sin(q(t)), A_y: B_x*sin(q(t)) + B_y*cos(q(t)), A_z: B_z}\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "x",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.x",
    "type": "property",
    "description": "The basis Vector for the ReferenceFrame, in the x direction.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "xx",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.xx",
    "type": "property",
    "description": "Unit dyad of basis Vectors x and x for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "xy",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.xy",
    "type": "property",
    "description": "Unit dyad of basis Vectors x and y for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "xz",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.xz",
    "type": "property",
    "description": "Unit dyad of basis Vectors x and z for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "y",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.y",
    "type": "property",
    "description": "The basis Vector for the ReferenceFrame, in the y direction.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "yx",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.yx",
    "type": "property",
    "description": "Unit dyad of basis Vectors y and x for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "yy",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.yy",
    "type": "property",
    "description": "Unit dyad of basis Vectors y and y for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "yz",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.yz",
    "type": "property",
    "description": "Unit dyad of basis Vectors y and z for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "z",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.z",
    "type": "property",
    "description": "The basis Vector for the ReferenceFrame, in the z direction.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "zx",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.zx",
    "type": "property",
    "description": "Unit dyad of basis Vectors z and x for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "zy",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.zy",
    "type": "property",
    "description": "Unit dyad of basis Vectors z and y for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "zz",
    "full_id": "sympy.physics.vector.frame.ReferenceFrame.zz",
    "type": "property",
    "description": "Unit dyad of basis Vectors z and z for the ReferenceFrame.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "angle_between",
    "full_id": "sympy.physics.vector.vector.Vector.angle_between",
    "type": "method",
    "description": "\n        Returns the smallest angle between Vector 'vec' and self.\n\n        Parameter\n        =========\n\n        vec : Vector\n            The Vector between which angle is needed.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> A = ReferenceFrame(\"A\")\n        >>> v1 = A.x\n        >>> v2 = A.y\n        >>> v1.angle_between(v2)\n        pi/2\n\n        >>> v3 = A.x + A.y + A.z\n        >>> v1.angle_between(v3)\n        acos(sqrt(3)/3)\n\n        Warnings\n        ========\n\n        Python ignores the leading negative sign so that might give wrong\n        results. ``-A.x.angle_between()`` would be treated as\n        ``-(A.x.angle_between())``, instead of ``(-A.x).angle_between()``.\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "applyfunc",
    "full_id": "sympy.physics.vector.vector.Vector.applyfunc",
    "type": "method",
    "description": "Apply a function to each component of a vector.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "cross",
    "full_id": "sympy.physics.vector.vector.Vector.cross",
    "type": "method",
    "description": "The cross product operator for two Vectors.\n\n        Returns a Vector, expressed in the same ReferenceFrames as self.\n\n        Parameters\n        ==========\n\n        other : Vector\n            The Vector which we are crossing with\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame, cross\n        >>> q1 = symbols('q1')\n        >>> N = ReferenceFrame('N')\n        >>> cross(N.x, N.y)\n        N.z\n        >>> A = ReferenceFrame('A')\n        >>> A.orient_axis(N, q1, N.x)\n        >>> cross(A.x, N.y)\n        N.z\n        >>> cross(N.y, A.x)\n        - sin(q1)*A.y - cos(q1)*A.z\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "diff",
    "full_id": "sympy.physics.vector.vector.Vector.diff",
    "type": "method",
    "description": "Returns the partial derivative of the vector with respect to a\n        variable in the provided reference frame.\n\n        Parameters\n        ==========\n        var : Symbol\n            What the partial derivative is taken with respect to.\n        frame : ReferenceFrame\n            The reference frame that the partial derivative is taken in.\n        var_in_dcm : boolean\n            If true, the differentiation algorithm assumes that the variable\n            may be present in any of the direction cosine matrices that relate\n            the frame to the frames of any component of the vector. But if it\n            is known that the variable is not present in the direction cosine\n            matrices, false can be set to skip full reexpression in the desired\n            frame.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy.physics.vector import dynamicsymbols, ReferenceFrame\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> t = Symbol('t')\n        >>> q1 = dynamicsymbols('q1')\n        >>> N = ReferenceFrame('N')\n        >>> A = N.orientnew('A', 'Axis', [q1, N.y])\n        >>> A.x.diff(t, N)\n        - sin(q1)*q1'*N.x - cos(q1)*q1'*N.z\n        >>> A.x.diff(t, N).express(A).simplify()\n        - q1'*A.z\n        >>> B = ReferenceFrame('B')\n        >>> u1, u2 = dynamicsymbols('u1, u2')\n        >>> v = u1 * A.x + u2 * B.y\n        >>> v.diff(u2, N, var_in_dcm=False)\n        B.y\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.vector.vector.Vector.doit",
    "type": "method",
    "description": "Calls .doit() on each term in the Vector",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "dot",
    "full_id": "sympy.physics.vector.vector.Vector.dot",
    "type": "method",
    "description": "Dot product of two vectors.\n\n        Returns a scalar, the dot product of the two Vectors\n\n        Parameters\n        ==========\n\n        other : Vector\n            The Vector which we are dotting with\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, dot\n        >>> from sympy import symbols\n        >>> q1 = symbols('q1')\n        >>> N = ReferenceFrame('N')\n        >>> dot(N.x, N.x)\n        1\n        >>> dot(N.x, N.y)\n        0\n        >>> A = N.orientnew('A', 'Axis', [q1, N.x])\n        >>> dot(N.y, A.y)\n        cos(q1)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "dt",
    "full_id": "sympy.physics.vector.vector.Vector.dt",
    "type": "method",
    "description": "\n        Returns a Vector which is the time derivative of\n        the self Vector, taken in frame otherframe.\n\n        Calls the global time_derivative method\n\n        Parameters\n        ==========\n\n        otherframe : ReferenceFrame\n            The frame to calculate the time derivative in\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "express",
    "full_id": "sympy.physics.vector.vector.Vector.express",
    "type": "method",
    "description": "\n        Returns a Vector equivalent to this one, expressed in otherframe.\n        Uses the global express method.\n\n        Parameters\n        ==========\n\n        otherframe : ReferenceFrame\n            The frame for this Vector to be described in\n\n        variables : boolean\n            If True, the coordinate symbols(if present) in this Vector\n            are re-expressed in terms otherframe\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> q1 = dynamicsymbols('q1')\n        >>> N = ReferenceFrame('N')\n        >>> A = N.orientnew('A', 'Axis', [q1, N.y])\n        >>> A.x.express(N)\n        cos(q1)*N.x - sin(q1)*N.z\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "free_dynamicsymbols",
    "full_id": "sympy.physics.vector.vector.Vector.free_dynamicsymbols",
    "type": "method",
    "description": "Returns the free dynamic symbols (functions of time ``t``) in the\n        measure numbers of the vector expressed in the given reference frame.\n\n        Parameters\n        ==========\n        reference_frame : ReferenceFrame\n            The frame with respect to which the free dynamic symbols of the\n            given vector is to be determined.\n\n        Returns\n        =======\n        set\n            Set of functions of time ``t``, e.g.\n            ``Function('f')(me.dynamicsymbols._t)``.\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.physics.vector.vector.Vector.free_symbols",
    "type": "method",
    "description": "Returns the free symbols in the measure numbers of the vector\n        expressed in the given reference frame.\n\n        Parameters\n        ==========\n        reference_frame : ReferenceFrame\n            The frame with respect to which the free symbols of the given\n            vector is to be determined.\n\n        Returns\n        =======\n        set of Symbol\n            set of symbols present in the measure numbers of\n            ``reference_frame``.\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "func",
    "full_id": "sympy.physics.vector.vector.Vector.func",
    "type": "property",
    "description": "Returns the class Vector.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "magnitude",
    "full_id": "sympy.physics.vector.vector.Vector.magnitude",
    "type": "method",
    "description": "Returns the magnitude (Euclidean norm) of self.\n\n        Warnings\n        ========\n\n        Python ignores the leading negative sign so that might\n        give wrong results.\n        ``-A.x.magnitude()`` would be treated as ``-(A.x.magnitude())``,\n        instead of ``(-A.x).magnitude()``.\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "normalize",
    "full_id": "sympy.physics.vector.vector.Vector.normalize",
    "type": "method",
    "description": "Returns a Vector of magnitude 1, codirectional with self.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "outer",
    "full_id": "sympy.physics.vector.vector.Vector.outer",
    "type": "method",
    "description": "Outer product between two Vectors.\n\n        A rank increasing operation, which returns a Dyadic from two Vectors\n\n        Parameters\n        ==========\n\n        other : Vector\n            The Vector to take the outer product with\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, outer\n        >>> N = ReferenceFrame('N')\n        >>> outer(N.x, N.x)\n        (N.x|N.x)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "separate",
    "full_id": "sympy.physics.vector.vector.Vector.separate",
    "type": "method",
    "description": "\n        The constituents of this vector in different reference frames,\n        as per its definition.\n\n        Returns a dict mapping each ReferenceFrame to the corresponding\n        constituent Vector.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> R1 = ReferenceFrame('R1')\n        >>> R2 = ReferenceFrame('R2')\n        >>> v = R1.x + R2.x\n        >>> v.separate() == {R1: R1.x, R2: R2.x}\n        True\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "simplify",
    "full_id": "sympy.physics.vector.vector.Vector.simplify",
    "type": "method",
    "description": "Returns a simplified Vector.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "subs",
    "full_id": "sympy.physics.vector.vector.Vector.subs",
    "type": "method",
    "description": "Substitution on the Vector.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> from sympy import Symbol\n        >>> N = ReferenceFrame('N')\n        >>> s = Symbol('s')\n        >>> a = N.x * s\n        >>> a.subs({s: 2})\n        2*N.x\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "to_matrix",
    "full_id": "sympy.physics.vector.vector.Vector.to_matrix",
    "type": "method",
    "description": "Returns the matrix form of the vector with respect to the given\n        frame.\n\n        Parameters\n        ----------\n        reference_frame : ReferenceFrame\n            The reference frame that the rows of the matrix correspond to.\n\n        Returns\n        -------\n        matrix : ImmutableMatrix, shape(3,1)\n            The matrix that gives the 1D vector.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> a, b, c = symbols('a, b, c')\n        >>> N = ReferenceFrame('N')\n        >>> vector = a * N.x + b * N.y + c * N.z\n        >>> vector.to_matrix(N)\n        Matrix([\n        [a],\n        [b],\n        [c]])\n        >>> beta = symbols('beta')\n        >>> A = N.orientnew('A', 'Axis', (beta, N.x))\n        >>> vector.to_matrix(A)\n        Matrix([\n        [                         a],\n        [ b*cos(beta) + c*sin(beta)],\n        [-b*sin(beta) + c*cos(beta)]])\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "xreplace",
    "full_id": "sympy.physics.vector.vector.Vector.xreplace",
    "type": "method",
    "description": "Replace occurrences of objects within the measure numbers of the\n        vector.\n\n        Parameters\n        ==========\n\n        rule : dict-like\n            Expresses a replacement rule.\n\n        Returns\n        =======\n\n        Vector\n            Result of the replacement.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, pi\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> A = ReferenceFrame('A')\n        >>> x, y, z = symbols('x y z')\n        >>> ((1 + x*y) * A.x).xreplace({x: pi})\n        (pi*y + 1)*A.x\n        >>> ((1 + x*y) * A.x).xreplace({x: pi, y: 2})\n        (1 + 2*pi)*A.x\n\n        Replacements occur only if an entire node in the expression tree is\n        matched:\n\n        >>> ((x*y + z) * A.x).xreplace({x*y: pi})\n        (z + pi)*A.x\n        >>> ((x*y*z) * A.x).xreplace({x*y: pi})\n        x*y*z*A.x\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "applyfunc",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.applyfunc",
    "type": "method",
    "description": "Apply a function to each component of a Dyadic.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "cross",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.cross",
    "type": "method",
    "description": "Returns the dyadic resulting from the dyadic vector cross product:\n        Dyadic x Vector.\n\n        Parameters\n        ==========\n        other : Vector\n            Vector to cross with.\n\n        Examples\n        ========\n        >>> from sympy.physics.vector import ReferenceFrame, outer, cross\n        >>> N = ReferenceFrame('N')\n        >>> d = outer(N.x, N.x)\n        >>> cross(d, N.y)\n        (N.x|N.z)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.doit",
    "type": "method",
    "description": "Calls .doit() on each term in the Dyadic",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "dot",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.dot",
    "type": "method",
    "description": "The inner product operator for a Dyadic and a Dyadic or Vector.\n\n        Parameters\n        ==========\n\n        other : Dyadic or Vector\n            The other Dyadic or Vector to take the inner product with\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, outer\n        >>> N = ReferenceFrame('N')\n        >>> D1 = outer(N.x, N.y)\n        >>> D2 = outer(N.y, N.y)\n        >>> D1.dot(D2)\n        (N.x|N.y)\n        >>> D1.dot(N.y)\n        N.x\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "dt",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.dt",
    "type": "method",
    "description": "Take the time derivative of this Dyadic in a frame.\n\n        This function calls the global time_derivative method\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame\n            The frame to take the time derivative in\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, outer, dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> N = ReferenceFrame('N')\n        >>> q = dynamicsymbols('q')\n        >>> B = N.orientnew('B', 'Axis', [q, N.z])\n        >>> d = outer(N.x, N.x)\n        >>> d.dt(B)\n        - q'*(N.y|N.x) - q'*(N.x|N.y)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "express",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.express",
    "type": "method",
    "description": "Expresses this Dyadic in alternate frame(s)\n\n        The first frame is the list side expression, the second frame is the\n        right side; if Dyadic is in form A.x|B.y, you can express it in two\n        different frames. If no second frame is given, the Dyadic is\n        expressed in only one frame.\n\n        Calls the global express function\n\n        Parameters\n        ==========\n\n        frame1 : ReferenceFrame\n            The frame to express the left side of the Dyadic in\n        frame2 : ReferenceFrame\n            If provided, the frame to express the right side of the Dyadic in\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, outer, dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> N = ReferenceFrame('N')\n        >>> q = dynamicsymbols('q')\n        >>> B = N.orientnew('B', 'Axis', [q, N.z])\n        >>> d = outer(N.x, N.x)\n        >>> d.express(B, N)\n        cos(q)*(B.x|N.x) - sin(q)*(B.y|N.x)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "func",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.func",
    "type": "property",
    "description": "Returns the class Dyadic.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "simplify",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.simplify",
    "type": "method",
    "description": "Returns a simplified Dyadic.",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "subs",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.subs",
    "type": "method",
    "description": "Substitution on the Dyadic.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> from sympy import Symbol\n        >>> N = ReferenceFrame('N')\n        >>> s = Symbol('s')\n        >>> a = s*(N.x|N.x)\n        >>> a.subs({s: 2})\n        2*(N.x|N.x)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "to_matrix",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.to_matrix",
    "type": "method",
    "description": "Returns the matrix form of the dyadic with respect to one or two\n        reference frames.\n\n        Parameters\n        ----------\n        reference_frame : ReferenceFrame\n            The reference frame that the rows and columns of the matrix\n            correspond to. If a second reference frame is provided, this\n            only corresponds to the rows of the matrix.\n        second_reference_frame : ReferenceFrame, optional, default=None\n            The reference frame that the columns of the matrix correspond\n            to.\n\n        Returns\n        -------\n        matrix : ImmutableMatrix, shape(3,3)\n            The matrix that gives the 2D tensor form.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, trigsimp\n        >>> from sympy.physics.vector import ReferenceFrame\n        >>> from sympy.physics.mechanics import inertia\n        >>> Ixx, Iyy, Izz, Ixy, Iyz, Ixz = symbols('Ixx, Iyy, Izz, Ixy, Iyz, Ixz')\n        >>> N = ReferenceFrame('N')\n        >>> inertia_dyadic = inertia(N, Ixx, Iyy, Izz, Ixy, Iyz, Ixz)\n        >>> inertia_dyadic.to_matrix(N)\n        Matrix([\n        [Ixx, Ixy, Ixz],\n        [Ixy, Iyy, Iyz],\n        [Ixz, Iyz, Izz]])\n        >>> beta = symbols('beta')\n        >>> A = N.orientnew('A', 'Axis', (beta, N.x))\n        >>> trigsimp(inertia_dyadic.to_matrix(A))\n        Matrix([\n        [                           Ixx,                                           Ixy*cos(beta) + Ixz*sin(beta),                                           -Ixy*sin(beta) + Ixz*cos(beta)],\n        [ Ixy*cos(beta) + Ixz*sin(beta), Iyy*cos(2*beta)/2 + Iyy/2 + Iyz*sin(2*beta) - Izz*cos(2*beta)/2 + Izz/2,                 -Iyy*sin(2*beta)/2 + Iyz*cos(2*beta) + Izz*sin(2*beta)/2],\n        [-Ixy*sin(beta) + Ixz*cos(beta),                -Iyy*sin(2*beta)/2 + Iyz*cos(2*beta) + Izz*sin(2*beta)/2, -Iyy*cos(2*beta)/2 + Iyy/2 - Iyz*sin(2*beta) + Izz*cos(2*beta)/2 + Izz/2]])\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "xreplace",
    "full_id": "sympy.physics.vector.dyadic.Dyadic.xreplace",
    "type": "method",
    "description": "\n        Replace occurrences of objects within the measure numbers of the\n        Dyadic.\n\n        Parameters\n        ==========\n\n        rule : dict-like\n            Expresses a replacement rule.\n\n        Returns\n        =======\n\n        Dyadic\n            Result of the replacement.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, pi\n        >>> from sympy.physics.vector import ReferenceFrame, outer\n        >>> N = ReferenceFrame('N')\n        >>> D = outer(N.x, N.x)\n        >>> x, y, z = symbols('x y z')\n        >>> ((1 + x*y) * D).xreplace({x: pi})\n        (pi*y + 1)*(N.x|N.x)\n        >>> ((1 + x*y) * D).xreplace({x: pi, y: 2})\n        (1 + 2*pi)*(N.x|N.x)\n\n        Replacements occur only if an entire node in the expression tree is\n        matched:\n\n        >>> ((x*y + z) * D).xreplace({x*y: pi})\n        (z + pi)*(N.x|N.x)\n        >>> ((x*y*z) * D).xreplace({x*y: pi})\n        x*y*z*(N.x|N.x)\n\n        ",
    "section": "Essential Classes",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/classes.html"
  },
  {
    "name": "a1pt_theory",
    "full_id": "sympy.physics.vector.point.Point.a1pt_theory",
    "type": "method",
    "description": "Sets the acceleration of this point with the 1-point theory.\n\n        The 1-point theory for point acceleration looks like this:\n\n        ^N a^P = ^B a^P + ^N a^O + ^N alpha^B x r^OP + ^N omega^B x (^N omega^B\n        x r^OP) + 2 ^N omega^B x ^B v^P\n\n        where O is a point fixed in B, P is a point moving in B, and B is\n        rotating in frame N.\n\n        Parameters\n        ==========\n\n        otherpoint : Point\n            The first point of the 1-point theory (O)\n        outframe : ReferenceFrame\n            The frame we want this point's acceleration defined in (N)\n        fixedframe : ReferenceFrame\n            The intermediate frame in this calculation (B)\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame\n        >>> from sympy.physics.vector import dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> q = dynamicsymbols('q')\n        >>> q2 = dynamicsymbols('q2')\n        >>> qd = dynamicsymbols('q', 1)\n        >>> q2d = dynamicsymbols('q2', 1)\n        >>> N = ReferenceFrame('N')\n        >>> B = ReferenceFrame('B')\n        >>> B.set_ang_vel(N, 5 * B.y)\n        >>> O = Point('O')\n        >>> P = O.locatenew('P', q * B.x + q2 * B.y)\n        >>> P.set_vel(B, qd * B.x + q2d * B.y)\n        >>> O.set_vel(N, 0)\n        >>> P.a1pt_theory(O, N, B)\n        (-25*q + q'')*B.x + q2''*B.y - 10*q'*B.z\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "a2pt_theory",
    "full_id": "sympy.physics.vector.point.Point.a2pt_theory",
    "type": "method",
    "description": "Sets the acceleration of this point with the 2-point theory.\n\n        The 2-point theory for point acceleration looks like this:\n\n        ^N a^P = ^N a^O + ^N alpha^B x r^OP + ^N omega^B x (^N omega^B x r^OP)\n\n        where O and P are both points fixed in frame B, which is rotating in\n        frame N.\n\n        Parameters\n        ==========\n\n        otherpoint : Point\n            The first point of the 2-point theory (O)\n        outframe : ReferenceFrame\n            The frame we want this point's acceleration defined in (N)\n        fixedframe : ReferenceFrame\n            The frame in which both points are fixed (B)\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame, dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> q = dynamicsymbols('q')\n        >>> qd = dynamicsymbols('q', 1)\n        >>> N = ReferenceFrame('N')\n        >>> B = N.orientnew('B', 'Axis', [q, N.z])\n        >>> O = Point('O')\n        >>> P = O.locatenew('P', 10 * B.x)\n        >>> O.set_vel(N, 5 * N.x)\n        >>> P.a2pt_theory(O, N, B)\n        - 10*q'**2*B.x + 10*q''*B.y\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "acc",
    "full_id": "sympy.physics.vector.point.Point.acc",
    "type": "method",
    "description": "The acceleration Vector of this Point in a ReferenceFrame.\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame\n            The frame in which the returned acceleration vector will be defined\n            in.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame\n        >>> N = ReferenceFrame('N')\n        >>> p1 = Point('p1')\n        >>> p1.set_acc(N, 10 * N.x)\n        >>> p1.acc(N)\n        10*N.x\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "locatenew",
    "full_id": "sympy.physics.vector.point.Point.locatenew",
    "type": "method",
    "description": "Creates a new point with a position defined from this point.\n\n        Parameters\n        ==========\n\n        name : str\n            The name for the new point\n        value : Vector\n            The position of the new point relative to this point\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, Point\n        >>> N = ReferenceFrame('N')\n        >>> P1 = Point('P1')\n        >>> P2 = P1.locatenew('P2', 10 * N.x)\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "partial_velocity",
    "full_id": "sympy.physics.vector.point.Point.partial_velocity",
    "type": "method",
    "description": "Returns the partial velocities of the linear velocity vector of this\n        point in the given frame with respect to one or more provided\n        generalized speeds.\n\n        Parameters\n        ==========\n        frame : ReferenceFrame\n            The frame with which the velocity is defined in.\n        gen_speeds : functions of time\n            The generalized speeds.\n\n        Returns\n        =======\n        partial_velocities : tuple of Vector\n            The partial velocity vectors corresponding to the provided\n            generalized speeds.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, Point\n        >>> from sympy.physics.vector import dynamicsymbols\n        >>> N = ReferenceFrame('N')\n        >>> A = ReferenceFrame('A')\n        >>> p = Point('p')\n        >>> u1, u2 = dynamicsymbols('u1, u2')\n        >>> p.set_vel(N, u1 * N.x + u2 * A.y)\n        >>> p.partial_velocity(N, u1)\n        N.x\n        >>> p.partial_velocity(N, u1, u2)\n        (N.x, A.y)\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "pos_from",
    "full_id": "sympy.physics.vector.point.Point.pos_from",
    "type": "method",
    "description": "Returns a Vector distance between this Point and the other Point.\n\n        Parameters\n        ==========\n\n        otherpoint : Point\n            The otherpoint we are locating this one relative to\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame\n        >>> N = ReferenceFrame('N')\n        >>> p1 = Point('p1')\n        >>> p2 = Point('p2')\n        >>> p1.set_pos(p2, 10 * N.x)\n        >>> p1.pos_from(p2)\n        10*N.x\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "set_acc",
    "full_id": "sympy.physics.vector.point.Point.set_acc",
    "type": "method",
    "description": "Used to set the acceleration of this Point in a ReferenceFrame.\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame\n            The frame in which this point's acceleration is defined\n        value : Vector\n            The vector value of this point's acceleration in the frame\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame\n        >>> N = ReferenceFrame('N')\n        >>> p1 = Point('p1')\n        >>> p1.set_acc(N, 10 * N.x)\n        >>> p1.acc(N)\n        10*N.x\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "set_pos",
    "full_id": "sympy.physics.vector.point.Point.set_pos",
    "type": "method",
    "description": "Used to set the position of this point w.r.t. another point.\n\n        Parameters\n        ==========\n\n        otherpoint : Point\n            The other point which this point's location is defined relative to\n        value : Vector\n            The vector which defines the location of this point\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame\n        >>> N = ReferenceFrame('N')\n        >>> p1 = Point('p1')\n        >>> p2 = Point('p2')\n        >>> p1.set_pos(p2, 10 * N.x)\n        >>> p1.pos_from(p2)\n        10*N.x\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "set_vel",
    "full_id": "sympy.physics.vector.point.Point.set_vel",
    "type": "method",
    "description": "Sets the velocity Vector of this Point in a ReferenceFrame.\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame\n            The frame in which this point's velocity is defined\n        value : Vector\n            The vector value of this point's velocity in the frame\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame\n        >>> N = ReferenceFrame('N')\n        >>> p1 = Point('p1')\n        >>> p1.set_vel(N, 10 * N.x)\n        >>> p1.vel(N)\n        10*N.x\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "v1pt_theory",
    "full_id": "sympy.physics.vector.point.Point.v1pt_theory",
    "type": "method",
    "description": "Sets the velocity of this point with the 1-point theory.\n\n        The 1-point theory for point velocity looks like this:\n\n        ^N v^P = ^B v^P + ^N v^O + ^N omega^B x r^OP\n\n        where O is a point fixed in B, P is a point moving in B, and B is\n        rotating in frame N.\n\n        Parameters\n        ==========\n\n        otherpoint : Point\n            The first point of the 1-point theory (O)\n        outframe : ReferenceFrame\n            The frame we want this point's velocity defined in (N)\n        interframe : ReferenceFrame\n            The intermediate frame in this calculation (B)\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame\n        >>> from sympy.physics.vector import dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> q = dynamicsymbols('q')\n        >>> q2 = dynamicsymbols('q2')\n        >>> qd = dynamicsymbols('q', 1)\n        >>> q2d = dynamicsymbols('q2', 1)\n        >>> N = ReferenceFrame('N')\n        >>> B = ReferenceFrame('B')\n        >>> B.set_ang_vel(N, 5 * B.y)\n        >>> O = Point('O')\n        >>> P = O.locatenew('P', q * B.x + q2 * B.y)\n        >>> P.set_vel(B, qd * B.x + q2d * B.y)\n        >>> O.set_vel(N, 0)\n        >>> P.v1pt_theory(O, N, B)\n        q'*B.x + q2'*B.y - 5*q*B.z\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "v2pt_theory",
    "full_id": "sympy.physics.vector.point.Point.v2pt_theory",
    "type": "method",
    "description": "Sets the velocity of this point with the 2-point theory.\n\n        The 2-point theory for point velocity looks like this:\n\n        ^N v^P = ^N v^O + ^N omega^B x r^OP\n\n        where O and P are both points fixed in frame B, which is rotating in\n        frame N.\n\n        Parameters\n        ==========\n\n        otherpoint : Point\n            The first point of the 2-point theory (O)\n        outframe : ReferenceFrame\n            The frame we want this point's velocity defined in (N)\n        fixedframe : ReferenceFrame\n            The frame in which both points are fixed (B)\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame, dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> q = dynamicsymbols('q')\n        >>> qd = dynamicsymbols('q', 1)\n        >>> N = ReferenceFrame('N')\n        >>> B = N.orientnew('B', 'Axis', [q, N.z])\n        >>> O = Point('O')\n        >>> P = O.locatenew('P', 10 * B.x)\n        >>> O.set_vel(N, 5 * N.x)\n        >>> P.v2pt_theory(O, N, B)\n        5*N.x + 10*q'*B.y\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "vel",
    "full_id": "sympy.physics.vector.point.Point.vel",
    "type": "method",
    "description": "The velocity Vector of this Point in the ReferenceFrame.\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame\n            The frame in which the returned velocity vector will be defined in\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import Point, ReferenceFrame, dynamicsymbols\n        >>> N = ReferenceFrame('N')\n        >>> p1 = Point('p1')\n        >>> p1.set_vel(N, 10 * N.x)\n        >>> p1.vel(N)\n        10*N.x\n\n        Velocities will be automatically calculated if possible, otherwise a\n        ``ValueError`` will be returned. If it is possible to calculate\n        multiple different velocities from the relative points, the points\n        defined most directly relative to this point will be used. In the case\n        of inconsistent relative positions of points, incorrect velocities may\n        be returned. It is up to the user to define prior relative positions\n        and velocities of points in a self-consistent way.\n\n        >>> p = Point('p')\n        >>> q = dynamicsymbols('q')\n        >>> p.set_vel(N, 10 * N.x)\n        >>> p2 = Point('p2')\n        >>> p2.set_pos(p, q*N.x)\n        >>> p2.vel(N)\n        (Derivative(q(t), t) + 10)*N.x\n\n        ",
    "section": "Kinematics (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "get_motion_params",
    "full_id": "sympy.physics.vector.functions.get_motion_params",
    "type": "function",
    "description": "\n    Returns the three motion parameters - (acceleration, velocity, and\n    position) as vectorial functions of time in the given frame.\n\n    If a higher order differential function is provided, the lower order\n    functions are used as boundary conditions. For example, given the\n    acceleration, the velocity and position parameters are taken as\n    boundary conditions.\n\n    The values of time at which the boundary conditions are specified\n    are taken from timevalue1(for position boundary condition) and\n    timevalue2(for velocity boundary condition).\n\n    If any of the boundary conditions are not provided, they are taken\n    to be zero by default (zero vectors, in case of vectorial inputs). If\n    the boundary conditions are also functions of time, they are converted\n    to constants by substituting the time values in the dynamicsymbols._t\n    time Symbol.\n\n    This function can also be used for calculating rotational motion\n    parameters. Have a look at the Parameters and Examples for more clarity.\n\n    Parameters\n    ==========\n\n    frame : ReferenceFrame\n        The frame to express the motion parameters in\n\n    acceleration : Vector\n        Acceleration of the object/frame as a function of time\n\n    velocity : Vector\n        Velocity as function of time or as boundary condition\n        of velocity at time = timevalue1\n\n    position : Vector\n        Velocity as function of time or as boundary condition\n        of velocity at time = timevalue1\n\n    timevalue1 : sympyfiable\n        Value of time for position boundary condition\n\n    timevalue2 : sympyfiable\n        Value of time for velocity boundary condition\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame, get_motion_params, dynamicsymbols\n    >>> from sympy.physics.vector import init_vprinting\n    >>> init_vprinting(pretty_print=False)\n    >>> from sympy import symbols\n    >>> R = ReferenceFrame('R')\n    >>> v1, v2, v3 = dynamicsymbols('v1 v2 v3')\n    >>> v = v1*R.x + v2*R.y + v3*R.z\n    >>> get_motion_params(R, position = v)\n    (v1''*R.x + v2''*R.y + v3''*R.z, v1'*R.x + v2'*R.y + v3'*R.z, v1*R.x + v2*R.y + v3*R.z)\n    >>> a, b, c = symbols('a b c')\n    >>> v = a*R.x + b*R.y + c*R.z\n    >>> get_motion_params(R, velocity = v)\n    (0, a*R.x + b*R.y + c*R.z, a*t*R.x + b*t*R.y + c*t*R.z)\n    >>> parameters = get_motion_params(R, acceleration = v)\n    >>> parameters[1]\n    a*t*R.x + b*t*R.y + c*t*R.z\n    >>> parameters[2]\n    a*t**2/2*R.x + b*t**2/2*R.y + c*t**2/2*R.z\n\n    ",
    "section": "kinematic_equations",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "kinematic_equations",
    "full_id": "sympy.physics.vector.functions.kinematic_equations",
    "type": "function",
    "description": "Gives equations relating the qdot's to u's for a rotation type.\n\n    Supply rotation type and order as in orient. Speeds are assumed to be\n    body-fixed; if we are defining the orientation of B in A using by rot_type,\n    the angular velocity of B in A is assumed to be in the form: speed[0]*B.x +\n    speed[1]*B.y + speed[2]*B.z\n\n    Parameters\n    ==========\n\n    speeds : list of length 3\n        The body fixed angular velocity measure numbers.\n    coords : list of length 3 or 4\n        The coordinates used to define the orientation of the two frames.\n    rot_type : str\n        The type of rotation used to create the equations. Body, Space, or\n        Quaternion only\n    rot_order : str or int\n        If applicable, the order of a series of rotations.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import dynamicsymbols\n    >>> from sympy.physics.vector import kinematic_equations, vprint\n    >>> u1, u2, u3 = dynamicsymbols('u1 u2 u3')\n    >>> q1, q2, q3 = dynamicsymbols('q1 q2 q3')\n    >>> vprint(kinematic_equations([u1,u2,u3], [q1,q2,q3], 'body', '313'),\n    ...     order=None)\n    [-(u1*sin(q3) + u2*cos(q3))/sin(q2) + q1', -u1*cos(q3) + u2*sin(q3) + q2', (u1*sin(q3) + u2*cos(q3))*cos(q2)/sin(q2) - u3 + q3']\n\n    ",
    "section": "kinematic_equations",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "partial_velocity",
    "full_id": "sympy.physics.vector.functions.partial_velocity",
    "type": "function",
    "description": "Returns a list of partial velocities with respect to the provided\n    generalized speeds in the given reference frame for each of the supplied\n    velocity vectors.\n\n    The output is a list of lists. The outer list has a number of elements\n    equal to the number of supplied velocity vectors. The inner lists are, for\n    each velocity vector, the partial derivatives of that velocity vector with\n    respect to the generalized speeds supplied.\n\n    Parameters\n    ==========\n\n    vel_vecs : iterable\n        An iterable of velocity vectors (angular or linear).\n    gen_speeds : iterable\n        An iterable of generalized speeds.\n    frame : ReferenceFrame\n        The reference frame that the partial derivatives are going to be taken\n        in.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import Point, ReferenceFrame\n    >>> from sympy.physics.vector import dynamicsymbols\n    >>> from sympy.physics.vector import partial_velocity\n    >>> u = dynamicsymbols('u')\n    >>> N = ReferenceFrame('N')\n    >>> P = Point('P')\n    >>> P.set_vel(N, u * N.x)\n    >>> vel_vecs = [P.vel(N)]\n    >>> gen_speeds = [u]\n    >>> partial_velocity(vel_vecs, gen_speeds, N)\n    [[N.x]]\n\n    ",
    "section": "kinematic_equations",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/kinematics.html"
  },
  {
    "name": "init_vprinting",
    "full_id": "sympy.physics.vector.printing.init_vprinting",
    "type": "function",
    "description": "Initializes time derivative printing for all SymPy objects, i.e. any\n    functions of time will be displayed in a more compact notation. The main\n    benefit of this is for printing of time derivatives; instead of\n    displaying as ``Derivative(f(t),t)``, it will display ``f'``. This is\n    only actually needed for when derivatives are present and are not in a\n    physics.vector.Vector or physics.vector.Dyadic object. This function is a\n    light wrapper to :func:`~.init_printing`. Any keyword\n    arguments for it are valid here.\n\n    \n    Initializes pretty-printer depending on the environment.\n\n    Parameters\n    ==========\n\n    pretty_print : bool, default=True\n        If ``True``, use :func:`~.pretty_print` to stringify or the provided pretty\n        printer; if ``False``, use :func:`~.sstrrepr` to stringify or the provided string\n        printer.\n    order : string or None, default='lex'\n        There are a few different settings for this parameter:\n        ``'lex'`` (default), which is lexographic order;\n        ``'grlex'``, which is graded lexographic order;\n        ``'grevlex'``, which is reversed graded lexographic order;\n        ``'old'``, which is used for compatibility reasons and for long expressions;\n        ``None``, which sets it to lex.\n    use_unicode : bool or None, default=None\n        If ``True``, use unicode characters;\n        if ``False``, do not use unicode characters;\n        if ``None``, make a guess based on the environment.\n    use_latex : string, bool, or None, default=None\n        If ``True``, use default LaTeX rendering in GUI interfaces (png and\n        mathjax);\n        if ``False``, do not use LaTeX rendering;\n        if ``None``, make a guess based on the environment;\n        if ``'png'``, enable LaTeX rendering with an external LaTeX compiler,\n        falling back to matplotlib if external compilation fails;\n        if ``'matplotlib'``, enable LaTeX rendering with matplotlib;\n        if ``'mathjax'``, enable LaTeX text generation, for example MathJax\n        rendering in IPython notebook or text rendering in LaTeX documents;\n        if ``'svg'``, enable LaTeX rendering with an external latex compiler,\n        no fallback\n    wrap_line : bool\n        If True, lines will wrap at the end; if False, they will not wrap\n        but continue as one line. This is only relevant if ``pretty_print`` is\n        True.\n    num_columns : int or None, default=None\n        If ``int``, number of columns before wrapping is set to num_columns; if\n        ``None``, number of columns before wrapping is set to terminal width.\n        This is only relevant if ``pretty_print`` is ``True``.\n    no_global : bool, default=False\n        If ``True``, the settings become system wide;\n        if ``False``, use just for this console/session.\n    ip : An interactive console\n        This can either be an instance of IPython,\n        or a class that derives from code.InteractiveConsole.\n    euler : bool, optional, default=False\n        Loads the euler package in the LaTeX preamble for handwritten style\n        fonts (https://www.ctan.org/pkg/euler).\n    forecolor : string or None, optional, default=None\n        DVI setting for foreground color. ``None`` means that either ``'Black'``,\n        ``'White'``, or ``'Gray'`` will be selected based on a guess of the IPython\n        terminal color setting. See notes.\n    backcolor : string, optional, default='Transparent'\n        DVI setting for background color. See notes.\n    fontsize : string or int, optional, default='10pt'\n        A font size to pass to the LaTeX documentclass function in the\n        preamble. Note that the options are limited by the documentclass.\n        Consider using scale instead.\n    latex_mode : string, optional, default='plain'\n        The mode used in the LaTeX printer. Can be one of:\n        ``{'inline'|'plain'|'equation'|'equation*'}``.\n    print_builtin : boolean, optional, default=True\n        If ``True`` then floats and integers will be printed. If ``False`` the\n        printer will only print SymPy types.\n    str_printer : function, optional, default=None\n        A custom string printer function. This should mimic\n        :func:`~.sstrrepr`.\n    pretty_printer : function, optional, default=None\n        A custom pretty printer. This should mimic :func:`~.pretty`.\n    latex_printer : function, optional, default=None\n        A custom LaTeX printer. This should mimic :func:`~.latex`.\n    scale : float, optional, default=1.0\n        Scale the LaTeX output when using the ``'png'`` or ``'svg'`` backends.\n        Useful for high dpi screens.\n    settings :\n        Any additional settings for the ``latex`` and ``pretty`` commands can\n        be used to fine-tune the output.\n\n    \n\n    Examples\n    ========\n\n    >>> from sympy import Function, symbols\n    >>> t, x = symbols('t, x')\n    >>> omega = Function('omega')\n    >>> omega(x).diff()\n    Derivative(omega(x), x)\n    >>> omega(t).diff()\n    Derivative(omega(t), t)\n\n    Now use the string printer:\n\n    >>> from sympy.physics.vector import init_vprinting\n    >>> init_vprinting(pretty_print=False)\n    >>> omega(x).diff()\n    Derivative(omega(x), x)\n    >>> omega(t).diff()\n    omega'\n\n    ",
    "section": "Printing (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/printing.html"
  },
  {
    "name": "vprint",
    "full_id": "sympy.physics.vector.printing.vprint",
    "type": "function",
    "description": "Function for printing of expressions generated in the\n    sympy.physics vector package.\n\n    Extends SymPy's StrPrinter, takes the same setting accepted by SymPy's\n    :func:`~.sstr`, and is equivalent to ``print(sstr(foo))``.\n\n    Parameters\n    ==========\n\n    expr : valid SymPy object\n        SymPy expression to print.\n    settings : args\n        Same as the settings accepted by SymPy's sstr().\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import vprint, dynamicsymbols\n    >>> u1 = dynamicsymbols('u1')\n    >>> print(u1)\n    u1(t)\n    >>> vprint(u1)\n    u1\n\n    ",
    "section": "Printing (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/printing.html"
  },
  {
    "name": "vpprint",
    "full_id": "sympy.physics.vector.printing.vpprint",
    "type": "function",
    "description": "Function for pretty printing of expressions generated in the\n    sympy.physics vector package.\n\n    Mainly used for expressions not inside a vector; the output of running\n    scripts and generating equations of motion. Takes the same options as\n    SymPy's :func:`~.pretty_print`; see that function for more information.\n\n    Parameters\n    ==========\n\n    expr : valid SymPy object\n        SymPy expression to pretty print\n    settings : args\n        Same as those accepted by SymPy's pretty_print.\n\n\n    ",
    "section": "Printing (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/printing.html"
  },
  {
    "name": "vlatex",
    "full_id": "sympy.physics.vector.printing.vlatex",
    "type": "function",
    "description": "Function for printing latex representation of sympy.physics.vector\n    objects.\n\n    For latex representation of Vectors, Dyadics, and dynamicsymbols. Takes the\n    same options as SymPy's :func:`~.latex`; see that function for more\n    information;\n\n    Parameters\n    ==========\n\n    expr : valid SymPy object\n        SymPy expression to represent in LaTeX form\n    settings : args\n        Same as latex()\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import vlatex, ReferenceFrame, dynamicsymbols\n    >>> N = ReferenceFrame('N')\n    >>> q1, q2 = dynamicsymbols('q1 q2')\n    >>> q1d, q2d = dynamicsymbols('q1 q2', 1)\n    >>> q1dd, q2dd = dynamicsymbols('q1 q2', 2)\n    >>> vlatex(N.x + N.y)\n    '\\\\mathbf{\\\\hat{n}_x} + \\\\mathbf{\\\\hat{n}_y}'\n    >>> vlatex(q1 + q2)\n    'q_{1} + q_{2}'\n    >>> vlatex(q1d)\n    '\\\\dot{q}_{1}'\n    >>> vlatex(q1 * q2d)\n    'q_{1} \\\\dot{q}_{2}'\n    >>> vlatex(q1dd * q1 / q1d)\n    '\\\\frac{q_{1} \\\\ddot{q}_{1}}{\\\\dot{q}_{1}}'\n\n    ",
    "section": "Printing (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/printing.html"
  },
  {
    "name": "dynamicsymbols",
    "full_id": "sympy.physics.vector.dynamicsymbols",
    "type": "function",
    "description": "Uses symbols and Function for functions of time.\n\n    Creates a SymPy UndefinedFunction, which is then initialized as a function\n    of a variable, the default being Symbol('t').\n\n    Parameters\n    ==========\n\n    names : str\n        Names of the dynamic symbols you want to create; works the same way as\n        inputs to symbols\n    level : int\n        Level of differentiation of the returned function; d/dt once of t,\n        twice of t, etc.\n    assumptions :\n        - real(bool) : This is used to set the dynamicsymbol as real,\n                    by default is False.\n        - positive(bool) : This is used to set the dynamicsymbol as positive,\n                    by default is False.\n        - commutative(bool) : This is used to set the commutative property of\n                    a dynamicsymbol, by default is True.\n        - integer(bool) : This is used to set the dynamicsymbol as integer,\n                    by default is False.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import dynamicsymbols\n    >>> from sympy import diff, Symbol\n    >>> q1 = dynamicsymbols('q1')\n    >>> q1\n    q1(t)\n    >>> q2 = dynamicsymbols('q2', real=True)\n    >>> q2.is_real\n    True\n    >>> q3 = dynamicsymbols('q3', positive=True)\n    >>> q3.is_positive\n    True\n    >>> q4, q5 = dynamicsymbols('q4,q5', commutative=False)\n    >>> bool(q4*q5 != q5*q4)\n    True\n    >>> q6 = dynamicsymbols('q6', integer=True)\n    >>> q6.is_integer\n    True\n    >>> diff(q1, Symbol('t'))\n    Derivative(q1(t), t)\n\n    ",
    "section": "Essential Functions (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/functions.html"
  },
  {
    "name": "dot",
    "full_id": "sympy.physics.vector.functions.dot",
    "type": "function",
    "description": "Dot product convenience wrapper for Vector.dot(): \nDot product of two vectors.\n\n        Returns a scalar, the dot product of the two Vectors\n\n        Parameters\n        ==========\n\n        other : Vector\n            The Vector which we are dotting with\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, dot\n        >>> from sympy import symbols\n        >>> q1 = symbols('q1')\n        >>> N = ReferenceFrame('N')\n        >>> dot(N.x, N.x)\n        1\n        >>> dot(N.x, N.y)\n        0\n        >>> A = N.orientnew('A', 'Axis', [q1, N.x])\n        >>> dot(N.y, A.y)\n        cos(q1)\n\n        ",
    "section": "Essential Functions (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/functions.html"
  },
  {
    "name": "cross",
    "full_id": "sympy.physics.vector.functions.cross",
    "type": "function",
    "description": "Cross product convenience wrapper for Vector.cross(): \nThe cross product operator for two Vectors.\n\n        Returns a Vector, expressed in the same ReferenceFrames as self.\n\n        Parameters\n        ==========\n\n        other : Vector\n            The Vector which we are crossing with\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.vector import ReferenceFrame, cross\n        >>> q1 = symbols('q1')\n        >>> N = ReferenceFrame('N')\n        >>> cross(N.x, N.y)\n        N.z\n        >>> A = ReferenceFrame('A')\n        >>> A.orient_axis(N, q1, N.x)\n        >>> cross(A.x, N.y)\n        N.z\n        >>> cross(N.y, A.x)\n        - sin(q1)*A.y - cos(q1)*A.z\n\n        ",
    "section": "Essential Functions (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/functions.html"
  },
  {
    "name": "outer",
    "full_id": "sympy.physics.vector.functions.outer",
    "type": "function",
    "description": "Outer product convenience wrapper for Vector.outer():\nOuter product between two Vectors.\n\n        A rank increasing operation, which returns a Dyadic from two Vectors\n\n        Parameters\n        ==========\n\n        other : Vector\n            The Vector to take the outer product with\n\n        Examples\n        ========\n\n        >>> from sympy.physics.vector import ReferenceFrame, outer\n        >>> N = ReferenceFrame('N')\n        >>> outer(N.x, N.x)\n        (N.x|N.x)\n\n        ",
    "section": "Essential Functions (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/functions.html"
  },
  {
    "name": "express",
    "full_id": "sympy.physics.vector.functions.express",
    "type": "function",
    "description": "\n    Global function for 'express' functionality.\n\n    Re-expresses a Vector, scalar(sympyfiable) or Dyadic in given frame.\n\n    Refer to the local methods of Vector and Dyadic for details.\n    If 'variables' is True, then the coordinate variables (CoordinateSym\n    instances) of other frames present in the vector/scalar field or\n    dyadic expression are also substituted in terms of the base scalars of\n    this frame.\n\n    Parameters\n    ==========\n\n    expr : Vector/Dyadic/scalar(sympyfiable)\n        The expression to re-express in ReferenceFrame 'frame'\n\n    frame: ReferenceFrame\n        The reference frame to express expr in\n\n    frame2 : ReferenceFrame\n        The other frame required for re-expression(only for Dyadic expr)\n\n    variables : boolean\n        Specifies whether to substitute the coordinate variables present\n        in expr, in terms of those of frame\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame, outer, dynamicsymbols\n    >>> from sympy.physics.vector import init_vprinting\n    >>> init_vprinting(pretty_print=False)\n    >>> N = ReferenceFrame('N')\n    >>> q = dynamicsymbols('q')\n    >>> B = N.orientnew('B', 'Axis', [q, N.z])\n    >>> d = outer(N.x, N.x)\n    >>> from sympy.physics.vector import express\n    >>> express(d, B, N)\n    cos(q)*(B.x|N.x) - sin(q)*(B.y|N.x)\n    >>> express(B.x, N)\n    cos(q)*N.x + sin(q)*N.y\n    >>> express(N[0], B, variables=True)\n    B_x*cos(q) - B_y*sin(q)\n\n    ",
    "section": "Essential Functions (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/functions.html"
  },
  {
    "name": "time_derivative",
    "full_id": "sympy.physics.vector.functions.time_derivative",
    "type": "function",
    "description": "\n    Calculate the time derivative of a vector/scalar field function\n    or dyadic expression in given frame.\n\n    References\n    ==========\n\n    https://en.wikipedia.org/wiki/Rotating_reference_frame#Time_derivatives_in_the_two_frames\n\n    Parameters\n    ==========\n\n    expr : Vector/Dyadic/sympifyable\n        The expression whose time derivative is to be calculated\n\n    frame : ReferenceFrame\n        The reference frame to calculate the time derivative in\n\n    order : integer\n        The order of the derivative to be calculated\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame, dynamicsymbols\n    >>> from sympy.physics.vector import init_vprinting\n    >>> init_vprinting(pretty_print=False)\n    >>> from sympy import Symbol\n    >>> q1 = Symbol('q1')\n    >>> u1 = dynamicsymbols('u1')\n    >>> N = ReferenceFrame('N')\n    >>> A = N.orientnew('A', 'Axis', [q1, N.x])\n    >>> v = u1 * N.x\n    >>> A.set_ang_vel(N, 10*A.x)\n    >>> from sympy.physics.vector import time_derivative\n    >>> time_derivative(v, N)\n    u1'*N.x\n    >>> time_derivative(u1*A[0], N)\n    N_x*u1'\n    >>> B = N.orientnew('B', 'Axis', [u1, N.z])\n    >>> from sympy.physics.vector import outer\n    >>> d = outer(N.x, N.x)\n    >>> time_derivative(d, B)\n    - u1'*(N.y|N.x) - u1'*(N.x|N.y)\n\n    ",
    "section": "Essential Functions (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/functions.html"
  },
  {
    "name": "curl",
    "full_id": "sympy.physics.vector.fieldfunctions.curl",
    "type": "function",
    "description": "\n    Returns the curl of a vector field computed wrt the coordinate\n    symbols of the given frame.\n\n    Parameters\n    ==========\n\n    vect : Vector\n        The vector operand\n\n    frame : ReferenceFrame\n        The reference frame to calculate the curl in\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy.physics.vector import curl\n    >>> R = ReferenceFrame('R')\n    >>> v1 = R[1]*R[2]*R.x + R[0]*R[2]*R.y + R[0]*R[1]*R.z\n    >>> curl(v1, R)\n    0\n    >>> v2 = R[0]*R[1]*R[2]*R.x\n    >>> curl(v2, R)\n    R_x*R_y*R.y - R_x*R_z*R.z\n\n    ",
    "section": "Field operation functions",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/fieldfunctions.html"
  },
  {
    "name": "divergence",
    "full_id": "sympy.physics.vector.fieldfunctions.divergence",
    "type": "function",
    "description": "\n    Returns the divergence of a vector field computed wrt the coordinate\n    symbols of the given frame.\n\n    Parameters\n    ==========\n\n    vect : Vector\n        The vector operand\n\n    frame : ReferenceFrame\n        The reference frame to calculate the divergence in\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy.physics.vector import divergence\n    >>> R = ReferenceFrame('R')\n    >>> v1 = R[0]*R[1]*R[2] * (R.x+R.y+R.z)\n    >>> divergence(v1, R)\n    R_x*R_y + R_x*R_z + R_y*R_z\n    >>> v2 = 2*R[1]*R[2]*R.y\n    >>> divergence(v2, R)\n    2*R_z\n\n    ",
    "section": "Field operation functions",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/fieldfunctions.html"
  },
  {
    "name": "gradient",
    "full_id": "sympy.physics.vector.fieldfunctions.gradient",
    "type": "function",
    "description": "\n    Returns the vector gradient of a scalar field computed wrt the\n    coordinate symbols of the given frame.\n\n    Parameters\n    ==========\n\n    scalar : sympifiable\n        The scalar field to take the gradient of\n\n    frame : ReferenceFrame\n        The frame to calculate the gradient in\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy.physics.vector import gradient\n    >>> R = ReferenceFrame('R')\n    >>> s1 = R[0]*R[1]*R[2]\n    >>> gradient(s1, R)\n    R_y*R_z*R.x + R_x*R_z*R.y + R_x*R_y*R.z\n    >>> s2 = 5*R[0]**2*R[2]\n    >>> gradient(s2, R)\n    10*R_x*R_z*R.x + 5*R_x**2*R.z\n\n    ",
    "section": "Field operation functions",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/fieldfunctions.html"
  },
  {
    "name": "scalar_potential",
    "full_id": "sympy.physics.vector.fieldfunctions.scalar_potential",
    "type": "function",
    "description": "\n    Returns the scalar potential function of a field in a given frame\n    (without the added integration constant).\n\n    Parameters\n    ==========\n\n    field : Vector\n        The vector field whose scalar potential function is to be\n        calculated\n\n    frame : ReferenceFrame\n        The frame to do the calculation in\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy.physics.vector import scalar_potential, gradient\n    >>> R = ReferenceFrame('R')\n    >>> scalar_potential(R.z, R) == R[2]\n    True\n    >>> scalar_field = 2*R[0]**2*R[1]*R[2]\n    >>> grad_field = gradient(scalar_field, R)\n    >>> scalar_potential(grad_field, R)\n    2*R_x**2*R_y*R_z\n\n    ",
    "section": "Field operation functions",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/fieldfunctions.html"
  },
  {
    "name": "scalar_potential_difference",
    "full_id": "sympy.physics.vector.fieldfunctions.scalar_potential_difference",
    "type": "function",
    "description": "\n    Returns the scalar potential difference between two points in a\n    certain frame, wrt a given field.\n\n    If a scalar field is provided, its values at the two points are\n    considered. If a conservative vector field is provided, the values\n    of its scalar potential function at the two points are used.\n\n    Returns (potential at position 2) - (potential at position 1)\n\n    Parameters\n    ==========\n\n    field : Vector/sympyfiable\n        The field to calculate wrt\n\n    frame : ReferenceFrame\n        The frame to do the calculations in\n\n    point1 : Point\n        The initial Point in given frame\n\n    position2 : Point\n        The second Point in the given frame\n\n    origin : Point\n        The Point to use as reference point for position vector\n        calculation\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame, Point\n    >>> from sympy.physics.vector import scalar_potential_difference\n    >>> R = ReferenceFrame('R')\n    >>> O = Point('O')\n    >>> P = O.locatenew('P', R[0]*R.x + R[1]*R.y + R[2]*R.z)\n    >>> vectfield = 4*R[0]*R[1]*R.x + 2*R[0]**2*R.y\n    >>> scalar_potential_difference(vectfield, R, O, P, O)\n    2*R_x**2*R_y\n    >>> Q = O.locatenew('O', 3*R.x + R.y + 2*R.z)\n    >>> scalar_potential_difference(vectfield, R, P, Q, O)\n    -2*R_x**2*R_y + 18\n\n    ",
    "section": "Field operation functions",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/fieldfunctions.html"
  },
  {
    "name": "is_conservative",
    "full_id": "sympy.physics.vector.fieldfunctions.is_conservative",
    "type": "function",
    "description": "\n    Checks if a field is conservative.\n\n    Parameters\n    ==========\n\n    field : Vector\n        The field to check for conservative property\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy.physics.vector import is_conservative\n    >>> R = ReferenceFrame('R')\n    >>> is_conservative(R[1]*R[2]*R.x + R[0]*R[2]*R.y + R[0]*R[1]*R.z)\n    True\n    >>> is_conservative(R[2] * R.y)\n    False\n\n    ",
    "section": "Checking the type of vector field",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/fieldfunctions.html"
  },
  {
    "name": "is_solenoidal",
    "full_id": "sympy.physics.vector.fieldfunctions.is_solenoidal",
    "type": "function",
    "description": "\n    Checks if a field is solenoidal.\n\n    Parameters\n    ==========\n\n    field : Vector\n        The field to check for solenoidal property\n\n    Examples\n    ========\n\n    >>> from sympy.physics.vector import ReferenceFrame\n    >>> from sympy.physics.vector import is_solenoidal\n    >>> R = ReferenceFrame('R')\n    >>> is_solenoidal(R[1]*R[2]*R.x + R[0]*R[2]*R.y + R[0]*R[1]*R.z)\n    True\n    >>> is_solenoidal(R[1] * R.y)\n    False\n\n    ",
    "section": "Checking the type of vector field",
    "url": "https://docs.sympy.org/latest/modules/physics/vector/api/fieldfunctions.html"
  },
  {
    "name": "angular_momentum",
    "full_id": "sympy.physics.mechanics.particle.Particle.angular_momentum",
    "type": "method",
    "description": "Angular momentum of the particle about the point.\n\n        Explanation\n        ===========\n\n        The angular momentum H, about some point O of a particle, P, is given\n        by:\n\n        ``H = cross(r, m * v)``\n\n        where r is the position vector from point O to the particle P, m is\n        the mass of the particle, and v is the velocity of the particle in\n        the inertial frame, N.\n\n        Parameters\n        ==========\n\n        point : Point\n            The point about which angular momentum of the particle is desired.\n\n        frame : ReferenceFrame\n            The frame in which angular momentum is desired.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.mechanics import Particle, Point, ReferenceFrame\n        >>> from sympy.physics.mechanics import dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> m, v, r = dynamicsymbols('m v r')\n        >>> N = ReferenceFrame('N')\n        >>> O = Point('O')\n        >>> A = O.locatenew('A', r * N.x)\n        >>> P = Particle('P', A, m)\n        >>> P.point.set_vel(N, v * N.y)\n        >>> P.angular_momentum(O, N)\n        m*r*v*N.z\n\n        ",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "kinetic_energy",
    "full_id": "sympy.physics.mechanics.particle.Particle.kinetic_energy",
    "type": "method",
    "description": "Kinetic energy of the particle.\n\n        Explanation\n        ===========\n\n        The kinetic energy, T, of a particle, P, is given by:\n\n        ``T = 1/2 (dot(m * v, v))``\n\n        where m is the mass of particle P, and v is the velocity of the\n        particle in the supplied ReferenceFrame.\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame\n            The Particle's velocity is typically defined with respect to\n            an inertial frame but any relevant frame in which the velocity is\n            known can be supplied.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.mechanics import Particle, Point, ReferenceFrame\n        >>> from sympy import symbols\n        >>> m, v, r = symbols('m v r')\n        >>> N = ReferenceFrame('N')\n        >>> O = Point('O')\n        >>> P = Particle('P', O, m)\n        >>> P.point.set_vel(N, v * N.y)\n        >>> P.kinetic_energy(N)\n        m*v**2/2\n\n        ",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "linear_momentum",
    "full_id": "sympy.physics.mechanics.particle.Particle.linear_momentum",
    "type": "method",
    "description": "Linear momentum of the particle.\n\n        Explanation\n        ===========\n\n        The linear momentum L, of a particle P, with respect to frame N is\n        given by:\n\n        L = m * v\n\n        where m is the mass of the particle, and v is the velocity of the\n        particle in the frame N.\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame\n            The frame in which linear momentum is desired.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.mechanics import Particle, Point, ReferenceFrame\n        >>> from sympy.physics.mechanics import dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> m, v = dynamicsymbols('m v')\n        >>> N = ReferenceFrame('N')\n        >>> P = Point('P')\n        >>> A = Particle('A', P, m)\n        >>> P.set_vel(N, v * N.x)\n        >>> A.linear_momentum(N)\n        m*v*N.x\n\n        ",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "mass",
    "full_id": "sympy.physics.mechanics.particle.Particle.mass",
    "type": "property",
    "description": "The body's mass.",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "masscenter",
    "full_id": "sympy.physics.mechanics.particle.Particle.masscenter",
    "type": "property",
    "description": "The body's center of mass.",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "name",
    "full_id": "sympy.physics.mechanics.particle.Particle.name",
    "type": "property",
    "description": "The name of the body.",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "parallel_axis",
    "full_id": "sympy.physics.mechanics.particle.Particle.parallel_axis",
    "type": "method",
    "description": "Returns an inertia dyadic of the particle with respect to another\n        point and frame.\n\n        Parameters\n        ==========\n\n        point : sympy.physics.vector.Point\n            The point to express the inertia dyadic about.\n        frame : sympy.physics.vector.ReferenceFrame\n            The reference frame used to construct the dyadic.\n\n        Returns\n        =======\n\n        inertia : sympy.physics.vector.Dyadic\n            The inertia dyadic of the particle expressed about the provided\n            point and frame.\n\n        ",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "potential_energy",
    "full_id": "sympy.physics.mechanics.particle.Particle.potential_energy",
    "type": "property",
    "description": "The potential energy of the body.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.mechanics import Particle, Point\n        >>> from sympy import symbols\n        >>> m, g, h = symbols('m g h')\n        >>> O = Point('O')\n        >>> P = Particle('P', O, m)\n        >>> P.potential_energy = m * g * h\n        >>> P.potential_energy\n        g*h*m\n\n        ",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "angular_momentum",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.angular_momentum",
    "type": "method",
    "description": "Returns the angular momentum of the rigid body about a point in the\n        given frame.\n\n        Explanation\n        ===========\n\n        The angular momentum H of a rigid body B about some point O in a frame N\n        is given by:\n\n        ``H = dot(I, w) + cross(r, m * v)``\n\n        where I and m are the central inertia dyadic and mass of rigid body B, w\n        is the angular velocity of body B in the frame N, r is the position\n        vector from point O to the mass center of B, and v is the velocity of\n        the mass center in the frame N.\n\n        Parameters\n        ==========\n\n        point : Point\n            The point about which angular momentum is desired.\n        frame : ReferenceFrame\n            The frame in which angular momentum is desired.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.mechanics import Point, ReferenceFrame, outer\n        >>> from sympy.physics.mechanics import RigidBody, dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> m, v, r, omega = dynamicsymbols('m v r omega')\n        >>> N = ReferenceFrame('N')\n        >>> b = ReferenceFrame('b')\n        >>> b.set_ang_vel(N, omega * b.x)\n        >>> P = Point('P')\n        >>> P.set_vel(N, 1 * N.x)\n        >>> I = outer(b.x, b.x)\n        >>> B = RigidBody('B', P, b, m, (I, P))\n        >>> B.angular_momentum(P, N)\n        omega*b.x\n\n        ",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "central_inertia",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.central_inertia",
    "type": "property",
    "description": "The body's central inertia dyadic.",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "frame",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.frame",
    "type": "property",
    "description": "The ReferenceFrame fixed to the body.",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "inertia",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.inertia",
    "type": "property",
    "description": "The body's inertia about a point; stored as (Dyadic, Point).",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "kinetic_energy",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.kinetic_energy",
    "type": "method",
    "description": "Kinetic energy of the rigid body.\n\n        Explanation\n        ===========\n\n        The kinetic energy, T, of a rigid body, B, is given by:\n\n        ``T = 1/2 * (dot(dot(I, w), w) + dot(m * v, v))``\n\n        where I and m are the central inertia dyadic and mass of rigid body B\n        respectively, w is the body's angular velocity, and v is the velocity of\n        the body's mass center in the supplied ReferenceFrame.\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame\n            The RigidBody's angular velocity and the velocity of it's mass\n            center are typically defined with respect to an inertial frame but\n            any relevant frame in which the velocities are known can be\n            supplied.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.mechanics import Point, ReferenceFrame, outer\n        >>> from sympy.physics.mechanics import RigidBody\n        >>> from sympy import symbols\n        >>> m, v, r, omega = symbols('m v r omega')\n        >>> N = ReferenceFrame('N')\n        >>> b = ReferenceFrame('b')\n        >>> b.set_ang_vel(N, omega * b.x)\n        >>> P = Point('P')\n        >>> P.set_vel(N, v * N.x)\n        >>> I = outer (b.x, b.x)\n        >>> inertia_tuple = (I, P)\n        >>> B = RigidBody('B', P, b, m, inertia_tuple)\n        >>> B.kinetic_energy(N)\n        m*v**2/2 + omega**2/2\n\n        ",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "linear_momentum",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.linear_momentum",
    "type": "method",
    "description": "Linear momentum of the rigid body.\n\n        Explanation\n        ===========\n\n        The linear momentum L, of a rigid body B, with respect to frame N is\n        given by:\n\n        ``L = m * v``\n\n        where m is the mass of the rigid body, and v is the velocity of the mass\n        center of B in the frame N.\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame\n            The frame in which linear momentum is desired.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.mechanics import Point, ReferenceFrame, outer\n        >>> from sympy.physics.mechanics import RigidBody, dynamicsymbols\n        >>> from sympy.physics.vector import init_vprinting\n        >>> init_vprinting(pretty_print=False)\n        >>> m, v = dynamicsymbols('m v')\n        >>> N = ReferenceFrame('N')\n        >>> P = Point('P')\n        >>> P.set_vel(N, v * N.x)\n        >>> I = outer (N.x, N.x)\n        >>> Inertia_tuple = (I, P)\n        >>> B = RigidBody('B', P, N, m, Inertia_tuple)\n        >>> B.linear_momentum(N)\n        m*v*N.x\n\n        ",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "parallel_axis",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.parallel_axis",
    "type": "method",
    "description": "Returns the inertia dyadic of the body with respect to another point.\n\n        Parameters\n        ==========\n\n        point : sympy.physics.vector.Point\n            The point to express the inertia dyadic about.\n        frame : sympy.physics.vector.ReferenceFrame\n            The reference frame used to construct the dyadic.\n\n        Returns\n        =======\n\n        inertia : sympy.physics.vector.Dyadic\n            The inertia dyadic of the rigid body expressed about the provided\n            point.\n\n        ",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "x",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.x",
    "type": "property",
    "description": "The basis Vector for the body, in the x direction.",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "y",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.y",
    "type": "property",
    "description": "The basis Vector for the body, in the y direction.",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "z",
    "full_id": "sympy.physics.mechanics.rigidbody.RigidBody.z",
    "type": "property",
    "description": "The basis Vector for the body, in the z direction.",
    "section": "Bodies",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "from_inertia_scalars",
    "full_id": "sympy.physics.mechanics.inertia.Inertia.from_inertia_scalars",
    "type": "method",
    "description": "Simple way to create an Inertia object based on the tensor values.\n\n        Explanation\n        ===========\n\n        This class method uses the :func`~.inertia` to create the Dyadic based\n        on the tensor values.\n\n        Parameters\n        ==========\n\n        point : Point\n            The reference point of the inertia.\n        frame : ReferenceFrame\n            The frame the inertia is defined in.\n        ixx : Sympifyable\n            The xx element in the inertia dyadic.\n        iyy : Sympifyable\n            The yy element in the inertia dyadic.\n        izz : Sympifyable\n            The zz element in the inertia dyadic.\n        ixy : Sympifyable\n            The xy element in the inertia dyadic.\n        iyz : Sympifyable\n            The yz element in the inertia dyadic.\n        izx : Sympifyable\n            The zx element in the inertia dyadic.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.mechanics import ReferenceFrame, Point, Inertia\n        >>> ixx, iyy, izz, ixy, iyz, izx = symbols('ixx iyy izz ixy iyz izx')\n        >>> N = ReferenceFrame('N')\n        >>> P = Point('P')\n        >>> I = Inertia.from_inertia_scalars(P, N, ixx, iyy, izz, ixy, iyz, izx)\n\n        The tensor values can easily be seen when converting the dyadic to a\n        matrix.\n\n        >>> I.dyadic.to_matrix(N)\n        Matrix([\n        [ixx, ixy, izx],\n        [ixy, iyy, iyz],\n        [izx, iyz, izz]])\n\n        ",
    "section": "Inertias",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "inertia",
    "full_id": "sympy.physics.mechanics.inertia.inertia",
    "type": "function",
    "description": "Simple way to create inertia Dyadic object.\n\n    Explanation\n    ===========\n\n    Creates an inertia Dyadic based on the given tensor values and a body-fixed\n    reference frame.\n\n    Parameters\n    ==========\n\n    frame : ReferenceFrame\n        The frame the inertia is defined in.\n    ixx : Sympifyable\n        The xx element in the inertia dyadic.\n    iyy : Sympifyable\n        The yy element in the inertia dyadic.\n    izz : Sympifyable\n        The zz element in the inertia dyadic.\n    ixy : Sympifyable\n        The xy element in the inertia dyadic.\n    iyz : Sympifyable\n        The yz element in the inertia dyadic.\n    izx : Sympifyable\n        The zx element in the inertia dyadic.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.mechanics import ReferenceFrame, inertia\n    >>> N = ReferenceFrame('N')\n    >>> inertia(N, 1, 2, 3)\n    (N.x|N.x) + 2*(N.y|N.y) + 3*(N.z|N.z)\n\n    ",
    "section": "Inertias",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "inertia_of_point_mass",
    "full_id": "sympy.physics.mechanics.inertia.inertia_of_point_mass",
    "type": "function",
    "description": "Inertia dyadic of a point mass relative to point O.\n\n    Parameters\n    ==========\n\n    mass : Sympifyable\n        Mass of the point mass\n    pos_vec : Vector\n        Position from point O to point mass\n    frame : ReferenceFrame\n        Reference frame to express the dyadic in\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.physics.mechanics import ReferenceFrame, inertia_of_point_mass\n    >>> N = ReferenceFrame('N')\n    >>> r, m = symbols('r m')\n    >>> px = r * N.x\n    >>> inertia_of_point_mass(m, px, N)\n    m*r**2*(N.y|N.y) + m*r**2*(N.z|N.z)\n\n    ",
    "section": "Inertias",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "center_of_mass",
    "full_id": "sympy.physics.mechanics.functions.center_of_mass",
    "type": "function",
    "description": "\n    Returns the position vector from the given point to the center of mass\n    of the given bodies(particles or rigidbodies).\n\n    Example\n    =======\n\n    >>> from sympy import symbols, S\n    >>> from sympy.physics.vector import Point\n    >>> from sympy.physics.mechanics import Particle, ReferenceFrame, RigidBody, outer\n    >>> from sympy.physics.mechanics.functions import center_of_mass\n    >>> a = ReferenceFrame('a')\n    >>> m = symbols('m', real=True)\n    >>> p1 = Particle('p1', Point('p1_pt'), S(1))\n    >>> p2 = Particle('p2', Point('p2_pt'), S(2))\n    >>> p3 = Particle('p3', Point('p3_pt'), S(3))\n    >>> p4 = Particle('p4', Point('p4_pt'), m)\n    >>> b_f = ReferenceFrame('b_f')\n    >>> b_cm = Point('b_cm')\n    >>> mb = symbols('mb')\n    >>> b = RigidBody('b', b_cm, b_f, mb, (outer(b_f.x, b_f.x), b_cm))\n    >>> p2.point.set_pos(p1.point, a.x)\n    >>> p3.point.set_pos(p1.point, a.x + a.y)\n    >>> p4.point.set_pos(p1.point, a.y)\n    >>> b.masscenter.set_pos(p1.point, a.y + a.z)\n    >>> point_o=Point('o')\n    >>> point_o.set_pos(p1.point, center_of_mass(p1.point, p1, p2, p3, p4, b))\n    >>> expr = 5/(m + mb + 6)*a.x + (m + mb + 3)/(m + mb + 6)*a.y + mb/(m + mb + 6)*a.z\n    >>> point_o.pos_from(p1.point)\n    5/(m + mb + 6)*a.x + (m + mb + 3)/(m + mb + 6)*a.y + mb/(m + mb + 6)*a.z\n\n    ",
    "section": "Other Functions",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "linear_momentum",
    "full_id": "sympy.physics.mechanics.functions.linear_momentum",
    "type": "function",
    "description": "Linear momentum of the system.\n\n    Explanation\n    ===========\n\n    This function returns the linear momentum of a system of Particle's and/or\n    RigidBody's. The linear momentum of a system is equal to the vector sum of\n    the linear momentum of its constituents. Consider a system, S, comprised of\n    a rigid body, A, and a particle, P. The linear momentum of the system, L,\n    is equal to the vector sum of the linear momentum of the particle, L1, and\n    the linear momentum of the rigid body, L2, i.e.\n\n    L = L1 + L2\n\n    Parameters\n    ==========\n\n    frame : ReferenceFrame\n        The frame in which linear momentum is desired.\n    body1, body2, body3... : Particle and/or RigidBody\n        The body (or bodies) whose linear momentum is required.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.mechanics import Point, Particle, ReferenceFrame\n    >>> from sympy.physics.mechanics import RigidBody, outer, linear_momentum\n    >>> N = ReferenceFrame('N')\n    >>> P = Point('P')\n    >>> P.set_vel(N, 10 * N.x)\n    >>> Pa = Particle('Pa', P, 1)\n    >>> Ac = Point('Ac')\n    >>> Ac.set_vel(N, 25 * N.y)\n    >>> I = outer(N.x, N.x)\n    >>> A = RigidBody('A', Ac, N, 20, (I, Ac))\n    >>> linear_momentum(N, A, Pa)\n    10*N.x + 500*N.y\n\n    ",
    "section": "Other Functions",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "angular_momentum",
    "full_id": "sympy.physics.mechanics.functions.angular_momentum",
    "type": "function",
    "description": "Angular momentum of a system.\n\n    Explanation\n    ===========\n\n    This function returns the angular momentum of a system of Particle's and/or\n    RigidBody's. The angular momentum of such a system is equal to the vector\n    sum of the angular momentum of its constituents. Consider a system, S,\n    comprised of a rigid body, A, and a particle, P. The angular momentum of\n    the system, H, is equal to the vector sum of the angular momentum of the\n    particle, H1, and the angular momentum of the rigid body, H2, i.e.\n\n    H = H1 + H2\n\n    Parameters\n    ==========\n\n    point : Point\n        The point about which angular momentum of the system is desired.\n    frame : ReferenceFrame\n        The frame in which angular momentum is desired.\n    body1, body2, body3... : Particle and/or RigidBody\n        The body (or bodies) whose angular momentum is required.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.mechanics import Point, Particle, ReferenceFrame\n    >>> from sympy.physics.mechanics import RigidBody, outer, angular_momentum\n    >>> N = ReferenceFrame('N')\n    >>> O = Point('O')\n    >>> O.set_vel(N, 0 * N.x)\n    >>> P = O.locatenew('P', 1 * N.x)\n    >>> P.set_vel(N, 10 * N.x)\n    >>> Pa = Particle('Pa', P, 1)\n    >>> Ac = O.locatenew('Ac', 2 * N.y)\n    >>> Ac.set_vel(N, 5 * N.y)\n    >>> a = ReferenceFrame('a')\n    >>> a.set_ang_vel(N, 10 * N.z)\n    >>> I = outer(N.z, N.z)\n    >>> A = RigidBody('A', Ac, a, 20, (I, Ac))\n    >>> angular_momentum(O, N, Pa, A)\n    10*N.z\n\n    ",
    "section": "Other Functions",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "kinetic_energy",
    "full_id": "sympy.physics.mechanics.functions.kinetic_energy",
    "type": "function",
    "description": "Kinetic energy of a multibody system.\n\n    Explanation\n    ===========\n\n    This function returns the kinetic energy of a system of Particle's and/or\n    RigidBody's. The kinetic energy of such a system is equal to the sum of\n    the kinetic energies of its constituents. Consider a system, S, comprising\n    a rigid body, A, and a particle, P. The kinetic energy of the system, T,\n    is equal to the vector sum of the kinetic energy of the particle, T1, and\n    the kinetic energy of the rigid body, T2, i.e.\n\n    T = T1 + T2\n\n    Kinetic energy is a scalar.\n\n    Parameters\n    ==========\n\n    frame : ReferenceFrame\n        The frame in which the velocity or angular velocity of the body is\n        defined.\n    body1, body2, body3... : Particle and/or RigidBody\n        The body (or bodies) whose kinetic energy is required.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.mechanics import Point, Particle, ReferenceFrame\n    >>> from sympy.physics.mechanics import RigidBody, outer, kinetic_energy\n    >>> N = ReferenceFrame('N')\n    >>> O = Point('O')\n    >>> O.set_vel(N, 0 * N.x)\n    >>> P = O.locatenew('P', 1 * N.x)\n    >>> P.set_vel(N, 10 * N.x)\n    >>> Pa = Particle('Pa', P, 1)\n    >>> Ac = O.locatenew('Ac', 2 * N.y)\n    >>> Ac.set_vel(N, 5 * N.y)\n    >>> a = ReferenceFrame('a')\n    >>> a.set_ang_vel(N, 10 * N.z)\n    >>> I = outer(N.z, N.z)\n    >>> A = RigidBody('A', Ac, a, 20, (I, Ac))\n    >>> kinetic_energy(N, Pa, A)\n    350\n\n    ",
    "section": "Other Functions",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "potential_energy",
    "full_id": "sympy.physics.mechanics.functions.potential_energy",
    "type": "function",
    "description": "Potential energy of a multibody system.\n\n    Explanation\n    ===========\n\n    This function returns the potential energy of a system of Particle's and/or\n    RigidBody's. The potential energy of such a system is equal to the sum of\n    the potential energy of its constituents. Consider a system, S, comprising\n    a rigid body, A, and a particle, P. The potential energy of the system, V,\n    is equal to the vector sum of the potential energy of the particle, V1, and\n    the potential energy of the rigid body, V2, i.e.\n\n    V = V1 + V2\n\n    Potential energy is a scalar.\n\n    Parameters\n    ==========\n\n    body1, body2, body3... : Particle and/or RigidBody\n        The body (or bodies) whose potential energy is required.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.mechanics import Point, Particle, ReferenceFrame\n    >>> from sympy.physics.mechanics import RigidBody, outer, potential_energy\n    >>> from sympy import symbols\n    >>> M, m, g, h = symbols('M m g h')\n    >>> N = ReferenceFrame('N')\n    >>> O = Point('O')\n    >>> O.set_vel(N, 0 * N.x)\n    >>> P = O.locatenew('P', 1 * N.x)\n    >>> Pa = Particle('Pa', P, m)\n    >>> Ac = O.locatenew('Ac', 2 * N.y)\n    >>> a = ReferenceFrame('a')\n    >>> I = outer(N.z, N.z)\n    >>> A = RigidBody('A', Ac, a, M, (I, Ac))\n    >>> Pa.potential_energy = m * g * h\n    >>> A.potential_energy = M * g * h\n    >>> potential_energy(Pa, A)\n    M*g*h + g*h*m\n\n    ",
    "section": "Other Functions",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "Lagrangian",
    "full_id": "sympy.physics.mechanics.functions.Lagrangian",
    "type": "function",
    "description": "Lagrangian of a multibody system.\n\n    Explanation\n    ===========\n\n    This function returns the Lagrangian of a system of Particle's and/or\n    RigidBody's. The Lagrangian of such a system is equal to the difference\n    between the kinetic energies and potential energies of its constituents. If\n    T and V are the kinetic and potential energies of a system then it's\n    Lagrangian, L, is defined as\n\n    L = T - V\n\n    The Lagrangian is a scalar.\n\n    Parameters\n    ==========\n\n    frame : ReferenceFrame\n        The frame in which the velocity or angular velocity of the body is\n        defined to determine the kinetic energy.\n\n    body1, body2, body3... : Particle and/or RigidBody\n        The body (or bodies) whose Lagrangian is required.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.mechanics import Point, Particle, ReferenceFrame\n    >>> from sympy.physics.mechanics import RigidBody, outer, Lagrangian\n    >>> from sympy import symbols\n    >>> M, m, g, h = symbols('M m g h')\n    >>> N = ReferenceFrame('N')\n    >>> O = Point('O')\n    >>> O.set_vel(N, 0 * N.x)\n    >>> P = O.locatenew('P', 1 * N.x)\n    >>> P.set_vel(N, 10 * N.x)\n    >>> Pa = Particle('Pa', P, 1)\n    >>> Ac = O.locatenew('Ac', 2 * N.y)\n    >>> Ac.set_vel(N, 5 * N.y)\n    >>> a = ReferenceFrame('a')\n    >>> a.set_ang_vel(N, 10 * N.z)\n    >>> I = outer(N.z, N.z)\n    >>> A = RigidBody('A', Ac, a, 20, (I, Ac))\n    >>> Pa.potential_energy = m * g * h\n    >>> A.potential_energy = M * g * h\n    >>> Lagrangian(N, Pa, A)\n    -M*g*h - g*h*m + 350\n\n    ",
    "section": "Other Functions",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "find_dynamicsymbols",
    "full_id": "sympy.physics.mechanics.functions.find_dynamicsymbols",
    "type": "function",
    "description": "Find all dynamicsymbols in expression.\n\n    Explanation\n    ===========\n\n    If the optional ``exclude`` kwarg is used, only dynamicsymbols\n    not in the iterable ``exclude`` are returned.\n    If we intend to apply this function on a vector, the optional\n    ``reference_frame`` is also used to inform about the corresponding frame\n    with respect to which the dynamic symbols of the given vector is to be\n    determined.\n\n    Parameters\n    ==========\n\n    expression : SymPy expression\n\n    exclude : iterable of dynamicsymbols, optional\n\n    reference_frame : ReferenceFrame, optional\n        The frame with respect to which the dynamic symbols of the\n        given vector is to be determined.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.mechanics import dynamicsymbols, find_dynamicsymbols\n    >>> from sympy.physics.mechanics import ReferenceFrame\n    >>> x, y = dynamicsymbols('x, y')\n    >>> expr = x + x.diff()*y\n    >>> find_dynamicsymbols(expr)\n    {x(t), y(t), Derivative(x(t), t)}\n    >>> find_dynamicsymbols(expr, exclude=[x, y])\n    {Derivative(x(t), t)}\n    >>> a, b, c = dynamicsymbols('a, b, c')\n    >>> A = ReferenceFrame('A')\n    >>> v = a * A.x + b * A.y + c * A.z\n    >>> find_dynamicsymbols(v, reference_frame=A)\n    {a(t), b(t), c(t)}\n\n    ",
    "section": "Other Functions",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/part_bod.html"
  },
  {
    "name": "auxiliary_eqs",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.auxiliary_eqs",
    "type": "property",
    "description": "A matrix containing the auxiliary equations.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "forcing",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.forcing",
    "type": "property",
    "description": "The forcing vector of the system.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "forcing_full",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.forcing_full",
    "type": "property",
    "description": "The forcing vector of the system, augmented by the kinematic\n        differential equations in explicit or implicit form.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "forcing_kin",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.forcing_kin",
    "type": "property",
    "description": "The kinematic \"forcing vector\" of the system.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "kanes_equations",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.kanes_equations",
    "type": "method",
    "description": "Method to form Kane's equations, Fr + Fr* = 0.\n\n        Explanation\n        ===========\n\n        Returns (Fr, Fr*). In the case where auxiliary generalized speeds are\n        present (say, s auxiliary speeds, o generalized speeds, and m motion\n        constraints) the length of the returned vectors will be o - m + s in\n        length. The first o - m equations will be the constrained Kane's\n        equations, then the s auxiliary Kane's equations. These auxiliary\n        equations can be accessed with the auxiliary_eqs property.\n\n        Parameters\n        ==========\n\n        bodies : iterable\n            An iterable of all RigidBody's and Particle's in the system.\n            A system must have at least one body.\n        loads : iterable\n            Takes in an iterable of (Particle, Vector) or (ReferenceFrame, Vector)\n            tuples which represent the force at a point or torque on a frame.\n            Must be either a non-empty iterable of tuples or None which corresponds\n            to a system with no constraints.\n        ",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "kindiffdict",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.kindiffdict",
    "type": "method",
    "description": "Returns a dictionary mapping q' to u.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "linearize",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.linearize",
    "type": "method",
    "description": "Linearize the equations of motion about a symbolic operating point.\n\n        Parameters\n        ==========\n        new_method\n            Deprecated, does nothing and will be removed.\n        linear_solver : str, callable\n            Method used to solve the several symbolic linear systems of the\n            form ``A*x=b`` in the linearization process. If a string is\n            supplied, it should be a valid method that can be used with the\n            :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is\n            supplied, it should have the format ``x = f(A, b)``, where it\n            solves the equations and returns the solution. The default is\n            ``'LU'`` which corresponds to SymPy's ``A.LUsolve(b)``.\n            ``LUsolve()`` is fast to compute but will often result in\n            divide-by-zero and thus ``nan`` results.\n        **kwargs\n            Extra keyword arguments are passed to\n            :meth:`sympy.physics.mechanics.linearize.Linearizer.linearize`.\n\n        Explanation\n        ===========\n\n        If kwarg A_and_B is False (default), returns M, A, B, r for the\n        linearized form, M*[q', u']^T = A*[q_ind, u_ind]^T + B*r.\n\n        If kwarg A_and_B is True, returns A, B, r for the linearized form\n        dx = A*x + B*r, where x = [q_ind, u_ind]^T. Note that this is\n        computationally intensive if there are many symbolic parameters. For\n        this reason, it may be more desirable to use the default A_and_B=False,\n        returning M, A, and B. Values may then be substituted in to these\n        matrices, and the state space form found as\n        A = P.T*M.inv()*A, B = P.T*M.inv()*B, where P = Linearizer.perm_mat.\n\n        In both cases, r is found as all dynamicsymbols in the equations of\n        motion that are not part of q, u, q', or u'. They are sorted in\n        canonical form.\n\n        The operating points may be also entered using the ``op_point`` kwarg.\n        This takes a dictionary of {symbol: value}, or a an iterable of such\n        dictionaries. The values may be numeric or symbolic. The more values\n        you can specify beforehand, the faster this computation will run.\n\n        For more documentation, please see the ``Linearizer`` class.\n\n        ",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "mass_matrix",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.mass_matrix",
    "type": "property",
    "description": "The mass matrix of the system.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "mass_matrix_full",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.mass_matrix_full",
    "type": "property",
    "description": "The mass matrix of the system, augmented by the kinematic\n        differential equations in explicit or implicit form.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "mass_matrix_kin",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.mass_matrix_kin",
    "type": "property",
    "description": "The kinematic \"mass matrix\" $\\mathbf{k_{k\\dot{q}}}$ of the system.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "rhs",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.rhs",
    "type": "method",
    "description": "Returns the system's equations of motion in first order form. The\n        output is the right hand side of::\n\n           x' = |q'| =: f(q, u, r, p, t)\n                |u'|\n\n        The right hand side is what is needed by most numerical ODE\n        integrators.\n\n        Parameters\n        ==========\n\n        inv_method : str\n            The specific sympy inverse matrix calculation method to use. For a\n            list of valid methods, see\n            :meth:`~sympy.matrices.matrixbase.MatrixBase.inv`\n\n        ",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "to_linearizer",
    "full_id": "sympy.physics.mechanics.kane.KanesMethod.to_linearizer",
    "type": "method",
    "description": "Returns an instance of the Linearizer class, initiated from the\n        data in the KanesMethod class. This may be more desirable than using\n        the linearize class method, as the Linearizer object will allow more\n        efficient recalculation (i.e. about varying operating points).\n\n        Parameters\n        ==========\n        linear_solver : str, callable\n            Method used to solve the several symbolic linear systems of the\n            form ``A*x=b`` in the linearization process. If a string is\n            supplied, it should be a valid method that can be used with the\n            :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is\n            supplied, it should have the format ``x = f(A, b)``, where it\n            solves the equations and returns the solution. The default is\n            ``'LU'`` which corresponds to SymPy's ``A.LUsolve(b)``.\n            ``LUsolve()`` is fast to compute but will often result in\n            divide-by-zero and thus ``nan`` results.\n\n        Returns\n        =======\n        Linearizer\n            An instantiated\n            :class:`sympy.physics.mechanics.linearize.Linearizer`.\n\n        ",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "forcing",
    "full_id": "sympy.physics.mechanics.lagrange.LagrangesMethod.forcing",
    "type": "property",
    "description": "Returns the forcing vector from 'lagranges_equations' method.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "forcing_full",
    "full_id": "sympy.physics.mechanics.lagrange.LagrangesMethod.forcing_full",
    "type": "property",
    "description": "Augments qdots to the forcing vector above.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "form_lagranges_equations",
    "full_id": "sympy.physics.mechanics.lagrange.LagrangesMethod.form_lagranges_equations",
    "type": "method",
    "description": "Method to form Lagrange's equations of motion.\n\n        Returns a vector of equations of motion using Lagrange's equations of\n        the second kind.\n        ",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "linearize",
    "full_id": "sympy.physics.mechanics.lagrange.LagrangesMethod.linearize",
    "type": "method",
    "description": "Linearize the equations of motion about a symbolic operating point.\n\n        Parameters\n        ==========\n        linear_solver : str, callable\n            Method used to solve the several symbolic linear systems of the\n            form ``A*x=b`` in the linearization process. If a string is\n            supplied, it should be a valid method that can be used with the\n            :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is\n            supplied, it should have the format ``x = f(A, b)``, where it\n            solves the equations and returns the solution. The default is\n            ``'LU'`` which corresponds to SymPy's ``A.LUsolve(b)``.\n            ``LUsolve()`` is fast to compute but will often result in\n            divide-by-zero and thus ``nan`` results.\n        **kwargs\n            Extra keyword arguments are passed to\n            :meth:`sympy.physics.mechanics.linearize.Linearizer.linearize`.\n\n        Explanation\n        ===========\n\n        If kwarg A_and_B is False (default), returns M, A, B, r for the\n        linearized form, M*[q', u']^T = A*[q_ind, u_ind]^T + B*r.\n\n        If kwarg A_and_B is True, returns A, B, r for the linearized form\n        dx = A*x + B*r, where x = [q_ind, u_ind]^T. Note that this is\n        computationally intensive if there are many symbolic parameters. For\n        this reason, it may be more desirable to use the default A_and_B=False,\n        returning M, A, and B. Values may then be substituted in to these\n        matrices, and the state space form found as\n        A = P.T*M.inv()*A, B = P.T*M.inv()*B, where P = Linearizer.perm_mat.\n\n        In both cases, r is found as all dynamicsymbols in the equations of\n        motion that are not part of q, u, q', or u'. They are sorted in\n        canonical form.\n\n        The operating points may be also entered using the ``op_point`` kwarg.\n        This takes a dictionary of {symbol: value}, or a an iterable of such\n        dictionaries. The values may be numeric or symbolic. The more values\n        you can specify beforehand, the faster this computation will run.\n\n        For more documentation, please see the ``Linearizer`` class.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "mass_matrix",
    "full_id": "sympy.physics.mechanics.lagrange.LagrangesMethod.mass_matrix",
    "type": "property",
    "description": "Returns the mass matrix, which is augmented by the Lagrange\n        multipliers, if necessary.\n\n        Explanation\n        ===========\n\n        If the system is described by 'n' generalized coordinates and there are\n        no constraint equations then an n X n matrix is returned.\n\n        If there are 'n' generalized coordinates and 'm' constraint equations\n        have been supplied during initialization then an n X (n+m) matrix is\n        returned. The (n + m - 1)th and (n + m)th columns contain the\n        coefficients of the Lagrange multipliers.\n        ",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "mass_matrix_full",
    "full_id": "sympy.physics.mechanics.lagrange.LagrangesMethod.mass_matrix_full",
    "type": "property",
    "description": "Augments the coefficients of qdots to the mass_matrix.",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "rhs",
    "full_id": "sympy.physics.mechanics.lagrange.LagrangesMethod.rhs",
    "type": "method",
    "description": "Returns equations that can be solved numerically.\n\n        Parameters\n        ==========\n\n        inv_method : str\n            The specific sympy inverse matrix calculation method to use. For a\n            list of valid methods, see\n            :meth:`~sympy.matrices.matrixbase.MatrixBase.inv`\n        ",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "solve_multipliers",
    "full_id": "sympy.physics.mechanics.lagrange.LagrangesMethod.solve_multipliers",
    "type": "method",
    "description": "Solves for the values of the lagrange multipliers symbolically at\n        the specified operating point.\n\n        Parameters\n        ==========\n\n        op_point : dict or iterable of dicts, optional\n            Point at which to solve at. The operating point is specified as\n            a dictionary or iterable of dictionaries of {symbol: value}. The\n            value may be numeric or symbolic itself.\n\n        sol_type : str, optional\n            Solution return type. Valid options are:\n            - 'dict': A dict of {symbol : value} (default)\n            - 'Matrix': An ordered column matrix of the solution\n        ",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "to_linearizer",
    "full_id": "sympy.physics.mechanics.lagrange.LagrangesMethod.to_linearizer",
    "type": "method",
    "description": "Returns an instance of the Linearizer class, initiated from the data\n        in the LagrangesMethod class. This may be more desirable than using the\n        linearize class method, as the Linearizer object will allow more\n        efficient recalculation (i.e. about varying operating points).\n\n        Parameters\n        ==========\n\n        q_ind, qd_ind : array_like, optional\n            The independent generalized coordinates and speeds.\n        q_dep, qd_dep : array_like, optional\n            The dependent generalized coordinates and speeds.\n        linear_solver : str, callable\n            Method used to solve the several symbolic linear systems of the\n            form ``A*x=b`` in the linearization process. If a string is\n            supplied, it should be a valid method that can be used with the\n            :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is\n            supplied, it should have the format ``x = f(A, b)``, where it\n            solves the equations and returns the solution. The default is\n            ``'LU'`` which corresponds to SymPy's ``A.LUsolve(b)``.\n            ``LUsolve()`` is fast to compute but will often result in\n            divide-by-zero and thus ``nan`` results.\n\n        Returns\n        =======\n        Linearizer\n            An instantiated\n            :class:`sympy.physics.mechanics.linearize.Linearizer`.\n\n        ",
    "section": "Kane\u2019s Method & Lagrange\u2019s Method (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html"
  },
  {
    "name": "child",
    "full_id": "sympy.physics.mechanics.joint.Joint.child",
    "type": "property",
    "description": "Child body of Joint.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "child_axis",
    "full_id": "sympy.physics.mechanics.joint.Joint.child_axis",
    "type": "property",
    "description": "The axis of child frame.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "child_point",
    "full_id": "sympy.physics.mechanics.joint.Joint.child_point",
    "type": "property",
    "description": "Attachment point where the joint is fixed to the child body.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "coordinates",
    "full_id": "sympy.physics.mechanics.joint.Joint.coordinates",
    "type": "property",
    "description": "Matrix of the joint's generalized coordinates.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "kdes",
    "full_id": "sympy.physics.mechanics.joint.Joint.kdes",
    "type": "property",
    "description": "Kinematical differential equations of the joint.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "name",
    "full_id": "sympy.physics.mechanics.joint.Joint.name",
    "type": "property",
    "description": "Name of the joint.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "parent",
    "full_id": "sympy.physics.mechanics.joint.Joint.parent",
    "type": "property",
    "description": "Parent body of Joint.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "parent_axis",
    "full_id": "sympy.physics.mechanics.joint.Joint.parent_axis",
    "type": "property",
    "description": "The axis of parent frame.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "parent_point",
    "full_id": "sympy.physics.mechanics.joint.Joint.parent_point",
    "type": "property",
    "description": "Attachment point where the joint is fixed to the parent body.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "speeds",
    "full_id": "sympy.physics.mechanics.joint.Joint.speeds",
    "type": "property",
    "description": "Matrix of the joint's generalized speeds.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "joint_axis",
    "full_id": "sympy.physics.mechanics.joint.PinJoint.joint_axis",
    "type": "property",
    "description": "Axis about which the child rotates with respect to the parent.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "joint_axis",
    "full_id": "sympy.physics.mechanics.joint.PrismaticJoint.joint_axis",
    "type": "property",
    "description": "Axis along which the child translates with respect to the parent.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "joint_axis",
    "full_id": "sympy.physics.mechanics.joint.CylindricalJoint.joint_axis",
    "type": "property",
    "description": "Axis about and along which the rotation and translation occurs.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "rotation_coordinate",
    "full_id": "sympy.physics.mechanics.joint.CylindricalJoint.rotation_coordinate",
    "type": "property",
    "description": "Generalized coordinate corresponding to the rotation angle.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "rotation_speed",
    "full_id": "sympy.physics.mechanics.joint.CylindricalJoint.rotation_speed",
    "type": "property",
    "description": "Generalized speed corresponding to the angular velocity.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "translation_coordinate",
    "full_id": "sympy.physics.mechanics.joint.CylindricalJoint.translation_coordinate",
    "type": "property",
    "description": "Generalized coordinate corresponding to the translation distance.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "translation_speed",
    "full_id": "sympy.physics.mechanics.joint.CylindricalJoint.translation_speed",
    "type": "property",
    "description": "Generalized speed corresponding to the translation velocity.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "planar_coordinates",
    "full_id": "sympy.physics.mechanics.joint.PlanarJoint.planar_coordinates",
    "type": "property",
    "description": "Two generalized coordinates used for the planar translation.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "planar_speeds",
    "full_id": "sympy.physics.mechanics.joint.PlanarJoint.planar_speeds",
    "type": "property",
    "description": "Two generalized speeds used for the planar translation velocity.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "planar_vectors",
    "full_id": "sympy.physics.mechanics.joint.PlanarJoint.planar_vectors",
    "type": "property",
    "description": "The vectors that describe the planar translation directions.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "rotation_axis",
    "full_id": "sympy.physics.mechanics.joint.PlanarJoint.rotation_axis",
    "type": "property",
    "description": "The axis about which the rotation occurs.",
    "section": "Joint (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/joint.html"
  },
  {
    "name": "alg_con",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.alg_con",
    "type": "property",
    "description": "Returns a list with the indices of the rows containing algebraic\n        constraints in the combined form of the equations of motion",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "bodies",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.bodies",
    "type": "property",
    "description": "Returns the bodies in the system",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "comb_explicit_rhs",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.comb_explicit_rhs",
    "type": "property",
    "description": "Returns the right hand side of the equations of motion in explicit\n        form, x' = F, where the kinematical equations are included",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "comb_implicit_mat",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.comb_implicit_mat",
    "type": "property",
    "description": "Returns the matrix, M, corresponding to the equations of motion in\n        implicit form (form [2]), M x' = F, where the kinematical equations are\n        included",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "comb_implicit_rhs",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.comb_implicit_rhs",
    "type": "property",
    "description": "Returns the column matrix, F, corresponding to the equations of\n        motion in implicit form (form [2]), M x' = F, where the kinematical\n        equations are included",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "compute_explicit_form",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.compute_explicit_form",
    "type": "method",
    "description": "If the explicit right hand side of the combined equations of motion\n        is to provided upon initialization, this method will calculate it. This\n        calculation can potentially take awhile to compute.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "constant_symbols",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.constant_symbols",
    "type": "method",
    "description": "Returns a column matrix containing all of the symbols in the system\n        that do not depend on time",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "coordinates",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.coordinates",
    "type": "property",
    "description": "Returns the column matrix of the generalized coordinates",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "dyn_implicit_mat",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.dyn_implicit_mat",
    "type": "property",
    "description": "Returns the matrix, M, corresponding to the dynamic equations in\n        implicit form, M x' = F, where the kinematical equations are not\n        included",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "dyn_implicit_rhs",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.dyn_implicit_rhs",
    "type": "property",
    "description": "Returns the column matrix, F, corresponding to the dynamic equations\n        in implicit form, M x' = F, where the kinematical equations are not\n        included",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "dynamic_symbols",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.dynamic_symbols",
    "type": "method",
    "description": "Returns a column matrix containing all of the symbols in the system\n        that depend on time",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "kin_explicit_rhs",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.kin_explicit_rhs",
    "type": "property",
    "description": "Returns the right hand side of the kinematical equations in explicit\n        form, q' = G",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "loads",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.loads",
    "type": "property",
    "description": "Returns the loads in the system",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "speeds",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.speeds",
    "type": "property",
    "description": "Returns the column matrix of generalized speeds",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "states",
    "full_id": "sympy.physics.mechanics.system.SymbolicSystem.states",
    "type": "property",
    "description": "Returns the column matrix of the state variables",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "actuators",
    "full_id": "sympy.physics.mechanics.system.System.actuators",
    "type": "property",
    "description": "Tuple of actuators present in the system.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_actuators",
    "full_id": "sympy.physics.mechanics.system.System.add_actuators",
    "type": "method",
    "description": "Add actuator(s) to the system.\n\n        Parameters\n        ==========\n\n        *actuators : subclass of ActuatorBase\n            One or more actuators.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_auxiliary_speeds",
    "full_id": "sympy.physics.mechanics.system.System.add_auxiliary_speeds",
    "type": "method",
    "description": "Add auxiliary speed(s) to the system.\n\n        Parameters\n        ==========\n\n        *speeds : dynamicsymbols\n            One or more auxiliary speeds to be added to the system.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_bodies",
    "full_id": "sympy.physics.mechanics.system.System.add_bodies",
    "type": "method",
    "description": "Add body(ies) to the system.\n\n        Parameters\n        ==========\n\n        bodies : Particle or RigidBody\n            One or more bodies.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_coordinates",
    "full_id": "sympy.physics.mechanics.system.System.add_coordinates",
    "type": "method",
    "description": "Add generalized coordinate(s) to the system.\n\n        Parameters\n        ==========\n\n        *coordinates : dynamicsymbols\n            One or more generalized coordinates to be added to the system.\n        independent : bool or list of bool, optional\n            Boolean whether a coordinate is dependent or independent. The\n            default is True, so the coordinates are added as independent by\n            default.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_holonomic_constraints",
    "full_id": "sympy.physics.mechanics.system.System.add_holonomic_constraints",
    "type": "method",
    "description": "Add holonomic constraint(s) to the system.\n\n        Parameters\n        ==========\n\n        *constraints : Expr\n            One or more holonomic constraints, which are expressions that should\n            be zero.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_joints",
    "full_id": "sympy.physics.mechanics.system.System.add_joints",
    "type": "method",
    "description": "Add joint(s) to the system.\n\n        Explanation\n        ===========\n\n        This methods adds one or more joints to the system including its\n        associated objects, i.e. generalized coordinates, generalized speeds,\n        kinematic differential equations and the bodies.\n\n        Parameters\n        ==========\n\n        *joints : subclass of Joint\n            One or more joints.\n\n        Notes\n        =====\n\n        For the generalized coordinates, generalized speeds and bodies it is\n        checked whether they are already known by the system instance. If they\n        are, then they are not added. The kinematic differential equations are\n        however always added to the system, so you should not also manually add\n        those on beforehand.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_kdes",
    "full_id": "sympy.physics.mechanics.system.System.add_kdes",
    "type": "method",
    "description": "Add kinematic differential equation(s) to the system.\n\n        Parameters\n        ==========\n\n        *kdes : Expr\n            One or more kinematic differential equations.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_loads",
    "full_id": "sympy.physics.mechanics.system.System.add_loads",
    "type": "method",
    "description": "Add load(s) to the system.\n\n        Parameters\n        ==========\n\n        *loads : Force or Torque\n            One or more loads.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_nonholonomic_constraints",
    "full_id": "sympy.physics.mechanics.system.System.add_nonholonomic_constraints",
    "type": "method",
    "description": "Add nonholonomic constraint(s) to the system.\n\n        Parameters\n        ==========\n\n        *constraints : Expr\n            One or more nonholonomic constraints, which are expressions that\n            should be zero.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "add_speeds",
    "full_id": "sympy.physics.mechanics.system.System.add_speeds",
    "type": "method",
    "description": "Add generalized speed(s) to the system.\n\n        Parameters\n        ==========\n\n        *speeds : dynamicsymbols\n            One or more generalized speeds to be added to the system.\n        independent : bool or list of bool, optional\n            Boolean whether a speed is dependent or independent. The default is\n            True, so the speeds are added as independent by default.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "apply_uniform_gravity",
    "full_id": "sympy.physics.mechanics.system.System.apply_uniform_gravity",
    "type": "method",
    "description": "Apply uniform gravity to all bodies in the system by adding loads.\n\n        Parameters\n        ==========\n\n        acceleration : Vector\n            The acceleration due to gravity.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "bodies",
    "full_id": "sympy.physics.mechanics.system.System.bodies",
    "type": "property",
    "description": "Tuple of all bodies that have been added to the system.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "eom_method",
    "full_id": "sympy.physics.mechanics.system.System.eom_method",
    "type": "property",
    "description": "Backend for forming the equations of motion.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "fixed_point",
    "full_id": "sympy.physics.mechanics.system.System.fixed_point",
    "type": "property",
    "description": "Fixed point in the inertial reference frame.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "form_eoms",
    "full_id": "sympy.physics.mechanics.system.System.form_eoms",
    "type": "method",
    "description": "Form the equations of motion of the system.\n\n        Parameters\n        ==========\n\n        eom_method : subclass of KanesMethod or LagrangesMethod\n            Backend class to be used for forming the equations of motion. The\n            default is ``KanesMethod``.\n\n        Returns\n        ========\n\n        ImmutableMatrix\n            Vector of equations of motions.\n\n        Examples\n        ========\n\n        This is a simple example for a one degree of freedom translational\n        spring-mass-damper.\n\n        >>> from sympy import S, symbols\n        >>> from sympy.physics.mechanics import (\n        ...     LagrangesMethod, dynamicsymbols, PrismaticJoint, Particle,\n        ...     RigidBody, System)\n        >>> q = dynamicsymbols('q')\n        >>> qd = dynamicsymbols('q', 1)\n        >>> m, k, b = symbols('m k b')\n        >>> wall = RigidBody('W')\n        >>> system = System.from_newtonian(wall)\n        >>> bob = Particle('P', mass=m)\n        >>> bob.potential_energy = S.Half * k * q**2\n        >>> system.add_joints(PrismaticJoint('J', wall, bob, q, qd))\n        >>> system.add_loads((bob.masscenter, b * qd * system.x))\n        >>> system.form_eoms(LagrangesMethod)\n        Matrix([[-b*Derivative(q(t), t) + k*q(t) + m*Derivative(q(t), (t, 2))]])\n\n        We can also solve for the states using the 'rhs' method.\n\n        >>> system.rhs()\n        Matrix([\n        [               Derivative(q(t), t)],\n        [(b*Derivative(q(t), t) - k*q(t))/m]])\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "frame",
    "full_id": "sympy.physics.mechanics.system.System.frame",
    "type": "property",
    "description": "Inertial reference frame of the system.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "from_newtonian",
    "full_id": "sympy.physics.mechanics.system.System.from_newtonian",
    "type": "method",
    "description": "Constructs the system with respect to a Newtonian body.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "get_body",
    "full_id": "sympy.physics.mechanics.system.System.get_body",
    "type": "method",
    "description": "Retrieve a body from the system by name.\n\n        Parameters\n        ==========\n\n        name : str\n            The name of the body to retrieve.\n\n        Returns\n        =======\n\n        RigidBody or Particle\n            The body with the given name, or None if no such body exists.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "get_joint",
    "full_id": "sympy.physics.mechanics.system.System.get_joint",
    "type": "method",
    "description": "Retrieve a joint from the system by name.\n\n        Parameters\n        ==========\n\n        name : str\n            The name of the joint to retrieve.\n\n        Returns\n        =======\n\n        subclass of Joint\n            The joint with the given name, or None if no such joint exists.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "holonomic_constraints",
    "full_id": "sympy.physics.mechanics.system.System.holonomic_constraints",
    "type": "property",
    "description": "Matrix with the holonomic constraints as expressions equated to the\n        zero matrix.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "joints",
    "full_id": "sympy.physics.mechanics.system.System.joints",
    "type": "property",
    "description": "Tuple of all joints that have been added to the system.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "kdes",
    "full_id": "sympy.physics.mechanics.system.System.kdes",
    "type": "property",
    "description": "Kinematical differential equations as expressions equated to the zero\n        matrix. These equations describe the coupling between the generalized\n        coordinates and the generalized speeds.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "loads",
    "full_id": "sympy.physics.mechanics.system.System.loads",
    "type": "property",
    "description": "Tuple of loads that have been applied on the system.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "mass_matrix",
    "full_id": "sympy.physics.mechanics.system.System.mass_matrix",
    "type": "property",
    "description": "The mass matrix of the system.\n\n        Explanation\n        ===========\n\n        The mass matrix $M_d$ and the forcing vector $f_d$ of a system describe\n        the system's dynamics according to the following equations:\n\n        .. math::\n            M_d \\dot{u} = f_d\n\n        where $\\dot{u}$ is the time derivative of the generalized speeds.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "mass_matrix_full",
    "full_id": "sympy.physics.mechanics.system.System.mass_matrix_full",
    "type": "property",
    "description": "The mass matrix of the system, augmented by the kinematic\n        differential equations in explicit or implicit form.\n\n        Explanation\n        ===========\n\n        The full mass matrix $M_m$ and the full forcing vector $f_m$ of a system\n        describe the dynamics and kinematics according to the following\n        equation:\n\n        .. math::\n            M_m \\dot{x} = f_m\n\n        where $x$ is the state vector stacking $q$ and $u$.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "nonholonomic_constraints",
    "full_id": "sympy.physics.mechanics.system.System.nonholonomic_constraints",
    "type": "property",
    "description": "Matrix with the nonholonomic constraints as expressions equated to\n        the zero matrix.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "q",
    "full_id": "sympy.physics.mechanics.system.System.q",
    "type": "property",
    "description": "Matrix of all the generalized coordinates with the independent\n        stacked upon the dependent.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "q_dep",
    "full_id": "sympy.physics.mechanics.system.System.q_dep",
    "type": "property",
    "description": "Matrix of the dependent generalized coordinates.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "q_ind",
    "full_id": "sympy.physics.mechanics.system.System.q_ind",
    "type": "property",
    "description": "Matrix of the independent generalized coordinates.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "rhs",
    "full_id": "sympy.physics.mechanics.system.System.rhs",
    "type": "method",
    "description": "Compute the equations of motion in the explicit form.\n\n        Parameters\n        ==========\n\n        inv_method : str\n            The specific sympy inverse matrix calculation method to use. For a\n            list of valid methods, see\n            :meth:`~sympy.matrices.matrixbase.MatrixBase.inv`\n\n        Returns\n        ========\n\n        ImmutableMatrix\n            Equations of motion in the explicit form.\n\n        See Also\n        ========\n\n        sympy.physics.mechanics.kane.KanesMethod.rhs:\n            KanesMethod's ``rhs`` function.\n        sympy.physics.mechanics.lagrange.LagrangesMethod.rhs:\n            LagrangesMethod's ``rhs`` function.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "u",
    "full_id": "sympy.physics.mechanics.system.System.u",
    "type": "property",
    "description": "Matrix of all the generalized speeds with the independent stacked\n        upon the dependent.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "u_aux",
    "full_id": "sympy.physics.mechanics.system.System.u_aux",
    "type": "property",
    "description": "Matrix of auxiliary generalized speeds.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "u_dep",
    "full_id": "sympy.physics.mechanics.system.System.u_dep",
    "type": "property",
    "description": "Matrix of the dependent generalized speeds.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "u_ind",
    "full_id": "sympy.physics.mechanics.system.System.u_ind",
    "type": "property",
    "description": "Matrix of the independent generalized speeds.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "validate_system",
    "full_id": "sympy.physics.mechanics.system.System.validate_system",
    "type": "method",
    "description": "Validates the system using some basic checks.\n\n        Explanation\n        ===========\n\n        This method validates the system based on the following checks:\n\n        - The number of dependent generalized coordinates should equal the\n          number of holonomic constraints.\n        - All generalized coordinates defined by the joints should also be known\n          to the system.\n        - If ``KanesMethod`` is used as a ``eom_method``:\n            - All generalized speeds and kinematic differential equations\n              defined by the joints should also be known to the system.\n            - The number of dependent generalized speeds should equal the number\n              of velocity constraints.\n            - The number of generalized coordinates should be less than or equal\n              to the number of generalized speeds.\n            - The number of generalized coordinates should equal the number of\n              kinematic differential equations.\n        - If ``LagrangesMethod`` is used as ``eom_method``:\n            - There should not be any generalized speeds that are not\n              derivatives of the generalized coordinates (this includes the\n              generalized speeds defined by the joints).\n\n        Parameters\n        ==========\n\n        eom_method : subclass of KanesMethod or LagrangesMethod\n            Backend class that will be used for forming the equations of motion.\n            There are different checks for the different backends. The default\n            is ``KanesMethod``.\n        check_duplicates : bool\n            Boolean whether the system should be checked for duplicate\n            definitions. The default is False, because duplicates are already\n            checked when adding objects to the system.\n\n        Notes\n        =====\n\n        This method is not guaranteed to be backwards compatible as it may\n        improve over time. The method can become both more and less strict in\n        certain areas. However a well-defined system should always pass all\n        these tests.\n\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "velocity_constraints",
    "full_id": "sympy.physics.mechanics.system.System.velocity_constraints",
    "type": "property",
    "description": "Matrix with the velocity constraints as expressions equated to the\n        zero matrix. The velocity constraints are by default derived from the\n        holonomic and nonholonomic constraints unless they are explicitly set.\n        ",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "x",
    "full_id": "sympy.physics.mechanics.system.System.x",
    "type": "property",
    "description": "Unit vector fixed in the inertial reference frame.",
    "section": "System (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.physics.mechanics.linearize.Linearizer.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        f_0, f_1, f_2, f_3, f_4, f_c, f_v, f_a : array_like\n            System of equations holding the general system form.\n            Supply empty array or Matrix if the parameter\n            does not exist.\n        q : array_like\n            The generalized coordinates.\n        u : array_like\n            The generalized speeds\n        q_i, u_i : array_like, optional\n            The independent generalized coordinates and speeds.\n        q_d, u_d : array_like, optional\n            The dependent generalized coordinates and speeds.\n        r : array_like, optional\n            The input variables.\n        lams : array_like, optional\n            The lagrange multipliers\n        linear_solver : str, callable\n            Method used to solve the several symbolic linear systems of the\n            form ``A*x=b`` in the linearization process. If a string is\n            supplied, it should be a valid method that can be used with the\n            :meth:`sympy.matrices.matrixbase.MatrixBase.solve`. If a callable is\n            supplied, it should have the format ``x = f(A, b)``, where it\n            solves the equations and returns the solution. The default is\n            ``'LU'`` which corresponds to SymPy's ``A.LUsolve(b)``.\n            ``LUsolve()`` is fast to compute but will often result in\n            divide-by-zero and thus ``nan`` results.\n\n        ",
    "section": "Linearization (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/linearize.html"
  },
  {
    "name": "linearize",
    "full_id": "sympy.physics.mechanics.linearize.Linearizer.linearize",
    "type": "method",
    "description": "Linearize the system about the operating point. Note that\n        q_op, u_op, qd_op, ud_op must satisfy the equations of motion.\n        These may be either symbolic or numeric.\n\n        Parameters\n        ==========\n        op_point : dict or iterable of dicts, optional\n            Dictionary or iterable of dictionaries containing the operating\n            point conditions for all or a subset of the generalized\n            coordinates, generalized speeds, and time derivatives of the\n            generalized speeds. These will be substituted into the linearized\n            system before the linearization is complete. Leave set to ``None``\n            if you want the operating point to be an arbitrary set of symbols.\n            Note that any reduction in symbols (whether substituted for numbers\n            or expressions with a common parameter) will result in faster\n            runtime.\n        A_and_B : bool, optional\n            If A_and_B=False (default), (M, A, B) is returned and of\n            A_and_B=True, (A, B) is returned. See below.\n        simplify : bool, optional\n            Determines if returned values are simplified before return.\n            For large expressions this may be time consuming. Default is False.\n\n        Returns\n        =======\n        M, A, B : Matrices, ``A_and_B=False``\n            Matrices from the implicit form:\n                ``[M]*[q', u']^T = [A]*[q_ind, u_ind]^T + [B]*r``\n        A, B : Matrices, ``A_and_B=True``\n            Matrices from the explicit form:\n                ``[q_ind', u_ind']^T = [A]*[q_ind, u_ind]^T + [B]*r``\n\n        Notes\n        =====\n\n        Note that the process of solving with A_and_B=True is computationally\n        intensive if there are many symbolic parameters. For this reason, it\n        may be more desirable to use the default A_and_B=False, returning M, A,\n        and B. More values may then be substituted in to these matrices later\n        on. The state space form can then be found as A = P.T*M.LUsolve(A), B =\n        P.T*M.LUsolve(B), where P = Linearizer.perm_mat.\n\n        ",
    "section": "Linearization (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/linearize.html"
  },
  {
    "name": "msubs",
    "full_id": "sympy.physics.mechanics.msubs",
    "type": "function",
    "description": "A custom subs for use on expressions derived in physics.mechanics.\n\n    Traverses the expression tree once, performing the subs found in sub_dicts.\n    Terms inside ``Derivative`` expressions are ignored:\n\n    Examples\n    ========\n\n    >>> from sympy.physics.mechanics import dynamicsymbols, msubs\n    >>> x = dynamicsymbols('x')\n    >>> msubs(x.diff() + x, {x: 1})\n    Derivative(x(t), t) + 1\n\n    Note that sub_dicts can be a single dictionary, or several dictionaries:\n\n    >>> x, y, z = dynamicsymbols('x, y, z')\n    >>> sub1 = {x: 1, y: 2}\n    >>> sub2 = {z: 3, x.diff(): 4}\n    >>> msubs(x.diff() + x + y + z, sub1, sub2)\n    10\n\n    If smart=True (default False), also checks for conditions that may result\n    in ``nan``, but if simplified would yield a valid expression. For example:\n\n    >>> from sympy import sin, tan\n    >>> (sin(x)/tan(x)).subs(x, 0)\n    nan\n    >>> msubs(sin(x)/tan(x), {x: 0}, smart=True)\n    1\n\n    It does this by first replacing all ``tan`` with ``sin/cos``. Then each\n    node is traversed. If the node is a fraction, subs is first evaluated on\n    the denominator. If this results in 0, simplification of the entire\n    fraction is attempted. Using this selective simplification, only\n    subexpressions that result in 1/0 are targeted, resulting in faster\n    performance.\n\n    ",
    "section": "Expression Manipulation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/expr_manip.html"
  },
  {
    "name": "extension_velocity",
    "full_id": "sympy.physics.mechanics.pathway.LinearPathway.extension_velocity",
    "type": "property",
    "description": "Exact analytical expression for the pathway's extension velocity.",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "length",
    "full_id": "sympy.physics.mechanics.pathway.LinearPathway.length",
    "type": "property",
    "description": "Exact analytical expression for the pathway's length.",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "to_loads",
    "full_id": "sympy.physics.mechanics.pathway.LinearPathway.to_loads",
    "type": "method",
    "description": "Loads required by the equations of motion method classes.\n\n        Explanation\n        ===========\n\n        ``KanesMethod`` requires a list of ``Point``-``Vector`` tuples to be\n        passed to the ``loads`` parameters of its ``kanes_equations`` method\n        when constructing the equations of motion. This method acts as a\n        utility to produce the correctly-structred pairs of points and vectors\n        required so that these can be easily concatenated with other items in\n        the list of loads and passed to ``KanesMethod.kanes_equations``. These\n        loads are also in the correct form to also be passed to the other\n        equations of motion method classes, e.g. ``LagrangesMethod``.\n\n        Examples\n        ========\n\n        The below example shows how to generate the loads produced in a linear\n        actuator that produces an expansile force ``F``. First, create a linear\n        actuator between two points separated by the coordinate ``q`` in the\n        ``x`` direction of the global frame ``N``.\n\n        >>> from sympy.physics.mechanics import (LinearPathway, Point,\n        ...     ReferenceFrame)\n        >>> from sympy.physics.vector import dynamicsymbols\n        >>> q = dynamicsymbols('q')\n        >>> N = ReferenceFrame('N')\n        >>> pA, pB = Point('pA'), Point('pB')\n        >>> pB.set_pos(pA, q*N.x)\n        >>> linear_pathway = LinearPathway(pA, pB)\n\n        Now create a symbol ``F`` to describe the magnitude of the (expansile)\n        force that will be produced along the pathway. The list of loads that\n        ``KanesMethod`` requires can be produced by calling the pathway's\n        ``to_loads`` method with ``F`` passed as the only argument.\n\n        >>> from sympy import symbols\n        >>> F = symbols('F')\n        >>> linear_pathway.to_loads(F)\n        [(pA, - F*q(t)/sqrt(q(t)**2)*N.x), (pB, F*q(t)/sqrt(q(t)**2)*N.x)]\n\n        Parameters\n        ==========\n\n        force : Expr\n            Magnitude of the force acting along the length of the pathway. As\n            per the sign conventions for the pathway length, pathway extension\n            velocity, and pair of point forces, if this ``Expr`` is positive\n            then the force will act to push the pair of points away from one\n            another (it is expansile).\n\n        ",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "attachments",
    "full_id": "sympy.physics.mechanics.pathway.ObstacleSetPathway.attachments",
    "type": "property",
    "description": "The set of points defining a pathway's segmented path.",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "to_loads",
    "full_id": "sympy.physics.mechanics.pathway.ObstacleSetPathway.to_loads",
    "type": "method",
    "description": "Loads required by the equations of motion method classes.\n\n        Explanation\n        ===========\n\n        ``KanesMethod`` requires a list of ``Point``-``Vector`` tuples to be\n        passed to the ``loads`` parameters of its ``kanes_equations`` method\n        when constructing the equations of motion. This method acts as a\n        utility to produce the correctly-structred pairs of points and vectors\n        required so that these can be easily concatenated with other items in\n        the list of loads and passed to ``KanesMethod.kanes_equations``. These\n        loads are also in the correct form to also be passed to the other\n        equations of motion method classes, e.g. ``LagrangesMethod``.\n\n        Examples\n        ========\n\n        The below example shows how to generate the loads produced in an\n        actuator that follows an obstacle-set pathway between four points and\n        produces an expansile force ``F``. First, create a pair of reference\n        frames, ``A`` and ``B``, in which the four points ``pA``, ``pB``,\n        ``pC``, and ``pD`` will be located. The first two points in frame ``A``\n        and the second two in frame ``B``. Frame ``B`` will also be oriented\n        such that it relates to ``A`` via a rotation of ``q`` about an axis\n        ``N.z`` in a global frame (``N.z``, ``A.z``, and ``B.z`` are parallel).\n\n        >>> from sympy.physics.mechanics import (ObstacleSetPathway, Point,\n        ...     ReferenceFrame)\n        >>> from sympy.physics.vector import dynamicsymbols\n        >>> q = dynamicsymbols('q')\n        >>> N = ReferenceFrame('N')\n        >>> N = ReferenceFrame('N')\n        >>> A = N.orientnew('A', 'axis', (0, N.x))\n        >>> B = A.orientnew('B', 'axis', (q, N.z))\n        >>> pO = Point('pO')\n        >>> pA, pB, pC, pD = Point('pA'), Point('pB'), Point('pC'), Point('pD')\n        >>> pA.set_pos(pO, A.x)\n        >>> pB.set_pos(pO, -A.y)\n        >>> pC.set_pos(pO, B.y)\n        >>> pD.set_pos(pO, B.x)\n        >>> obstacle_set_pathway = ObstacleSetPathway(pA, pB, pC, pD)\n\n        Now create a symbol ``F`` to describe the magnitude of the (expansile)\n        force that will be produced along the pathway. The list of loads that\n        ``KanesMethod`` requires can be produced by calling the pathway's\n        ``to_loads`` method with ``F`` passed as the only argument.\n\n        >>> from sympy import Symbol\n        >>> F = Symbol('F')\n        >>> obstacle_set_pathway.to_loads(F)\n        [(pA, sqrt(2)*F/2*A.x + sqrt(2)*F/2*A.y),\n         (pB, - sqrt(2)*F/2*A.x - sqrt(2)*F/2*A.y),\n         (pB, - F/sqrt(2*cos(q(t)) + 2)*A.y - F/sqrt(2*cos(q(t)) + 2)*B.y),\n         (pC, F/sqrt(2*cos(q(t)) + 2)*A.y + F/sqrt(2*cos(q(t)) + 2)*B.y),\n         (pC, - sqrt(2)*F/2*B.x + sqrt(2)*F/2*B.y),\n         (pD, sqrt(2)*F/2*B.x - sqrt(2)*F/2*B.y)]\n\n        Parameters\n        ==========\n\n        force : Expr\n            The force acting along the length of the pathway. It is assumed\n            that this ``Expr`` represents an expansile force.\n\n        ",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "attachments",
    "full_id": "sympy.physics.mechanics.pathway.PathwayBase.attachments",
    "type": "property",
    "description": "The pair of points defining a pathway's ends.",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "extension_velocity",
    "full_id": "sympy.physics.mechanics.pathway.PathwayBase.extension_velocity",
    "type": "property",
    "description": "An expression representing the pathway's extension velocity.",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "length",
    "full_id": "sympy.physics.mechanics.pathway.PathwayBase.length",
    "type": "property",
    "description": "An expression representing the pathway's length.",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "to_loads",
    "full_id": "sympy.physics.mechanics.pathway.PathwayBase.to_loads",
    "type": "method",
    "description": "Loads required by the equations of motion method classes.\n\n        Explanation\n        ===========\n\n        ``KanesMethod`` requires a list of ``Point``-``Vector`` tuples to be\n        passed to the ``loads`` parameters of its ``kanes_equations`` method\n        when constructing the equations of motion. This method acts as a\n        utility to produce the correctly-structred pairs of points and vectors\n        required so that these can be easily concatenated with other items in\n        the list of loads and passed to ``KanesMethod.kanes_equations``. These\n        loads are also in the correct form to also be passed to the other\n        equations of motion method classes, e.g. ``LagrangesMethod``.\n\n        ",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "geometry",
    "full_id": "sympy.physics.mechanics.pathway.WrappingPathway.geometry",
    "type": "property",
    "description": "Geometry around which the pathway wraps.",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "to_loads",
    "full_id": "sympy.physics.mechanics.pathway.WrappingPathway.to_loads",
    "type": "method",
    "description": "Loads required by the equations of motion method classes.\n\n        Explanation\n        ===========\n\n        ``KanesMethod`` requires a list of ``Point``-``Vector`` tuples to be\n        passed to the ``loads`` parameters of its ``kanes_equations`` method\n        when constructing the equations of motion. This method acts as a\n        utility to produce the correctly-structred pairs of points and vectors\n        required so that these can be easily concatenated with other items in\n        the list of loads and passed to ``KanesMethod.kanes_equations``. These\n        loads are also in the correct form to also be passed to the other\n        equations of motion method classes, e.g. ``LagrangesMethod``.\n\n        Examples\n        ========\n\n        The below example shows how to generate the loads produced in an\n        actuator that produces an expansile force ``F`` while wrapping around a\n        cylinder. First, create a cylinder with radius ``r`` and an axis\n        parallel to the ``N.z`` direction of the global frame ``N`` that also\n        passes through a point ``pO``.\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.mechanics import (Point, ReferenceFrame,\n        ...     WrappingCylinder)\n        >>> N = ReferenceFrame('N')\n        >>> r = symbols('r', positive=True)\n        >>> pO = Point('pO')\n        >>> cylinder = WrappingCylinder(r, pO, N.z)\n\n        Create the pathway of the actuator using the ``WrappingPathway`` class,\n        defined to span between two points ``pA`` and ``pB``. Both points lie\n        on the surface of the cylinder and the location of ``pB`` is defined\n        relative to ``pA`` by the dynamics symbol ``q``.\n\n        >>> from sympy import cos, sin\n        >>> from sympy.physics.mechanics import WrappingPathway, dynamicsymbols\n        >>> q = dynamicsymbols('q')\n        >>> pA = Point('pA')\n        >>> pB = Point('pB')\n        >>> pA.set_pos(pO, r*N.x)\n        >>> pB.set_pos(pO, r*(cos(q)*N.x + sin(q)*N.y))\n        >>> pB.pos_from(pA)\n        (r*cos(q(t)) - r)*N.x + r*sin(q(t))*N.y\n        >>> pathway = WrappingPathway(pA, pB, cylinder)\n\n        Now create a symbol ``F`` to describe the magnitude of the (expansile)\n        force that will be produced along the pathway. The list of loads that\n        ``KanesMethod`` requires can be produced by calling the pathway's\n        ``to_loads`` method with ``F`` passed as the only argument.\n\n        >>> F = symbols('F')\n        >>> loads = pathway.to_loads(F)\n        >>> [load.__class__(load.location, load.vector.simplify()) for load in loads]\n        [(pA, F*N.y), (pB, F*sin(q(t))*N.x - F*cos(q(t))*N.y),\n         (pO, - F*sin(q(t))*N.x + F*(cos(q(t)) - 1)*N.y)]\n\n        Parameters\n        ==========\n\n        force : Expr\n            Magnitude of the force acting along the length of the pathway. It\n            is assumed that this ``Expr`` represents an expansile force.\n\n        ",
    "section": "Pathway (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"
  },
  {
    "name": "force",
    "full_id": "sympy.physics.mechanics.actuator.DuffingSpring.force",
    "type": "property",
    "description": "The force produced by the Duffing spring.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "force",
    "full_id": "sympy.physics.mechanics.actuator.ForceActuator.force",
    "type": "property",
    "description": "The magnitude of the force produced by the actuator.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "pathway",
    "full_id": "sympy.physics.mechanics.actuator.ForceActuator.pathway",
    "type": "property",
    "description": "The ``Pathway`` defining the actuator's line of action.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "to_loads",
    "full_id": "sympy.physics.mechanics.actuator.ForceActuator.to_loads",
    "type": "method",
    "description": "Loads required by the equations of motion method classes.\n\n        Explanation\n        ===========\n\n        ``KanesMethod`` requires a list of ``Point``-``Vector`` tuples to be\n        passed to the ``loads`` parameters of its ``kanes_equations`` method\n        when constructing the equations of motion. This method acts as a\n        utility to produce the correctly-structred pairs of points and vectors\n        required so that these can be easily concatenated with other items in\n        the list of loads and passed to ``KanesMethod.kanes_equations``. These\n        loads are also in the correct form to also be passed to the other\n        equations of motion method classes, e.g. ``LagrangesMethod``.\n\n        Examples\n        ========\n\n        The below example shows how to generate the loads produced by a force\n        actuator that follows a linear pathway. In this example we'll assume\n        that the force actuator is being used to model a simple linear spring.\n        First, create a linear pathway between two points separated by the\n        coordinate ``q`` in the ``x`` direction of the global frame ``N``.\n\n        >>> from sympy.physics.mechanics import (LinearPathway, Point,\n        ...     ReferenceFrame)\n        >>> from sympy.physics.vector import dynamicsymbols\n        >>> q = dynamicsymbols('q')\n        >>> N = ReferenceFrame('N')\n        >>> pA, pB = Point('pA'), Point('pB')\n        >>> pB.set_pos(pA, q*N.x)\n        >>> pathway = LinearPathway(pA, pB)\n\n        Now create a symbol ``k`` to describe the spring's stiffness and\n        instantiate a force actuator that produces a (contractile) force\n        proportional to both the spring's stiffness and the pathway's length.\n        Note that actuator classes use the sign convention that expansile\n        forces are positive, so for a spring to produce a contractile force the\n        spring force needs to be calculated as the negative for the stiffness\n        multiplied by the length.\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.mechanics import ForceActuator\n        >>> stiffness = symbols('k')\n        >>> spring_force = -stiffness*pathway.length\n        >>> spring = ForceActuator(spring_force, pathway)\n\n        The forces produced by the spring can be generated in the list of loads\n        form that ``KanesMethod`` (and other equations of motion methods)\n        requires by calling the ``to_loads`` method.\n\n        >>> spring.to_loads()\n        [(pA, k*q(t)*N.x), (pB, - k*q(t)*N.x)]\n\n        A simple linear damper can be modeled in a similar way. Create another\n        symbol ``c`` to describe the dampers damping coefficient. This time\n        instantiate a force actuator that produces a force proportional to both\n        the damper's damping coefficient and the pathway's extension velocity.\n        Note that the damping force is negative as it acts in the opposite\n        direction to which the damper is changing in length.\n\n        >>> damping_coefficient = symbols('c')\n        >>> damping_force = -damping_coefficient*pathway.extension_velocity\n        >>> damper = ForceActuator(damping_force, pathway)\n\n        Again, the forces produces by the damper can be generated by calling\n        the ``to_loads`` method.\n\n        >>> damper.to_loads()\n        [(pA, c*Derivative(q(t), t)*N.x), (pB, - c*Derivative(q(t), t)*N.x)]\n\n        ",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "damping",
    "full_id": "sympy.physics.mechanics.actuator.LinearDamper.damping",
    "type": "property",
    "description": "The damping constant for the linear damper.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "force",
    "full_id": "sympy.physics.mechanics.actuator.LinearDamper.force",
    "type": "property",
    "description": "The damping force produced by the linear damper.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "equilibrium_length",
    "full_id": "sympy.physics.mechanics.actuator.LinearSpring.equilibrium_length",
    "type": "property",
    "description": "The length of the spring at which it produces no force.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "force",
    "full_id": "sympy.physics.mechanics.actuator.LinearSpring.force",
    "type": "property",
    "description": "The spring force produced by the linear spring.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "stiffness",
    "full_id": "sympy.physics.mechanics.actuator.LinearSpring.stiffness",
    "type": "property",
    "description": "The spring constant for the linear spring.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "at_pin_joint",
    "full_id": "sympy.physics.mechanics.actuator.TorqueActuator.at_pin_joint",
    "type": "method",
    "description": "Alternate construtor to instantiate from a ``PinJoint`` instance.\n\n        Examples\n        ========\n\n        To create a pin joint the ``PinJoint`` class requires a name, parent\n        body, and child body to be passed to its constructor. It is also\n        possible to control the joint axis using the ``joint_axis`` keyword\n        argument. In this example let's use the parent body's reference frame's\n        z-axis as the joint axis.\n\n        >>> from sympy.physics.mechanics import (PinJoint, ReferenceFrame,\n        ...     RigidBody, TorqueActuator)\n        >>> N = ReferenceFrame('N')\n        >>> A = ReferenceFrame('A')\n        >>> parent = RigidBody('parent', frame=N)\n        >>> child = RigidBody('child', frame=A)\n        >>> pin_joint = PinJoint(\n        ...     'pin',\n        ...     parent,\n        ...     child,\n        ...     joint_axis=N.z,\n        ... )\n\n        Let's also create a symbol ``T`` that will represent the torque applied\n        by the torque actuator.\n\n        >>> from sympy import symbols\n        >>> torque = symbols('T')\n\n        To create the torque actuator from the ``torque`` and ``pin_joint``\n        variables previously instantiated, these can be passed to the alternate\n        constructor class method ``at_pin_joint`` of the ``TorqueActuator``\n        class. It should be noted that a positive torque will cause a positive\n        displacement of the joint coordinate or that the torque is applied on\n        the child body with a reaction torque on the parent.\n\n        >>> actuator = TorqueActuator.at_pin_joint(torque, pin_joint)\n        >>> actuator\n        TorqueActuator(T, axis=N.z, target_frame=A, reaction_frame=N)\n\n        Parameters\n        ==========\n\n        torque : Expr\n            The scalar expression defining the torque that the actuator\n            produces.\n        pin_joint : PinJoint\n            The pin joint, and by association the parent and child bodies, on\n            which the torque actuator will act. The pair of bodies acted upon\n            by the torque actuator are the parent and child bodies of the pin\n            joint, with the child acting as the reaction body. The pin joint's\n            axis is used as the axis about which the torque actuator will apply\n            its torque.\n\n        ",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "axis",
    "full_id": "sympy.physics.mechanics.actuator.TorqueActuator.axis",
    "type": "property",
    "description": "The axis about which the torque acts.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "reaction_frame",
    "full_id": "sympy.physics.mechanics.actuator.TorqueActuator.reaction_frame",
    "type": "property",
    "description": "The primary reference frames on which the torque will act.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "to_loads",
    "full_id": "sympy.physics.mechanics.actuator.TorqueActuator.to_loads",
    "type": "method",
    "description": "Loads required by the equations of motion method classes.\n\n        Explanation\n        ===========\n\n        ``KanesMethod`` requires a list of ``Point``-``Vector`` tuples to be\n        passed to the ``loads`` parameters of its ``kanes_equations`` method\n        when constructing the equations of motion. This method acts as a\n        utility to produce the correctly-structred pairs of points and vectors\n        required so that these can be easily concatenated with other items in\n        the list of loads and passed to ``KanesMethod.kanes_equations``. These\n        loads are also in the correct form to also be passed to the other\n        equations of motion method classes, e.g. ``LagrangesMethod``.\n\n        Examples\n        ========\n\n        The below example shows how to generate the loads produced by a torque\n        actuator that acts on a pair of bodies attached by a pin joint.\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.mechanics import (PinJoint, ReferenceFrame,\n        ...     RigidBody, TorqueActuator)\n        >>> torque = symbols('T')\n        >>> N = ReferenceFrame('N')\n        >>> A = ReferenceFrame('A')\n        >>> parent = RigidBody('parent', frame=N)\n        >>> child = RigidBody('child', frame=A)\n        >>> pin_joint = PinJoint(\n        ...     'pin',\n        ...     parent,\n        ...     child,\n        ...     joint_axis=N.z,\n        ... )\n        >>> actuator = TorqueActuator.at_pin_joint(torque, pin_joint)\n\n        The forces produces by the damper can be generated by calling the\n        ``to_loads`` method.\n\n        >>> actuator.to_loads()\n        [(A, T*N.z), (N, - T*N.z)]\n\n        Alternatively, if a torque actuator is created without a reaction frame\n        then the loads returned by the ``to_loads`` method will contain just\n        the single load acting on the target frame.\n\n        >>> actuator = TorqueActuator(torque, N.z, N)\n        >>> actuator.to_loads()\n        [(N, T*N.z)]\n\n        ",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "torque",
    "full_id": "sympy.physics.mechanics.actuator.TorqueActuator.torque",
    "type": "property",
    "description": "The magnitude of the torque produced by the actuator.",
    "section": "Actuator (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"
  },
  {
    "name": "axis",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingCylinder.axis",
    "type": "property",
    "description": "Axis along which the cylinder is aligned.",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "geodesic_end_vectors",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingCylinder.geodesic_end_vectors",
    "type": "method",
    "description": "The vectors parallel to the geodesic at the two end points.\n\n        Parameters\n        ==========\n\n        point_1 : Point\n            The point from which the geodesic originates.\n        point_2 : Point\n            The point at which the geodesic terminates.\n\n        ",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "geodesic_length",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingCylinder.geodesic_length",
    "type": "method",
    "description": "The shortest distance between two points on a geometry's surface.\n\n        Explanation\n        ===========\n\n        The geodesic length, i.e. the shortest arc along the surface of a\n        cylinder, connecting two points. It can be calculated using Pythagoras'\n        theorem. The first short side is the distance between the two points on\n        the cylinder's surface parallel to the cylinder's axis. The second\n        short side is the arc of a circle between the two points of the\n        cylinder's surface perpendicular to the cylinder's axis. The resulting\n        hypotenuse is the geodesic length.\n\n        Examples\n        ========\n\n        A geodesic length can only be calculated between two points on the\n        cylinder's surface. Firstly, a ``WrappingCylinder`` instance must be\n        created along with two points that will lie on its surface:\n\n        >>> from sympy import symbols, cos, sin\n        >>> from sympy.physics.mechanics import (Point, ReferenceFrame,\n        ...     WrappingCylinder, dynamicsymbols)\n        >>> N = ReferenceFrame('N')\n        >>> r = symbols('r')\n        >>> pO = Point('pO')\n        >>> pO.set_vel(N, 0)\n        >>> cylinder = WrappingCylinder(r, pO, N.x)\n        >>> p1 = Point('p1')\n        >>> p2 = Point('p2')\n\n        Let's assume that ``p1`` is located at ``N.x + r*N.y`` relative to\n        ``pO`` and that ``p2`` is located at ``r*(cos(q)*N.y + sin(q)*N.z)``\n        relative to ``pO``, where ``q(t)`` is a generalized coordinate\n        specifying the angle rotated around the ``N.x`` axis according to the\n        right-hand rule where ``N.y`` is zero. These positions can be set with:\n\n        >>> q = dynamicsymbols('q')\n        >>> p1.set_pos(pO, N.x + r*N.y)\n        >>> p1.pos_from(pO)\n        N.x + r*N.y\n        >>> p2.set_pos(pO, r*(cos(q)*N.y + sin(q)*N.z).normalize())\n        >>> p2.pos_from(pO).simplify()\n        r*cos(q(t))*N.y + r*sin(q(t))*N.z\n\n        The geodesic length, which is in this case a is the hypotenuse of a\n        right triangle where the other two side lengths are ``1`` (parallel to\n        the cylinder's axis) and ``r*q(t)`` (parallel to the cylinder's cross\n        section), can be calculated using the ``geodesic_length`` method:\n\n        >>> cylinder.geodesic_length(p1, p2).simplify()\n        sqrt(r**2*q(t)**2 + 1)\n\n        If the ``geodesic_length`` method is passed an argument ``Point`` that\n        doesn't lie on the sphere's surface then a ``ValueError`` is raised\n        because it's not possible to calculate a value in this case.\n\n        Parameters\n        ==========\n\n        point_1 : Point\n            Point from which the geodesic length should be calculated.\n        point_2 : Point\n            Point to which the geodesic length should be calculated.\n\n        ",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "point",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingCylinder.point",
    "type": "property",
    "description": "A point through which the cylinder's axis passes.",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "point_on_surface",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingCylinder.point_on_surface",
    "type": "method",
    "description": "Returns ``True`` if a point is on the cylinder's surface.\n\n        Parameters\n        ==========\n\n        point : Point\n            The point for which it's to be ascertained if it's on the\n            cylinder's surface or not. This point's position relative to the\n            cylinder's axis must be a simple expression involving the radius of\n            the sphere, otherwise this check will likely not work.\n\n        ",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "radius",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingCylinder.radius",
    "type": "property",
    "description": "Radius of the cylinder.",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "geodesic_length",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingGeometryBase.geodesic_length",
    "type": "method",
    "description": "Returns the shortest distance between two points on a geometry's\n        surface.\n\n        Parameters\n        ==========\n\n        point_1 : Point\n            The point from which the geodesic length should be calculated.\n        point_2 : Point\n            The point to which the geodesic length should be calculated.\n\n        ",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "point",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingGeometryBase.point",
    "type": "property",
    "description": "The point with which the geometry is associated.",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "point_on_surface",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingGeometryBase.point_on_surface",
    "type": "method",
    "description": "Returns ``True`` if a point is on the geometry's surface.\n\n        Parameters\n        ==========\n        point : Point\n            The point for which it's to be ascertained if it's on the\n            geometry's surface or not.\n\n        ",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "geodesic_length",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingSphere.geodesic_length",
    "type": "method",
    "description": "Returns the shortest distance between two points on the sphere's\n        surface.\n\n        Explanation\n        ===========\n\n        The geodesic length, i.e. the shortest arc along the surface of a\n        sphere, connecting two points can be calculated using the formula:\n\n        .. math::\n\n           l = \\arccos\\left(\\mathbf{v}_1 \\cdot \\mathbf{v}_2\\right)\n\n        where $\\mathbf{v}_1$ and $\\mathbf{v}_2$ are the unit vectors from the\n        sphere's center to the first and second points on the sphere's surface\n        respectively. Note that the actual path that the geodesic will take is\n        undefined when the two points are directly opposite one another.\n\n        Examples\n        ========\n\n        A geodesic length can only be calculated between two points on the\n        sphere's surface. Firstly, a ``WrappingSphere`` instance must be\n        created along with two points that will lie on its surface:\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.mechanics import (Point, ReferenceFrame,\n        ...     WrappingSphere)\n        >>> N = ReferenceFrame('N')\n        >>> r = symbols('r')\n        >>> pO = Point('pO')\n        >>> pO.set_vel(N, 0)\n        >>> sphere = WrappingSphere(r, pO)\n        >>> p1 = Point('p1')\n        >>> p2 = Point('p2')\n\n        Let's assume that ``p1`` lies at a distance of ``r`` in the ``N.x``\n        direction from ``pO`` and that ``p2`` is located on the sphere's\n        surface in the ``N.y + N.z`` direction from ``pO``. These positions can\n        be set with:\n\n        >>> p1.set_pos(pO, r*N.x)\n        >>> p1.pos_from(pO)\n        r*N.x\n        >>> p2.set_pos(pO, r*(N.y + N.z).normalize())\n        >>> p2.pos_from(pO)\n        sqrt(2)*r/2*N.y + sqrt(2)*r/2*N.z\n\n        The geodesic length, which is in this case is a quarter of the sphere's\n        circumference, can be calculated using the ``geodesic_length`` method:\n\n        >>> sphere.geodesic_length(p1, p2)\n        pi*r/2\n\n        If the ``geodesic_length`` method is passed an argument, the ``Point``\n        that doesn't lie on the sphere's surface then a ``ValueError`` is\n        raised because it's not possible to calculate a value in this case.\n\n        Parameters\n        ==========\n\n        point_1 : Point\n            Point from which the geodesic length should be calculated.\n        point_2 : Point\n            Point to which the geodesic length should be calculated.\n\n        ",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "point",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingSphere.point",
    "type": "property",
    "description": "A point on which the sphere is centered.",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "point_on_surface",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingSphere.point_on_surface",
    "type": "method",
    "description": "Returns ``True`` if a point is on the sphere's surface.\n\n        Parameters\n        ==========\n\n        point : Point\n            The point for which it's to be ascertained if it's on the sphere's\n            surface or not. This point's position relative to the sphere's\n            center must be a simple expression involving the radius of the\n            sphere, otherwise this check will likely not work.\n\n        ",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "radius",
    "full_id": "sympy.physics.mechanics.wrapping_geometry.WrappingSphere.radius",
    "type": "property",
    "description": "Radius of the sphere.",
    "section": "Wrapping Geometry (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/wrapping_geometry.html"
  },
  {
    "name": "ang_vel_in",
    "full_id": "sympy.physics.mechanics.body.Body.ang_vel_in",
    "type": "method",
    "description": "\n        Returns this body's angular velocity with respect to the provided\n        rigid body or reference frame.\n\n        Parameters\n        ==========\n\n        body: Body or ReferenceFrame\n            The rigid body or reference frame to calculate the angular velocity in.\n\n        Example\n        =======\n\n        As Body has been deprecated, the following examples are for illustrative\n        purposes only. The functionality of Body is fully captured by\n        :class:`~.RigidBody` and :class:`~.Particle`. To ignore the deprecation\n        warning we can use the ignore_warnings context manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n        >>> from sympy.physics.mechanics import Body, ReferenceFrame\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     A = Body('A')\n        >>> N = ReferenceFrame('N')\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     B = Body('B', frame=N)\n        >>> A.frame.set_ang_vel(N, 5*N.x)\n        >>> A.ang_vel_in(B)\n        5*N.x\n        >>> A.ang_vel_in(N)\n        5*N.x\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "apply_force",
    "full_id": "sympy.physics.mechanics.body.Body.apply_force",
    "type": "method",
    "description": "Add force to the body(s).\n\n        Explanation\n        ===========\n\n        Applies the force on self or equal and opposite forces on\n        self and other body if both are given on the desired point on the bodies.\n        The force applied on other body is taken opposite of self, i.e, -force.\n\n        Parameters\n        ==========\n\n        force: Vector\n            The force to be applied.\n        point: Point, optional\n            The point on self on which force is applied.\n            By default self's masscenter.\n        reaction_body: Body, optional\n            Second body on which equal and opposite force\n            is to be applied.\n        reaction_point : Point, optional\n            The point on other body on which equal and opposite\n            force is applied. By default masscenter of other body.\n\n        Example\n        =======\n\n        As Body has been deprecated, the following examples are for illustrative\n        purposes only. The functionality of Body is fully captured by\n        :class:`~.RigidBody` and :class:`~.Particle`. To ignore the deprecation\n        warning we can use the ignore_warnings context manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n        >>> from sympy import symbols\n        >>> from sympy.physics.mechanics import Body, Point, dynamicsymbols\n        >>> m, g = symbols('m g')\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     B = Body('B')\n        >>> force1 = m*g*B.z\n        >>> B.apply_force(force1) #Applying force on B's masscenter\n        >>> B.loads\n        [(B_masscenter, g*m*B_frame.z)]\n\n        We can also remove some part of force from any point on the body by\n        adding the opposite force to the body on that point.\n\n        >>> f1, f2 = dynamicsymbols('f1 f2')\n        >>> P = Point('P') #Considering point P on body B\n        >>> B.apply_force(f1*B.x + f2*B.y, P)\n        >>> B.loads\n        [(B_masscenter, g*m*B_frame.z), (P, f1(t)*B_frame.x + f2(t)*B_frame.y)]\n\n        Let's remove f1 from point P on body B.\n\n        >>> B.apply_force(-f1*B.x, P)\n        >>> B.loads\n        [(B_masscenter, g*m*B_frame.z), (P, f2(t)*B_frame.y)]\n\n        To further demonstrate the use of ``apply_force`` attribute,\n        consider two bodies connected through a spring.\n\n        >>> from sympy.physics.mechanics import Body, dynamicsymbols\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     N = Body('N') #Newtonion Frame\n        >>> x = dynamicsymbols('x')\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     B1 = Body('B1')\n        ...     B2 = Body('B2')\n        >>> spring_force = x*N.x\n\n        Now let's apply equal and opposite spring force to the bodies.\n\n        >>> P1 = Point('P1')\n        >>> P2 = Point('P2')\n        >>> B1.apply_force(spring_force, point=P1, reaction_body=B2, reaction_point=P2)\n\n        We can check the loads(forces) applied to bodies now.\n\n        >>> B1.loads\n        [(P1, x(t)*N_frame.x)]\n        >>> B2.loads\n        [(P2, - x(t)*N_frame.x)]\n\n        Notes\n        =====\n\n        If a new force is applied to a body on a point which already has some\n        force applied on it, then the new force is added to the already applied\n        force on that point.\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "apply_torque",
    "full_id": "sympy.physics.mechanics.body.Body.apply_torque",
    "type": "method",
    "description": "Add torque to the body(s).\n\n        Explanation\n        ===========\n\n        Applies the torque on self or equal and opposite torques on\n        self and other body if both are given.\n        The torque applied on other body is taken opposite of self,\n        i.e, -torque.\n\n        Parameters\n        ==========\n\n        torque: Vector\n            The torque to be applied.\n        reaction_body: Body, optional\n            Second body on which equal and opposite torque\n            is to be applied.\n\n        Example\n        =======\n\n        As Body has been deprecated, the following examples are for illustrative\n        purposes only. The functionality of Body is fully captured by\n        :class:`~.RigidBody` and :class:`~.Particle`. To ignore the deprecation\n        warning we can use the ignore_warnings context manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n        >>> from sympy import symbols\n        >>> from sympy.physics.mechanics import Body, dynamicsymbols\n        >>> t = symbols('t')\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     B = Body('B')\n        >>> torque1 = t*B.z\n        >>> B.apply_torque(torque1)\n        >>> B.loads\n        [(B_frame, t*B_frame.z)]\n\n        We can also remove some part of torque from the body by\n        adding the opposite torque to the body.\n\n        >>> t1, t2 = dynamicsymbols('t1 t2')\n        >>> B.apply_torque(t1*B.x + t2*B.y)\n        >>> B.loads\n        [(B_frame, t1(t)*B_frame.x + t2(t)*B_frame.y + t*B_frame.z)]\n\n        Let's remove t1 from Body B.\n\n        >>> B.apply_torque(-t1*B.x)\n        >>> B.loads\n        [(B_frame, t2(t)*B_frame.y + t*B_frame.z)]\n\n        To further demonstrate the use, let us consider two bodies such that\n        a torque `T` is acting on one body, and `-T` on the other.\n\n        >>> from sympy.physics.mechanics import Body, dynamicsymbols\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     N = Body('N') #Newtonion frame\n        ...     B1 = Body('B1')\n        ...     B2 = Body('B2')\n        >>> v = dynamicsymbols('v')\n        >>> T = v*N.y #Torque\n\n        Now let's apply equal and opposite torque to the bodies.\n\n        >>> B1.apply_torque(T, B2)\n\n        We can check the loads (torques) applied to bodies now.\n\n        >>> B1.loads\n        [(B1_frame, v(t)*N_frame.y)]\n        >>> B2.loads\n        [(B2_frame, - v(t)*N_frame.y)]\n\n        Notes\n        =====\n\n        If a new torque is applied on body which already has some torque applied on it,\n        then the new torque is added to the previous torque about the body's frame.\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "clear_loads",
    "full_id": "sympy.physics.mechanics.body.Body.clear_loads",
    "type": "method",
    "description": "\n        Clears the Body's loads list.\n\n        Example\n        =======\n\n        As Body has been deprecated, the following examples are for illustrative\n        purposes only. The functionality of Body is fully captured by\n        :class:`~.RigidBody` and :class:`~.Particle`. To ignore the deprecation\n        warning we can use the ignore_warnings context manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n        >>> from sympy.physics.mechanics import Body\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     B = Body('B')\n        >>> force = B.x + B.y\n        >>> B.apply_force(force)\n        >>> B.loads\n        [(B_masscenter, B_frame.x + B_frame.y)]\n        >>> B.clear_loads()\n        >>> B.loads\n        []\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "dcm",
    "full_id": "sympy.physics.mechanics.body.Body.dcm",
    "type": "method",
    "description": "\n        Returns the direction cosine matrix of this body relative to the\n        provided rigid body or reference frame.\n\n        Parameters\n        ==========\n\n        body: Body or ReferenceFrame\n            The rigid body or reference frame to calculate the dcm.\n\n        Example\n        =======\n\n        As Body has been deprecated, the following examples are for illustrative\n        purposes only. The functionality of Body is fully captured by\n        :class:`~.RigidBody` and :class:`~.Particle`. To ignore the deprecation\n        warning we can use the ignore_warnings context manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n        >>> from sympy.physics.mechanics import Body\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     A = Body('A')\n        ...     B = Body('B')\n        >>> A.frame.orient_axis(B.frame, B.frame.x, 5)\n        >>> A.dcm(B)\n        Matrix([\n        [1,       0,      0],\n        [0,  cos(5), sin(5)],\n        [0, -sin(5), cos(5)]])\n        >>> A.dcm(B.frame)\n        Matrix([\n        [1,       0,      0],\n        [0,  cos(5), sin(5)],\n        [0, -sin(5), cos(5)]])\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "kinetic_energy",
    "full_id": "sympy.physics.mechanics.body.Body.kinetic_energy",
    "type": "method",
    "description": "Kinetic energy of the body.\n\n        Parameters\n        ==========\n\n        frame : ReferenceFrame or Body\n            The Body's angular velocity and the velocity of it's mass\n            center are typically defined with respect to an inertial frame but\n            any relevant frame in which the velocities are known can be supplied.\n\n        Examples\n        ========\n\n        As Body has been deprecated, the following examples are for illustrative\n        purposes only. The functionality of Body is fully captured by\n        :class:`~.RigidBody` and :class:`~.Particle`. To ignore the deprecation\n        warning we can use the ignore_warnings context manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n        >>> from sympy.physics.mechanics import Body, ReferenceFrame, Point\n        >>> from sympy import symbols\n        >>> m, v, r, omega = symbols('m v r omega')\n        >>> N = ReferenceFrame('N')\n        >>> O = Point('O')\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     P = Body('P', masscenter=O, mass=m)\n        >>> P.masscenter.set_vel(N, v * N.y)\n        >>> P.kinetic_energy(N)\n        m*v**2/2\n\n        >>> N = ReferenceFrame('N')\n        >>> b = ReferenceFrame('b')\n        >>> b.set_ang_vel(N, omega * b.x)\n        >>> P = Point('P')\n        >>> P.set_vel(N, v * N.x)\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     B = Body('B', masscenter=P, frame=b)\n        >>> B.kinetic_energy(N)\n        B_ixx*omega**2/2 + B_mass*v**2/2\n\n        See Also\n        ========\n\n        sympy.physics.mechanics : Particle, RigidBody\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "masscenter_vel",
    "full_id": "sympy.physics.mechanics.body.Body.masscenter_vel",
    "type": "method",
    "description": "\n        Returns the velocity of the mass center with respect to the provided\n        rigid body or reference frame.\n\n        Parameters\n        ==========\n\n        body: Body or ReferenceFrame\n            The rigid body or reference frame to calculate the velocity in.\n\n        Example\n        =======\n\n        As Body has been deprecated, the following examples are for illustrative\n        purposes only. The functionality of Body is fully captured by\n        :class:`~.RigidBody` and :class:`~.Particle`. To ignore the deprecation\n        warning we can use the ignore_warnings context manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n        >>> from sympy.physics.mechanics import Body\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     A = Body('A')\n        ...     B = Body('B')\n        >>> A.masscenter.set_vel(B.frame, 5*B.frame.x)\n        >>> A.masscenter_vel(B)\n        5*B_frame.x\n        >>> A.masscenter_vel(B.frame)\n        5*B_frame.x\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "parallel_axis",
    "full_id": "sympy.physics.mechanics.body.Body.parallel_axis",
    "type": "method",
    "description": "Returns the inertia dyadic of the body with respect to another\n        point.\n\n        Parameters\n        ==========\n\n        point : sympy.physics.vector.Point\n            The point to express the inertia dyadic about.\n        frame : sympy.physics.vector.ReferenceFrame\n            The reference frame used to construct the dyadic.\n\n        Returns\n        =======\n\n        inertia : sympy.physics.vector.Dyadic\n            The inertia dyadic of the rigid body expressed about the provided\n            point.\n\n        Example\n        =======\n\n        As Body has been deprecated, the following examples are for illustrative\n        purposes only. The functionality of Body is fully captured by\n        :class:`~.RigidBody` and :class:`~.Particle`. To ignore the deprecation\n        warning we can use the ignore_warnings context manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n        >>> from sympy.physics.mechanics import Body\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     A = Body('A')\n        >>> P = A.masscenter.locatenew('point', 3 * A.x + 5 * A.y)\n        >>> A.parallel_axis(P).to_matrix(A.frame)\n        Matrix([\n        [A_ixx + 25*A_mass, A_ixy - 15*A_mass,             A_izx],\n        [A_ixy - 15*A_mass,  A_iyy + 9*A_mass,             A_iyz],\n        [            A_izx,             A_iyz, A_izz + 34*A_mass]])\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "remove_load",
    "full_id": "sympy.physics.mechanics.body.Body.remove_load",
    "type": "method",
    "description": "\n        Remove load about a point or frame.\n\n        Parameters\n        ==========\n\n        about : Point or ReferenceFrame, optional\n            The point about which force is applied,\n            and is to be removed.\n            If about is None, then the torque about\n            self's frame is removed.\n\n        Example\n        =======\n\n        As Body has been deprecated, the following examples are for illustrative\n        purposes only. The functionality of Body is fully captured by\n        :class:`~.RigidBody` and :class:`~.Particle`. To ignore the deprecation\n        warning we can use the ignore_warnings context manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n        >>> from sympy.physics.mechanics import Body, Point\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     B = Body('B')\n        >>> P = Point('P')\n        >>> f1 = B.x\n        >>> f2 = B.y\n        >>> B.apply_force(f1)\n        >>> B.apply_force(f2, P)\n        >>> B.loads\n        [(B_masscenter, B_frame.x), (P, B_frame.y)]\n\n        >>> B.remove_load(P)\n        >>> B.loads\n        [(B_masscenter, B_frame.x)]\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "x",
    "full_id": "sympy.physics.mechanics.body.Body.x",
    "type": "property",
    "description": "The basis Vector for the Body, in the x direction.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "y",
    "full_id": "sympy.physics.mechanics.body.Body.y",
    "type": "property",
    "description": "The basis Vector for the Body, in the y direction.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "z",
    "full_id": "sympy.physics.mechanics.body.Body.z",
    "type": "property",
    "description": "The basis Vector for the Body, in the z direction.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "bodies",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.bodies",
    "type": "property",
    "description": "List of bodies in they system.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "forcing",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.forcing",
    "type": "property",
    "description": "The system's forcing vector.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "forcing_full",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.forcing_full",
    "type": "property",
    "description": "The \"forcing vector\" for the u's and q's.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "form_eoms",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.form_eoms",
    "type": "method",
    "description": "Method to form system's equation of motions.\n\n        Parameters\n        ==========\n\n        method : Class\n            Class name of method.\n\n        Returns\n        ========\n\n        Matrix\n            Vector of equations of motions.\n\n        Examples\n        ========\n\n        As Body and JointsMethod have been deprecated, the following examples\n        are for illustrative purposes only. The functionality of Body is fully\n        captured by :class:`~.RigidBody` and :class:`~.Particle` and the\n        functionality of JointsMethod is fully captured by :class:`~.System`. To\n        ignore the deprecation warning we can use the ignore_warnings context\n        manager.\n\n        >>> from sympy.utilities.exceptions import ignore_warnings\n\n        This is a simple example for a one degree of freedom translational\n        spring-mass-damper.\n\n        >>> from sympy import S, symbols\n        >>> from sympy.physics.mechanics import LagrangesMethod, dynamicsymbols, Body\n        >>> from sympy.physics.mechanics import PrismaticJoint, JointsMethod\n        >>> q = dynamicsymbols('q')\n        >>> qd = dynamicsymbols('q', 1)\n        >>> m, k, b = symbols('m k b')\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     wall = Body('W')\n        ...     part = Body('P', mass=m)\n        >>> part.potential_energy = k * q**2 / S(2)\n        >>> J = PrismaticJoint('J', wall, part, coordinates=q, speeds=qd)\n        >>> wall.apply_force(b * qd * wall.x, reaction_body=part)\n        >>> with ignore_warnings(DeprecationWarning):\n        ...     method = JointsMethod(wall, J)\n        >>> method.form_eoms(LagrangesMethod)\n        Matrix([[b*Derivative(q(t), t) + k*q(t) + m*Derivative(q(t), (t, 2))]])\n\n        We can also solve for the states using the 'rhs' method.\n\n        >>> method.rhs()\n        Matrix([\n        [                Derivative(q(t), t)],\n        [(-b*Derivative(q(t), t) - k*q(t))/m]])\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "kdes",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.kdes",
    "type": "property",
    "description": "List of the generalized coordinates.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "loads",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.loads",
    "type": "property",
    "description": "List of loads on the system.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "mass_matrix",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.mass_matrix",
    "type": "property",
    "description": "The system's mass matrix.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "mass_matrix_full",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.mass_matrix_full",
    "type": "property",
    "description": "The \"mass matrix\" for the u's and q's.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "method",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.method",
    "type": "property",
    "description": "Object of method used to form equations of systems.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "rhs",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.rhs",
    "type": "method",
    "description": "Returns equations that can be solved numerically.\n\n        Parameters\n        ==========\n\n        inv_method : str\n            The specific sympy inverse matrix calculation method to use. For a\n            list of valid methods, see\n            :meth:`~sympy.matrices.matrixbase.MatrixBase.inv`\n\n        Returns\n        ========\n\n        Matrix\n            Numerically solvable equations.\n\n        See Also\n        ========\n\n        sympy.physics.mechanics.kane.KanesMethod.rhs:\n            KanesMethod's rhs function.\n        sympy.physics.mechanics.lagrange.LagrangesMethod.rhs:\n            LagrangesMethod's rhs function.\n\n        ",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "u",
    "full_id": "sympy.physics.mechanics.jointsmethod.JointsMethod.u",
    "type": "property",
    "description": "List of the generalized speeds.",
    "section": "Deprecated Classes (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/mechanics/api/deprecated_classes.html"
  },
  {
    "name": "F",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.F",
    "type": "property",
    "description": "Ordered column matrix of equations on the RHS of ``M x' = F``.\n\n        Explanation\n        ===========\n\n        The column matrix that forms the RHS of the linear system of ordinary\n        differential equations governing the activation dynamics:\n\n        ``M(x, r, t, p) x' = F(x, r, t, p)``.\n\n        As zeroth-order activation dynamics have no state variables, this\n        linear system has dimension 0 and therefore ``F`` is an empty column\n        ``Matrix`` with shape (0, 1).\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "F_M_max",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.F_M_max",
    "type": "property",
    "description": "Symbol or value corresponding to the peak isometric force constant.\n\n        Explanation\n        ===========\n\n        The maximum force that the muscle fiber can produce when it is\n        undergoing an isometric contraction (no lengthening velocity). In all\n        musculotendon models, peak isometric force is used to normalized tendon\n        and muscle fiber force to give\n        :math:`\\tilde{F}^T = \\frac{F^T}{F^M_{max}}`.\n\n        The alias ``peak_isometric_force`` can also be used to access the same\n        attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "M",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.M",
    "type": "property",
    "description": "Ordered square matrix of coefficients on the LHS of ``M x' = F``.\n\n        Explanation\n        ===========\n\n        The square matrix that forms part of the LHS of the linear system of\n        ordinary differential equations governing the activation dynamics:\n\n        ``M(x, r, t, p) x' = F(x, r, t, p)``.\n\n        As zeroth-order activation dynamics have no state variables, this\n        linear system has dimension 0 and therefore ``M`` is an empty square\n        ``Matrix`` with shape (0, 0).\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "a",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.a",
    "type": "property",
    "description": "Dynamic symbol representing activation.\n\n        Explanation\n        ===========\n\n        The alias ``activation`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "activation",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.activation",
    "type": "property",
    "description": "Dynamic symbol representing activation.\n\n        Explanation\n        ===========\n\n        The alias ``a`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "activation_dynamics",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.activation_dynamics",
    "type": "property",
    "description": "Activation dynamics model governing this musculotendon's activation.\n\n        Explanation\n        ===========\n\n        Returns the instance of a subclass of ``ActivationBase`` that governs\n        the relationship between excitation and activation that is used to\n        represent the activation dynamics of this musculotendon.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "alpha_opt",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.alpha_opt",
    "type": "property",
    "description": "Symbol or value corresponding to the optimal pennation angle\n        constant.\n\n        Explanation\n        ===========\n\n        The pennation angle when muscle fiber length equals the optimal fiber\n        length.\n\n        The alias ``optimal_pennation_angle`` can also be used to access the\n        same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "beta",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.beta",
    "type": "property",
    "description": "Symbol or value corresponding to the fiber damping coefficient\n        constant.\n\n        Explanation\n        ===========\n\n        The coefficient of damping to be used in the damping element in the\n        muscle fiber model.\n\n        The alias ``fiber_damping_coefficient`` can also be used to access the\n        same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "constants",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.constants",
    "type": "property",
    "description": "Ordered column matrix of non-time varying symbols present in ``M``\n        and ``F``.\n\n        Explanation\n        ===========\n\n        Only symbolic constants are returned. If a numeric type (e.g. ``Float``)\n        has been used instead of ``Symbol`` for a constant then that attribute\n        will not be included in the matrix returned by this property. This is\n        because the primary use of this property attribute is to provide an\n        ordered sequence of the still-free symbols that require numeric values\n        during code generation.\n\n        The alias ``p`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "curves",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.curves",
    "type": "method",
    "description": "Return a ``CharacteristicCurveCollection`` of the curves related to\n        the specific model.",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "e",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.e",
    "type": "property",
    "description": "Dynamic symbol representing excitation.\n\n        Explanation\n        ===========\n\n        The alias ``excitation`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "excitation",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.excitation",
    "type": "property",
    "description": "Dynamic symbol representing excitation.\n\n        Explanation\n        ===========\n\n        The alias ``e`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "fiber_damping_coefficient",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.fiber_damping_coefficient",
    "type": "property",
    "description": "Symbol or value corresponding to the fiber damping coefficient\n        constant.\n\n        Explanation\n        ===========\n\n        The coefficient of damping to be used in the damping element in the\n        muscle fiber model.\n\n        The alias ``beta`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "input_vars",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.input_vars",
    "type": "property",
    "description": "Ordered column matrix of functions of time that represent the input\n        variables.\n\n        Explanation\n        ===========\n\n        The alias ``r`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "l_M_opt",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.l_M_opt",
    "type": "property",
    "description": "Symbol or value corresponding to the optimal fiber length constant.\n\n        Explanation\n        ===========\n\n        The muscle fiber length at which the muscle fibers produce no passive\n        force and their maximum active force. In all musculotendon models,\n        optimal fiber length is used to normalize muscle fiber length to give\n        :math:`\\tilde{l}^M = \\frac{l^M}{l^M_{opt}}`.\n\n        The alias ``optimal_fiber_length`` can also be used to access the same\n        attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "l_T_slack",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.l_T_slack",
    "type": "property",
    "description": "Symbol or value corresponding to the tendon slack length constant.\n\n        Explanation\n        ===========\n\n        The length of the tendon when the musculotendon is in its unloaded\n        state. In a rigid tendon model the tendon length is the tendon slack\n        length. In all musculotendon models, tendon slack length is used to\n        normalize tendon length to give\n        :math:`\\tilde{l}^T = \\frac{l^T}{l^T_{slack}}`.\n\n        The alias ``tendon_slack_length`` can also be used to access the same\n        attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "maximal_fiber_velocity",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.maximal_fiber_velocity",
    "type": "property",
    "description": "Symbol or value corresponding to the maximal fiber velocity constant.\n\n        Explanation\n        ===========\n\n        The fiber velocity at which, during muscle fiber shortening, the muscle\n        fibers are unable to produce any active force. In all musculotendon\n        models, maximal fiber velocity is used to normalize muscle fiber\n        extension velocity to give :math:`\\tilde{v}^M = \\frac{v^M}{v^M_{max}}`.\n\n        The alias ``v_M_max`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "musculotendon_dynamics",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.musculotendon_dynamics",
    "type": "property",
    "description": "The choice of rigid or type of elastic tendon musculotendon dynamics.\n\n        Explanation\n        ===========\n\n        The formulation of musculotendon dynamics that should be used\n        internally, i.e. rigid or elastic tendon model, the choice of\n        musculotendon state etc. This must be a member of the integer\n        enumeration ``MusculotendonFormulation`` or an integer that can be cast\n        to a member. To use a rigid tendon formulation, set this to\n        ``MusculotendonFormulation.RIGID_TENDON`` (or the integer value ``0``,\n        which will be cast to the enumeration member). There are four possible\n        formulations for an elastic tendon model. To use an explicit formulation\n        with the fiber length as the state, set this to\n        ``MusculotendonFormulation.FIBER_LENGTH_EXPLICIT`` (or the integer value\n        ``1``). To use an explicit formulation with the tendon force as the\n        state, set this to ``MusculotendonFormulation.TENDON_FORCE_EXPLICIT``\n        (or the integer value ``2``). To use an implicit formulation with the\n        fiber length as the state, set this to\n        ``MusculotendonFormulation.FIBER_LENGTH_IMPLICIT`` (or the integer value\n        ``3``). To use an implicit formulation with the tendon force as the\n        state, set this to ``MusculotendonFormulation.TENDON_FORCE_IMPLICIT``\n        (or the integer value ``4``). The default is\n        ``MusculotendonFormulation.RIGID_TENDON``, which corresponds to a rigid\n        tendon formulation.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "optimal_fiber_length",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.optimal_fiber_length",
    "type": "property",
    "description": "Symbol or value corresponding to the optimal fiber length constant.\n\n        Explanation\n        ===========\n\n        The muscle fiber length at which the muscle fibers produce no passive\n        force and their maximum active force. In all musculotendon models,\n        optimal fiber length is used to normalize muscle fiber length to give\n        :math:`\\tilde{l}^M = \\frac{l^M}{l^M_{opt}}`.\n\n        The alias ``l_M_opt`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "optimal_pennation_angle",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.optimal_pennation_angle",
    "type": "property",
    "description": "Symbol or value corresponding to the optimal pennation angle\n        constant.\n\n        Explanation\n        ===========\n\n        The pennation angle when muscle fiber length equals the optimal fiber\n        length.\n\n        The alias ``alpha_opt`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "p",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.p",
    "type": "property",
    "description": "Ordered column matrix of non-time varying symbols present in ``M``\n        and ``F``.\n\n        Explanation\n        ===========\n\n        Only symbolic constants are returned. If a numeric type (e.g. ``Float``)\n        has been used instead of ``Symbol`` for a constant then that attribute\n        will not be included in the matrix returned by this property. This is\n        because the primary use of this property attribute is to provide an\n        ordered sequence of the still-free symbols that require numeric values\n        during code generation.\n\n        The alias ``constants`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "peak_isometric_force",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.peak_isometric_force",
    "type": "property",
    "description": "Symbol or value corresponding to the peak isometric force constant.\n\n        Explanation\n        ===========\n\n        The maximum force that the muscle fiber can produce when it is\n        undergoing an isometric contraction (no lengthening velocity). In all\n        musculotendon models, peak isometric force is used to normalized tendon\n        and muscle fiber force to give\n        :math:`\\tilde{F}^T = \\frac{F^T}{F^M_{max}}`.\n\n        The alias ``F_M_max`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "r",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.r",
    "type": "property",
    "description": "Ordered column matrix of functions of time that represent the input\n        variables.\n\n        Explanation\n        ===========\n\n        The alias ``input_vars`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "rhs",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.rhs",
    "type": "method",
    "description": "Ordered column matrix of equations for the solution of ``M x' = F``.\n\n        Explanation\n        ===========\n\n        The solution to the linear system of ordinary differential equations\n        governing the activation dynamics:\n\n        ``M(x, r, t, p) x' = F(x, r, t, p)``.\n\n        As zeroth-order activation dynamics have no state variables, this\n        linear has dimension 0 and therefore this method returns an empty\n        column ``Matrix`` with shape (0, 1).\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "state_vars",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.state_vars",
    "type": "property",
    "description": "Ordered column matrix of functions of time that represent the state\n        variables.\n\n        Explanation\n        ===========\n\n        The alias ``x`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "tendon_slack_length",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.tendon_slack_length",
    "type": "property",
    "description": "Symbol or value corresponding to the tendon slack length constant.\n\n        Explanation\n        ===========\n\n        The length of the tendon when the musculotendon is in its unloaded\n        state. In a rigid tendon model the tendon length is the tendon slack\n        length. In all musculotendon models, tendon slack length is used to\n        normalize tendon length to give\n        :math:`\\tilde{l}^T = \\frac{l^T}{l^T_{slack}}`.\n\n        The alias ``l_T_slack`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "v_M_max",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.v_M_max",
    "type": "property",
    "description": "Symbol or value corresponding to the maximal fiber velocity constant.\n\n        Explanation\n        ===========\n\n        The fiber velocity at which, during muscle fiber shortening, the muscle\n        fibers are unable to produce any active force. In all musculotendon\n        models, maximal fiber velocity is used to normalize muscle fiber\n        extension velocity to give :math:`\\tilde{v}^M = \\frac{v^M}{v^M_{max}}`.\n\n        The alias ``maximal_fiber_velocity`` can also be used to access the same\n        attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.with_defaults",
    "type": "method",
    "description": "Recommended constructor that will use the published constants.\n\n        Explanation\n        ===========\n\n        Returns a new instance of the musculotendon class using recommended\n        values for ``v_M_max``, ``alpha_opt``, and ``beta``. The values are:\n\n            :math:`v^M_{max} = 10`\n            :math:`\\alpha_{opt} = 0`\n            :math:`\\beta = \\frac{1}{10}`\n\n        The musculotendon curves are also instantiated using the constants from\n        the original publication.\n\n        Parameters\n        ==========\n\n        name : str\n            The name identifier associated with the musculotendon. This name is\n            used as a suffix when automatically generated symbols are\n            instantiated. It must be a string of nonzero length.\n        pathway : PathwayBase\n            The pathway that the actuator follows. This must be an instance of a\n            concrete subclass of ``PathwayBase``, e.g. ``LinearPathway``.\n        activation_dynamics : ActivationBase\n            The activation dynamics that will be modeled within the\n            musculotendon. This must be an instance of a concrete subclass of\n            ``ActivationBase``, e.g. ``FirstOrderActivationDeGroote2016``.\n        musculotendon_dynamics : MusculotendonFormulation | int\n            The formulation of musculotendon dynamics that should be used\n            internally, i.e. rigid or elastic tendon model, the choice of\n            musculotendon state etc. This must be a member of the integer\n            enumeration ``MusculotendonFormulation`` or an integer that can be\n            cast to a member. To use a rigid tendon formulation, set this to\n            ``MusculotendonFormulation.RIGID_TENDON`` (or the integer value\n            ``0``, which will be cast to the enumeration member). There are four\n            possible formulations for an elastic tendon model. To use an\n            explicit formulation with the fiber length as the state, set this to\n            ``MusculotendonFormulation.FIBER_LENGTH_EXPLICIT`` (or the integer\n            value ``1``). To use an explicit formulation with the tendon force\n            as the state, set this to\n            ``MusculotendonFormulation.TENDON_FORCE_EXPLICIT`` (or the integer\n            value ``2``). To use an implicit formulation with the fiber length\n            as the state, set this to\n            ``MusculotendonFormulation.FIBER_LENGTH_IMPLICIT`` (or the integer\n            value ``3``). To use an implicit formulation with the tendon force\n            as the state, set this to\n            ``MusculotendonFormulation.TENDON_FORCE_IMPLICIT`` (or the integer\n            value ``4``). The default is\n            ``MusculotendonFormulation.RIGID_TENDON``, which corresponds to a\n            rigid tendon formulation.\n        tendon_slack_length : Expr | None\n            The length of the tendon when the musculotendon is in its unloaded\n            state. In a rigid tendon model the tendon length is the tendon slack\n            length. In all musculotendon models, tendon slack length is used to\n            normalize tendon length to give\n            :math:`\\tilde{l}^T = \\frac{l^T}{l^T_{slack}}`.\n        peak_isometric_force : Expr | None\n            The maximum force that the muscle fiber can produce when it is\n            undergoing an isometric contraction (no lengthening velocity). In\n            all musculotendon models, peak isometric force is used to normalized\n            tendon and muscle fiber force to give\n            :math:`\\tilde{F}^T = \\frac{F^T}{F^M_{max}}`.\n        optimal_fiber_length : Expr | None\n            The muscle fiber length at which the muscle fibers produce no\n            passive force and their maximum active force. In all musculotendon\n            models, optimal fiber length is used to normalize muscle fiber\n            length to give :math:`\\tilde{l}^M = \\frac{l^M}{l^M_{opt}}`.\n        maximal_fiber_velocity : Expr | None\n            The fiber velocity at which, during muscle fiber shortening, the\n            muscle fibers are unable to produce any active force. In all\n            musculotendon models, maximal fiber velocity is used to normalize\n            muscle fiber extension velocity to give\n            :math:`\\tilde{v}^M = \\frac{v^M}{v^M_{max}}`.\n        optimal_pennation_angle : Expr | None\n            The pennation angle when muscle fiber length equals the optimal\n            fiber length.\n        fiber_damping_coefficient : Expr | None\n            The coefficient of damping to be used in the damping element in the\n            muscle fiber model.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "x",
    "full_id": "sympy.physics.biomechanics.musculotendon.MusculotendonBase.x",
    "type": "property",
    "description": "Ordered column matrix of functions of time that represent the state\n        variables.\n\n        Explanation\n        ===========\n\n        The alias ``state_vars`` can also be used to access the same attribute.\n\n        ",
    "section": "Musculotendon (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/musculotendon.html"
  },
  {
    "name": "F",
    "full_id": "sympy.physics.biomechanics.activation.ActivationBase.F",
    "type": "property",
    "description": "Ordered column matrix of equations on the RHS of ``M x' = F``.\n\n        Explanation\n        ===========\n\n        The column matrix that forms the RHS of the linear system of ordinary\n        differential equations governing the activation dynamics:\n\n        ``M(x, r, t, p) x' = F(x, r, t, p)``.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "M",
    "full_id": "sympy.physics.biomechanics.activation.ActivationBase.M",
    "type": "property",
    "description": "Ordered square matrix of coefficients on the LHS of ``M x' = F``.\n\n        Explanation\n        ===========\n\n        The square matrix that forms part of the LHS of the linear system of\n        ordinary differential equations governing the activation dynamics:\n\n        ``M(x, r, t, p) x' = F(x, r, t, p)``.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "constants",
    "full_id": "sympy.physics.biomechanics.activation.ActivationBase.constants",
    "type": "property",
    "description": "Ordered column matrix of non-time varying symbols present in ``M``\n        and ``F``.\n\n        Only symbolic constants are returned. If a numeric type (e.g. ``Float``)\n        has been used instead of ``Symbol`` for a constant then that attribute\n        will not be included in the matrix returned by this property. This is\n        because the primary use of this property attribute is to provide an\n        ordered sequence of the still-free symbols that require numeric values\n        during code generation.\n\n        Explanation\n        ===========\n\n        The alias ``p`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "order",
    "full_id": "sympy.physics.biomechanics.activation.ActivationBase.order",
    "type": "property",
    "description": "Order of the (differential) equation governing activation.",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "p",
    "full_id": "sympy.physics.biomechanics.activation.ActivationBase.p",
    "type": "property",
    "description": "Ordered column matrix of non-time varying symbols present in ``M``\n        and ``F``.\n\n        Only symbolic constants are returned. If a numeric type (e.g. ``Float``)\n        has been used instead of ``Symbol`` for a constant then that attribute\n        will not be included in the matrix returned by this property. This is\n        because the primary use of this property attribute is to provide an\n        ordered sequence of the still-free symbols that require numeric values\n        during code generation.\n\n        Explanation\n        ===========\n\n        The alias ``constants`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "rhs",
    "full_id": "sympy.physics.biomechanics.activation.ActivationBase.rhs",
    "type": "method",
    "description": "\n\n        Explanation\n        ===========\n\n        The solution to the linear system of ordinary differential equations\n        governing the activation dynamics:\n\n        ``M(x, r, t, p) x' = F(x, r, t, p)``.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.activation.ActivationBase.with_defaults",
    "type": "method",
    "description": "Alternate constructor that provides recommended defaults for\n        constants.",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "activation_time_constant",
    "full_id": "sympy.physics.biomechanics.activation.FirstOrderActivationDeGroote2016.activation_time_constant",
    "type": "property",
    "description": "Delay constant for activation.\n\n        Explanation\n        ===========\n\n        The alias ```tau_a`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "b",
    "full_id": "sympy.physics.biomechanics.activation.FirstOrderActivationDeGroote2016.b",
    "type": "property",
    "description": "Smoothing constant for the hyperbolic tangent term.\n\n        Explanation\n        ===========\n\n        The alias ``smoothing_rate`` can also be used to access the same\n        attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "deactivation_time_constant",
    "full_id": "sympy.physics.biomechanics.activation.FirstOrderActivationDeGroote2016.deactivation_time_constant",
    "type": "property",
    "description": "Delay constant for deactivation.\n\n        Explanation\n        ===========\n\n        The alias ``tau_d`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "rhs",
    "full_id": "sympy.physics.biomechanics.activation.FirstOrderActivationDeGroote2016.rhs",
    "type": "method",
    "description": "Ordered column matrix of equations for the solution of ``M x' = F``.\n\n        Explanation\n        ===========\n\n        The solution to the linear system of ordinary differential equations\n        governing the activation dynamics:\n\n        ``M(x, r, t, p) x' = F(x, r, t, p)``.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "smoothing_rate",
    "full_id": "sympy.physics.biomechanics.activation.FirstOrderActivationDeGroote2016.smoothing_rate",
    "type": "property",
    "description": "Smoothing constant for the hyperbolic tangent term.\n\n        Explanation\n        ===========\n\n        The alias ``b`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "tau_a",
    "full_id": "sympy.physics.biomechanics.activation.FirstOrderActivationDeGroote2016.tau_a",
    "type": "property",
    "description": "Delay constant for activation.\n\n        Explanation\n        ===========\n\n        The alias ``activation_time_constant`` can also be used to access the\n        same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "tau_d",
    "full_id": "sympy.physics.biomechanics.activation.FirstOrderActivationDeGroote2016.tau_d",
    "type": "property",
    "description": "Delay constant for deactivation.\n\n        Explanation\n        ===========\n\n        The alias ``deactivation_time_constant`` can also be used to access the\n        same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.activation.FirstOrderActivationDeGroote2016.with_defaults",
    "type": "method",
    "description": "Alternate constructor that will use the published constants.\n\n        Explanation\n        ===========\n\n        Returns an instance of ``FirstOrderActivationDeGroote2016`` using the\n        three constant values specified in the original publication.\n\n        These have the values:\n\n        :math:`tau_a = 0.015`\n        :math:`tau_d = 0.060`\n        :math:`b = 10`\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "constants",
    "full_id": "sympy.physics.biomechanics.activation.ZerothOrderActivation.constants",
    "type": "property",
    "description": "Ordered column matrix of non-time varying symbols present in ``M``\n        and ``F``.\n\n        Only symbolic constants are returned. If a numeric type (e.g. ``Float``)\n        has been used instead of ``Symbol`` for a constant then that attribute\n        will not be included in the matrix returned by this property. This is\n        because the primary use of this property attribute is to provide an\n        ordered sequence of the still-free symbols that require numeric values\n        during code generation.\n\n        Explanation\n        ===========\n\n        As zeroth-order activation dynamics simply maps excitation to\n        activation, this class has no associated constants and so this property\n        return an empty column ``Matrix`` with shape (0, 1).\n\n        The alias ``p`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "input_vars",
    "full_id": "sympy.physics.biomechanics.activation.ZerothOrderActivation.input_vars",
    "type": "property",
    "description": "Ordered column matrix of functions of time that represent the input\n        variables.\n\n        Explanation\n        ===========\n\n        Excitation is the only input in zeroth-order activation dynamics and so\n        this property returns a column ``Matrix`` with one entry, ``e``, and\n        shape (1, 1).\n\n        The alias ``r`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "p",
    "full_id": "sympy.physics.biomechanics.activation.ZerothOrderActivation.p",
    "type": "property",
    "description": "Ordered column matrix of non-time varying symbols present in ``M``\n        and ``F``.\n\n        Only symbolic constants are returned. If a numeric type (e.g. ``Float``)\n        has been used instead of ``Symbol`` for a constant then that attribute\n        will not be included in the matrix returned by this property. This is\n        because the primary use of this property attribute is to provide an\n        ordered sequence of the still-free symbols that require numeric values\n        during code generation.\n\n        Explanation\n        ===========\n\n        As zeroth-order activation dynamics simply maps excitation to\n        activation, this class has no associated constants and so this property\n        return an empty column ``Matrix`` with shape (0, 1).\n\n        The alias ``constants`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "r",
    "full_id": "sympy.physics.biomechanics.activation.ZerothOrderActivation.r",
    "type": "property",
    "description": "Ordered column matrix of functions of time that represent the input\n        variables.\n\n        Explanation\n        ===========\n\n        Excitation is the only input in zeroth-order activation dynamics and so\n        this property returns a column ``Matrix`` with one entry, ``e``, and\n        shape (1, 1).\n\n        The alias ``input_vars`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "state_vars",
    "full_id": "sympy.physics.biomechanics.activation.ZerothOrderActivation.state_vars",
    "type": "property",
    "description": "Ordered column matrix of functions of time that represent the state\n        variables.\n\n        Explanation\n        ===========\n\n        As zeroth-order activation dynamics simply maps excitation to\n        activation, this class has no associated state variables and so this\n        property return an empty column ``Matrix`` with shape (0, 1).\n\n        The alias ``x`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.activation.ZerothOrderActivation.with_defaults",
    "type": "method",
    "description": "Alternate constructor that provides recommended defaults for\n        constants.\n\n        Explanation\n        ===========\n\n        As this concrete class doesn't implement any constants associated with\n        its dynamics, this ``classmethod`` simply creates a standard instance\n        of ``ZerothOrderActivation``. An implementation is provided to ensure\n        a consistent interface between all ``ActivationBase`` concrete classes.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "x",
    "full_id": "sympy.physics.biomechanics.activation.ZerothOrderActivation.x",
    "type": "property",
    "description": "Ordered column matrix of functions of time that represent the state\n        variables.\n\n        Explanation\n        ===========\n\n        As zeroth-order activation dynamics simply maps excitation to\n        activation, this class has no associated state variables and so this\n        property return an empty column ``Matrix`` with shape (0, 1).\n\n        The alias ``state_vars`` can also be used to access the same attribute.\n\n        ",
    "section": "Activation (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/activation.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthActiveDeGroote2016.doit",
    "type": "method",
    "description": "Evaluate the expression defining the function.\n\n        Parameters\n        ==========\n\n        deep : bool\n            Whether ``doit`` should be recursively called. Default is ``True``.\n        evaluate : bool.\n            Whether the SymPy expression should be evaluated as it is\n            constructed. If ``False``, then no constant folding will be\n            conducted which will leave the expression in a more numerically-\n            stable for values of ``l_M_tilde`` that correspond to a sensible\n            operating range for a musculotendon. Default is ``True``.\n        **kwargs : dict[str, Any]\n            Additional keyword argument pairs to be recursively passed to\n            ``doit``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthActiveDeGroote2016.eval",
    "type": "method",
    "description": "Evaluation of basic inputs.\n\n        Parameters\n        ==========\n\n        l_M_tilde : Any (sympifiable)\n            Normalized muscle fiber length.\n        c0 : Any (sympifiable)\n            The first constant in the characteristic equation. The published\n            value is ``0.814``.\n        c1 : Any (sympifiable)\n            The second constant in the characteristic equation. The published\n            value is ``1.06``.\n        c2 : Any (sympifiable)\n            The third constant in the characteristic equation. The published\n            value is ``0.162``.\n        c3 : Any (sympifiable)\n            The fourth constant in the characteristic equation. The published\n            value is ``0.0633``.\n        c4 : Any (sympifiable)\n            The fifth constant in the characteristic equation. The published\n            value is ``0.433``.\n        c5 : Any (sympifiable)\n            The sixth constant in the characteristic equation. The published\n            value is ``0.717``.\n        c6 : Any (sympifiable)\n            The seventh constant in the characteristic equation. The published\n            value is ``-0.0299``.\n        c7 : Any (sympifiable)\n            The eighth constant in the characteristic equation. The published\n            value is ``0.2``.\n        c8 : Any (sympifiable)\n            The ninth constant in the characteristic equation. The published\n            value is ``0.1``.\n        c9 : Any (sympifiable)\n            The tenth constant in the characteristic equation. The published\n            value is ``1.0``.\n        c10 : Any (sympifiable)\n            The eleventh constant in the characteristic equation. The published\n            value is ``0.354``.\n        c11 : Any (sympifiable)\n            The tweflth constant in the characteristic equation. The published\n            value is ``0.0``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "fdiff",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthActiveDeGroote2016.fdiff",
    "type": "method",
    "description": "Derivative of the function with respect to a single argument.\n\n        Parameters\n        ==========\n\n        argindex : int\n            The index of the function's arguments with respect to which the\n            derivative should be taken. Argument indexes start at ``1``.\n            Default is ``1``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthActiveDeGroote2016.with_defaults",
    "type": "method",
    "description": "Recommended constructor that will use the published constants.\n\n        Explanation\n        ===========\n\n        Returns a new instance of the inverse muscle fiber act force-length\n        function using the four constant values specified in the original\n        publication.\n\n        These have the values:\n\n        $c0 = 0.814$\n        $c1 = 1.06$\n        $c2 = 0.162$\n        $c3 = 0.0633$\n        $c4 = 0.433$\n        $c5 = 0.717$\n        $c6 = -0.0299$\n        $c7 = 0.2$\n        $c8 = 0.1$\n        $c9 = 1.0$\n        $c10 = 0.354$\n        $c11 = 0.0$\n\n        Parameters\n        ==========\n\n        fl_M_act : Any (sympifiable)\n            Normalized passive muscle fiber force as a function of muscle fiber\n            length.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthPassiveDeGroote2016.doit",
    "type": "method",
    "description": "Evaluate the expression defining the function.\n\n        Parameters\n        ==========\n\n        deep : bool\n            Whether ``doit`` should be recursively called. Default is ``True``.\n        evaluate : bool.\n            Whether the SymPy expression should be evaluated as it is\n            constructed. If ``False``, then no constant folding will be\n            conducted which will leave the expression in a more numerically-\n            stable for values of ``l_T_tilde`` that correspond to a sensible\n            operating range for a musculotendon. Default is ``True``.\n        **kwargs : dict[str, Any]\n            Additional keyword argument pairs to be recursively passed to\n            ``doit``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthPassiveDeGroote2016.eval",
    "type": "method",
    "description": "Evaluation of basic inputs.\n\n        Parameters\n        ==========\n\n        l_M_tilde : Any (sympifiable)\n            Normalized muscle fiber length.\n        c0 : Any (sympifiable)\n            The first constant in the characteristic equation. The published\n            value is ``0.6``.\n        c1 : Any (sympifiable)\n            The second constant in the characteristic equation. The published\n            value is ``4.0``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "inverse",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthPassiveDeGroote2016.inverse",
    "type": "method",
    "description": "Inverse function.\n\n        Parameters\n        ==========\n\n        argindex : int\n            Value to start indexing the arguments at. Default is ``1``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthPassiveDeGroote2016.with_defaults",
    "type": "method",
    "description": "Recommended constructor that will use the published constants.\n\n        Explanation\n        ===========\n\n        Returns a new instance of the muscle fiber passive force-length\n        function using the four constant values specified in the original\n        publication.\n\n        These have the values:\n\n        $c_0 = 0.6$\n        $c_1 = 4.0$\n\n        Parameters\n        ==========\n\n        l_M_tilde : Any (sympifiable)\n            Normalized muscle fiber length.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthPassiveInverseDeGroote2016.eval",
    "type": "method",
    "description": "Evaluation of basic inputs.\n\n        Parameters\n        ==========\n\n        fl_M_pas : Any (sympifiable)\n            Normalized passive muscle fiber force.\n        c0 : Any (sympifiable)\n            The first constant in the characteristic equation. The published\n            value is ``0.6``.\n        c1 : Any (sympifiable)\n            The second constant in the characteristic equation. The published\n            value is ``4.0``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceLengthPassiveInverseDeGroote2016.with_defaults",
    "type": "method",
    "description": "Recommended constructor that will use the published constants.\n\n        Explanation\n        ===========\n\n        Returns a new instance of the inverse muscle fiber passive force-length\n        function using the four constant values specified in the original\n        publication.\n\n        These have the values:\n\n        $c_0 = 0.6$\n        $c_1 = 4.0$\n\n        Parameters\n        ==========\n\n        fl_M_pas : Any (sympifiable)\n            Normalized passive muscle fiber force as a function of muscle fiber\n            length.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceVelocityDeGroote2016.doit",
    "type": "method",
    "description": "Evaluate the expression defining the function.\n\n        Parameters\n        ==========\n\n        deep : bool\n            Whether ``doit`` should be recursively called. Default is ``True``.\n        evaluate : bool.\n            Whether the SymPy expression should be evaluated as it is\n            constructed. If ``False``, then no constant folding will be\n            conducted which will leave the expression in a more numerically-\n            stable for values of ``v_M_tilde`` that correspond to a sensible\n            operating range for a musculotendon. Default is ``True``.\n        **kwargs : dict[str, Any]\n            Additional keyword argument pairs to be recursively passed to\n            ``doit``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceVelocityDeGroote2016.eval",
    "type": "method",
    "description": "Evaluation of basic inputs.\n\n        Parameters\n        ==========\n\n        v_M_tilde : Any (sympifiable)\n            Normalized muscle fiber extension velocity.\n        c0 : Any (sympifiable)\n            The first constant in the characteristic equation. The published\n            value is ``-0.318``.\n        c1 : Any (sympifiable)\n            The second constant in the characteristic equation. The published\n            value is ``-8.149``.\n        c2 : Any (sympifiable)\n            The third constant in the characteristic equation. The published\n            value is ``-0.374``.\n        c3 : Any (sympifiable)\n            The fourth constant in the characteristic equation. The published\n            value is ``0.886``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceVelocityDeGroote2016.with_defaults",
    "type": "method",
    "description": "Recommended constructor that will use the published constants.\n\n        Explanation\n        ===========\n\n        Returns a new instance of the muscle fiber force-velocity function\n        using the four constant values specified in the original publication.\n\n        These have the values:\n\n        $c_0 = -0.318$\n        $c_1 = -8.149$\n        $c_2 = -0.374$\n        $c_3 = 0.886$\n\n        Parameters\n        ==========\n\n        v_M_tilde : Any (sympifiable)\n            Normalized muscle fiber extension velocity.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceVelocityInverseDeGroote2016.doit",
    "type": "method",
    "description": "Evaluate the expression defining the function.\n\n        Parameters\n        ==========\n\n        deep : bool\n            Whether ``doit`` should be recursively called. Default is ``True``.\n        evaluate : bool.\n            Whether the SymPy expression should be evaluated as it is\n            constructed. If ``False``, then no constant folding will be\n            conducted which will leave the expression in a more numerically-\n            stable for values of ``fv_M`` that correspond to a sensible\n            operating range for a musculotendon. Default is ``True``.\n        **kwargs : dict[str, Any]\n            Additional keyword argument pairs to be recursively passed to\n            ``doit``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceVelocityInverseDeGroote2016.eval",
    "type": "method",
    "description": "Evaluation of basic inputs.\n\n        Parameters\n        ==========\n\n        fv_M : Any (sympifiable)\n            Normalized muscle fiber force as a function of muscle fiber\n            extension velocity.\n        c0 : Any (sympifiable)\n            The first constant in the characteristic equation. The published\n            value is ``-0.318``.\n        c1 : Any (sympifiable)\n            The second constant in the characteristic equation. The published\n            value is ``-8.149``.\n        c2 : Any (sympifiable)\n            The third constant in the characteristic equation. The published\n            value is ``-0.374``.\n        c3 : Any (sympifiable)\n            The fourth constant in the characteristic equation. The published\n            value is ``0.886``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.curve.FiberForceVelocityInverseDeGroote2016.with_defaults",
    "type": "method",
    "description": "Recommended constructor that will use the published constants.\n\n        Explanation\n        ===========\n\n        Returns a new instance of the inverse muscle fiber force-velocity\n        function using the four constant values specified in the original\n        publication.\n\n        These have the values:\n\n        $c_0 = -0.318$\n        $c_1 = -8.149$\n        $c_2 = -0.374$\n        $c_3 = 0.886$\n\n        Parameters\n        ==========\n\n        fv_M : Any (sympifiable)\n            Normalized muscle fiber extension velocity.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.biomechanics.curve.TendonForceLengthDeGroote2016.eval",
    "type": "method",
    "description": "Evaluation of basic inputs.\n\n        Parameters\n        ==========\n\n        l_T_tilde : Any (sympifiable)\n            Normalized tendon length.\n        c0 : Any (sympifiable)\n            The first constant in the characteristic equation. The published\n            value is ``0.2``.\n        c1 : Any (sympifiable)\n            The second constant in the characteristic equation. The published\n            value is ``0.995``.\n        c2 : Any (sympifiable)\n            The third constant in the characteristic equation. The published\n            value is ``0.25``.\n        c3 : Any (sympifiable)\n            The fourth constant in the characteristic equation. The published\n            value is ``33.93669377311689``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.curve.TendonForceLengthDeGroote2016.with_defaults",
    "type": "method",
    "description": "Recommended constructor that will use the published constants.\n\n        Explanation\n        ===========\n\n        Returns a new instance of the tendon force-length function using the\n        four constant values specified in the original publication.\n\n        These have the values:\n\n        $c_0 = 0.2$\n        $c_1 = 0.995$\n        $c_2 = 0.25$\n        $c_3 = 33.93669377311689$\n\n        Parameters\n        ==========\n\n        l_T_tilde : Any (sympifiable)\n            Normalized tendon length.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.biomechanics.curve.TendonForceLengthInverseDeGroote2016.eval",
    "type": "method",
    "description": "Evaluation of basic inputs.\n\n        Parameters\n        ==========\n\n        fl_T : Any (sympifiable)\n            Normalized tendon force as a function of tendon length.\n        c0 : Any (sympifiable)\n            The first constant in the characteristic equation. The published\n            value is ``0.2``.\n        c1 : Any (sympifiable)\n            The second constant in the characteristic equation. The published\n            value is ``0.995``.\n        c2 : Any (sympifiable)\n            The third constant in the characteristic equation. The published\n            value is ``0.25``.\n        c3 : Any (sympifiable)\n            The fourth constant in the characteristic equation. The published\n            value is ``33.93669377311689``.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "with_defaults",
    "full_id": "sympy.physics.biomechanics.curve.TendonForceLengthInverseDeGroote2016.with_defaults",
    "type": "method",
    "description": "Recommended constructor that will use the published constants.\n\n        Explanation\n        ===========\n\n        Returns a new instance of the inverse tendon force-length function\n        using the four constant values specified in the original publication.\n\n        These have the values:\n\n        $c_0 = 0.2$\n        $c_1 = 0.995$\n        $c_2 = 0.25$\n        $c_3 = 33.93669377311689$\n\n        Parameters\n        ==========\n\n        fl_T : Any (sympifiable)\n            Normalized tendon force as a function of tendon length.\n\n        ",
    "section": "Curve (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/biomechanics/api/curve.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.quantum.anticommutator.AntiCommutator.doit",
    "type": "method",
    "description": "Evaluate anticommutator",
    "section": "Anticommutator",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/anticommutator.html"
  },
  {
    "name": "cg_simp",
    "full_id": "sympy.physics.quantum.cg.cg_simp",
    "type": "function",
    "description": "Simplify and combine CG coefficients.\n\n    Explanation\n    ===========\n\n    This function uses various symmetry and properties of sums and\n    products of Clebsch-Gordan coefficients to simplify statements\n    involving these terms [1]_.\n\n    Examples\n    ========\n\n    Simplify the sum over CG(a,alpha,0,0,a,alpha) for all alpha to\n    2*a+1\n\n        >>> from sympy.physics.quantum.cg import CG, cg_simp\n        >>> a = CG(1,1,0,0,1,1)\n        >>> b = CG(1,0,0,0,1,0)\n        >>> c = CG(1,-1,0,0,1,-1)\n        >>> cg_simp(a+b+c)\n        3\n\n    See Also\n    ========\n\n    CG: Clebsh-Gordan coefficients\n\n    References\n    ==========\n\n    .. [1] Varshalovich, D A, Quantum Theory of Angular Momentum. 1988.\n    ",
    "section": "Clebsch-Gordan Coefficients",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/cg.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.quantum.commutator.Commutator.doit",
    "type": "method",
    "description": "Evaluate commutator",
    "section": "Commutator",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/commutator.html"
  },
  {
    "name": "tensor_product_simp",
    "full_id": "sympy.physics.quantum.tensorproduct.tensor_product_simp",
    "type": "function",
    "description": "Try to simplify and combine TensorProducts.\n\n    In general this will try to pull expressions inside of ``TensorProducts``.\n    It currently only works for relatively simple cases where the products have\n    only scalars, raw ``TensorProducts``, not ``Add``, ``Pow``, ``Commutators``\n    of ``TensorProducts``. It is best to see what it does by showing examples.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum import tensor_product_simp\n    >>> from sympy.physics.quantum import TensorProduct\n    >>> from sympy import Symbol\n    >>> A = Symbol('A',commutative=False)\n    >>> B = Symbol('B',commutative=False)\n    >>> C = Symbol('C',commutative=False)\n    >>> D = Symbol('D',commutative=False)\n\n    First see what happens to products of tensor products:\n\n    >>> e = TensorProduct(A,B)*TensorProduct(C,D)\n    >>> e\n    AxB*CxD\n    >>> tensor_product_simp(e)\n    (A*C)x(B*D)\n\n    This is the core logic of this function, and it works inside, powers, sums,\n    commutators and anticommutators as well:\n\n    >>> tensor_product_simp(e**2)\n    (A*C)x(B*D)**2\n\n    ",
    "section": "Tensor Product",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/tensorproduct.html"
  },
  {
    "name": "position_x",
    "full_id": "sympy.physics.quantum.cartesian.PositionState3D.position_x",
    "type": "property",
    "description": "The x coordinate of the state",
    "section": "Cartesian Operators and States",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/cartesian.html"
  },
  {
    "name": "position_y",
    "full_id": "sympy.physics.quantum.cartesian.PositionState3D.position_y",
    "type": "property",
    "description": "The y coordinate of the state",
    "section": "Cartesian Operators and States",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/cartesian.html"
  },
  {
    "name": "position_z",
    "full_id": "sympy.physics.quantum.cartesian.PositionState3D.position_z",
    "type": "property",
    "description": "The z coordinate of the state",
    "section": "Cartesian Operators and States",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/cartesian.html"
  },
  {
    "name": "momentum",
    "full_id": "sympy.physics.quantum.cartesian.PxBra.momentum",
    "type": "property",
    "description": "The momentum of the state.",
    "section": "Cartesian Operators and States",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/cartesian.html"
  },
  {
    "name": "position",
    "full_id": "sympy.physics.quantum.cartesian.XBra.position",
    "type": "property",
    "description": "The position of the state.",
    "section": "Cartesian Operators and States",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/cartesian.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.physics.quantum.hilbert.DirectSumHilbertSpace.eval",
    "type": "method",
    "description": "Evaluates the direct product.",
    "section": "Hilbert Space",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/hilbert.html"
  },
  {
    "name": "spaces",
    "full_id": "sympy.physics.quantum.hilbert.DirectSumHilbertSpace.spaces",
    "type": "property",
    "description": "A tuple of the Hilbert spaces in this direct sum.",
    "section": "Hilbert Space",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/hilbert.html"
  },
  {
    "name": "dimension",
    "full_id": "sympy.physics.quantum.hilbert.HilbertSpace.dimension",
    "type": "property",
    "description": "Return the Hilbert dimension of the space.",
    "section": "Hilbert Space",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/hilbert.html"
  },
  {
    "name": "spaces",
    "full_id": "sympy.physics.quantum.hilbert.TensorProductHilbertSpace.spaces",
    "type": "property",
    "description": "A tuple of the Hilbert spaces in this tensor product.",
    "section": "Hilbert Space",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/hilbert.html"
  },
  {
    "name": "expr",
    "full_id": "sympy.physics.quantum.operator.DifferentialOperator.expr",
    "type": "property",
    "description": "\n        Returns the arbitrary expression which is to have the Wavefunction\n        substituted into it\n\n        Examples\n        ========\n\n        >>> from sympy.physics.quantum.operator import DifferentialOperator\n        >>> from sympy import Function, Symbol, Derivative\n        >>> x = Symbol('x')\n        >>> f = Function('f')\n        >>> d = DifferentialOperator(Derivative(f(x), x), f(x))\n        >>> d.expr\n        Derivative(f(x), x)\n        >>> y = Symbol('y')\n        >>> d = DifferentialOperator(Derivative(f(x, y), x) +\n        ...                          Derivative(f(x, y), y), f(x, y))\n        >>> d.expr\n        Derivative(f(x, y), x) + Derivative(f(x, y), y)\n        ",
    "section": "Operator",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/operator.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.physics.quantum.operator.DifferentialOperator.free_symbols",
    "type": "property",
    "description": "\n        Return the free symbols of the expression.\n        ",
    "section": "Operator",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/operator.html"
  },
  {
    "name": "function",
    "full_id": "sympy.physics.quantum.operator.DifferentialOperator.function",
    "type": "property",
    "description": "\n        Returns the function which is to be replaced with the Wavefunction\n\n        Examples\n        ========\n\n        >>> from sympy.physics.quantum.operator import DifferentialOperator\n        >>> from sympy import Function, Symbol, Derivative\n        >>> x = Symbol('x')\n        >>> f = Function('f')\n        >>> d = DifferentialOperator(Derivative(f(x), x), f(x))\n        >>> d.function\n        f(x)\n        >>> y = Symbol('y')\n        >>> d = DifferentialOperator(Derivative(f(x, y), x) +\n        ...                          Derivative(f(x, y), y), f(x, y))\n        >>> d.function\n        f(x, y)\n        ",
    "section": "Operator",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/operator.html"
  },
  {
    "name": "variables",
    "full_id": "sympy.physics.quantum.operator.DifferentialOperator.variables",
    "type": "property",
    "description": "\n        Returns the variables with which the function in the specified\n        arbitrary expression is evaluated\n\n        Examples\n        ========\n\n        >>> from sympy.physics.quantum.operator import DifferentialOperator\n        >>> from sympy import Symbol, Function, Derivative\n        >>> x = Symbol('x')\n        >>> f = Function('f')\n        >>> d = DifferentialOperator(1/x*Derivative(f(x), x), f(x))\n        >>> d.variables\n        (x,)\n        >>> y = Symbol('y')\n        >>> d = DifferentialOperator(Derivative(f(x, y), x) +\n        ...                          Derivative(f(x, y), y), f(x, y))\n        >>> d.variables\n        (x, y)\n        ",
    "section": "Operator",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/operator.html"
  },
  {
    "name": "bra",
    "full_id": "sympy.physics.quantum.operator.OuterProduct.bra",
    "type": "property",
    "description": "Return the bra on the right side of the outer product.",
    "section": "Operator",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/operator.html"
  },
  {
    "name": "ket",
    "full_id": "sympy.physics.quantum.operator.OuterProduct.ket",
    "type": "property",
    "description": "Return the ket on the left side of the outer product.",
    "section": "Operator",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/operator.html"
  },
  {
    "name": "operators_to_state",
    "full_id": "sympy.physics.quantum.operatorset.operators_to_state",
    "type": "function",
    "description": "Returns the eigenstate of the given operator or set of operators\n\n    A global function for mapping operator classes to their associated\n    states. It takes either an Operator or a set of operators and\n    returns the state associated with these.\n\n    This function can handle both instances of a given operator or\n    just the class itself (i.e. both XOp() and XOp)\n\n    There are multiple use cases to consider:\n\n    1) A class or set of classes is passed: First, we try to\n    instantiate default instances for these operators. If this fails,\n    then the class is simply returned. If we succeed in instantiating\n    default instances, then we try to call state._operators_to_state\n    on the operator instances. If this fails, the class is returned.\n    Otherwise, the instance returned by _operators_to_state is returned.\n\n    2) An instance or set of instances is passed: In this case,\n    state._operators_to_state is called on the instances passed. If\n    this fails, a state class is returned. If the method returns an\n    instance, that instance is returned.\n\n    In both cases, if the operator class or set does not exist in the\n    state_mapping dictionary, None is returned.\n\n    Parameters\n    ==========\n\n    arg: Operator or set\n         The class or instance of the operator or set of operators\n         to be mapped to a state\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.cartesian import XOp, PxOp\n    >>> from sympy.physics.quantum.operatorset import operators_to_state\n    >>> from sympy.physics.quantum.operator import Operator\n    >>> operators_to_state(XOp)\n    |x>\n    >>> operators_to_state(XOp())\n    |x>\n    >>> operators_to_state(PxOp)\n    |px>\n    >>> operators_to_state(PxOp())\n    |px>\n    >>> operators_to_state(Operator)\n    |psi>\n    >>> operators_to_state(Operator())\n    |psi>\n    ",
    "section": "Operator/State Helper Functions",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/operatorset.html"
  },
  {
    "name": "state_to_operators",
    "full_id": "sympy.physics.quantum.operatorset.state_to_operators",
    "type": "function",
    "description": "Returns the operator or set of operators corresponding to the\n    given eigenstate\n\n    A global function for mapping state classes to their associated\n    operators or sets of operators. It takes either a state class\n    or instance.\n\n    This function can handle both instances of a given state or just\n    the class itself (i.e. both XKet() and XKet)\n\n    There are multiple use cases to consider:\n\n    1) A state class is passed: In this case, we first try\n    instantiating a default instance of the class. If this succeeds,\n    then we try to call state._state_to_operators on that instance.\n    If the creation of the default instance or if the calling of\n    _state_to_operators fails, then either an operator class or set of\n    operator classes is returned. Otherwise, the appropriate\n    operator instances are returned.\n\n    2) A state instance is returned: Here, state._state_to_operators\n    is called for the instance. If this fails, then a class or set of\n    operator classes is returned. Otherwise, the instances are returned.\n\n    In either case, if the state's class does not exist in\n    state_mapping, None is returned.\n\n    Parameters\n    ==========\n\n    arg: StateBase class or instance (or subclasses)\n         The class or instance of the state to be mapped to an\n         operator or set of operators\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.cartesian import XKet, PxKet, XBra, PxBra\n    >>> from sympy.physics.quantum.operatorset import state_to_operators\n    >>> from sympy.physics.quantum.state import Ket, Bra\n    >>> state_to_operators(XKet)\n    X\n    >>> state_to_operators(XKet())\n    X\n    >>> state_to_operators(PxKet)\n    Px\n    >>> state_to_operators(PxKet())\n    Px\n    >>> state_to_operators(PxBra)\n    Px\n    >>> state_to_operators(XBra)\n    X\n    >>> state_to_operators(Ket)\n    O\n    >>> state_to_operators(Bra)\n    O\n    ",
    "section": "Operator/State Helper Functions",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/operatorset.html"
  },
  {
    "name": "qapply",
    "full_id": "sympy.physics.quantum.qapply.qapply",
    "type": "function",
    "description": "Apply operators to states in a quantum expression.\n\n    Parameters\n    ==========\n\n    e : Expr\n        The expression containing operators and states. This expression tree\n        will be walked to find operators acting on states symbolically.\n    options : dict\n        A dict of key/value pairs that determine how the operator actions\n        are carried out.\n\n        The following options are valid:\n\n        * ``dagger``: try to apply Dagger operators to the left\n          (default: False).\n        * ``ip_doit``: call ``.doit()`` in inner products when they are\n          encountered (default: True).\n\n    Returns\n    =======\n\n    e : Expr\n        The original expression, but with the operators applied to states.\n\n    Examples\n    ========\n\n        >>> from sympy.physics.quantum import qapply, Ket, Bra\n        >>> b = Bra('b')\n        >>> k = Ket('k')\n        >>> A = k * b\n        >>> A\n        |k><b|\n        >>> qapply(A * b.dual / (b * b.dual))\n        |k>\n        >>> qapply(k.dual * A / (k.dual * k), dagger=True)\n        <b|\n        >>> qapply(k.dual * A / (k.dual * k))\n        <k|*|k><b|/<k|k>\n    ",
    "section": "Qapply",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qapply.html"
  },
  {
    "name": "enumerate_states",
    "full_id": "sympy.physics.quantum.represent.enumerate_states",
    "type": "function",
    "description": "\n    Returns instances of the given state with dummy indices appended\n\n    Operates in two different modes:\n\n    1. Two arguments are passed to it. The first is the base state which is to\n       be indexed, and the second argument is a list of indices to append.\n\n    2. Three arguments are passed. The first is again the base state to be\n       indexed. The second is the start index for counting.  The final argument\n       is the number of kets you wish to receive.\n\n    Tries to call state._enumerate_state. If this fails, returns an empty list\n\n    Parameters\n    ==========\n\n    args : list\n        See list of operation modes above for explanation\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.cartesian import XBra, XKet\n    >>> from sympy.physics.quantum.represent import enumerate_states\n    >>> test = XKet('foo')\n    >>> enumerate_states(test, 1, 3)\n    [|foo_1>, |foo_2>, |foo_3>]\n    >>> test2 = XBra('bar')\n    >>> enumerate_states(test2, [4, 5, 10])\n    [<bar_4|, <bar_5|, <bar_10|]\n\n    ",
    "section": "Represent",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/represent.html"
  },
  {
    "name": "get_basis",
    "full_id": "sympy.physics.quantum.represent.get_basis",
    "type": "function",
    "description": "\n    Returns a basis state instance corresponding to the basis specified in\n    options=s. If no basis is specified, the function tries to form a default\n    basis state of the given expression.\n\n    There are three behaviors:\n\n    1. The basis specified in options is already an instance of StateBase. If\n       this is the case, it is simply returned. If the class is specified but\n       not an instance, a default instance is returned.\n\n    2. The basis specified is an operator or set of operators. If this\n       is the case, the operator_to_state mapping method is used.\n\n    3. No basis is specified. If expr is a state, then a default instance of\n       its class is returned.  If expr is an operator, then it is mapped to the\n       corresponding state.  If it is neither, then we cannot obtain the basis\n       state.\n\n    If the basis cannot be mapped, then it is not changed.\n\n    This will be called from within represent, and represent will\n    only pass QExpr's.\n\n    TODO (?): Support for Muls and other types of expressions?\n\n    Parameters\n    ==========\n\n    expr : Operator or StateBase\n        Expression whose basis is sought\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.represent import get_basis\n    >>> from sympy.physics.quantum.cartesian import XOp, XKet, PxOp, PxKet\n    >>> x = XKet()\n    >>> X = XOp()\n    >>> get_basis(x)\n    |x>\n    >>> get_basis(X)\n    |x>\n    >>> get_basis(x, basis=PxOp())\n    |px>\n    >>> get_basis(x, basis=PxKet)\n    |px>\n\n    ",
    "section": "Represent",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/represent.html"
  },
  {
    "name": "integrate_result",
    "full_id": "sympy.physics.quantum.represent.integrate_result",
    "type": "function",
    "description": "\n    Returns the result of integrating over any unities ``(|x><x|)`` in\n    the given expression. Intended for integrating over the result of\n    representations in continuous bases.\n\n    This function integrates over any unities that may have been\n    inserted into the quantum expression and returns the result.\n    It uses the interval of the Hilbert space of the basis state\n    passed to it in order to figure out the limits of integration.\n    The unities option must be\n    specified for this to work.\n\n    Note: This is mostly used internally by represent(). Examples are\n    given merely to show the use cases.\n\n    Parameters\n    ==========\n\n    orig_expr : quantum expression\n        The original expression which was to be represented\n\n    result: Expr\n        The resulting representation that we wish to integrate over\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, DiracDelta\n    >>> from sympy.physics.quantum.represent import integrate_result\n    >>> from sympy.physics.quantum.cartesian import XOp, XKet\n    >>> x_ket = XKet()\n    >>> X_op = XOp()\n    >>> x, x_1, x_2 = symbols('x, x_1, x_2')\n    >>> integrate_result(X_op*x_ket, x*DiracDelta(x-x_1)*DiracDelta(x_1-x_2))\n    x*DiracDelta(x - x_1)*DiracDelta(x_1 - x_2)\n    >>> integrate_result(X_op*x_ket, x*DiracDelta(x-x_1)*DiracDelta(x_1-x_2),\n    ...     unities=[1])\n    x*DiracDelta(x - x_2)\n\n    ",
    "section": "Represent",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/represent.html"
  },
  {
    "name": "rep_expectation",
    "full_id": "sympy.physics.quantum.represent.rep_expectation",
    "type": "function",
    "description": "\n    Returns an ``<x'|A|x>`` type representation for the given operator.\n\n    Parameters\n    ==========\n\n    expr : Operator\n        Operator to be represented in the specified basis\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.cartesian import XOp, PxOp, PxKet\n    >>> from sympy.physics.quantum.represent import rep_expectation\n    >>> rep_expectation(XOp())\n    x_1*DiracDelta(x_1 - x_2)\n    >>> rep_expectation(XOp(), basis=PxOp())\n    <px_2|*X*|px_1>\n    >>> rep_expectation(XOp(), basis=PxKet())\n    <px_2|*X*|px_1>\n\n    ",
    "section": "Represent",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/represent.html"
  },
  {
    "name": "rep_innerproduct",
    "full_id": "sympy.physics.quantum.represent.rep_innerproduct",
    "type": "function",
    "description": "\n    Returns an innerproduct like representation (e.g. ``<x'|x>``) for the\n    given state.\n\n    Attempts to calculate inner product with a bra from the specified\n    basis. Should only be passed an instance of KetBase or BraBase\n\n    Parameters\n    ==========\n\n    expr : KetBase or BraBase\n        The expression to be represented\n\n    Examples\n    ========\n\n    >>> from sympy.physics.quantum.represent import rep_innerproduct\n    >>> from sympy.physics.quantum.cartesian import XOp, XKet, PxOp, PxKet\n    >>> rep_innerproduct(XKet())\n    DiracDelta(x - x_1)\n    >>> rep_innerproduct(XKet(), basis=PxOp())\n    sqrt(2)*exp(-I*px_1*x/hbar)/(2*sqrt(hbar)*sqrt(pi))\n    >>> rep_innerproduct(PxKet(), basis=XOp())\n    sqrt(2)*exp(I*px*x_1/hbar)/(2*sqrt(hbar)*sqrt(pi))\n\n    ",
    "section": "Represent",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/represent.html"
  },
  {
    "name": "represent",
    "full_id": "sympy.physics.quantum.represent.represent",
    "type": "function",
    "description": "Represent the quantum expression in the given basis.\n\n    In quantum mechanics abstract states and operators can be represented in\n    various basis sets. Under this operation the follow transforms happen:\n\n    * Ket -> column vector or function\n    * Bra -> row vector of function\n    * Operator -> matrix or differential operator\n\n    This function is the top-level interface for this action.\n\n    This function walks the SymPy expression tree looking for ``QExpr``\n    instances that have a ``_represent`` method. This method is then called\n    and the object is replaced by the representation returned by this method.\n    By default, the ``_represent`` method will dispatch to other methods\n    that handle the representation logic for a particular basis set. The\n    naming convention for these methods is the following::\n\n        def _represent_FooBasis(self, e, basis, **options)\n\n    This function will have the logic for representing instances of its class\n    in the basis set having a class named ``FooBasis``.\n\n    Parameters\n    ==========\n\n    expr  : Expr\n        The expression to represent.\n    basis : Operator, basis set\n        An object that contains the information about the basis set. If an\n        operator is used, the basis is assumed to be the orthonormal\n        eigenvectors of that operator. In general though, the basis argument\n        can be any object that contains the basis set information.\n    options : dict\n        Key/value pairs of options that are passed to the underlying method\n        that finds the representation. These options can be used to\n        control how the representation is done. For example, this is where\n        the size of the basis set would be set.\n\n    Returns\n    =======\n\n    e : Expr\n        The SymPy expression of the represented quantum expression.\n\n    Examples\n    ========\n\n    Here we subclass ``Operator`` and ``Ket`` to create the z-spin operator\n    and its spin 1/2 up eigenstate. By defining the ``_represent_SzOp``\n    method, the ket can be represented in the z-spin basis.\n\n    >>> from sympy.physics.quantum import Operator, represent, Ket\n    >>> from sympy import Matrix\n\n    >>> class SzUpKet(Ket):\n    ...     def _represent_SzOp(self, basis, **options):\n    ...         return Matrix([1,0])\n    ...\n    >>> class SzOp(Operator):\n    ...     pass\n    ...\n    >>> sz = SzOp('Sz')\n    >>> up = SzUpKet('up')\n    >>> represent(up, basis=sz)\n    Matrix([\n    [1],\n    [0]])\n\n    Here we see an example of representations in a continuous\n    basis. We see that the result of representing various combinations\n    of cartesian position operators and kets give us continuous\n    expressions involving DiracDelta functions.\n\n    >>> from sympy.physics.quantum.cartesian import XOp, XKet, XBra\n    >>> X = XOp()\n    >>> x = XKet()\n    >>> y = XBra('y')\n    >>> represent(X*x)\n    x*DiracDelta(x - x_2)\n    >>> represent(X*x*y)\n    x*DiracDelta(x - x_3)*DiracDelta(x_1 - y)\n\n    ",
    "section": "Represent",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/represent.html"
  },
  {
    "name": "D",
    "full_id": "sympy.physics.quantum.spin.Rotation.D",
    "type": "method",
    "description": "Wigner D-function.\n\n        Returns an instance of the WignerD class corresponding to the Wigner-D\n        function specified by the parameters.\n\n        Parameters\n        ===========\n\n        j : Number\n            Total angular momentum\n        m : Number\n            Eigenvalue of angular momentum along axis after rotation\n        mp : Number\n            Eigenvalue of angular momentum along rotated axis\n        alpha : Number, Symbol\n            First Euler angle of rotation\n        beta : Number, Symbol\n            Second Euler angle of rotation\n        gamma : Number, Symbol\n            Third Euler angle of rotation\n\n        Examples\n        ========\n\n        Return the Wigner-D matrix element for a defined rotation, both\n        numerical and symbolic:\n\n            >>> from sympy.physics.quantum.spin import Rotation\n            >>> from sympy import pi, symbols\n            >>> alpha, beta, gamma = symbols('alpha beta gamma')\n            >>> Rotation.D(1, 1, 0,pi, pi/2,-pi)\n            WignerD(1, 1, 0, pi, pi/2, -pi)\n\n        See Also\n        ========\n\n        WignerD: Symbolic Wigner-D function\n\n        ",
    "section": "Spin",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/spin.html"
  },
  {
    "name": "d",
    "full_id": "sympy.physics.quantum.spin.Rotation.d",
    "type": "method",
    "description": "Wigner small-d function.\n\n        Returns an instance of the WignerD class corresponding to the Wigner-D\n        function specified by the parameters with the alpha and gamma angles\n        given as 0.\n\n        Parameters\n        ===========\n\n        j : Number\n            Total angular momentum\n        m : Number\n            Eigenvalue of angular momentum along axis after rotation\n        mp : Number\n            Eigenvalue of angular momentum along rotated axis\n        beta : Number, Symbol\n            Second Euler angle of rotation\n\n        Examples\n        ========\n\n        Return the Wigner-D matrix element for a defined rotation, both\n        numerical and symbolic:\n\n            >>> from sympy.physics.quantum.spin import Rotation\n            >>> from sympy import pi, symbols\n            >>> beta = symbols('beta')\n            >>> Rotation.d(1, 1, 0, pi/2)\n            WignerD(1, 1, 0, 0, pi/2, 0)\n\n        See Also\n        ========\n\n        WignerD: Symbolic Wigner-D function\n\n        ",
    "section": "Spin",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/spin.html"
  },
  {
    "name": "couple",
    "full_id": "sympy.physics.quantum.spin.couple",
    "type": "function",
    "description": "Couple a tensor product of spin states\n\n    This function can be used to couple an uncoupled tensor product of spin\n    states. All of the eigenstates to be coupled must be of the same class. It\n    will return a linear combination of eigenstates that are subclasses of\n    CoupledSpinState determined by Clebsch-Gordan angular momentum coupling\n    coefficients.\n\n    Parameters\n    ==========\n\n    expr : Expr\n        An expression involving TensorProducts of spin states to be coupled.\n        Each state must be a subclass of SpinState and they all must be the\n        same class.\n\n    jcoupling_list : list or tuple\n        Elements of this list are sub-lists of length 2 specifying the order of\n        the coupling of the spin spaces. The length of this must be N-1, where N\n        is the number of states in the tensor product to be coupled. The\n        elements of this sublist are the same as the first two elements of each\n        sublist in the ``jcoupling`` parameter defined for JzKetCoupled. If this\n        parameter is not specified, the default value is taken, which couples\n        the first and second product basis spaces, then couples this new coupled\n        space to the third product space, etc\n\n    Examples\n    ========\n\n    Couple a tensor product of numerical states for two spaces:\n\n        >>> from sympy.physics.quantum.spin import JzKet, couple\n        >>> from sympy.physics.quantum.tensorproduct import TensorProduct\n        >>> couple(TensorProduct(JzKet(1,0), JzKet(1,1)))\n        -sqrt(2)*|1,1,j1=1,j2=1>/2 + sqrt(2)*|2,1,j1=1,j2=1>/2\n\n\n    Numerical coupling of three spaces using the default coupling method, i.e.\n    first and second spaces couple, then this couples to the third space:\n\n        >>> couple(TensorProduct(JzKet(1,1), JzKet(1,1), JzKet(1,0)))\n        sqrt(6)*|2,2,j1=1,j2=1,j3=1,j(1,2)=2>/3 + sqrt(3)*|3,2,j1=1,j2=1,j3=1,j(1,2)=2>/3\n\n    Perform this same coupling, but we define the coupling to first couple\n    the first and third spaces:\n\n        >>> couple(TensorProduct(JzKet(1,1), JzKet(1,1), JzKet(1,0)), ((1,3),(1,2)) )\n        sqrt(2)*|2,2,j1=1,j2=1,j3=1,j(1,3)=1>/2 - sqrt(6)*|2,2,j1=1,j2=1,j3=1,j(1,3)=2>/6 + sqrt(3)*|3,2,j1=1,j2=1,j3=1,j(1,3)=2>/3\n\n    Couple a tensor product of symbolic states:\n\n        >>> from sympy import symbols\n        >>> j1,m1,j2,m2 = symbols('j1 m1 j2 m2')\n        >>> couple(TensorProduct(JzKet(j1,m1), JzKet(j2,m2)))\n        Sum(CG(j1, m1, j2, m2, j, m1 + m2)*|j,m1 + m2,j1=j1,j2=j2>, (j, m1 + m2, j1 + j2))\n\n    ",
    "section": "Spin",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/spin.html"
  },
  {
    "name": "uncouple",
    "full_id": "sympy.physics.quantum.spin.uncouple",
    "type": "function",
    "description": "Uncouple a coupled spin state\n\n    Gives the uncoupled representation of a coupled spin state. Arguments must\n    be either a spin state that is a subclass of CoupledSpinState or a spin\n    state that is a subclass of SpinState and an array giving the j values\n    of the spaces that are to be coupled\n\n    Parameters\n    ==========\n\n    expr : Expr\n        The expression containing states that are to be coupled. If the states\n        are a subclass of SpinState, the ``jn`` and ``jcoupling`` parameters\n        must be defined. If the states are a subclass of CoupledSpinState,\n        ``jn`` and ``jcoupling`` will be taken from the state.\n\n    jn : list or tuple\n        The list of the j-values that are coupled. If state is a\n        CoupledSpinState, this parameter is ignored. This must be defined if\n        state is not a subclass of CoupledSpinState. The syntax of this\n        parameter is the same as the ``jn`` parameter of JzKetCoupled.\n\n    jcoupling_list : list or tuple\n        The list defining how the j-values are coupled together. If state is a\n        CoupledSpinState, this parameter is ignored. This must be defined if\n        state is not a subclass of CoupledSpinState. The syntax of this\n        parameter is the same as the ``jcoupling`` parameter of JzKetCoupled.\n\n    Examples\n    ========\n\n    Uncouple a numerical state using a CoupledSpinState state:\n\n        >>> from sympy.physics.quantum.spin import JzKetCoupled, uncouple\n        >>> from sympy import S\n        >>> uncouple(JzKetCoupled(1, 0, (S(1)/2, S(1)/2)))\n        sqrt(2)*|1/2,-1/2>x|1/2,1/2>/2 + sqrt(2)*|1/2,1/2>x|1/2,-1/2>/2\n\n    Perform the same calculation using a SpinState state:\n\n        >>> from sympy.physics.quantum.spin import JzKet\n        >>> uncouple(JzKet(1, 0), (S(1)/2, S(1)/2))\n        sqrt(2)*|1/2,-1/2>x|1/2,1/2>/2 + sqrt(2)*|1/2,1/2>x|1/2,-1/2>/2\n\n    Uncouple a numerical state of three coupled spaces using a CoupledSpinState state:\n\n        >>> uncouple(JzKetCoupled(1, 1, (1, 1, 1), ((1,3,1),(1,2,1)) ))\n        |1,-1>x|1,1>x|1,1>/2 - |1,0>x|1,0>x|1,1>/2 + |1,1>x|1,0>x|1,0>/2 - |1,1>x|1,1>x|1,-1>/2\n\n    Perform the same calculation using a SpinState state:\n\n        >>> uncouple(JzKet(1, 1), (1, 1, 1), ((1,3,1),(1,2,1)) )\n        |1,-1>x|1,1>x|1,1>/2 - |1,0>x|1,0>x|1,1>/2 + |1,1>x|1,0>x|1,0>/2 - |1,1>x|1,1>x|1,-1>/2\n\n    Uncouple a symbolic state using a CoupledSpinState state:\n\n        >>> from sympy import symbols\n        >>> j,m,j1,j2 = symbols('j m j1 j2')\n        >>> uncouple(JzKetCoupled(j, m, (j1, j2)))\n        Sum(CG(j1, m1, j2, m2, j, m)*|j1,m1>x|j2,m2>, (m1, -j1, j1), (m2, -j2, j2))\n\n    Perform the same calculation using a SpinState state\n\n        >>> uncouple(JzKet(j, m), (j1, j2))\n        Sum(CG(j1, m1, j2, m2, j, m)*|j1,m1>x|j2,m2>, (m1, -j1, j1), (m2, -j2, j2))\n\n    ",
    "section": "Spin",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/spin.html"
  },
  {
    "name": "dual",
    "full_id": "sympy.physics.quantum.state.StateBase.dual",
    "type": "property",
    "description": "Return the dual state of this one.",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "dual_class",
    "full_id": "sympy.physics.quantum.state.StateBase.dual_class",
    "type": "method",
    "description": "Return the class used to construct the dual.",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "operators",
    "full_id": "sympy.physics.quantum.state.StateBase.operators",
    "type": "property",
    "description": "Return the operator(s) that this state is an eigenstate of",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "label",
    "full_id": "sympy.physics.quantum.state.TimeDepState.label",
    "type": "property",
    "description": "The label of the state.",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "time",
    "full_id": "sympy.physics.quantum.state.TimeDepState.time",
    "type": "property",
    "description": "The time of the state.",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "expr",
    "full_id": "sympy.physics.quantum.state.Wavefunction.expr",
    "type": "property",
    "description": "\n        Return the expression which is the functional form of the Wavefunction\n\n        Examples\n        ========\n\n            >>> from sympy.physics.quantum.state import Wavefunction\n            >>> from sympy import symbols\n            >>> x, y = symbols('x, y')\n            >>> f = Wavefunction(x**2, x)\n            >>> f.expr\n            x**2\n\n        ",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "is_commutative",
    "full_id": "sympy.physics.quantum.state.Wavefunction.is_commutative",
    "type": "property",
    "description": "\n        Override Function's is_commutative so that order is preserved in\n        represented expressions\n        ",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "is_normalized",
    "full_id": "sympy.physics.quantum.state.Wavefunction.is_normalized",
    "type": "property",
    "description": "\n        Returns true if the Wavefunction is properly normalized\n\n        Examples\n        ========\n\n            >>> from sympy import symbols, pi\n            >>> from sympy.functions import sqrt, sin\n            >>> from sympy.physics.quantum.state import Wavefunction\n            >>> x, L = symbols('x,L', positive=True)\n            >>> n = symbols('n', integer=True, positive=True)\n            >>> g = sqrt(2/L)*sin(n*pi*x/L)\n            >>> f = Wavefunction(g, (x, 0, L))\n            >>> f.is_normalized\n            True\n\n        ",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "limits",
    "full_id": "sympy.physics.quantum.state.Wavefunction.limits",
    "type": "property",
    "description": "\n        Return the limits of the coordinates which the w.f. depends on If no\n        limits are specified, defaults to ``(-oo, oo)``.\n\n        Examples\n        ========\n\n            >>> from sympy.physics.quantum.state import Wavefunction\n            >>> from sympy import symbols\n            >>> x, y = symbols('x, y')\n            >>> f = Wavefunction(x**2, (x, 0, 1))\n            >>> f.limits\n            {x: (0, 1)}\n            >>> f = Wavefunction(x**2, x)\n            >>> f.limits\n            {x: (-oo, oo)}\n            >>> f = Wavefunction(x**2 + y**2, x, (y, -1, 2))\n            >>> f.limits\n            {x: (-oo, oo), y: (-1, 2)}\n\n        ",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "norm",
    "full_id": "sympy.physics.quantum.state.Wavefunction.norm",
    "type": "property",
    "description": "\n        Return the normalization of the specified functional form.\n\n        This function integrates over the coordinates of the Wavefunction, with\n        the bounds specified.\n\n        Examples\n        ========\n\n            >>> from sympy import symbols, pi\n            >>> from sympy.functions import sqrt, sin\n            >>> from sympy.physics.quantum.state import Wavefunction\n            >>> x, L = symbols('x,L', positive=True)\n            >>> n = symbols('n', integer=True, positive=True)\n            >>> g = sqrt(2/L)*sin(n*pi*x/L)\n            >>> f = Wavefunction(g, (x, 0, L))\n            >>> f.norm\n            1\n            >>> g = sin(n*pi*x/L)\n            >>> f = Wavefunction(g, (x, 0, L))\n            >>> f.norm\n            sqrt(2)*sqrt(L)/2\n\n        ",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "normalize",
    "full_id": "sympy.physics.quantum.state.Wavefunction.normalize",
    "type": "method",
    "description": "\n        Return a normalized version of the Wavefunction\n\n        Examples\n        ========\n\n            >>> from sympy import symbols, pi\n            >>> from sympy.functions import sin\n            >>> from sympy.physics.quantum.state import Wavefunction\n            >>> x = symbols('x', real=True)\n            >>> L = symbols('L', positive=True)\n            >>> n = symbols('n', integer=True, positive=True)\n            >>> g = sin(n*pi*x/L)\n            >>> f = Wavefunction(g, (x, 0, L))\n            >>> f.normalize()\n            Wavefunction(sqrt(2)*sin(pi*n*x/L)/sqrt(L), (x, 0, L))\n\n        ",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "prob",
    "full_id": "sympy.physics.quantum.state.Wavefunction.prob",
    "type": "method",
    "description": "\n        Return the absolute magnitude of the w.f., `|\\psi(x)|^2`\n\n        Examples\n        ========\n\n            >>> from sympy import symbols, pi\n            >>> from sympy.functions import sin\n            >>> from sympy.physics.quantum.state import Wavefunction\n            >>> x, L = symbols('x,L', real=True)\n            >>> n = symbols('n', integer=True)\n            >>> g = sin(n*pi*x/L)\n            >>> f = Wavefunction(g, (x, 0, L))\n            >>> f.prob()\n            Wavefunction(sin(pi*n*x/L)**2, x)\n\n        ",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "variables",
    "full_id": "sympy.physics.quantum.state.Wavefunction.variables",
    "type": "property",
    "description": "\n        Return the coordinates which the wavefunction depends on\n\n        Examples\n        ========\n\n            >>> from sympy.physics.quantum.state import Wavefunction\n            >>> from sympy import symbols\n            >>> x,y = symbols('x,y')\n            >>> f = Wavefunction(x*y, x, y)\n            >>> f.variables\n            (x, y)\n            >>> g = Wavefunction(x*y, x)\n            >>> g.variables\n            (x,)\n\n        ",
    "section": "State",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/state.html"
  },
  {
    "name": "control_line",
    "full_id": "sympy.physics.quantum.circuitplot.CircuitPlot.control_line",
    "type": "method",
    "description": "Draw a vertical control line.",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "control_point",
    "full_id": "sympy.physics.quantum.circuitplot.CircuitPlot.control_point",
    "type": "method",
    "description": "Draw a control point.",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "not_point",
    "full_id": "sympy.physics.quantum.circuitplot.CircuitPlot.not_point",
    "type": "method",
    "description": "Draw a NOT gates as the circle with plus in the middle.",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "one_qubit_box",
    "full_id": "sympy.physics.quantum.circuitplot.CircuitPlot.one_qubit_box",
    "type": "method",
    "description": "Draw a box for a single qubit gate.",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "swap_point",
    "full_id": "sympy.physics.quantum.circuitplot.CircuitPlot.swap_point",
    "type": "method",
    "description": "Draw a swap point as a cross.",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "two_qubit_box",
    "full_id": "sympy.physics.quantum.circuitplot.CircuitPlot.two_qubit_box",
    "type": "method",
    "description": "Draw a box for a two qubit gate. Does not work yet.",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "update",
    "full_id": "sympy.physics.quantum.circuitplot.CircuitPlot.update",
    "type": "method",
    "description": "Load the kwargs into the instance dict.",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "CreateCGate",
    "full_id": "sympy.physics.quantum.circuitplot.CreateCGate",
    "type": "function",
    "description": "Use a lexical closure to make a controlled gate.",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "circuit_plot",
    "full_id": "sympy.physics.quantum.circuitplot.circuit_plot",
    "type": "function",
    "description": "Draw the circuit diagram for the circuit with nqubits.\n\n    Parameters\n    ==========\n\n    c : circuit\n        The circuit to plot. Should be a product of Gate instances.\n    nqubits : int\n        The number of qubits to include in the circuit. Must be at least\n        as big as the largest ``min_qubits`` of the gates.\n    ",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "labeller",
    "full_id": "sympy.physics.quantum.circuitplot.labeller",
    "type": "function",
    "description": "Autogenerate labels for wires of quantum circuits.\n\n    Parameters\n    ==========\n\n    n : int\n        number of qubits in the circuit.\n    symbol : string\n        A character string to precede all gate labels. E.g. 'q_0', 'q_1', etc.\n\n    >>> from sympy.physics.quantum.circuitplot import labeller\n    >>> labeller(2)\n    ['q_1', 'q_0']\n    >>> labeller(3,'j')\n    ['j_2', 'j_1', 'j_0']\n    ",
    "section": "Circuit Plot",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/circuitplot.html"
  },
  {
    "name": "controls",
    "full_id": "sympy.physics.quantum.gate.CGate.controls",
    "type": "property",
    "description": "A tuple of control qubits.",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "decompose",
    "full_id": "sympy.physics.quantum.gate.CGate.decompose",
    "type": "method",
    "description": "Decompose the controlled gate into CNOT and single qubits gates.",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "eval_controls",
    "full_id": "sympy.physics.quantum.gate.CGate.eval_controls",
    "type": "method",
    "description": "Return True/False to indicate if the controls are satisfied.",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "gate",
    "full_id": "sympy.physics.quantum.gate.CGate.gate",
    "type": "property",
    "description": "The non-controlled gate that will be applied to the targets.",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "min_qubits",
    "full_id": "sympy.physics.quantum.gate.CGate.min_qubits",
    "type": "property",
    "description": "The minimum number of qubits this gate needs to act on.",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "nqubits",
    "full_id": "sympy.physics.quantum.gate.CGate.nqubits",
    "type": "property",
    "description": "The total number of qubits this gate acts on.\n\n        For controlled gate subclasses this includes both target and control\n        qubits, so that, for examples the CNOT gate acts on 2 qubits.\n        ",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "plot_gate",
    "full_id": "sympy.physics.quantum.gate.CGate.plot_gate",
    "type": "method",
    "description": "\n        Plot the controlled gate. If *simplify_cgate* is true, simplify\n        C-X and C-Z gates into their more familiar forms.\n        ",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "targets",
    "full_id": "sympy.physics.quantum.gate.CGate.targets",
    "type": "property",
    "description": "A tuple of target qubits.",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "get_target_matrix",
    "full_id": "sympy.physics.quantum.gate.Gate.get_target_matrix",
    "type": "method",
    "description": "The matrix representation of the target part of the gate.\n\n        Parameters\n        ----------\n        format : str\n            The format string ('sympy','numpy', etc.)\n        ",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "decompose",
    "full_id": "sympy.physics.quantum.gate.SwapGate.decompose",
    "type": "method",
    "description": "Decompose the SWAP gate into CNOT gates.",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "get_target_matrix",
    "full_id": "sympy.physics.quantum.gate.UGate.get_target_matrix",
    "type": "method",
    "description": "The matrix rep. of the target part of the gate.\n\n        Parameters\n        ----------\n        format : str\n            The format string ('sympy','numpy', etc.)\n        ",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "gate_simp",
    "full_id": "sympy.physics.quantum.gate.gate_simp",
    "type": "function",
    "description": "Simplifies gates symbolically\n\n    It first sorts gates using gate_sort. It then applies basic\n    simplification rules to the circuit, e.g., XGate**2 = Identity\n    ",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "gate_sort",
    "full_id": "sympy.physics.quantum.gate.gate_sort",
    "type": "function",
    "description": "Sorts the gates while keeping track of commutation relations\n\n    This function uses a bubble sort to rearrange the order of gate\n    application. Keeps track of Quantum computations special commutation\n    relations (e.g. things that apply to the same Qubit do not commute with\n    each other)\n\n    circuit is the Mul of gates that are to be sorted.\n    ",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "normalized",
    "full_id": "sympy.physics.quantum.gate.normalized",
    "type": "function",
    "description": "Set flag controlling normalization of Hadamard gates by `1/\\sqrt{2}`.\n\n    This is a global setting that can be used to simplify the look of various\n    expressions, by leaving off the leading `1/\\sqrt{2}` of the Hadamard gate.\n\n    Parameters\n    ----------\n    normalize : bool\n        Should the Hadamard gate include the `1/\\sqrt{2}` normalization factor?\n        When True, the Hadamard gate will have the `1/\\sqrt{2}`. When False, the\n        Hadamard gate will not have this factor.\n    ",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "random_circuit",
    "full_id": "sympy.physics.quantum.gate.random_circuit",
    "type": "function",
    "description": "Return a random circuit of ngates and nqubits.\n\n    This uses an equally weighted sample of (X, Y, Z, S, T, H, CNOT, SWAP)\n    gates.\n\n    Parameters\n    ----------\n    ngates : int\n        The number of gates in the circuit.\n    nqubits : int\n        The number of qubits in the circuit.\n    gate_space : tuple\n        A tuple of the gate classes that will be used in the circuit.\n        Repeating gate classes multiple times in this tuple will increase\n        the frequency they appear in the random circuit.\n    ",
    "section": "Gates",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/gate.html"
  },
  {
    "name": "search_function",
    "full_id": "sympy.physics.quantum.grover.OracleGate.search_function",
    "type": "property",
    "description": "The unknown function that helps find the sought after qubits.",
    "section": "Grover\u2019s Algorithm",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/grover.html"
  },
  {
    "name": "apply_grover",
    "full_id": "sympy.physics.quantum.grover.apply_grover",
    "type": "function",
    "description": "Applies grover's algorithm.\n\n    Parameters\n    ==========\n\n    oracle : callable\n        The unknown callable function that returns true when applied to the\n        desired qubits and false otherwise.\n\n    Returns\n    =======\n\n    state : Expr\n        The resulting state after Grover's algorithm has been iterated.\n\n    Examples\n    ========\n\n    Apply grover's algorithm to an even superposition of 2 qubits::\n\n        >>> from sympy.physics.quantum.qapply import qapply\n        >>> from sympy.physics.quantum.qubit import IntQubit\n        >>> from sympy.physics.quantum.grover import apply_grover\n        >>> f = lambda qubits: qubits == IntQubit(2)\n        >>> qapply(apply_grover(f, 2))\n        |2>\n\n    ",
    "section": "Grover\u2019s Algorithm",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/grover.html"
  },
  {
    "name": "grover_iteration",
    "full_id": "sympy.physics.quantum.grover.grover_iteration",
    "type": "function",
    "description": "Applies one application of the Oracle and W Gate, WV.\n\n    Parameters\n    ==========\n\n    qstate : Qubit\n        A superposition of qubits.\n    oracle : OracleGate\n        The black box operator that flips the sign of the desired basis qubits.\n\n    Returns\n    =======\n\n    Qubit : The qubits after applying the Oracle and W gate.\n\n    Examples\n    ========\n\n    Perform one iteration of grover's algorithm to see a phase change::\n\n        >>> from sympy.physics.quantum.qapply import qapply\n        >>> from sympy.physics.quantum.qubit import IntQubit\n        >>> from sympy.physics.quantum.grover import OracleGate\n        >>> from sympy.physics.quantum.grover import superposition_basis\n        >>> from sympy.physics.quantum.grover import grover_iteration\n        >>> numqubits = 2\n        >>> basis_states = superposition_basis(numqubits)\n        >>> f = lambda qubits: qubits == IntQubit(2)\n        >>> v = OracleGate(numqubits, f)\n        >>> qapply(grover_iteration(basis_states, v))\n        |2>\n\n    ",
    "section": "Grover\u2019s Algorithm",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/grover.html"
  },
  {
    "name": "superposition_basis",
    "full_id": "sympy.physics.quantum.grover.superposition_basis",
    "type": "function",
    "description": "Creates an equal superposition of the computational basis.\n\n    Parameters\n    ==========\n\n    nqubits : int\n        The number of qubits.\n\n    Returns\n    =======\n\n    state : Qubit\n        An equal superposition of the computational basis with nqubits.\n\n    Examples\n    ========\n\n    Create an equal superposition of 2 qubits::\n\n        >>> from sympy.physics.quantum.grover import superposition_basis\n        >>> superposition_basis(2)\n        |0>/2 + |1>/2 + |2>/2 + |3>/2\n    ",
    "section": "Grover\u2019s Algorithm",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/grover.html"
  },
  {
    "name": "decompose",
    "full_id": "sympy.physics.quantum.qft.IQFT.decompose",
    "type": "method",
    "description": "Decomposes IQFT into elementary gates.",
    "section": "QFT",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qft.html"
  },
  {
    "name": "decompose",
    "full_id": "sympy.physics.quantum.qft.QFT.decompose",
    "type": "method",
    "description": "Decomposes QFT into elementary gates.",
    "section": "QFT",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qft.html"
  },
  {
    "name": "matrix_to_density",
    "full_id": "sympy.physics.quantum.qubit.matrix_to_density",
    "type": "function",
    "description": "\n    Works by finding the eigenvectors and eigenvalues of the matrix.\n    We know we can decompose rho by doing:\n    sum(EigenVal*|Eigenvect><Eigenvect|)\n    ",
    "section": "Qubit",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qubit.html"
  },
  {
    "name": "matrix_to_qubit",
    "full_id": "sympy.physics.quantum.qubit.matrix_to_qubit",
    "type": "function",
    "description": "Convert from the matrix repr. to a sum of Qubit objects.\n\n    Parameters\n    ----------\n    matrix : Matrix, numpy.matrix, scipy.sparse\n        The matrix to build the Qubit representation of. This works with\n        SymPy matrices, numpy matrices and scipy.sparse sparse matrices.\n\n    Examples\n    ========\n\n    Represent a state and then go back to its qubit form:\n\n        >>> from sympy.physics.quantum.qubit import matrix_to_qubit, Qubit\n        >>> from sympy.physics.quantum.represent import represent\n        >>> q = Qubit('01')\n        >>> matrix_to_qubit(represent(q))\n        |01>\n    ",
    "section": "Qubit",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qubit.html"
  },
  {
    "name": "measure_all",
    "full_id": "sympy.physics.quantum.qubit.measure_all",
    "type": "function",
    "description": "Perform an ensemble measurement of all qubits.\n\n    Parameters\n    ==========\n\n    qubit : Qubit, Add\n        The qubit to measure. This can be any Qubit or a linear combination\n        of them.\n    format : str\n        The format of the intermediate matrices to use. Possible values are\n        ('sympy','numpy','scipy.sparse'). Currently only 'sympy' is\n        implemented.\n\n    Returns\n    =======\n\n    result : list\n        A list that consists of primitive states and their probabilities.\n\n    Examples\n    ========\n\n        >>> from sympy.physics.quantum.qubit import Qubit, measure_all\n        >>> from sympy.physics.quantum.gate import H\n        >>> from sympy.physics.quantum.qapply import qapply\n\n        >>> c = H(0)*H(1)*Qubit('00')\n        >>> c\n        H(0)*H(1)*|00>\n        >>> q = qapply(c)\n        >>> measure_all(q)\n        [(|00>, 1/4), (|01>, 1/4), (|10>, 1/4), (|11>, 1/4)]\n    ",
    "section": "Qubit",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qubit.html"
  },
  {
    "name": "measure_all_oneshot",
    "full_id": "sympy.physics.quantum.qubit.measure_all_oneshot",
    "type": "function",
    "description": "Perform a oneshot ensemble measurement on all qubits.\n\n    A oneshot measurement is equivalent to performing a measurement on a\n    quantum system. This type of measurement does not return the probabilities\n    like an ensemble measurement does, but rather returns *one* of the\n    possible resulting states. The exact state that is returned is determined\n    by picking a state randomly according to the ensemble probabilities.\n\n    Parameters\n    ----------\n    qubits : Qubit\n        The qubit to measure.  This can be any Qubit or a linear combination\n        of them.\n    format : str\n        The format of the intermediate matrices to use. Possible values are\n        ('sympy','numpy','scipy.sparse'). Currently only 'sympy' is\n        implemented.\n\n    Returns\n    -------\n    result : Qubit\n        The qubit that the system collapsed to upon measurement.\n    ",
    "section": "Qubit",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qubit.html"
  },
  {
    "name": "measure_partial",
    "full_id": "sympy.physics.quantum.qubit.measure_partial",
    "type": "function",
    "description": "Perform a partial ensemble measure on the specified qubits.\n\n    Parameters\n    ==========\n\n    qubits : Qubit\n        The qubit to measure.  This can be any Qubit or a linear combination\n        of them.\n    bits : tuple\n        The qubits to measure.\n    format : str\n        The format of the intermediate matrices to use. Possible values are\n        ('sympy','numpy','scipy.sparse'). Currently only 'sympy' is\n        implemented.\n\n    Returns\n    =======\n\n    result : list\n        A list that consists of primitive states and their probabilities.\n\n    Examples\n    ========\n\n        >>> from sympy.physics.quantum.qubit import Qubit, measure_partial\n        >>> from sympy.physics.quantum.gate import H\n        >>> from sympy.physics.quantum.qapply import qapply\n\n        >>> c = H(0)*H(1)*Qubit('00')\n        >>> c\n        H(0)*H(1)*|00>\n        >>> q = qapply(c)\n        >>> measure_partial(q, (0,))\n        [(sqrt(2)*|00>/2 + sqrt(2)*|10>/2, 1/2), (sqrt(2)*|01>/2 + sqrt(2)*|11>/2, 1/2)]\n    ",
    "section": "Qubit",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qubit.html"
  },
  {
    "name": "measure_partial_oneshot",
    "full_id": "sympy.physics.quantum.qubit.measure_partial_oneshot",
    "type": "function",
    "description": "Perform a partial oneshot measurement on the specified qubits.\n\n    A oneshot measurement is equivalent to performing a measurement on a\n    quantum system. This type of measurement does not return the probabilities\n    like an ensemble measurement does, but rather returns *one* of the\n    possible resulting states. The exact state that is returned is determined\n    by picking a state randomly according to the ensemble probabilities.\n\n    Parameters\n    ----------\n    qubits : Qubit\n        The qubit to measure.  This can be any Qubit or a linear combination\n        of them.\n    bits : tuple\n        The qubits to measure.\n    format : str\n        The format of the intermediate matrices to use. Possible values are\n        ('sympy','numpy','scipy.sparse'). Currently only 'sympy' is\n        implemented.\n\n    Returns\n    -------\n    result : Qubit\n        The qubit that the system collapsed to upon measurement.\n    ",
    "section": "Qubit",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qubit.html"
  },
  {
    "name": "qubit_to_matrix",
    "full_id": "sympy.physics.quantum.qubit.qubit_to_matrix",
    "type": "function",
    "description": "Converts an Add/Mul of Qubit objects into it's matrix representation\n\n    This function is the inverse of ``matrix_to_qubit`` and is a shorthand\n    for ``represent(qubit)``.\n    ",
    "section": "Qubit",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/qubit.html"
  },
  {
    "name": "N",
    "full_id": "sympy.physics.quantum.shor.CMod.N",
    "type": "property",
    "description": "N is the type of modular arithmetic we are doing.",
    "section": "Shor\u2019s Algorithm",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/shor.html"
  },
  {
    "name": "a",
    "full_id": "sympy.physics.quantum.shor.CMod.a",
    "type": "property",
    "description": "Base of the controlled mod function.",
    "section": "Shor\u2019s Algorithm",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/shor.html"
  },
  {
    "name": "t",
    "full_id": "sympy.physics.quantum.shor.CMod.t",
    "type": "property",
    "description": "Size of 1/2 input register.  First 1/2 holds output.",
    "section": "Shor\u2019s Algorithm",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/shor.html"
  },
  {
    "name": "period_find",
    "full_id": "sympy.physics.quantum.shor.period_find",
    "type": "function",
    "description": "Finds the period of a in modulo N arithmetic\n\n    This is quantum part of Shor's algorithm. It takes two registers,\n    puts first in superposition of states with Hadamards so: ``|k>|0>``\n    with k being all possible choices. It then does a controlled mod and\n    a QFT to determine the order of a.\n    ",
    "section": "Shor\u2019s Algorithm",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/shor.html"
  },
  {
    "name": "shor",
    "full_id": "sympy.physics.quantum.shor.shor",
    "type": "function",
    "description": "This function implements Shor's factoring algorithm on the Integer N\n\n    The algorithm starts by picking a random number (a) and seeing if it is\n    coprime with N. If it is not, then the gcd of the two numbers is a factor\n    and we are done. Otherwise, it begins the period_finding subroutine which\n    finds the period of a in modulo N arithmetic. This period, if even, can\n    be used to calculate factors by taking a**(r/2)-1 and a**(r/2)+1.\n    These values are returned.\n    ",
    "section": "Shor\u2019s Algorithm",
    "url": "https://docs.sympy.org/latest/modules/physics/quantum/shor.html"
  },
  {
    "name": "divergence",
    "full_id": "sympy.physics.optics.gaussopt.BeamParameter.divergence",
    "type": "property",
    "description": "\n        Half of the total angular spread.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import BeamParameter\n        >>> p = BeamParameter(530e-9, 1, w=1e-3)\n        >>> p.divergence\n        0.00053/pi\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "gouy",
    "full_id": "sympy.physics.optics.gaussopt.BeamParameter.gouy",
    "type": "property",
    "description": "\n        The Gouy phase.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import BeamParameter\n        >>> p = BeamParameter(530e-9, 1, w=1e-3)\n        >>> p.gouy\n        atan(0.53/pi)\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "q",
    "full_id": "sympy.physics.optics.gaussopt.BeamParameter.q",
    "type": "property",
    "description": "\n        The complex parameter representing the beam.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import BeamParameter\n        >>> p = BeamParameter(530e-9, 1, w=1e-3)\n        >>> p.q\n        1 + 1.88679245283019*I*pi\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "radius",
    "full_id": "sympy.physics.optics.gaussopt.BeamParameter.radius",
    "type": "property",
    "description": "\n        The radius of curvature of the phase front.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import BeamParameter\n        >>> p = BeamParameter(530e-9, 1, w=1e-3)\n        >>> p.radius\n        1 + 3.55998576005696*pi**2\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "w",
    "full_id": "sympy.physics.optics.gaussopt.BeamParameter.w",
    "type": "property",
    "description": "\n        The radius of the beam w(z), at any position z along the beam.\n        The beam radius at `1/e^2` intensity (axial value).\n\n        See Also\n        ========\n\n        w_0 :\n            The minimal radius of beam.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import BeamParameter\n        >>> p = BeamParameter(530e-9, 1, w=1e-3)\n        >>> p.w\n        0.001*sqrt(0.2809/pi**2 + 1)\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "w_0",
    "full_id": "sympy.physics.optics.gaussopt.BeamParameter.w_0",
    "type": "property",
    "description": "\n         The minimal radius of beam at `1/e^2` intensity (peak value).\n\n        See Also\n        ========\n\n        w : the beam radius at `1/e^2` intensity (axial value).\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import BeamParameter\n        >>> p = BeamParameter(530e-9, 1, w=1e-3)\n        >>> p.w_0\n        0.00100000000000000\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "waist_approximation_limit",
    "full_id": "sympy.physics.optics.gaussopt.BeamParameter.waist_approximation_limit",
    "type": "property",
    "description": "\n        The minimal waist for which the gauss beam approximation is valid.\n\n        Explanation\n        ===========\n\n        The gauss beam is a solution to the paraxial equation. For curvatures\n        that are too great it is not a valid approximation.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import BeamParameter\n        >>> p = BeamParameter(530e-9, 1, w=1e-3)\n        >>> p.waist_approximation_limit\n        1.06e-6/pi\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "angle",
    "full_id": "sympy.physics.optics.gaussopt.GeometricRay.angle",
    "type": "property",
    "description": "\n        The angle with the optical axis.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import GeometricRay\n        >>> from sympy import symbols\n        >>> h, angle = symbols('h, angle')\n        >>> gRay = GeometricRay(h, angle)\n        >>> gRay.angle\n        angle\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "height",
    "full_id": "sympy.physics.optics.gaussopt.GeometricRay.height",
    "type": "property",
    "description": "\n        The distance from the optical axis.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import GeometricRay\n        >>> from sympy import symbols\n        >>> h, angle = symbols('h, angle')\n        >>> gRay = GeometricRay(h, angle)\n        >>> gRay.height\n        h\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "A",
    "full_id": "sympy.physics.optics.gaussopt.RayTransferMatrix.A",
    "type": "property",
    "description": "\n        The A parameter of the Matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import RayTransferMatrix\n        >>> mat = RayTransferMatrix(1, 2, 3, 4)\n        >>> mat.A\n        1\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "B",
    "full_id": "sympy.physics.optics.gaussopt.RayTransferMatrix.B",
    "type": "property",
    "description": "\n        The B parameter of the Matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import RayTransferMatrix\n        >>> mat = RayTransferMatrix(1, 2, 3, 4)\n        >>> mat.B\n        2\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "C",
    "full_id": "sympy.physics.optics.gaussopt.RayTransferMatrix.C",
    "type": "property",
    "description": "\n        The C parameter of the Matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import RayTransferMatrix\n        >>> mat = RayTransferMatrix(1, 2, 3, 4)\n        >>> mat.C\n        3\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "D",
    "full_id": "sympy.physics.optics.gaussopt.RayTransferMatrix.D",
    "type": "property",
    "description": "\n        The D parameter of the Matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import RayTransferMatrix\n        >>> mat = RayTransferMatrix(1, 2, 3, 4)\n        >>> mat.D\n        4\n        ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "conjugate_gauss_beams",
    "full_id": "sympy.physics.optics.gaussopt.conjugate_gauss_beams",
    "type": "function",
    "description": "\n    Find the optical setup conjugating the object/image waists.\n\n    Parameters\n    ==========\n\n    wavelen :\n        The wavelength of the beam.\n    waist_in and waist_out :\n        The waists to be conjugated.\n    f :\n        The focal distance of the element used in the conjugation.\n\n    Returns\n    =======\n\n    a tuple containing (s_in, s_out, f)\n    s_in :\n        The distance before the optical element.\n    s_out :\n        The distance after the optical element.\n    f :\n        The focal distance of the optical element.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import conjugate_gauss_beams\n    >>> from sympy import symbols, factor\n    >>> l, w_i, w_o, f = symbols('l w_i w_o f')\n\n    >>> conjugate_gauss_beams(l, w_i, w_o, f=f)[0]\n    f*(1 - sqrt(w_i**2/w_o**2 - pi**2*w_i**4/(f**2*l**2)))\n\n    >>> factor(conjugate_gauss_beams(l, w_i, w_o, f=f)[1])\n    f*w_o**2*(w_i**2/w_o**2 - sqrt(w_i**2/w_o**2 -\n              pi**2*w_i**4/(f**2*l**2)))/w_i**2\n\n    >>> conjugate_gauss_beams(l, w_i, w_o, f=f)[2]\n    f\n    ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "gaussian_conj",
    "full_id": "sympy.physics.optics.gaussopt.gaussian_conj",
    "type": "function",
    "description": "\n    Conjugation relation for gaussian beams.\n\n    Parameters\n    ==========\n\n    s_in :\n        The distance to optical element from the waist.\n    z_r_in :\n        The rayleigh range of the incident beam.\n    f :\n        The focal length of the optical element.\n\n    Returns\n    =======\n\n    a tuple containing (s_out, z_r_out, m)\n    s_out :\n        The distance between the new waist and the optical element.\n    z_r_out :\n        The rayleigh range of the emergent beam.\n    m :\n        The ration between the new and the old waists.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import gaussian_conj\n    >>> from sympy import symbols\n    >>> s_in, z_r_in, f = symbols('s_in z_r_in f')\n\n    >>> gaussian_conj(s_in, z_r_in, f)[0]\n    1/(-1/(s_in + z_r_in**2/(-f + s_in)) + 1/f)\n\n    >>> gaussian_conj(s_in, z_r_in, f)[1]\n    z_r_in/(1 - s_in**2/f**2 + z_r_in**2/f**2)\n\n    >>> gaussian_conj(s_in, z_r_in, f)[2]\n    1/sqrt(1 - s_in**2/f**2 + z_r_in**2/f**2)\n    ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "geometric_conj_ab",
    "full_id": "sympy.physics.optics.gaussopt.geometric_conj_ab",
    "type": "function",
    "description": "\n    Conjugation relation for geometrical beams under paraxial conditions.\n\n    Explanation\n    ===========\n\n    Takes the distances to the optical element and returns the needed\n    focal distance.\n\n    See Also\n    ========\n\n    geometric_conj_af, geometric_conj_bf\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import geometric_conj_ab\n    >>> from sympy import symbols\n    >>> a, b = symbols('a b')\n    >>> geometric_conj_ab(a, b)\n    a*b/(a + b)\n    ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "geometric_conj_af",
    "full_id": "sympy.physics.optics.gaussopt.geometric_conj_af",
    "type": "function",
    "description": "\n    Conjugation relation for geometrical beams under paraxial conditions.\n\n    Explanation\n    ===========\n\n    Takes the object distance (for geometric_conj_af) or the image distance\n    (for geometric_conj_bf) to the optical element and the focal distance.\n    Then it returns the other distance needed for conjugation.\n\n    See Also\n    ========\n\n    geometric_conj_ab\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics.gaussopt import geometric_conj_af, geometric_conj_bf\n    >>> from sympy import symbols\n    >>> a, b, f = symbols('a b f')\n    >>> geometric_conj_af(a, f)\n    a*f/(a - f)\n    >>> geometric_conj_bf(b, f)\n    b*f/(b - f)\n    ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "rayleigh2waist",
    "full_id": "sympy.physics.optics.gaussopt.rayleigh2waist",
    "type": "function",
    "description": "Calculate the waist from the rayleigh range of a gaussian beam.\n\n    See Also\n    ========\n\n    waist2rayleigh, BeamParameter\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import rayleigh2waist\n    >>> from sympy import symbols\n    >>> z_r, wavelen = symbols('z_r wavelen')\n    >>> rayleigh2waist(z_r, wavelen)\n    sqrt(wavelen*z_r)/sqrt(pi)\n    ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "waist2rayleigh",
    "full_id": "sympy.physics.optics.gaussopt.waist2rayleigh",
    "type": "function",
    "description": "\n    Calculate the rayleigh range from the waist of a gaussian beam.\n\n    See Also\n    ========\n\n    rayleigh2waist, BeamParameter\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import waist2rayleigh\n    >>> from sympy import symbols\n    >>> w, wavelen = symbols('w wavelen')\n    >>> waist2rayleigh(w, wavelen)\n    pi*w**2/wavelen\n    ",
    "section": "Gaussian Optics",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/gaussopt.html"
  },
  {
    "name": "refractive_index",
    "full_id": "sympy.physics.optics.medium.Medium.refractive_index",
    "type": "property",
    "description": "\n        Returns refractive index of the medium.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import Medium\n        >>> m = Medium('m')\n        >>> m.refractive_index\n        1\n\n        ",
    "section": "Medium",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/medium.html"
  },
  {
    "name": "speed",
    "full_id": "sympy.physics.optics.medium.Medium.speed",
    "type": "property",
    "description": "\n        Returns speed of the electromagnetic wave travelling in the medium.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.optics import Medium\n        >>> m = Medium('m')\n        >>> m.speed\n        299792458*meter/second\n        >>> m2 = Medium('m2', n=1)\n        >>> m.speed == m2.speed\n        True\n\n        ",
    "section": "Medium",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/medium.html"
  },
  {
    "name": "half_wave_retarder",
    "full_id": "sympy.physics.optics.polarization.half_wave_retarder",
    "type": "function",
    "description": "A half-wave retarder Jones matrix at angle ``theta``.\n\n    Parameters\n    ==========\n\n    theta : numeric type or SymPy Symbol\n        The angle of the fast axis relative to the horizontal plane.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the retarder.\n\n    Examples\n    ========\n\n    A generic half-wave plate.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import half_wave_retarder\n    >>> theta= symbols(\"theta\", real=True)\n    >>> HWP = half_wave_retarder(theta)\n    >>> pprint(HWP, use_unicode=True)\n    \u23a1   \u239b     2         2   \u239e                        \u23a4\n    \u23a2-\u2148\u22c5\u239d- sin (\u03b8) + cos (\u03b8)\u23a0    -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u23a5\n    \u23a2                                                \u23a5\n    \u23a2                             \u239b   2         2   \u239e\u23a5\n    \u23a3   -2\u22c5\u2148\u22c5sin(\u03b8)\u22c5cos(\u03b8)     -\u2148\u22c5\u239dsin (\u03b8) - cos (\u03b8)\u23a0\u23a6\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "jones_2_stokes",
    "full_id": "sympy.physics.optics.polarization.jones_2_stokes",
    "type": "function",
    "description": "Return the Stokes vector for a Jones vector ``e``.\n\n    Parameters\n    ==========\n\n    e : SymPy Matrix\n        A Jones vector.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones vector.\n\n    Examples\n    ========\n\n    The axes on the Poincar\u00e9 sphere.\n\n    >>> from sympy import pprint, pi\n    >>> from sympy.physics.optics.polarization import jones_vector\n    >>> from sympy.physics.optics.polarization import jones_2_stokes\n    >>> H = jones_vector(0, 0)\n    >>> V = jones_vector(pi/2, 0)\n    >>> D = jones_vector(pi/4, 0)\n    >>> A = jones_vector(-pi/4, 0)\n    >>> R = jones_vector(0, pi/4)\n    >>> L = jones_vector(0, -pi/4)\n    >>> pprint([jones_2_stokes(e) for e in [H, V, D, A, R, L]],\n    ...         use_unicode=True)\n    \u23a1\u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4  \u23a11\u23a4  \u23a11 \u23a4\u23a4\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\n    \u23a2\u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\n    \u23a2\u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5, \u23a2 \u23a5, \u23a2  \u23a5\u23a5\n    \u23a2\u23a20\u23a5  \u23a20 \u23a5  \u23a21\u23a5  \u23a2-1\u23a5  \u23a20\u23a5  \u23a20 \u23a5\u23a5\n    \u23a2\u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5  \u23a2 \u23a5  \u23a2  \u23a5\u23a5\n    \u23a3\u23a30\u23a6  \u23a30 \u23a6  \u23a30\u23a6  \u23a30 \u23a6  \u23a31\u23a6  \u23a3-1\u23a6\u23a6\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "jones_vector",
    "full_id": "sympy.physics.optics.polarization.jones_vector",
    "type": "function",
    "description": "A Jones vector corresponding to a polarization ellipse with `psi` tilt,\n    and `chi` circularity.\n\n    Parameters\n    ==========\n\n    psi : numeric type or SymPy Symbol\n        The tilt of the polarization relative to the `x` axis.\n\n    chi : numeric type or SymPy Symbol\n        The angle adjacent to the mayor axis of the polarization ellipse.\n\n\n    Returns\n    =======\n\n    Matrix :\n        A Jones vector.\n\n    Examples\n    ========\n\n    The axes on the Poincar\u00e9 sphere.\n\n    >>> from sympy import pprint, symbols, pi\n    >>> from sympy.physics.optics.polarization import jones_vector\n    >>> psi, chi = symbols(\"psi, chi\", real=True)\n\n    A general Jones vector.\n\n    >>> pprint(jones_vector(psi, chi), use_unicode=True)\n    \u23a1-\u2148\u22c5sin(\u03c7)\u22c5sin(\u03c8) + cos(\u03c7)\u22c5cos(\u03c8)\u23a4\n    \u23a2                                \u23a5\n    \u23a3\u2148\u22c5sin(\u03c7)\u22c5cos(\u03c8) + sin(\u03c8)\u22c5cos(\u03c7) \u23a6\n\n    Horizontal polarization.\n\n    >>> pprint(jones_vector(0, 0), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a30\u23a6\n\n    Vertical polarization.\n\n    >>> pprint(jones_vector(pi/2, 0), use_unicode=True)\n    \u23a10\u23a4\n    \u23a2 \u23a5\n    \u23a31\u23a6\n\n    Diagonal polarization.\n\n    >>> pprint(jones_vector(pi/4, 0), use_unicode=True)\n    \u23a1\u221a2\u23a4\n    \u23a2\u2500\u2500\u23a5\n    \u23a22 \u23a5\n    \u23a2  \u23a5\n    \u23a2\u221a2\u23a5\n    \u23a2\u2500\u2500\u23a5\n    \u23a32 \u23a6\n\n    Anti-diagonal polarization.\n\n    >>> pprint(jones_vector(-pi/4, 0), use_unicode=True)\n    \u23a1 \u221a2 \u23a4\n    \u23a2 \u2500\u2500 \u23a5\n    \u23a2 2  \u23a5\n    \u23a2    \u23a5\n    \u23a2-\u221a2 \u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\n    \u23a3 2  \u23a6\n\n    Right-hand circular polarization.\n\n    >>> pprint(jones_vector(0, pi/4), use_unicode=True)\n    \u23a1 \u221a2 \u23a4\n    \u23a2 \u2500\u2500 \u23a5\n    \u23a2 2  \u23a5\n    \u23a2    \u23a5\n    \u23a2\u221a2\u22c5\u2148\u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u23a5\n    \u23a3 2  \u23a6\n\n    Left-hand circular polarization.\n\n    >>> pprint(jones_vector(0, -pi/4), use_unicode=True)\n    \u23a1  \u221a2  \u23a4\n    \u23a2  \u2500\u2500  \u23a5\n    \u23a2  2   \u23a5\n    \u23a2      \u23a5\n    \u23a2-\u221a2\u22c5\u2148 \u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u23a5\n    \u23a3  2   \u23a6\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "linear_polarizer",
    "full_id": "sympy.physics.optics.polarization.linear_polarizer",
    "type": "function",
    "description": "A linear polarizer Jones matrix with transmission axis at\n    an angle ``theta``.\n\n    Parameters\n    ==========\n\n    theta : numeric type or SymPy Symbol\n        The angle of the transmission axis relative to the horizontal plane.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the polarizer.\n\n    Examples\n    ========\n\n    A generic polarizer.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import linear_polarizer\n    >>> theta = symbols(\"theta\", real=True)\n    >>> J = linear_polarizer(theta)\n    >>> pprint(J, use_unicode=True)\n    \u23a1      2                     \u23a4\n    \u23a2   cos (\u03b8)     sin(\u03b8)\u22c5cos(\u03b8)\u23a5\n    \u23a2                            \u23a5\n    \u23a2                     2      \u23a5\n    \u23a3sin(\u03b8)\u22c5cos(\u03b8)     sin (\u03b8)   \u23a6\n\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "mueller_matrix",
    "full_id": "sympy.physics.optics.polarization.mueller_matrix",
    "type": "function",
    "description": "The Mueller matrix corresponding to Jones matrix `J`.\n\n    Parameters\n    ==========\n\n    J : SymPy Matrix\n        A Jones matrix.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        The corresponding Mueller matrix.\n\n    Examples\n    ========\n\n    Generic optical components.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import (mueller_matrix,\n    ...     linear_polarizer, half_wave_retarder, quarter_wave_retarder)\n    >>> theta = symbols(\"theta\", real=True)\n\n    A linear_polarizer\n\n    >>> pprint(mueller_matrix(linear_polarizer(theta)), use_unicode=True)\n    \u23a1            cos(2\u22c5\u03b8)      sin(2\u22c5\u03b8)     \u23a4\n    \u23a2  1/2       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\n    \u23a2               2             2         \u23a5\n    \u23a2                                       \u23a5\n    \u23a2cos(2\u22c5\u03b8)  cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)     \u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    0\u23a5\n    \u23a2   2         4       4       4         \u23a5\n    \u23a2                                       \u23a5\n    \u23a2sin(2\u22c5\u03b8)    sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)   \u23a5\n    \u23a2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  0\u23a5\n    \u23a2   2           4        4      4       \u23a5\n    \u23a2                                       \u23a5\n    \u23a3   0           0             0        0\u23a6\n\n    A half-wave plate\n\n    >>> pprint(mueller_matrix(half_wave_retarder(theta)), use_unicode=True)\n    \u23a11              0                           0               0 \u23a4\n    \u23a2                                                             \u23a5\n    \u23a2        4           2                                        \u23a5\n    \u23a20  8\u22c5sin (\u03b8) - 8\u22c5sin (\u03b8) + 1           sin(4\u22c5\u03b8)            0 \u23a5\n    \u23a2                                                             \u23a5\n    \u23a2                                     4           2           \u23a5\n    \u23a20          sin(4\u22c5\u03b8)           - 8\u22c5sin (\u03b8) + 8\u22c5sin (\u03b8) - 1  0 \u23a5\n    \u23a2                                                             \u23a5\n    \u23a30              0                           0               -1\u23a6\n\n    A quarter-wave plate\n\n    >>> pprint(mueller_matrix(quarter_wave_retarder(theta)), use_unicode=True)\n    \u23a11       0             0            0    \u23a4\n    \u23a2                                        \u23a5\n    \u23a2   cos(4\u22c5\u03b8)   1    sin(4\u22c5\u03b8)             \u23a5\n    \u23a20  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 + \u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    -sin(2\u22c5\u03b8)\u23a5\n    \u23a2      2       2       2                 \u23a5\n    \u23a2                                        \u23a5\n    \u23a2     sin(4\u22c5\u03b8)    1   cos(4\u22c5\u03b8)           \u23a5\n    \u23a20    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500 - \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  cos(2\u22c5\u03b8) \u23a5\n    \u23a2        2        2      2               \u23a5\n    \u23a2                                        \u23a5\n    \u23a30    sin(2\u22c5\u03b8)     -cos(2\u22c5\u03b8)        0    \u23a6\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "phase_retarder",
    "full_id": "sympy.physics.optics.polarization.phase_retarder",
    "type": "function",
    "description": "A phase retarder Jones matrix with retardance ``delta`` at angle ``theta``.\n\n    Parameters\n    ==========\n\n    theta : numeric type or SymPy Symbol\n        The angle of the fast axis relative to the horizontal plane.\n    delta : numeric type or SymPy Symbol\n        The phase difference between the fast and slow axes of the\n        transmitted light.\n\n    Returns\n    =======\n\n    SymPy Matrix :\n        A Jones matrix representing the retarder.\n\n    Examples\n    ========\n\n    A generic retarder.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import phase_retarder\n    >>> theta, delta = symbols(\"theta, delta\", real=True)\n    >>> R = phase_retarder(theta, delta)\n    >>> pprint(R, use_unicode=True)\n    \u23a1                          -\u2148\u22c5\u03b4               -\u2148\u22c5\u03b4               \u23a4\n    \u23a2                          \u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500              \u23a5\n    \u23a2\u239b \u2148\u22c5\u03b4    2         2   \u239e    2    \u239b     \u2148\u22c5\u03b4\u239e    2                \u23a5\n    \u23a2\u239d\u212f   \u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       \u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\n    \u23a2                                                                \u23a5\n    \u23a2            -\u2148\u22c5\u03b4                                           -\u2148\u22c5\u03b4 \u23a5\n    \u23a2            \u2500\u2500\u2500\u2500\u2500                                          \u2500\u2500\u2500\u2500\u2500\u23a5\n    \u23a2\u239b     \u2148\u22c5\u03b4\u239e    2                  \u239b \u2148\u22c5\u03b4    2         2   \u239e    2  \u23a5\n    \u23a3\u239d1 - \u212f   \u23a0\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239d\u212f   \u22c5cos (\u03b8) + sin (\u03b8)\u23a0\u22c5\u212f     \u23a6\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "polarizing_beam_splitter",
    "full_id": "sympy.physics.optics.polarization.polarizing_beam_splitter",
    "type": "function",
    "description": "A polarizing beam splitter Jones matrix at angle `theta`.\n\n    Parameters\n    ==========\n\n    J : SymPy Matrix\n        A Jones matrix.\n    Tp : numeric type or SymPy Symbol\n        The transmissivity of the P-polarized component.\n    Rs : numeric type or SymPy Symbol\n        The reflectivity of the S-polarized component.\n    Ts : numeric type or SymPy Symbol\n        The transmissivity of the S-polarized component.\n    Rp : numeric type or SymPy Symbol\n        The reflectivity of the P-polarized component.\n    phia : numeric type or SymPy Symbol\n        The phase difference between transmitted and reflected component for\n        output mode a.\n    phib : numeric type or SymPy Symbol\n        The phase difference between transmitted and reflected component for\n        output mode b.\n\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A 4x4 matrix representing the PBS. This matrix acts on a 4x1 vector\n        whose first two entries are the Jones vector on one of the PBS ports,\n        and the last two entries the Jones vector on the other port.\n\n    Examples\n    ========\n\n    Generic polarizing beam-splitter.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import polarizing_beam_splitter\n    >>> Ts, Rs, Tp, Rp = symbols(r\"Ts, Rs, Tp, Rp\", positive=True)\n    >>> phia, phib = symbols(\"phi_a, phi_b\", real=True)\n    >>> PBS = polarizing_beam_splitter(Tp, Rs, Ts, Rp, phia, phib)\n    >>> pprint(PBS, use_unicode=False)\n    [   ____                           ____                    ]\n    [ \\/ Tp            0           I*\\/ Rp           0         ]\n    [                                                          ]\n    [                  ____                       ____  I*phi_a]\n    [   0            \\/ Ts            0      -I*\\/ Rs *e       ]\n    [                                                          ]\n    [    ____                         ____                     ]\n    [I*\\/ Rp           0            \\/ Tp            0         ]\n    [                                                          ]\n    [               ____  I*phi_b                    ____      ]\n    [   0      -I*\\/ Rs *e            0            \\/ Ts       ]\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "quarter_wave_retarder",
    "full_id": "sympy.physics.optics.polarization.quarter_wave_retarder",
    "type": "function",
    "description": "A quarter-wave retarder Jones matrix at angle ``theta``.\n\n    Parameters\n    ==========\n\n    theta : numeric type or SymPy Symbol\n        The angle of the fast axis relative to the horizontal plane.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the retarder.\n\n    Examples\n    ========\n\n    A generic quarter-wave plate.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import quarter_wave_retarder\n    >>> theta= symbols(\"theta\", real=True)\n    >>> QWP = quarter_wave_retarder(theta)\n    >>> pprint(QWP, use_unicode=True)\n    \u23a1                       -\u2148\u22c5\u03c0            -\u2148\u22c5\u03c0               \u23a4\n    \u23a2                       \u2500\u2500\u2500\u2500\u2500           \u2500\u2500\u2500\u2500\u2500              \u23a5\n    \u23a2\u239b     2         2   \u239e    4               4                \u23a5\n    \u23a2\u239d\u2148\u22c5sin (\u03b8) + cos (\u03b8)\u23a0\u22c5\u212f       (1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)\u23a5\n    \u23a2                                                          \u23a5\n    \u23a2         -\u2148\u22c5\u03c0                                        -\u2148\u22c5\u03c0 \u23a5\n    \u23a2         \u2500\u2500\u2500\u2500\u2500                                       \u2500\u2500\u2500\u2500\u2500\u23a5\n    \u23a2           4                  \u239b   2           2   \u239e    4  \u23a5\n    \u23a3(1 - \u2148)\u22c5\u212f     \u22c5sin(\u03b8)\u22c5cos(\u03b8)  \u239dsin (\u03b8) + \u2148\u22c5cos (\u03b8)\u23a0\u22c5\u212f     \u23a6\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "reflective_filter",
    "full_id": "sympy.physics.optics.polarization.reflective_filter",
    "type": "function",
    "description": "A reflective filter Jones matrix with reflectance ``R``.\n\n    Parameters\n    ==========\n\n    R : numeric type or SymPy Symbol\n        The reflectance of the filter.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the filter.\n\n    Examples\n    ========\n\n    A generic filter.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import reflective_filter\n    >>> R = symbols(\"R\", real=True)\n    >>> pprint(reflective_filter(R), use_unicode=True)\n    \u23a1\u221aR   0 \u23a4\n    \u23a2       \u23a5\n    \u23a30   -\u221aR\u23a6\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "stokes_vector",
    "full_id": "sympy.physics.optics.polarization.stokes_vector",
    "type": "function",
    "description": "A Stokes vector corresponding to a polarization ellipse with ``psi``\n    tilt, and ``chi`` circularity.\n\n    Parameters\n    ==========\n\n    psi : numeric type or SymPy Symbol\n        The tilt of the polarization relative to the ``x`` axis.\n    chi : numeric type or SymPy Symbol\n        The angle adjacent to the mayor axis of the polarization ellipse.\n    p : numeric type or SymPy Symbol\n        The degree of polarization.\n    I : numeric type or SymPy Symbol\n        The intensity of the field.\n\n\n    Returns\n    =======\n\n    Matrix :\n        A Stokes vector.\n\n    Examples\n    ========\n\n    The axes on the Poincar\u00e9 sphere.\n\n    >>> from sympy import pprint, symbols, pi\n    >>> from sympy.physics.optics.polarization import stokes_vector\n    >>> psi, chi, p, I = symbols(\"psi, chi, p, I\", real=True)\n    >>> pprint(stokes_vector(psi, chi, p, I), use_unicode=True)\n    \u23a1          I          \u23a4\n    \u23a2                     \u23a5\n    \u23a2I\u22c5p\u22c5cos(2\u22c5\u03c7)\u22c5cos(2\u22c5\u03c8)\u23a5\n    \u23a2                     \u23a5\n    \u23a2I\u22c5p\u22c5sin(2\u22c5\u03c8)\u22c5cos(2\u22c5\u03c7)\u23a5\n    \u23a2                     \u23a5\n    \u23a3    I\u22c5p\u22c5sin(2\u22c5\u03c7)     \u23a6\n\n\n    Horizontal polarization\n\n    >>> pprint(stokes_vector(0, 0), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a21\u23a5\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a30\u23a6\n\n    Vertical polarization\n\n    >>> pprint(stokes_vector(pi/2, 0), use_unicode=True)\n    \u23a11 \u23a4\n    \u23a2  \u23a5\n    \u23a2-1\u23a5\n    \u23a2  \u23a5\n    \u23a20 \u23a5\n    \u23a2  \u23a5\n    \u23a30 \u23a6\n\n    Diagonal polarization\n\n    >>> pprint(stokes_vector(pi/4, 0), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a21\u23a5\n    \u23a2 \u23a5\n    \u23a30\u23a6\n\n    Anti-diagonal polarization\n\n    >>> pprint(stokes_vector(-pi/4, 0), use_unicode=True)\n    \u23a11 \u23a4\n    \u23a2  \u23a5\n    \u23a20 \u23a5\n    \u23a2  \u23a5\n    \u23a2-1\u23a5\n    \u23a2  \u23a5\n    \u23a30 \u23a6\n\n    Right-hand circular polarization\n\n    >>> pprint(stokes_vector(0, pi/4), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a31\u23a6\n\n    Left-hand circular polarization\n\n    >>> pprint(stokes_vector(0, -pi/4), use_unicode=True)\n    \u23a11 \u23a4\n    \u23a2  \u23a5\n    \u23a20 \u23a5\n    \u23a2  \u23a5\n    \u23a20 \u23a5\n    \u23a2  \u23a5\n    \u23a3-1\u23a6\n\n    Unpolarized light\n\n    >>> pprint(stokes_vector(0, 0, 0), use_unicode=True)\n    \u23a11\u23a4\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a20\u23a5\n    \u23a2 \u23a5\n    \u23a30\u23a6\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "transmissive_filter",
    "full_id": "sympy.physics.optics.polarization.transmissive_filter",
    "type": "function",
    "description": "An attenuator Jones matrix with transmittance ``T``.\n\n    Parameters\n    ==========\n\n    T : numeric type or SymPy Symbol\n        The transmittance of the attenuator.\n\n    Returns\n    =======\n\n    SymPy Matrix\n        A Jones matrix representing the filter.\n\n    Examples\n    ========\n\n    A generic filter.\n\n    >>> from sympy import pprint, symbols\n    >>> from sympy.physics.optics.polarization import transmissive_filter\n    >>> T = symbols(\"T\", real=True)\n    >>> NDF = transmissive_filter(T)\n    >>> pprint(NDF, use_unicode=True)\n    \u23a1\u221aT  0 \u23a4\n    \u23a2      \u23a5\n    \u23a30   \u221aT\u23a6\n\n    ",
    "section": "References",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/polarization.html"
  },
  {
    "name": "brewster_angle",
    "full_id": "sympy.physics.optics.utils.brewster_angle",
    "type": "function",
    "description": "\n    This function calculates the Brewster's angle of incidence to Medium 2 from\n    Medium 1 in radians.\n\n    Parameters\n    ==========\n\n    medium 1 : Medium or sympifiable\n        Refractive index of Medium 1\n    medium 2 : Medium or sympifiable\n        Refractive index of Medium 1\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import brewster_angle\n    >>> brewster_angle(1, 1.33)\n    0.926093295503462\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "critical_angle",
    "full_id": "sympy.physics.optics.utils.critical_angle",
    "type": "function",
    "description": "\n    This function calculates the critical angle of incidence (marking the onset\n    of total internal) to Medium 2 from Medium 1 in radians.\n\n    Parameters\n    ==========\n\n    medium 1 : Medium or sympifiable\n        Refractive index of Medium 1.\n    medium 2 : Medium or sympifiable\n        Refractive index of Medium 1.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import critical_angle\n    >>> critical_angle(1.33, 1)\n    0.850908514477849\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "deviation",
    "full_id": "sympy.physics.optics.utils.deviation",
    "type": "function",
    "description": "\n    This function calculates the angle of deviation of a ray\n    due to refraction at planar surface.\n\n    Parameters\n    ==========\n\n    incident : Matrix, Ray3D, sequence or float\n        Incident vector or angle of incidence\n    medium1 : sympy.physics.optics.medium.Medium or sympifiable\n        Medium 1 or its refractive index\n    medium2 : sympy.physics.optics.medium.Medium or sympifiable\n        Medium 2 or its refractive index\n    normal : Matrix, Ray3D, or sequence\n        Normal vector\n    plane : Plane\n        Plane of separation of the two media.\n\n    Returns angular deviation between incident and refracted rays\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import deviation\n    >>> from sympy.geometry import Point3D, Ray3D, Plane\n    >>> from sympy.matrices import Matrix\n    >>> from sympy import symbols\n    >>> n1, n2 = symbols('n1, n2')\n    >>> n = Matrix([0, 0, 1])\n    >>> P = Plane(Point3D(0, 0, 0), normal_vector=[0, 0, 1])\n    >>> r1 = Ray3D(Point3D(-1, -1, 1), Point3D(0, 0, 0))\n    >>> deviation(r1, 1, 1, n)\n    0\n    >>> deviation(r1, n1, n2, plane=P)\n    -acos(-sqrt(-2*n1**2/(3*n2**2) + 1)) + acos(-sqrt(3)/3)\n    >>> round(deviation(0.1, 1.2, 1.5), 5)\n    -0.02005\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "fresnel_coefficients",
    "full_id": "sympy.physics.optics.utils.fresnel_coefficients",
    "type": "function",
    "description": "\n    This function uses Fresnel equations to calculate reflection and\n    transmission coefficients. Those are obtained for both polarisations\n    when the electric field vector is in the plane of incidence (labelled 'p')\n    and when the electric field vector is perpendicular to the plane of\n    incidence (labelled 's'). There are four real coefficients unless the\n    incident ray reflects in total internal in which case there are two complex\n    ones. Angle of incidence is the angle between the incident ray and the\n    surface normal. ``medium1`` and ``medium2`` can be ``Medium`` or any\n    sympifiable object.\n\n    Parameters\n    ==========\n\n    angle_of_incidence : sympifiable\n\n    medium1 : Medium or sympifiable\n        Medium 1 or its refractive index\n\n    medium2 : Medium or sympifiable\n        Medium 2 or its refractive index\n\n    Returns\n    =======\n\n    Returns a list with four real Fresnel coefficients:\n    [reflection p (TM), reflection s (TE),\n    transmission p (TM), transmission s (TE)]\n    If the ray is undergoes total internal reflection then returns a\n    list of two complex Fresnel coefficients:\n    [reflection p (TM), reflection s (TE)]\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import fresnel_coefficients\n    >>> fresnel_coefficients(0.3, 1, 2)\n    [0.317843553417859, -0.348645229818821,\n            0.658921776708929, 0.651354770181179]\n    >>> fresnel_coefficients(0.6, 2, 1)\n    [-0.235625382192159 - 0.971843958291041*I,\n             0.816477005968898 - 0.577377951366403*I]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Fresnel_equations\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "hyperfocal_distance",
    "full_id": "sympy.physics.optics.utils.hyperfocal_distance",
    "type": "function",
    "description": "\n\n    Parameters\n    ==========\n\n    f: sympifiable\n        Focal length of a given lens.\n\n    N: sympifiable\n        F-number of a given lens.\n\n    c: sympifiable\n        Circle of Confusion (CoC) of a given image format.\n\n    Example\n    =======\n\n    >>> from sympy.physics.optics import hyperfocal_distance\n    >>> round(hyperfocal_distance(f = 0.5, N = 8, c = 0.0033), 2)\n    9.47\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "lens_formula",
    "full_id": "sympy.physics.optics.utils.lens_formula",
    "type": "function",
    "description": "\n    This function provides one of the three parameters\n    when two of them are supplied.\n    This is valid only for paraxial rays.\n\n    Parameters\n    ==========\n\n    focal_length : sympifiable\n        Focal length of the mirror.\n    u : sympifiable\n        Distance of object from the optical center on\n        the principal axis.\n    v : sympifiable\n        Distance of the image from the optical center\n        on the principal axis.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import lens_formula\n    >>> from sympy.abc import f, u, v\n    >>> lens_formula(focal_length=f, u=u)\n    f*u/(f + u)\n    >>> lens_formula(focal_length=f, v=v)\n    f*v/(f - v)\n    >>> lens_formula(u=u, v=v)\n    u*v/(u - v)\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "lens_makers_formula",
    "full_id": "sympy.physics.optics.utils.lens_makers_formula",
    "type": "function",
    "description": "\n    This function calculates focal length of a lens.\n    It follows cartesian sign convention.\n\n    Parameters\n    ==========\n\n    n_lens : Medium or sympifiable\n        Index of refraction of lens.\n    n_surr : Medium or sympifiable\n        Index of reflection of surrounding.\n    r1 : sympifiable\n        Radius of curvature of first surface.\n    r2 : sympifiable\n        Radius of curvature of second surface.\n    d : sympifiable, optional\n        Thickness of lens, default value is 0.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import lens_makers_formula\n    >>> from sympy import S\n    >>> lens_makers_formula(1.33, 1, 10, -10)\n    15.1515151515151\n    >>> lens_makers_formula(1.2, 1, 10, S.Infinity)\n    50.0000000000000\n    >>> lens_makers_formula(1.33, 1, 10, -10, d=1)\n    15.3418463277618\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "mirror_formula",
    "full_id": "sympy.physics.optics.utils.mirror_formula",
    "type": "function",
    "description": "\n    This function provides one of the three parameters\n    when two of them are supplied.\n    This is valid only for paraxial rays.\n\n    Parameters\n    ==========\n\n    focal_length : sympifiable\n        Focal length of the mirror.\n    u : sympifiable\n        Distance of object from the pole on\n        the principal axis.\n    v : sympifiable\n        Distance of the image from the pole\n        on the principal axis.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import mirror_formula\n    >>> from sympy.abc import f, u, v\n    >>> mirror_formula(focal_length=f, u=u)\n    f*u/(-f + u)\n    >>> mirror_formula(focal_length=f, v=v)\n    f*v/(-f + v)\n    >>> mirror_formula(u=u, v=v)\n    u*v/(u + v)\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "refraction_angle",
    "full_id": "sympy.physics.optics.utils.refraction_angle",
    "type": "function",
    "description": "\n    This function calculates transmitted vector after refraction at planar\n    surface. ``medium1`` and ``medium2`` can be ``Medium`` or any sympifiable object.\n    If ``incident`` is a number then treated as angle of incidence (in radians)\n    in which case refraction angle is returned.\n\n    If ``incident`` is an object of `Ray3D`, `normal` also has to be an instance\n    of `Ray3D` in order to get the output as a `Ray3D`. Please note that if\n    plane of separation is not provided and normal is an instance of `Ray3D`,\n    ``normal`` will be assumed to be intersecting incident ray at the plane of\n    separation. This will not be the case when `normal` is a `Matrix` or\n    any other sequence.\n    If ``incident`` is an instance of `Ray3D` and `plane` has not been provided\n    and ``normal`` is not `Ray3D`, output will be a `Matrix`.\n\n    Parameters\n    ==========\n\n    incident : Matrix, Ray3D, sequence or a number\n        Incident vector or angle of incidence\n    medium1 : sympy.physics.optics.medium.Medium or sympifiable\n        Medium 1 or its refractive index\n    medium2 : sympy.physics.optics.medium.Medium or sympifiable\n        Medium 2 or its refractive index\n    normal : Matrix, Ray3D, or sequence\n        Normal vector\n    plane : Plane\n        Plane of separation of the two media.\n\n    Returns\n    =======\n\n    Returns an angle of refraction or a refracted ray depending on inputs.\n\n    Examples\n    ========\n\n    >>> from sympy.physics.optics import refraction_angle\n    >>> from sympy.geometry import Point3D, Ray3D, Plane\n    >>> from sympy.matrices import Matrix\n    >>> from sympy import symbols, pi\n    >>> n = Matrix([0, 0, 1])\n    >>> P = Plane(Point3D(0, 0, 0), normal_vector=[0, 0, 1])\n    >>> r1 = Ray3D(Point3D(-1, -1, 1), Point3D(0, 0, 0))\n    >>> refraction_angle(r1, 1, 1, n)\n    Matrix([\n    [ 1],\n    [ 1],\n    [-1]])\n    >>> refraction_angle(r1, 1, 1, plane=P)\n    Ray3D(Point3D(0, 0, 0), Point3D(1, 1, -1))\n\n    With different index of refraction of the two media\n\n    >>> n1, n2 = symbols('n1, n2')\n    >>> refraction_angle(r1, n1, n2, n)\n    Matrix([\n    [                                n1/n2],\n    [                                n1/n2],\n    [-sqrt(3)*sqrt(-2*n1**2/(3*n2**2) + 1)]])\n    >>> refraction_angle(r1, n1, n2, plane=P)\n    Ray3D(Point3D(0, 0, 0), Point3D(n1/n2, n1/n2, -sqrt(3)*sqrt(-2*n1**2/(3*n2**2) + 1)))\n    >>> round(refraction_angle(pi/6, 1.2, 1.5), 5)\n    0.41152\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "transverse_magnification",
    "full_id": "sympy.physics.optics.utils.transverse_magnification",
    "type": "function",
    "description": "\n\n    Calculates the transverse magnification upon reflection in a mirror,\n    which is the ratio of the image size to the object size.\n\n    Parameters\n    ==========\n\n    so: sympifiable\n        Lens-object distance.\n\n    si: sympifiable\n        Lens-image distance.\n\n    Example\n    =======\n\n    >>> from sympy.physics.optics import transverse_magnification\n    >>> transverse_magnification(30, 15)\n    -2\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/utils.html"
  },
  {
    "name": "amplitude",
    "full_id": "sympy.physics.optics.waves.TWave.amplitude",
    "type": "property",
    "description": "\n        Returns the amplitude of the wave.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.optics import TWave\n        >>> A, phi, f = symbols('A, phi, f')\n        >>> w = TWave(A, f, phi)\n        >>> w.amplitude\n        A\n        ",
    "section": "Waves",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/waves.html"
  },
  {
    "name": "angular_velocity",
    "full_id": "sympy.physics.optics.waves.TWave.angular_velocity",
    "type": "property",
    "description": "\n        Returns the angular velocity of the wave,\n        in radians per second.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.optics import TWave\n        >>> A, phi, f = symbols('A, phi, f')\n        >>> w = TWave(A, f, phi)\n        >>> w.angular_velocity\n        2*pi*f\n        ",
    "section": "Waves",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/waves.html"
  },
  {
    "name": "frequency",
    "full_id": "sympy.physics.optics.waves.TWave.frequency",
    "type": "property",
    "description": "\n        Returns the frequency of the wave,\n        in cycles per second.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.optics import TWave\n        >>> A, phi, f = symbols('A, phi, f')\n        >>> w = TWave(A, f, phi)\n        >>> w.frequency\n        f\n        ",
    "section": "Waves",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/waves.html"
  },
  {
    "name": "n",
    "full_id": "sympy.physics.optics.waves.TWave.n",
    "type": "property",
    "description": "\n        Returns the refractive index of the medium\n        ",
    "section": "Waves",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/waves.html"
  },
  {
    "name": "phase",
    "full_id": "sympy.physics.optics.waves.TWave.phase",
    "type": "property",
    "description": "\n        Returns the phase angle of the wave,\n        in radians.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.optics import TWave\n        >>> A, phi, f = symbols('A, phi, f')\n        >>> w = TWave(A, f, phi)\n        >>> w.phase\n        phi\n        ",
    "section": "Waves",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/waves.html"
  },
  {
    "name": "speed",
    "full_id": "sympy.physics.optics.waves.TWave.speed",
    "type": "property",
    "description": "\n        Returns the propagation speed of the wave,\n        in meters per second.\n        It is dependent on the propagation medium.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.optics import TWave\n        >>> A, phi, f = symbols('A, phi, f')\n        >>> w = TWave(A, f, phi)\n        >>> w.speed\n        299792458*meter/(second*n)\n        ",
    "section": "Waves",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/waves.html"
  },
  {
    "name": "time_period",
    "full_id": "sympy.physics.optics.waves.TWave.time_period",
    "type": "property",
    "description": "\n        Returns the temporal period of the wave,\n        in seconds per cycle.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.optics import TWave\n        >>> A, phi, f = symbols('A, phi, f')\n        >>> w = TWave(A, f, phi)\n        >>> w.time_period\n        1/f\n        ",
    "section": "Waves",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/waves.html"
  },
  {
    "name": "wavelength",
    "full_id": "sympy.physics.optics.waves.TWave.wavelength",
    "type": "property",
    "description": "\n        Returns the wavelength (spatial period) of the wave,\n        in meters per cycle.\n        It depends on the medium of the wave.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.optics import TWave\n        >>> A, phi, f = symbols('A, phi, f')\n        >>> w = TWave(A, f, phi)\n        >>> w.wavelength\n        299792458*meter/(second*f*n)\n        ",
    "section": "Waves",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/waves.html"
  },
  {
    "name": "wavenumber",
    "full_id": "sympy.physics.optics.waves.TWave.wavenumber",
    "type": "property",
    "description": "\n        Returns the wavenumber of the wave,\n        in radians per meter.\n\n        Examples\n        ========\n\n        >>> from sympy import symbols\n        >>> from sympy.physics.optics import TWave\n        >>> A, phi, f = symbols('A, phi, f')\n        >>> w = TWave(A, f, phi)\n        >>> w.wavenumber\n        pi*second*f*n/(149896229*meter)\n        ",
    "section": "Waves",
    "url": "https://docs.sympy.org/latest/modules/physics/optics/waves.html"
  },
  {
    "name": "dc_gain",
    "full_id": "sympy.physics.control.lti.TransferFunction.dc_gain",
    "type": "method",
    "description": "\n        Computes the gain of the response as the frequency approaches zero.\n\n        The DC gain is infinite for systems with pure integrators.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> tf1 = TransferFunction(s + 3, s**2 - 9, s)\n        >>> tf1.dc_gain()\n        -1/3\n        >>> tf2 = TransferFunction(p**2, p - 3 + p**3, p)\n        >>> tf2.dc_gain()\n        0\n        >>> tf3 = TransferFunction(a*p**2 - b, s + b, s)\n        >>> tf3.dc_gain()\n        (a*p**2 - b)/b\n        >>> tf4 = TransferFunction(1, s, s)\n        >>> tf4.dc_gain()\n        oo\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "den",
    "full_id": "sympy.physics.control.lti.TransferFunction.den",
    "type": "property",
    "description": "\n        Returns the denominator polynomial of the transfer function.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> G1 = TransferFunction(s + 4, p**3 - 2*p + 4, s)\n        >>> G1.den\n        p**3 - 2*p + 4\n        >>> G2 = TransferFunction(3, 4, s)\n        >>> G2.den\n        4\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "eval_frequency",
    "full_id": "sympy.physics.control.lti.TransferFunction.eval_frequency",
    "type": "method",
    "description": "\n        Returns the system response at any point in the real or complex plane.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> from sympy import I\n        >>> tf1 = TransferFunction(1, s**2 + 2*s + 1, s)\n        >>> omega = 0.1\n        >>> tf1.eval_frequency(I*omega)\n        1/(0.99 + 0.2*I)\n        >>> tf2 = TransferFunction(s**2, a*s + p, s)\n        >>> tf2.eval_frequency(2)\n        4/(2*a + p)\n        >>> tf2.eval_frequency(I*2)\n        -4/(2*I*a + p)\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "expand",
    "full_id": "sympy.physics.control.lti.TransferFunction.expand",
    "type": "method",
    "description": "\n        Returns the transfer function with numerator and denominator\n        in expanded form.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> G1 = TransferFunction((a - s)**2, (s**2 + a)**2, s)\n        >>> G1.expand()\n        TransferFunction(a**2 - 2*a*s + s**2, a**2 + 2*a*s**2 + s**4, s)\n        >>> G2 = TransferFunction((p + 3*b)*(p - b), (p - b)*(p + 2*b), p)\n        >>> G2.expand()\n        TransferFunction(-3*b**2 + 2*b*p + p**2, -2*b**2 + b*p + p**2, p)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "from_coeff_lists",
    "full_id": "sympy.physics.control.lti.TransferFunction.from_coeff_lists",
    "type": "method",
    "description": "\n        Creates a new ``TransferFunction`` efficiently from a list of coefficients.\n\n        Parameters\n        ==========\n\n        num_list : Sequence\n            Sequence comprising of numerator coefficients.\n        den_list : Sequence\n            Sequence comprising of denominator coefficients.\n        var : Symbol\n            Complex variable of the Laplace transform used by the\n            polynomials of the transfer function.\n\n        Raises\n        ======\n\n        ZeroDivisionError\n            When the constructed denominator is zero.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> num = [1, 0, 2]\n        >>> den = [3, 2, 2, 1]\n        >>> tf = TransferFunction.from_coeff_lists(num, den, s)\n        >>> tf\n        TransferFunction(s**2 + 2, 3*s**3 + 2*s**2 + 2*s + 1, s)\n\n        # Create a Transfer Function with more than one variable\n        >>> tf1 = TransferFunction.from_coeff_lists([p, 1], [2*p, 0, 4], s)\n        >>> tf1\n        TransferFunction(p*s + 1, 2*p*s**2 + 4, s)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "from_rational_expression",
    "full_id": "sympy.physics.control.lti.TransferFunction.from_rational_expression",
    "type": "method",
    "description": "\n        Creates a new ``TransferFunction`` efficiently from a rational expression.\n\n        Parameters\n        ==========\n\n        expr : Expr, Number\n            The rational expression representing the ``TransferFunction``.\n        var : Symbol, optional\n            Complex variable of the Laplace transform used by the\n            polynomials of the transfer function.\n\n        Raises\n        ======\n\n        ValueError\n            When ``expr`` is of type ``Number`` and optional parameter ``var``\n            is not passed.\n\n            When ``expr`` has more than one variables and an optional parameter\n            ``var`` is not passed.\n        ZeroDivisionError\n            When denominator of ``expr`` is zero or it has ``ComplexInfinity``\n            in its numerator.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> expr1 = (s + 5)/(3*s**2 + 2*s + 1)\n        >>> tf1 = TransferFunction.from_rational_expression(expr1)\n        >>> tf1\n        TransferFunction(s + 5, 3*s**2 + 2*s + 1, s)\n        >>> expr2 = (a*p**3 - a*p**2 + s*p)/(p + a**2)  # Expr with more than one variables\n        >>> tf2 = TransferFunction.from_rational_expression(expr2, p)\n        >>> tf2\n        TransferFunction(a*p**3 - a*p**2 + p*s, a**2 + p, p)\n\n        In case of conflict between two or more variables in a expression, SymPy will\n        raise a ``ValueError``, if ``var`` is not passed by the user.\n\n        >>> tf = TransferFunction.from_rational_expression((a + a*s)/(s**2 + s + 1))\n        Traceback (most recent call last):\n        ...\n        ValueError: Conflicting values found for positional argument `var` ({a, s}). Specify it manually.\n\n        This can be corrected by specifying the ``var`` parameter manually.\n\n        >>> tf = TransferFunction.from_rational_expression((a + a*s)/(s**2 + s + 1), s)\n        >>> tf\n        TransferFunction(a*s + a, s**2 + s + 1, s)\n\n        ``var`` also need to be specified when ``expr`` is a ``Number``\n\n        >>> tf3 = TransferFunction.from_rational_expression(10, s)\n        >>> tf3\n        TransferFunction(10, 1, s)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "from_zpk",
    "full_id": "sympy.physics.control.lti.TransferFunction.from_zpk",
    "type": "method",
    "description": "\n        Creates a new ``TransferFunction`` from given zeros, poles and gain.\n\n        Parameters\n        ==========\n\n        zeros : Sequence\n            Sequence comprising of zeros of transfer function.\n        poles : Sequence\n            Sequence comprising of poles of transfer function.\n        gain : Number, Symbol, Expression\n            A scalar value specifying gain of the model.\n        var : Symbol\n            Complex variable of the Laplace transform used by the\n            polynomials of the transfer function.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, k\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> zeros = [1, 2, 3]\n        >>> poles = [6, 5, 4]\n        >>> gain = 7\n        >>> tf = TransferFunction.from_zpk(zeros, poles, gain, s)\n        >>> tf\n        TransferFunction(7*(s - 3)*(s - 2)*(s - 1), (s - 6)*(s - 5)*(s - 4), s)\n\n        # Create a Transfer Function with variable poles and zeros\n        >>> tf1 = TransferFunction.from_zpk([p, k], [p + k, p - k], 2, s)\n        >>> tf1\n        TransferFunction(2*(-k + s)*(-p + s), (-k - p + s)*(k - p + s), s)\n\n        # Complex poles or zeros are acceptable\n        >>> tf2 = TransferFunction.from_zpk([0], [1-1j, 1+1j, 2], -2, s)\n        >>> tf2\n        TransferFunction(-2*s, (s - 2)*(s - 1.0 - 1.0*I)*(s - 1.0 + 1.0*I), s)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_biproper",
    "full_id": "sympy.physics.control.lti.TransferFunction.is_biproper",
    "type": "property",
    "description": "\n        Returns True if degree of the numerator polynomial is equal to\n        degree of the denominator polynomial, else False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf1.is_biproper\n        True\n        >>> tf2 = TransferFunction(p**2, p + a, p)\n        >>> tf2.is_biproper\n        False\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_proper",
    "full_id": "sympy.physics.control.lti.TransferFunction.is_proper",
    "type": "property",
    "description": "\n        Returns True if degree of the numerator polynomial is less than\n        or equal to degree of the denominator polynomial, else False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> tf1 = TransferFunction(b*s**2 + p**2 - a*p + s, b - p**2, s)\n        >>> tf1.is_proper\n        False\n        >>> tf2 = TransferFunction(p**2 - 4*p, p**3 + 3*p + 2, p)\n        >>> tf2.is_proper\n        True\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_stable",
    "full_id": "sympy.physics.control.lti.TransferFunction.is_stable",
    "type": "method",
    "description": "\n        Returns True if the transfer function is asymptotically stable; else False.\n\n        This would not check the marginal or conditional stability of the system.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a\n        >>> from sympy import symbols\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> q, r = symbols('q, r', negative=True)\n        >>> tf1 = TransferFunction((1 - s)**2, (s + 1)**2, s)\n        >>> tf1.is_stable()\n        True\n        >>> tf2 = TransferFunction((1 - p)**2, (s**2 + 1)**2, s)\n        >>> tf2.is_stable()\n        False\n        >>> tf3 = TransferFunction(4, q*s - r, s)\n        >>> tf3.is_stable()\n        False\n        >>> tf4 = TransferFunction(p + 1, a*p - s**2, p)\n        >>> tf4.is_stable() is None   # Not enough info about the symbols to determine stability\n        True\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_strictly_proper",
    "full_id": "sympy.physics.control.lti.TransferFunction.is_strictly_proper",
    "type": "property",
    "description": "\n        Returns True if degree of the numerator polynomial is strictly less\n        than degree of the denominator polynomial, else False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf1.is_strictly_proper\n        False\n        >>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)\n        >>> tf2.is_strictly_proper\n        True\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "num",
    "full_id": "sympy.physics.control.lti.TransferFunction.num",
    "type": "property",
    "description": "\n        Returns the numerator polynomial of the transfer function.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> G1 = TransferFunction(s**2 + p*s + 3, s - 4, s)\n        >>> G1.num\n        p*s + s**2 + 3\n        >>> G2 = TransferFunction((p + 5)*(p - 3), (p - 3)*(p + 1), p)\n        >>> G2.num\n        (p - 3)*(p + 5)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "poles",
    "full_id": "sympy.physics.control.lti.TransferFunction.poles",
    "type": "method",
    "description": "\n        Returns the poles of a transfer function.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> tf1 = TransferFunction((p + 3)*(p - 1), (p - 1)*(p + 5), p)\n        >>> tf1.poles()\n        [-5, 1]\n        >>> tf2 = TransferFunction((1 - s)**2, (s**2 + 1)**2, s)\n        >>> tf2.poles()\n        [I, I, -I, -I]\n        >>> tf3 = TransferFunction(s**2, a*s + p, s)\n        >>> tf3.poles()\n        [-p/a]\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "to_expr",
    "full_id": "sympy.physics.control.lti.TransferFunction.to_expr",
    "type": "method",
    "description": "\n        Converts a ``TransferFunction`` object to SymPy Expr.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> from sympy import Expr\n        >>> tf1 = TransferFunction(s, a*s**2 + 1, s)\n        >>> tf1.to_expr()\n        s/(a*s**2 + 1)\n        >>> isinstance(_, Expr)\n        True\n        >>> tf2 = TransferFunction(1, (p + 3*b)*(b - p), p)\n        >>> tf2.to_expr()\n        1/((b - p)*(3*b + p))\n        >>> tf3 = TransferFunction((s - 2)*(s - 3), (s - 1)*(s - 2)*(s - 3), s)\n        >>> tf3.to_expr()\n        ((s - 3)*(s - 2))/(((s - 3)*(s - 2)*(s - 1)))\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "var",
    "full_id": "sympy.physics.control.lti.TransferFunction.var",
    "type": "property",
    "description": "\n        Returns the complex variable of the Laplace transform used by the polynomials of\n        the transfer function.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)\n        >>> G1.var\n        p\n        >>> G2 = TransferFunction(0, s - 5, s)\n        >>> G2.var\n        s\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "zeros",
    "full_id": "sympy.physics.control.lti.TransferFunction.zeros",
    "type": "method",
    "description": "\n        Returns the zeros of a transfer function.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a\n        >>> from sympy.physics.control.lti import TransferFunction\n        >>> tf1 = TransferFunction((p + 3)*(p - 1), (p - 1)*(p + 5), p)\n        >>> tf1.zeros()\n        [-3, 1]\n        >>> tf2 = TransferFunction((1 - s)**2, (s**2 + 1)**2, s)\n        >>> tf2.zeros()\n        [1, 1]\n        >>> tf3 = TransferFunction(s**2, a*s + p, s)\n        >>> tf3.zeros()\n        [0, 0]\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.control.lti.Series.doit",
    "type": "method",
    "description": "\n        Returns the resultant transfer function obtained after evaluating\n        the transfer functions in series configuration.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, Series\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)\n        >>> Series(tf2, tf1).doit()\n        TransferFunction((s**3 - 2)*(a*p**2 + b*s), (-p + s)*(s**4 + 5*s + 6), s)\n        >>> Series(-tf1, -tf2).doit()\n        TransferFunction((2 - s**3)*(-a*p**2 - b*s), (-p + s)*(s**4 + 5*s + 6), s)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_biproper",
    "full_id": "sympy.physics.control.lti.Series.is_biproper",
    "type": "property",
    "description": "\n        Returns True if degree of the numerator polynomial of the resultant transfer\n        function is equal to degree of the denominator polynomial of\n        the same, else False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, Series\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf2 = TransferFunction(p, s**2, s)\n        >>> tf3 = TransferFunction(s**2, 1, s)\n        >>> S1 = Series(tf1, -tf2)\n        >>> S1.is_biproper\n        False\n        >>> S2 = Series(tf2, tf3)\n        >>> S2.is_biproper\n        True\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_proper",
    "full_id": "sympy.physics.control.lti.Series.is_proper",
    "type": "property",
    "description": "\n        Returns True if degree of the numerator polynomial of the resultant transfer\n        function is less than or equal to degree of the denominator polynomial of\n        the same, else False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, Series\n        >>> tf1 = TransferFunction(b*s**2 + p**2 - a*p + s, b - p**2, s)\n        >>> tf2 = TransferFunction(p**2 - 4*p, p**3 + 3*s + 2, s)\n        >>> tf3 = TransferFunction(s, s**2 + s + 1, s)\n        >>> S1 = Series(-tf2, tf1)\n        >>> S1.is_proper\n        False\n        >>> S2 = Series(tf1, tf2, tf3)\n        >>> S2.is_proper\n        True\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_strictly_proper",
    "full_id": "sympy.physics.control.lti.Series.is_strictly_proper",
    "type": "property",
    "description": "\n        Returns True if degree of the numerator polynomial of the resultant transfer\n        function is strictly less than degree of the denominator polynomial of\n        the same, else False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, Series\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf2 = TransferFunction(s**3 - 2, s**2 + 5*s + 6, s)\n        >>> tf3 = TransferFunction(1, s**2 + s + 1, s)\n        >>> S1 = Series(tf1, tf2)\n        >>> S1.is_strictly_proper\n        False\n        >>> S2 = Series(tf1, tf2, tf3)\n        >>> S2.is_strictly_proper\n        True\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "to_expr",
    "full_id": "sympy.physics.control.lti.Series.to_expr",
    "type": "method",
    "description": "Returns the equivalent ``Expr`` object.",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "var",
    "full_id": "sympy.physics.control.lti.Series.var",
    "type": "property",
    "description": "\n        Returns the complex variable used by all the transfer functions.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import p\n        >>> from sympy.physics.control.lti import TransferFunction, Series, Parallel\n        >>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)\n        >>> G2 = TransferFunction(p, 4 - p, p)\n        >>> G3 = TransferFunction(0, p**4 - 1, p)\n        >>> Series(G1, G2).var\n        p\n        >>> Series(-G3, Parallel(G1, G2)).var\n        p\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.control.lti.Parallel.doit",
    "type": "method",
    "description": "\n        Returns the resultant transfer function obtained after evaluating\n        the transfer functions in parallel configuration.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, Parallel\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)\n        >>> Parallel(tf2, tf1).doit()\n        TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s)\n        >>> Parallel(-tf1, -tf2).doit()\n        TransferFunction((2 - s**3)*(-p + s) + (-a*p**2 - b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_biproper",
    "full_id": "sympy.physics.control.lti.Parallel.is_biproper",
    "type": "property",
    "description": "\n        Returns True if degree of the numerator polynomial of the resultant transfer\n        function is equal to degree of the denominator polynomial of\n        the same, else False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, Parallel\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf2 = TransferFunction(p**2, p + s, s)\n        >>> tf3 = TransferFunction(s, s**2 + s + 1, s)\n        >>> P1 = Parallel(tf1, -tf2)\n        >>> P1.is_biproper\n        True\n        >>> P2 = Parallel(tf2, tf3)\n        >>> P2.is_biproper\n        False\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_proper",
    "full_id": "sympy.physics.control.lti.Parallel.is_proper",
    "type": "property",
    "description": "\n        Returns True if degree of the numerator polynomial of the resultant transfer\n        function is less than or equal to degree of the denominator polynomial of\n        the same, else False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, Parallel\n        >>> tf1 = TransferFunction(b*s**2 + p**2 - a*p + s, b - p**2, s)\n        >>> tf2 = TransferFunction(p**2 - 4*p, p**3 + 3*s + 2, s)\n        >>> tf3 = TransferFunction(s, s**2 + s + 1, s)\n        >>> P1 = Parallel(-tf2, tf1)\n        >>> P1.is_proper\n        False\n        >>> P2 = Parallel(tf2, tf3)\n        >>> P2.is_proper\n        True\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "is_strictly_proper",
    "full_id": "sympy.physics.control.lti.Parallel.is_strictly_proper",
    "type": "property",
    "description": "\n        Returns True if degree of the numerator polynomial of the resultant transfer\n        function is strictly less than degree of the denominator polynomial of\n        the same, else False.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, Parallel\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)\n        >>> tf3 = TransferFunction(s, s**2 + s + 1, s)\n        >>> P1 = Parallel(tf1, tf2)\n        >>> P1.is_strictly_proper\n        False\n        >>> P2 = Parallel(tf2, tf3)\n        >>> P2.is_strictly_proper\n        True\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "var",
    "full_id": "sympy.physics.control.lti.Parallel.var",
    "type": "property",
    "description": "\n        Returns the complex variable used by all the transfer functions.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import p\n        >>> from sympy.physics.control.lti import TransferFunction, Parallel, Series\n        >>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)\n        >>> G2 = TransferFunction(p, 4 - p, p)\n        >>> G3 = TransferFunction(0, p**4 - 1, p)\n        >>> Parallel(G1, G2).var\n        p\n        >>> Parallel(-G3, Series(G1, G2)).var\n        p\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "den",
    "full_id": "sympy.physics.control.lti.Feedback.den",
    "type": "property",
    "description": "\n        Returns the denominator of the closed loop feedback model.\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.control.lti.Feedback.doit",
    "type": "method",
    "description": "\n        Returns the resultant transfer function obtained by the\n        feedback interconnection.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s\n        >>> from sympy.physics.control.lti import TransferFunction, Feedback\n        >>> plant = TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)\n        >>> controller = TransferFunction(5*s - 10, s + 7, s)\n        >>> F1 = Feedback(plant, controller)\n        >>> F1.doit()\n        TransferFunction((s + 7)*(s**2 - 4*s + 2)*(3*s**2 + 7*s - 3), ((s + 7)*(s**2 - 4*s + 2) + (5*s - 10)*(3*s**2 + 7*s - 3))*(s**2 - 4*s + 2), s)\n        >>> G = TransferFunction(2*s**2 + 5*s + 1, s**2 + 2*s + 3, s)\n        >>> F2 = Feedback(G, TransferFunction(1, 1, s))\n        >>> F2.doit()\n        TransferFunction((s**2 + 2*s + 3)*(2*s**2 + 5*s + 1), (s**2 + 2*s + 3)*(3*s**2 + 7*s + 4), s)\n\n        Use kwarg ``expand=True`` to expand the resultant transfer function.\n        Use ``cancel=True`` to cancel out the common terms in numerator and\n        denominator.\n\n        >>> F2.doit(cancel=True, expand=True)\n        TransferFunction(2*s**2 + 5*s + 1, 3*s**2 + 7*s + 4, s)\n        >>> F2.doit(expand=True)\n        TransferFunction(2*s**4 + 9*s**3 + 17*s**2 + 17*s + 3, 3*s**4 + 13*s**3 + 27*s**2 + 29*s + 12, s)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "num",
    "full_id": "sympy.physics.control.lti.Feedback.num",
    "type": "property",
    "description": "\n        Returns the numerator of the closed loop feedback system.\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "sensitivity",
    "full_id": "sympy.physics.control.lti.Feedback.sensitivity",
    "type": "property",
    "description": "\n        Returns the sensitivity function of the feedback loop.\n\n        Sensitivity of a Feedback system is the ratio\n        of change in the open loop gain to the change in\n        the closed loop gain.\n\n        .. note::\n            This method would not return the complementary\n            sensitivity function.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import p\n        >>> from sympy.physics.control.lti import TransferFunction, Feedback\n        >>> C = TransferFunction(5*p + 10, p + 10, p)\n        >>> P = TransferFunction(1 - p, p + 2, p)\n        >>> F_1 = Feedback(P, C)\n        >>> F_1.sensitivity\n        1/((1 - p)*(5*p + 10)/((p + 2)*(p + 10)) + 1)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "sign",
    "full_id": "sympy.physics.control.lti.Feedback.sign",
    "type": "property",
    "description": "\n        Returns the type of MIMO Feedback model. ``1``\n        for Positive and ``-1`` for Negative.\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "sys1",
    "full_id": "sympy.physics.control.lti.Feedback.sys1",
    "type": "property",
    "description": "\n        Returns the feedforward system of the feedback interconnection.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p\n        >>> from sympy.physics.control.lti import TransferFunction, Feedback\n        >>> plant = TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)\n        >>> controller = TransferFunction(5*s - 10, s + 7, s)\n        >>> F1 = Feedback(plant, controller)\n        >>> F1.sys1\n        TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)\n        >>> G = TransferFunction(2*s**2 + 5*s + 1, p**2 + 2*p + 3, p)\n        >>> C = TransferFunction(5*p + 10, p + 10, p)\n        >>> P = TransferFunction(1 - s, p + 2, p)\n        >>> F2 = Feedback(TransferFunction(1, 1, p), G*C*P)\n        >>> F2.sys1\n        TransferFunction(1, 1, p)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "sys2",
    "full_id": "sympy.physics.control.lti.Feedback.sys2",
    "type": "property",
    "description": "\n        Returns the feedback controller of the feedback interconnection.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p\n        >>> from sympy.physics.control.lti import TransferFunction, Feedback\n        >>> plant = TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)\n        >>> controller = TransferFunction(5*s - 10, s + 7, s)\n        >>> F1 = Feedback(plant, controller)\n        >>> F1.sys2\n        TransferFunction(5*s - 10, s + 7, s)\n        >>> G = TransferFunction(2*s**2 + 5*s + 1, p**2 + 2*p + 3, p)\n        >>> C = TransferFunction(5*p + 10, p + 10, p)\n        >>> P = TransferFunction(1 - s, p + 2, p)\n        >>> F2 = Feedback(TransferFunction(1, 1, p), G*C*P)\n        >>> F2.sys2\n        Series(TransferFunction(2*s**2 + 5*s + 1, p**2 + 2*p + 3, p), TransferFunction(5*p + 10, p + 10, p), TransferFunction(1 - s, p + 2, p))\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "to_expr",
    "full_id": "sympy.physics.control.lti.Feedback.to_expr",
    "type": "method",
    "description": "\n        Converts a ``Feedback`` object to SymPy Expr.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, Feedback\n        >>> from sympy import Expr\n        >>> tf1 = TransferFunction(a+s, 1, s)\n        >>> tf2 = TransferFunction(b+s, 1, s)\n        >>> fd1 = Feedback(tf1, tf2)\n        >>> fd1.to_expr()\n        (a + s)/((a + s)*(b + s) + 1)\n        >>> isinstance(_, Expr)\n        True\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "var",
    "full_id": "sympy.physics.control.lti.Feedback.var",
    "type": "property",
    "description": "\n        Returns the complex variable of the Laplace transform used by all\n        the transfer functions involved in the feedback interconnection.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p\n        >>> from sympy.physics.control.lti import TransferFunction, Feedback\n        >>> plant = TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)\n        >>> controller = TransferFunction(5*s - 10, s + 7, s)\n        >>> F1 = Feedback(plant, controller)\n        >>> F1.var\n        s\n        >>> G = TransferFunction(2*s**2 + 5*s + 1, p**2 + 2*p + 3, p)\n        >>> C = TransferFunction(5*p + 10, p + 10, p)\n        >>> P = TransferFunction(1 - s, p + 2, p)\n        >>> F2 = Feedback(TransferFunction(1, 1, p), G*C*P)\n        >>> F2.var\n        p\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "elem_poles",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.elem_poles",
    "type": "method",
    "description": "\n        Returns the poles of each element of the ``TransferFunctionMatrix``.\n\n        .. note::\n            Actual poles of a MIMO system are NOT the poles of individual elements.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix\n        >>> tf_1 = TransferFunction(3, (s + 1), s)\n        >>> tf_2 = TransferFunction(s + 6, (s + 1)*(s + 2), s)\n        >>> tf_3 = TransferFunction(s + 3, s**2 + 3*s + 2, s)\n        >>> tf_4 = TransferFunction(s + 2, s**2 + 5*s - 10, s)\n        >>> tfm_1 = TransferFunctionMatrix([[tf_1, tf_2], [tf_3, tf_4]])\n        >>> tfm_1\n        TransferFunctionMatrix(((TransferFunction(3, s + 1, s), TransferFunction(s + 6, (s + 1)*(s + 2), s)), (TransferFunction(s + 3, s**2 + 3*s + 2, s), TransferFunction(s + 2, s**2 + 5*s - 10, s))))\n        >>> tfm_1.elem_poles()\n        [[[-1], [-2, -1]], [[-2, -1], [-5/2 + sqrt(65)/2, -sqrt(65)/2 - 5/2]]]\n\n        See Also\n        ========\n\n        elem_zeros\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "elem_zeros",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.elem_zeros",
    "type": "method",
    "description": "\n        Returns the zeros of each element of the ``TransferFunctionMatrix``.\n\n        .. note::\n            Actual zeros of a MIMO system are NOT the zeros of individual elements.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix\n        >>> tf_1 = TransferFunction(3, (s + 1), s)\n        >>> tf_2 = TransferFunction(s + 6, (s + 1)*(s + 2), s)\n        >>> tf_3 = TransferFunction(s + 3, s**2 + 3*s + 2, s)\n        >>> tf_4 = TransferFunction(s**2 - 9*s + 20, s**2 + 5*s - 10, s)\n        >>> tfm_1 = TransferFunctionMatrix([[tf_1, tf_2], [tf_3, tf_4]])\n        >>> tfm_1\n        TransferFunctionMatrix(((TransferFunction(3, s + 1, s), TransferFunction(s + 6, (s + 1)*(s + 2), s)), (TransferFunction(s + 3, s**2 + 3*s + 2, s), TransferFunction(s**2 - 9*s + 20, s**2 + 5*s - 10, s))))\n        >>> tfm_1.elem_zeros()\n        [[[], [-6]], [[-3], [4, 5]]]\n\n        See Also\n        ========\n\n        elem_poles\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "eval_frequency",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.eval_frequency",
    "type": "method",
    "description": "\n        Evaluates system response of each transfer function in the ``TransferFunctionMatrix`` at any point in the real or complex plane.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix\n        >>> from sympy import I\n        >>> tf_1 = TransferFunction(3, (s + 1), s)\n        >>> tf_2 = TransferFunction(s + 6, (s + 1)*(s + 2), s)\n        >>> tf_3 = TransferFunction(s + 3, s**2 + 3*s + 2, s)\n        >>> tf_4 = TransferFunction(s**2 - 9*s + 20, s**2 + 5*s - 10, s)\n        >>> tfm_1 = TransferFunctionMatrix([[tf_1, tf_2], [tf_3, tf_4]])\n        >>> tfm_1\n        TransferFunctionMatrix(((TransferFunction(3, s + 1, s), TransferFunction(s + 6, (s + 1)*(s + 2), s)), (TransferFunction(s + 3, s**2 + 3*s + 2, s), TransferFunction(s**2 - 9*s + 20, s**2 + 5*s - 10, s))))\n        >>> tfm_1.eval_frequency(2)\n        Matrix([\n        [   1, 2/3],\n        [5/12, 3/2]])\n        >>> tfm_1.eval_frequency(I*2)\n        Matrix([\n        [   3/5 - 6*I/5,                -I],\n        [3/20 - 11*I/20, -101/74 + 23*I/74]])\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "expand",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.expand",
    "type": "method",
    "description": "Expands the transfer function matrix",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "from_Matrix",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.from_Matrix",
    "type": "method",
    "description": "\n        Creates a new ``TransferFunctionMatrix`` efficiently from a SymPy Matrix of ``Expr`` objects.\n\n        Parameters\n        ==========\n\n        matrix : ``ImmutableMatrix`` having ``Expr``/``Number`` elements.\n        var : Symbol\n            Complex variable of the Laplace transform which will be used by the\n            all the ``TransferFunction`` objects in the ``TransferFunctionMatrix``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s\n        >>> from sympy.physics.control.lti import TransferFunctionMatrix\n        >>> from sympy import Matrix, pprint\n        >>> M = Matrix([[s, 1/s], [1/(s+1), s]])\n        >>> M_tf = TransferFunctionMatrix.from_Matrix(M, s)\n        >>> pprint(M_tf, use_unicode=False)\n        [  s    1]\n        [  -    -]\n        [  1    s]\n        [        ]\n        [  1    s]\n        [-----  -]\n        [s + 1  1]{t}\n        >>> M_tf.elem_poles()\n        [[[], [0]], [[-1], []]]\n        >>> M_tf.elem_zeros()\n        [[[0], []], [[], [0]]]\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "num_inputs",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.num_inputs",
    "type": "property",
    "description": "\n        Returns the number of inputs of the system.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix\n        >>> G1 = TransferFunction(s + 3, s**2 - 3, s)\n        >>> G2 = TransferFunction(4, s**2, s)\n        >>> G3 = TransferFunction(p**2 + s**2, p - 3, s)\n        >>> tfm_1 = TransferFunctionMatrix([[G2, -G1, G3], [-G2, -G1, -G3]])\n        >>> tfm_1.num_inputs\n        3\n\n        See Also\n        ========\n\n        num_outputs\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "num_outputs",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.num_outputs",
    "type": "property",
    "description": "\n        Returns the number of outputs of the system.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s\n        >>> from sympy.physics.control.lti import TransferFunctionMatrix\n        >>> from sympy import Matrix\n        >>> M_1 = Matrix([[s], [1/s]])\n        >>> TFM = TransferFunctionMatrix.from_Matrix(M_1, s)\n        >>> print(TFM)\n        TransferFunctionMatrix(((TransferFunction(s, 1, s),), (TransferFunction(1, s, s),)))\n        >>> TFM.num_outputs\n        2\n\n        See Also\n        ========\n\n        num_inputs\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "shape",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.shape",
    "type": "property",
    "description": "\n        Returns the shape of the transfer function matrix, that is, ``(# of outputs, # of inputs)``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix\n        >>> tf1 = TransferFunction(p**2 - 1, s**4 + s**3 - p, p)\n        >>> tf2 = TransferFunction(1 - p, p**2 - 3*p + 7, p)\n        >>> tf3 = TransferFunction(3, 4, p)\n        >>> tfm1 = TransferFunctionMatrix([[tf1, -tf2]])\n        >>> tfm1.shape\n        (1, 2)\n        >>> tfm2 = TransferFunctionMatrix([[-tf2, tf3], [tf1, -tf1]])\n        >>> tfm2.shape\n        (2, 2)\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "transpose",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.transpose",
    "type": "method",
    "description": "Returns the transpose of the ``TransferFunctionMatrix`` (switched input and output layers).",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "var",
    "full_id": "sympy.physics.control.lti.TransferFunctionMatrix.var",
    "type": "property",
    "description": "\n        Returns the complex variable used by all the transfer functions or\n        ``Series``/``Parallel`` objects in a transfer function matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import p, s\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, Series, Parallel\n        >>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)\n        >>> G2 = TransferFunction(p, 4 - p, p)\n        >>> G3 = TransferFunction(0, p**4 - 1, p)\n        >>> G4 = TransferFunction(s + 1, s**2 + s + 1, s)\n        >>> S1 = Series(G1, G2)\n        >>> S2 = Series(-G3, Parallel(G2, -G1))\n        >>> tfm1 = TransferFunctionMatrix([[G1], [G2], [G3]])\n        >>> tfm1.var\n        p\n        >>> tfm2 = TransferFunctionMatrix([[-S1, -S2], [S1, S2]])\n        >>> tfm2.var\n        p\n        >>> tfm3 = TransferFunctionMatrix([[G4]])\n        >>> tfm3.var\n        s\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.control.lti.MIMOSeries.doit",
    "type": "method",
    "description": "\n        Returns the resultant transfer function matrix obtained after evaluating\n        the MIMO systems arranged in a series configuration.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, MIMOSeries, TransferFunctionMatrix\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)\n        >>> tfm1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf2]])\n        >>> tfm2 = TransferFunctionMatrix([[tf2, tf1], [tf1, tf1]])\n        >>> MIMOSeries(tfm2, tfm1).doit()\n        TransferFunctionMatrix(((TransferFunction(2*(-p + s)*(s**3 - 2)*(a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)**2*(s**4 + 5*s + 6)**2, s), TransferFunction((-p + s)**2*(s**3 - 2)*(a*p**2 + b*s) + (-p + s)*(a*p**2 + b*s)**2*(s**4 + 5*s + 6), (-p + s)**3*(s**4 + 5*s + 6), s)), (TransferFunction((-p + s)*(s**3 - 2)**2*(s**4 + 5*s + 6) + (s**3 - 2)*(a*p**2 + b*s)*(s**4 + 5*s + 6)**2, (-p + s)*(s**4 + 5*s + 6)**3, s), TransferFunction(2*(s**3 - 2)*(a*p**2 + b*s), (-p + s)*(s**4 + 5*s + 6), s))))\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "num_inputs",
    "full_id": "sympy.physics.control.lti.MIMOSeries.num_inputs",
    "type": "property",
    "description": "Returns the number of input signals of the series system.",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "num_outputs",
    "full_id": "sympy.physics.control.lti.MIMOSeries.num_outputs",
    "type": "property",
    "description": "Returns the number of output signals of the series system.",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "shape",
    "full_id": "sympy.physics.control.lti.MIMOSeries.shape",
    "type": "property",
    "description": "Returns the shape of the equivalent MIMO system.",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "var",
    "full_id": "sympy.physics.control.lti.MIMOSeries.var",
    "type": "property",
    "description": "\n        Returns the complex variable used by all the transfer functions.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import p\n        >>> from sympy.physics.control.lti import TransferFunction, MIMOSeries, TransferFunctionMatrix\n        >>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)\n        >>> G2 = TransferFunction(p, 4 - p, p)\n        >>> G3 = TransferFunction(0, p**4 - 1, p)\n        >>> tfm_1 = TransferFunctionMatrix([[G1, G2, G3]])\n        >>> tfm_2 = TransferFunctionMatrix([[G1], [G2], [G3]])\n        >>> MIMOSeries(tfm_2, tfm_1).var\n        p\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.control.lti.MIMOParallel.doit",
    "type": "method",
    "description": "\n        Returns the resultant transfer function matrix obtained after evaluating\n        the MIMO systems arranged in a parallel configuration.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import s, p, a, b\n        >>> from sympy.physics.control.lti import TransferFunction, MIMOParallel, TransferFunctionMatrix\n        >>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)\n        >>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)\n        >>> tfm_1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])\n        >>> tfm_2 = TransferFunctionMatrix([[tf2, tf1], [tf1, tf2]])\n        >>> MIMOParallel(tfm_1, tfm_2).doit()\n        TransferFunctionMatrix(((TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s), TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s)), (TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s), TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s))))\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "num_inputs",
    "full_id": "sympy.physics.control.lti.MIMOParallel.num_inputs",
    "type": "property",
    "description": "Returns the number of input signals of the parallel system.",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "num_outputs",
    "full_id": "sympy.physics.control.lti.MIMOParallel.num_outputs",
    "type": "property",
    "description": "Returns the number of output signals of the parallel system.",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "var",
    "full_id": "sympy.physics.control.lti.MIMOParallel.var",
    "type": "property",
    "description": "\n        Returns the complex variable used by all the systems.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import p\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOParallel\n        >>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)\n        >>> G2 = TransferFunction(p, 4 - p, p)\n        >>> G3 = TransferFunction(0, p**4 - 1, p)\n        >>> G4 = TransferFunction(p**2, p**2 - 1, p)\n        >>> tfm_a = TransferFunctionMatrix([[G1, G2], [G3, G4]])\n        >>> tfm_b = TransferFunctionMatrix([[G2, G1], [G4, G3]])\n        >>> MIMOParallel(tfm_a, tfm_b).var\n        p\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "doit",
    "full_id": "sympy.physics.control.lti.MIMOFeedback.doit",
    "type": "method",
    "description": "\n        Returns the resultant transfer function matrix obtained by the\n        feedback interconnection.\n\n        Examples\n        ========\n\n        >>> from sympy import pprint\n        >>> from sympy.abc import s\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback\n        >>> tf1 = TransferFunction(s, 1 - s, s)\n        >>> tf2 = TransferFunction(1, s, s)\n        >>> tf3 = TransferFunction(5, 1, s)\n        >>> tf4 = TransferFunction(s - 1, s, s)\n        >>> tf5 = TransferFunction(0, 1, s)\n        >>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf3, tf4]])\n        >>> sys2 = TransferFunctionMatrix([[tf3, tf5], [tf5, tf5]])\n        >>> F_1 = MIMOFeedback(sys1, sys2, 1)\n        >>> pprint(F_1, use_unicode=False)\n        /    [  s      1  ]    [5  0]   \\-1   [  s      1  ]\n        |    [-----    -  ]    [-  -]   |     [-----    -  ]\n        |    [1 - s    s  ]    [1  1]   |     [1 - s    s  ]\n        |I - [            ]   *[    ]   |   * [            ]\n        |    [  5    s - 1]    [0  0]   |     [  5    s - 1]\n        |    [  -    -----]    [-  -]   |     [  -    -----]\n        \\    [  1      s  ]{t} [1  1]{t}/     [  1      s  ]{t}\n        >>> pprint(F_1.doit(), use_unicode=False)\n        [  -s           s - 1       ]\n        [-------     -----------    ]\n        [6*s - 1     s*(6*s - 1)    ]\n        [                           ]\n        [5*s - 5  (s - 1)*(6*s + 24)]\n        [-------  ------------------]\n        [6*s - 1     s*(6*s - 1)    ]{t}\n\n        If the user wants the resultant ``TransferFunctionMatrix`` object without\n        canceling the common factors then the ``cancel`` kwarg should be passed ``False``.\n\n        >>> pprint(F_1.doit(cancel=False), use_unicode=False)\n        [             s*(s - 1)                              s - 1               ]\n        [         -----------------                       -----------            ]\n        [         (1 - s)*(6*s - 1)                       s*(6*s - 1)            ]\n        [                                                                        ]\n        [s*(25*s - 25) + 5*(1 - s)*(6*s - 1)  s*(s - 1)*(6*s - 1) + s*(25*s - 25)]\n        [-----------------------------------  -----------------------------------]\n        [         (1 - s)*(6*s - 1)                        2                     ]\n        [                                                 s *(6*s - 1)           ]{t}\n\n        If the user wants the expanded form of the resultant transfer function matrix,\n        the ``expand`` kwarg should be passed as ``True``.\n\n        >>> pprint(F_1.doit(expand=True), use_unicode=False)\n        [  -s          s - 1      ]\n        [-------      --------    ]\n        [6*s - 1         2        ]\n        [             6*s  - s    ]\n        [                         ]\n        [            2            ]\n        [5*s - 5  6*s  + 18*s - 24]\n        [-------  ----------------]\n        [6*s - 1         2        ]\n        [             6*s  - s    ]{t}\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "sensitivity",
    "full_id": "sympy.physics.control.lti.MIMOFeedback.sensitivity",
    "type": "property",
    "description": "\n        Returns the sensitivity function matrix of the feedback loop.\n\n        Sensitivity of a closed-loop system is the ratio of change\n        in the open loop gain to the change in the closed loop gain.\n\n        .. note::\n            This method would not return the complementary\n            sensitivity function.\n\n        Examples\n        ========\n\n        >>> from sympy import pprint\n        >>> from sympy.abc import p\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback\n        >>> tf1 = TransferFunction(p, 1 - p, p)\n        >>> tf2 = TransferFunction(1, p, p)\n        >>> tf3 = TransferFunction(1, 1, p)\n        >>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])\n        >>> sys2 = TransferFunctionMatrix([[tf1, tf3], [tf3, tf2]])\n        >>> F_1 = MIMOFeedback(sys1, sys2, 1)  # Positive feedback\n        >>> F_2 = MIMOFeedback(sys1, sys2)  # Negative feedback\n        >>> pprint(F_1.sensitivity, use_unicode=False)\n        [   4      3      2               5      4      2           ]\n        [- p  + 3*p  - 4*p  + 3*p - 1    p  - 2*p  + 3*p  - 3*p + 1 ]\n        [----------------------------  -----------------------------]\n        [  4      3      2              5      4      3      2      ]\n        [ p  + 3*p  - 8*p  + 8*p - 3   p  + 3*p  - 8*p  + 8*p  - 3*p]\n        [                                                           ]\n        [       4    3    2                  3      2               ]\n        [      p  - p  - p  + p           3*p  - 6*p  + 4*p - 1     ]\n        [ --------------------------    --------------------------  ]\n        [  4      3      2               4      3      2            ]\n        [ p  + 3*p  - 8*p  + 8*p - 3    p  + 3*p  - 8*p  + 8*p - 3  ]\n        >>> pprint(F_2.sensitivity, use_unicode=False)\n        [ 4      3      2           5      4      2          ]\n        [p  - 3*p  + 2*p  + p - 1  p  - 2*p  + 3*p  - 3*p + 1]\n        [------------------------  --------------------------]\n        [   4      3                   5      4      2       ]\n        [  p  - 3*p  + 2*p - 1        p  - 3*p  + 2*p  - p   ]\n        [                                                    ]\n        [     4    3    2               4      3             ]\n        [    p  - p  - p  + p        2*p  - 3*p  + 2*p - 1   ]\n        [  -------------------       ---------------------   ]\n        [   4      3                   4      3              ]\n        [  p  - 3*p  + 2*p - 1        p  - 3*p  + 2*p - 1    ]\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "sign",
    "full_id": "sympy.physics.control.lti.MIMOFeedback.sign",
    "type": "property",
    "description": "\n        Returns the type of feedback interconnection of two models. ``1``\n        for Positive and ``-1`` for Negative.\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "sys1",
    "full_id": "sympy.physics.control.lti.MIMOFeedback.sys1",
    "type": "property",
    "description": "\n        Returns the system placed on the feedforward path of the MIMO feedback interconnection.\n\n        Examples\n        ========\n\n        >>> from sympy import pprint\n        >>> from sympy.abc import s\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback\n        >>> tf1 = TransferFunction(s**2 + s + 1, s**2 - s + 1, s)\n        >>> tf2 = TransferFunction(1, s, s)\n        >>> tf3 = TransferFunction(1, 1, s)\n        >>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])\n        >>> sys2 = TransferFunctionMatrix([[tf3, tf3], [tf3, tf2]])\n        >>> F_1 = MIMOFeedback(sys1, sys2, 1)\n        >>> F_1.sys1\n        TransferFunctionMatrix(((TransferFunction(s**2 + s + 1, s**2 - s + 1, s), TransferFunction(1, s, s)), (TransferFunction(1, s, s), TransferFunction(s**2 + s + 1, s**2 - s + 1, s))))\n        >>> pprint(_, use_unicode=False)\n        [ 2                    ]\n        [s  + s + 1      1     ]\n        [----------      -     ]\n        [ 2              s     ]\n        [s  - s + 1            ]\n        [                      ]\n        [             2        ]\n        [    1       s  + s + 1]\n        [    -       ----------]\n        [    s        2        ]\n        [            s  - s + 1]{t}\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "sys2",
    "full_id": "sympy.physics.control.lti.MIMOFeedback.sys2",
    "type": "property",
    "description": "\n        Returns the feedback controller of the MIMO feedback interconnection.\n\n        Examples\n        ========\n\n        >>> from sympy import pprint\n        >>> from sympy.abc import s\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback\n        >>> tf1 = TransferFunction(s**2, s**3 - s + 1, s)\n        >>> tf2 = TransferFunction(1, s, s)\n        >>> tf3 = TransferFunction(1, 1, s)\n        >>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])\n        >>> sys2 = TransferFunctionMatrix([[tf1, tf3], [tf3, tf2]])\n        >>> F_1 = MIMOFeedback(sys1, sys2)\n        >>> F_1.sys2\n        TransferFunctionMatrix(((TransferFunction(s**2, s**3 - s + 1, s), TransferFunction(1, 1, s)), (TransferFunction(1, 1, s), TransferFunction(1, s, s))))\n        >>> pprint(_, use_unicode=False)\n        [     2       ]\n        [    s       1]\n        [----------  -]\n        [ 3          1]\n        [s  - s + 1   ]\n        [             ]\n        [    1       1]\n        [    -       -]\n        [    1       s]{t}\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "var",
    "full_id": "sympy.physics.control.lti.MIMOFeedback.var",
    "type": "property",
    "description": "\n        Returns the complex variable of the Laplace transform used by all\n        the transfer functions involved in the MIMO feedback loop.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import p\n        >>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback\n        >>> tf1 = TransferFunction(p, 1 - p, p)\n        >>> tf2 = TransferFunction(1, p, p)\n        >>> tf3 = TransferFunction(1, 1, p)\n        >>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])\n        >>> sys2 = TransferFunctionMatrix([[tf1, tf3], [tf3, tf2]])\n        >>> F_1 = MIMOFeedback(sys1, sys2, 1)  # Positive feedback\n        >>> F_1.var\n        p\n\n        ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "gbt",
    "full_id": "sympy.physics.control.lti.gbt",
    "type": "function",
    "description": "\n    Returns falling coefficients of H(z) from numerator and denominator.\n\n    Explanation\n    ===========\n\n    Where H(z) is the corresponding discretized transfer function,\n    discretized with the generalised bilinear transformation method.\n    H(z) is obtained from the continuous transfer function H(s)\n    by substituting $s(z) = \\frac{z-1}{T(\\alpha z + (1-\\alpha))}$ into H(s), where T is the\n    sample period.\n    Coefficients are falling, i.e. $H(z) = \\frac{az+b}{cz+d}$ is returned\n    as [a, b], [c, d].\n\n    Examples\n    ========\n\n    >>> from sympy.physics.control.lti import TransferFunction, gbt\n    >>> from sympy.abc import s, L, R, T\n\n    >>> tf = TransferFunction(1, s*L + R, s)\n    >>> numZ, denZ = gbt(tf, T, 0.5)\n    >>> numZ\n    [T/(2*(L + R*T/2)), T/(2*(L + R*T/2))]\n    >>> denZ\n    [1, (-L + R*T/2)/(L + R*T/2)]\n\n    >>> numZ, denZ = gbt(tf, T, 0)\n    >>> numZ\n    [T/L]\n    >>> denZ\n    [1, (-L + R*T)/L]\n\n    >>> numZ, denZ = gbt(tf, T, 1)\n    >>> numZ\n    [T/(L + R*T), 0]\n    >>> denZ\n    [1, -L/(L + R*T)]\n\n    >>> numZ, denZ = gbt(tf, T, 0.3)\n    >>> numZ\n    [3*T/(10*(L + 3*R*T/10)), 7*T/(10*(L + 3*R*T/10))]\n    >>> denZ\n    [1, (-L + 7*R*T/10)/(L + 3*R*T/10)]\n\n    References\n    ==========\n\n    .. [1] https://www.polyu.edu.hk/ama/profile/gfzhang/Research/ZCC09_IJC.pdf\n    ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "bilinear",
    "full_id": "sympy.physics.control.lti.bilinear",
    "type": "function",
    "description": "\n    Returns falling coefficients of H(z) from numerator and denominator.\n\n    Explanation\n    ===========\n\n    Where H(z) is the corresponding discretized transfer function,\n    discretized with the bilinear transform method.\n    H(z) is obtained from the continuous transfer function H(s)\n    by substituting $s(z) = \\frac{2}{T}\\frac{z-1}{z+1}$ into H(s), where T is the\n    sample period.\n    Coefficients are falling, i.e. $H(z) = \\frac{az+b}{cz+d}$ is returned\n    as [a, b], [c, d].\n\n    Examples\n    ========\n\n    >>> from sympy.physics.control.lti import TransferFunction, bilinear\n    >>> from sympy.abc import s, L, R, T\n\n    >>> tf = TransferFunction(1, s*L + R, s)\n    >>> numZ, denZ = bilinear(tf, T)\n    >>> numZ\n    [T/(2*(L + R*T/2)), T/(2*(L + R*T/2))]\n    >>> denZ\n    [1, (-L + R*T/2)/(L + R*T/2)]\n    ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "forward_diff",
    "full_id": "sympy.physics.control.lti.forward_diff",
    "type": "function",
    "description": "\n    Returns falling coefficients of H(z) from numerator and denominator.\n\n    Explanation\n    ===========\n\n    Where H(z) is the corresponding discretized transfer function,\n    discretized with the forward difference transform method.\n    H(z) is obtained from the continuous transfer function H(s)\n    by substituting $s(z) = \\frac{z-1}{T}$ into H(s), where T is the\n    sample period.\n    Coefficients are falling, i.e. $H(z) = \\frac{az+b}{cz+d}$ is returned\n    as [a, b], [c, d].\n\n    Examples\n    ========\n\n    >>> from sympy.physics.control.lti import TransferFunction, forward_diff\n    >>> from sympy.abc import s, L, R, T\n\n    >>> tf = TransferFunction(1, s*L + R, s)\n    >>> numZ, denZ = forward_diff(tf, T)\n    >>> numZ\n    [T/L]\n    >>> denZ\n    [1, (-L + R*T)/L]\n    ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "backward_diff",
    "full_id": "sympy.physics.control.lti.backward_diff",
    "type": "function",
    "description": "\n    Returns falling coefficients of H(z) from numerator and denominator.\n\n    Explanation\n    ===========\n\n    Where H(z) is the corresponding discretized transfer function,\n    discretized with the backward difference transform method.\n    H(z) is obtained from the continuous transfer function H(s)\n    by substituting $s(z) =  \\frac{z-1}{Tz}$ into H(s), where T is the\n    sample period.\n    Coefficients are falling, i.e. $H(z) = \\frac{az+b}{cz+d}$ is returned\n    as [a, b], [c, d].\n\n    Examples\n    ========\n\n    >>> from sympy.physics.control.lti import TransferFunction, backward_diff\n    >>> from sympy.abc import s, L, R, T\n\n    >>> tf = TransferFunction(1, s*L + R, s)\n    >>> numZ, denZ = backward_diff(tf, T)\n    >>> numZ\n    [T/(L + R*T), 0]\n    >>> denZ\n    [1, -L/(L + R*T)]\n    ",
    "section": "lti",
    "url": "https://docs.sympy.org/latest/modules/physics/control/lti.html"
  },
  {
    "name": "applied_loads",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.applied_loads",
    "type": "property",
    "description": "\n        Returns a list of all loads applied on the beam object.\n        Each load in the list is a tuple of form (value, start, order, end).\n\n        Examples\n        ========\n        There is a beam of length 4 meters. A moment of magnitude 3 Nm is\n        applied in the clockwise direction at the starting point of the beam.\n        A pointload of magnitude 4 N is applied from the top of the beam at\n        2 meters from the starting point. Another pointload of magnitude 5 N\n        is applied at same position.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> b = Beam(4, E, I)\n        >>> b.apply_load(-3, 0, -2)\n        >>> b.apply_load(4, 2, -1)\n        >>> b.apply_load(5, 2, -1)\n        >>> b.load\n        -3*SingularityFunction(x, 0, -2) + 9*SingularityFunction(x, 2, -1)\n        >>> b.applied_loads\n        [(-3, 0, -2, None), (4, 2, -1, None), (5, 2, -1, None)]\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "apply_load",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.apply_load",
    "type": "method",
    "description": "\n        This method adds up the loads given to a particular beam object.\n\n        Parameters\n        ==========\n        value : Sympifyable\n            The value inserted should have the units [Force/(Distance**(n+1)]\n            where n is the order of applied load.\n            Units for applied loads:\n\n               - For moments, unit = kN*m\n               - For point loads, unit = kN\n               - For constant distributed load, unit = kN/m\n               - For ramp loads, unit = kN/m/m\n               - For parabolic ramp loads, unit = kN/m/m/m\n               - ... so on.\n\n        start : Sympifyable\n            The starting point of the applied load. For point moments and\n            point forces this is the location of application.\n        order : Integer\n            The order of the applied load.\n\n               - For moments, order = -2\n               - For point loads, order =-1\n               - For constant distributed load, order = 0\n               - For ramp loads, order = 1\n               - For parabolic ramp loads, order = 2\n               - ... so on.\n\n        end : Sympifyable, optional\n            An optional argument that can be used if the load has an end point\n            within the length of the beam.\n\n        Examples\n        ========\n        There is a beam of length 4 meters. A moment of magnitude 3 Nm is\n        applied in the clockwise direction at the starting point of the beam.\n        A point load of magnitude 4 N is applied from the top of the beam at\n        2 meters from the starting point and a parabolic ramp load of magnitude\n        2 N/m is applied below the beam starting from 2 meters to 3 meters\n        away from the starting point of the beam.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> b = Beam(4, E, I)\n        >>> b.apply_load(-3, 0, -2)\n        >>> b.apply_load(4, 2, -1)\n        >>> b.apply_load(-2, 2, 2, end=3)\n        >>> b.load\n        -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2)\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "apply_support",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.apply_support",
    "type": "method",
    "description": "\n        This method applies support to a particular beam object and returns\n        the symbol of the unknown reaction load(s).\n\n        Parameters\n        ==========\n        loc : Sympifyable\n            Location of point at which support is applied.\n        type : String\n            Determines type of Beam support applied. To apply support structure\n            with\n            - zero degree of freedom, type = \"fixed\"\n            - one degree of freedom, type = \"pin\"\n            - two degrees of freedom, type = \"roller\"\n\n        Returns\n        =======\n        Symbol or tuple of Symbol\n            The unknown reaction load as a symbol.\n            - Symbol(reaction_force) if type = \"pin\" or \"roller\"\n            - Symbol(reaction_force), Symbol(reaction_moment) if type = \"fixed\"\n\n        Examples\n        ========\n        There is a beam of length 20 meters. A moment of magnitude 100 Nm is\n        applied in the clockwise direction at the end of the beam. A pointload\n        of magnitude 8 N is applied from the top of the beam at a distance of 10 meters.\n        There is one fixed support at the start of the beam and a roller at the end.\n\n        Using the sign convention of upward forces and clockwise moment\n        being positive.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> b = Beam(20, E, I)\n        >>> p0, m0 = b.apply_support(0, 'fixed')\n        >>> p1 = b.apply_support(20, 'roller')\n        >>> b.apply_load(-8, 10, -1)\n        >>> b.apply_load(100, 20, -2)\n        >>> b.solve_for_reaction_loads(p0, m0, p1)\n        >>> b.reaction_loads\n        {M_0: 20, R_0: -2, R_20: 10}\n        >>> b.reaction_loads[p0]\n        -2\n        >>> b.load\n        20*SingularityFunction(x, 0, -2) - 2*SingularityFunction(x, 0, -1)\n        - 8*SingularityFunction(x, 10, -1) + 100*SingularityFunction(x, 20, -2)\n        + 10*SingularityFunction(x, 20, -1)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "area",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.area",
    "type": "property",
    "description": "Cross-sectional area of the Beam.",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "bending_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.bending_moment",
    "type": "method",
    "description": "\n        Returns a Singularity Function expression which represents\n        the bending moment curve of the Beam object.\n\n        Examples\n        ========\n        There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n        applied in the clockwise direction at the end of the beam. A pointload\n        of magnitude 8 N is applied from the top of the beam at the starting\n        point. There are two simple supports below the beam. One at the end\n        and another one at a distance of 10 meters from the start. The\n        deflection is restricted at both the supports.\n\n        Using the sign convention of upward forces and clockwise moment\n        being positive.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> R1, R2 = symbols('R1, R2')\n        >>> b = Beam(30, E, I)\n        >>> b.apply_load(-8, 0, -1)\n        >>> b.apply_load(R1, 10, -1)\n        >>> b.apply_load(R2, 30, -1)\n        >>> b.apply_load(120, 30, -2)\n        >>> b.bc_deflection = [(10, 0), (30, 0)]\n        >>> b.solve_for_reaction_loads(R1, R2)\n        >>> b.bending_moment()\n        8*SingularityFunction(x, 0, 1) - 6*SingularityFunction(x, 10, 1) - 120*SingularityFunction(x, 30, 0) - 2*SingularityFunction(x, 30, 1)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "boundary_conditions",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.boundary_conditions",
    "type": "property",
    "description": "\n        Returns a dictionary of boundary conditions applied on the beam.\n        The dictionary has three keywords namely moment, slope and deflection.\n        The value of each keyword is a list of tuple, where each tuple\n        contains location and value of a boundary condition in the format\n        (location, value).\n\n        Examples\n        ========\n        There is a beam of length 4 meters. The bending moment at 0 should be 4\n        and at 4 it should be 0. The slope of the beam should be 1 at 0. The\n        deflection should be 2 at 0.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> b = Beam(4, E, I)\n        >>> b.bc_deflection = [(0, 2)]\n        >>> b.bc_slope = [(0, 1)]\n        >>> b.boundary_conditions\n        {'deflection': [(0, 2)], 'slope': [(0, 1)]}\n\n        Here the deflection of the beam should be ``2`` at ``0``.\n        Similarly, the slope of the beam should be ``1`` at ``0``.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "cross_section",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.cross_section",
    "type": "property",
    "description": "Cross-section of the beam",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "deflection",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.deflection",
    "type": "method",
    "description": "\n        Returns a Singularity Function expression which represents\n        the elastic curve or deflection of the Beam object.\n\n        Examples\n        ========\n        There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n        applied in the clockwise direction at the end of the beam. A pointload\n        of magnitude 8 N is applied from the top of the beam at the starting\n        point. There are two simple supports below the beam. One at the end\n        and another one at a distance of 10 meters from the start. The\n        deflection is restricted at both the supports.\n\n        Using the sign convention of upward forces and clockwise moment\n        being positive.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> R1, R2 = symbols('R1, R2')\n        >>> b = Beam(30, E, I)\n        >>> b.apply_load(-8, 0, -1)\n        >>> b.apply_load(R1, 10, -1)\n        >>> b.apply_load(R2, 30, -1)\n        >>> b.apply_load(120, 30, -2)\n        >>> b.bc_deflection = [(10, 0), (30, 0)]\n        >>> b.solve_for_reaction_loads(R1, R2)\n        >>> b.deflection()\n        (4000*x/3 - 4*SingularityFunction(x, 0, 3)/3 + SingularityFunction(x, 10, 3)\n            + 60*SingularityFunction(x, 30, 2) + SingularityFunction(x, 30, 3)/3 - 12000)/(E*I)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "draw",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.draw",
    "type": "method",
    "description": "\n        Returns a plot object representing the beam diagram of the beam.\n        In particular, the diagram might include:\n\n        * the beam.\n        * vertical black arrows represent point loads and support reaction\n          forces (the latter if they have been added with the ``apply_load``\n          method).\n        * circular arrows represent moments.\n        * shaded areas represent distributed loads.\n        * the support, if ``apply_support`` has been executed.\n        * if a composite beam has been created with the ``join`` method and\n          a hinge has been specified, it will be shown with a white disc.\n\n        The diagram shows positive loads on the upper side of the beam,\n        and negative loads on the lower side. If two or more distributed\n        loads acts along the same direction over the same region, the\n        function will add them up together.\n\n        .. note::\n            The user must be careful while entering load values.\n            The draw function assumes a sign convention which is used\n            for plotting loads.\n            Given a right handed coordinate system with XYZ coordinates,\n            the beam's length is assumed to be along the positive X axis.\n            The draw function recognizes positive loads(with n>-2) as loads\n            acting along negative Y direction and positive moments acting\n            along positive Z direction.\n\n        Parameters\n        ==========\n\n        pictorial: Boolean (default=True)\n            Setting ``pictorial=True`` would simply create a pictorial (scaled)\n            view of the beam diagram. On the other hand, ``pictorial=False``\n            would create a beam diagram with the exact dimensions on the plot.\n\n        Examples\n        ========\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> from sympy import symbols\n            >>> P1, P2, M = symbols('P1, P2, M')\n            >>> E, I = symbols('E, I')\n            >>> b = Beam(50, 20, 30)\n            >>> b.apply_load(-10, 2, -1)\n            >>> b.apply_load(15, 26, -1)\n            >>> b.apply_load(P1, 10, -1)\n            >>> b.apply_load(-P2, 40, -1)\n            >>> b.apply_load(90, 5, 0, 23)\n            >>> b.apply_load(10, 30, 1, 50)\n            >>> b.apply_load(M, 15, -2)\n            >>> b.apply_load(-M, 30, -2)\n            >>> p50 = b.apply_support(50, \"pin\")\n            >>> p0, m0 = b.apply_support(0, \"fixed\")\n            >>> p20 = b.apply_support(20, \"roller\")\n            >>> p = b.draw()  # doctest: +SKIP\n            >>> p  # doctest: +ELLIPSIS,+SKIP\n            Plot object containing:\n            [0]: cartesian line: 25*SingularityFunction(x, 5, 0) - 25*SingularityFunction(x, 23, 0)\n            + SingularityFunction(x, 30, 1) - 20*SingularityFunction(x, 50, 0)\n            - SingularityFunction(x, 50, 1) + 5 for x over (0.0, 50.0)\n            [1]: cartesian line: 5 for x over (0.0, 50.0)\n            ...\n            >>> p.show() # doctest: +SKIP\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "elastic_modulus",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.elastic_modulus",
    "type": "property",
    "description": "Young's Modulus of the Beam.",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "ild_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.ild_moment",
    "type": "property",
    "description": "Returns the I.L.D. moment equation.",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "ild_reactions",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.ild_reactions",
    "type": "property",
    "description": "Returns the I.L.D. reaction forces in a dictionary.",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "ild_shear",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.ild_shear",
    "type": "property",
    "description": "Returns the I.L.D. shear equation.",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "join",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.join",
    "type": "method",
    "description": "\n        This method joins two beams to make a new composite beam system.\n        Passed Beam class instance is attached to the right end of calling\n        object. This method can be used to form beams having Discontinuous\n        values of Elastic modulus or Second moment.\n\n        Parameters\n        ==========\n        beam : Beam class object\n            The Beam object which would be connected to the right of calling\n            object.\n        via : String\n            States the way two Beam object would get connected\n            - For axially fixed Beams, via=\"fixed\"\n            - For Beams connected via hinge, via=\"hinge\"\n\n        Examples\n        ========\n        There is a cantilever beam of length 4 meters. For first 2 meters\n        its moment of inertia is `1.5*I` and `I` for the other end.\n        A pointload of magnitude 4 N is applied from the top at its free end.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> R1, R2 = symbols('R1, R2')\n        >>> b1 = Beam(2, E, 1.5*I)\n        >>> b2 = Beam(2, E, I)\n        >>> b = b1.join(b2, \"fixed\")\n        >>> b.apply_load(20, 4, -1)\n        >>> b.apply_load(R1, 0, -1)\n        >>> b.apply_load(R2, 0, -2)\n        >>> b.bc_slope = [(0, 0)]\n        >>> b.bc_deflection = [(0, 0)]\n        >>> b.solve_for_reaction_loads(R1, R2)\n        >>> b.load\n        80*SingularityFunction(x, 0, -2) - 20*SingularityFunction(x, 0, -1) + 20*SingularityFunction(x, 4, -1)\n        >>> b.slope()\n        (-((-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))/I + 120/I)/E + 80.0/(E*I))*SingularityFunction(x, 2, 0)\n        - 0.666666666666667*(-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 0, 0)/(E*I)\n        + 0.666666666666667*(-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 2, 0)/(E*I)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "length",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.length",
    "type": "property",
    "description": "Length of the Beam.",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "load",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.load",
    "type": "property",
    "description": "\n        Returns a Singularity Function expression which represents\n        the load distribution curve of the Beam object.\n\n        Examples\n        ========\n        There is a beam of length 4 meters. A moment of magnitude 3 Nm is\n        applied in the clockwise direction at the starting point of the beam.\n        A point load of magnitude 4 N is applied from the top of the beam at\n        2 meters from the starting point and a parabolic ramp load of magnitude\n        2 N/m is applied below the beam starting from 3 meters away from the\n        starting point of the beam.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> b = Beam(4, E, I)\n        >>> b.apply_load(-3, 0, -2)\n        >>> b.apply_load(4, 2, -1)\n        >>> b.apply_load(-2, 3, 2)\n        >>> b.load\n        -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 3, 2)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "max_bmoment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.max_bmoment",
    "type": "method",
    "description": "Returns maximum Shear force and its coordinate\n        in the Beam object.",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "max_deflection",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.max_deflection",
    "type": "method",
    "description": "\n        Returns point of max deflection and its corresponding deflection value\n        in a Beam object.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_bending_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.plot_bending_moment",
    "type": "method",
    "description": "\n\n        Returns a plot for Bending moment present in the Beam object.\n\n        Parameters\n        ==========\n        subs : dictionary\n            Python dictionary containing Symbols as key and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n        is applied from half of the beam till the end. There are two simple supports\n        below the beam, one at the starting point and another at the ending point\n        of the beam. A pointload of magnitude 5 KN is also applied from top of the\n        beam, at a distance of 4 meters from the starting point.\n        Take E = 200 GPa and I = 400*(10**-6) meter**4.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> from sympy import symbols\n            >>> R1, R2 = symbols('R1, R2')\n            >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n            >>> b.apply_load(5000, 2, -1)\n            >>> b.apply_load(R1, 0, -1)\n            >>> b.apply_load(R2, 8, -1)\n            >>> b.apply_load(10000, 4, 0, end=8)\n            >>> b.bc_deflection = [(0, 0), (8, 0)]\n            >>> b.solve_for_reaction_loads(R1, R2)\n            >>> b.plot_bending_moment()\n            Plot object containing:\n            [0]: cartesian line: 13750*SingularityFunction(x, 0, 1) - 5000*SingularityFunction(x, 2, 1)\n            - 5000*SingularityFunction(x, 4, 2) + 31250*SingularityFunction(x, 8, 1)\n            + 5000*SingularityFunction(x, 8, 2) for x over (0.0, 8.0)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_deflection",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.plot_deflection",
    "type": "method",
    "description": "\n\n        Returns a plot for deflection curve of the Beam object.\n\n        Parameters\n        ==========\n        subs : dictionary\n            Python dictionary containing Symbols as key and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n        is applied from half of the beam till the end. There are two simple supports\n        below the beam, one at the starting point and another at the ending point\n        of the beam. A pointload of magnitude 5 KN is also applied from top of the\n        beam, at a distance of 4 meters from the starting point.\n        Take E = 200 GPa and I = 400*(10**-6) meter**4.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> from sympy import symbols\n            >>> R1, R2 = symbols('R1, R2')\n            >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n            >>> b.apply_load(5000, 2, -1)\n            >>> b.apply_load(R1, 0, -1)\n            >>> b.apply_load(R2, 8, -1)\n            >>> b.apply_load(10000, 4, 0, end=8)\n            >>> b.bc_deflection = [(0, 0), (8, 0)]\n            >>> b.solve_for_reaction_loads(R1, R2)\n            >>> b.plot_deflection()\n            Plot object containing:\n            [0]: cartesian line: 0.00138541666666667*x - 2.86458333333333e-5*SingularityFunction(x, 0, 3)\n            + 1.04166666666667e-5*SingularityFunction(x, 2, 3) + 5.20833333333333e-6*SingularityFunction(x, 4, 4)\n            - 6.51041666666667e-5*SingularityFunction(x, 8, 3) - 5.20833333333333e-6*SingularityFunction(x, 8, 4)\n            for x over (0.0, 8.0)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_ild_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.plot_ild_moment",
    "type": "method",
    "description": "\n\n        Plots the Influence Line Diagram for Moment under the effect\n        of a moving load. This function should be called after\n        calling solve_for_ild_moment().\n\n        Parameters\n        ==========\n\n        subs : dictionary\n               Python dictionary containing Symbols as key and their\n               corresponding values.\n\n        Examples\n        ========\n\n        There is a beam of length 12 meters. There are two simple supports\n        below the beam, one at the starting point and another at a distance\n        of 8 meters. Plot the I.L.D. for Moment at a distance\n        of 4 meters under the effect of a moving load of magnitude 1kN.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy import symbols\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> E, I = symbols('E, I')\n            >>> R_0, R_8 = symbols('R_0, R_8')\n            >>> b = Beam(12, E, I)\n            >>> p0 = b.apply_support(0, 'roller')\n            >>> p8 = b.apply_support(8, 'roller')\n            >>> b.solve_for_ild_reactions(1, R_0, R_8)\n            >>> b.solve_for_ild_moment(4, 1, R_0, R_8)\n            >>> b.ild_moment\n            Piecewise((-x/2, x < 4), (x/2 - 4, x > 4))\n            >>> b.plot_ild_moment()\n            Plot object containing:\n            [0]: cartesian line: Piecewise((-x/2, x < 4), (x/2 - 4, x > 4)) for x over (0.0, 12.0)\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_ild_reactions",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.plot_ild_reactions",
    "type": "method",
    "description": "\n\n        Plots the Influence Line Diagram of Reaction Forces\n        under the effect of a moving load. This function\n        should be called after calling solve_for_ild_reactions().\n\n        Parameters\n        ==========\n\n        subs : dictionary\n               Python dictionary containing Symbols as key and their\n               corresponding values.\n\n        Examples\n        ========\n\n        There is a beam of length 10 meters. A point load of magnitude 5KN\n        is also applied from top of the beam, at a distance of 4 meters\n        from the starting point. There are two simple supports below the\n        beam, located at the starting point and at a distance of 7 meters\n        from the starting point. Plot the I.L.D. equations for reactions\n        at both support points under the effect of a moving load\n        of magnitude 1kN.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy import symbols\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> E, I = symbols('E, I')\n            >>> R_0, R_7 = symbols('R_0, R_7')\n            >>> b = Beam(10, E, I)\n            >>> p0 = b.apply_support(0, 'roller')\n            >>> p7 = b.apply_support(7, 'roller')\n            >>> b.apply_load(5,4,-1)\n            >>> b.solve_for_ild_reactions(1,R_0,R_7)\n            >>> b.ild_reactions\n            {R_0: x/7 - 22/7, R_7: -x/7 - 20/7}\n            >>> b.plot_ild_reactions()\n            PlotGrid object containing:\n            Plot[0]:Plot object containing:\n            [0]: cartesian line: x/7 - 22/7 for x over (0.0, 10.0)\n            Plot[1]:Plot object containing:\n            [0]: cartesian line: -x/7 - 20/7 for x over (0.0, 10.0)\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_ild_shear",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.plot_ild_shear",
    "type": "method",
    "description": "\n\n        Plots the Influence Line Diagram for Shear under the effect\n        of a moving load. This function should be called after\n        calling solve_for_ild_shear().\n\n        Parameters\n        ==========\n\n        subs : dictionary\n               Python dictionary containing Symbols as key and their\n               corresponding values.\n\n        Examples\n        ========\n\n        There is a beam of length 12 meters. There are two simple supports\n        below the beam, one at the starting point and another at a distance\n        of 8 meters. Plot the I.L.D. for Shear at a distance\n        of 4 meters under the effect of a moving load of magnitude 1kN.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy import symbols\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> E, I = symbols('E, I')\n            >>> R_0, R_8 = symbols('R_0, R_8')\n            >>> b = Beam(12, E, I)\n            >>> p0 = b.apply_support(0, 'roller')\n            >>> p8 = b.apply_support(8, 'roller')\n            >>> b.solve_for_ild_reactions(1, R_0, R_8)\n            >>> b.solve_for_ild_shear(4, 1, R_0, R_8)\n            >>> b.ild_shear\n            Piecewise((x/8, x < 4), (x/8 - 1, x > 4))\n            >>> b.plot_ild_shear()\n            Plot object containing:\n            [0]: cartesian line: Piecewise((x/8, x < 4), (x/8 - 1, x > 4)) for x over (0.0, 12.0)\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_loading_results",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.plot_loading_results",
    "type": "method",
    "description": "\n        Returns a subplot of Shear Force, Bending Moment,\n        Slope and Deflection of the Beam object.\n\n        Parameters\n        ==========\n\n        subs : dictionary\n               Python dictionary containing Symbols as key and their\n               corresponding values.\n\n        Examples\n        ========\n\n        There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n        is applied from half of the beam till the end. There are two simple supports\n        below the beam, one at the starting point and another at the ending point\n        of the beam. A pointload of magnitude 5 KN is also applied from top of the\n        beam, at a distance of 4 meters from the starting point.\n        Take E = 200 GPa and I = 400*(10**-6) meter**4.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> from sympy import symbols\n            >>> R1, R2 = symbols('R1, R2')\n            >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n            >>> b.apply_load(5000, 2, -1)\n            >>> b.apply_load(R1, 0, -1)\n            >>> b.apply_load(R2, 8, -1)\n            >>> b.apply_load(10000, 4, 0, end=8)\n            >>> b.bc_deflection = [(0, 0), (8, 0)]\n            >>> b.solve_for_reaction_loads(R1, R2)\n            >>> axes = b.plot_loading_results()\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_shear_force",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.plot_shear_force",
    "type": "method",
    "description": "\n\n        Returns a plot for Shear force present in the Beam object.\n\n        Parameters\n        ==========\n        subs : dictionary\n            Python dictionary containing Symbols as key and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n        is applied from half of the beam till the end. There are two simple supports\n        below the beam, one at the starting point and another at the ending point\n        of the beam. A pointload of magnitude 5 KN is also applied from top of the\n        beam, at a distance of 4 meters from the starting point.\n        Take E = 200 GPa and I = 400*(10**-6) meter**4.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> from sympy import symbols\n            >>> R1, R2 = symbols('R1, R2')\n            >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n            >>> b.apply_load(5000, 2, -1)\n            >>> b.apply_load(R1, 0, -1)\n            >>> b.apply_load(R2, 8, -1)\n            >>> b.apply_load(10000, 4, 0, end=8)\n            >>> b.bc_deflection = [(0, 0), (8, 0)]\n            >>> b.solve_for_reaction_loads(R1, R2)\n            >>> b.plot_shear_force()\n            Plot object containing:\n            [0]: cartesian line: 13750*SingularityFunction(x, 0, 0) - 5000*SingularityFunction(x, 2, 0)\n            - 10000*SingularityFunction(x, 4, 1) + 31250*SingularityFunction(x, 8, 0)\n            + 10000*SingularityFunction(x, 8, 1) for x over (0.0, 8.0)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_shear_stress",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.plot_shear_stress",
    "type": "method",
    "description": "\n\n        Returns a plot of shear stress present in the beam object.\n\n        Parameters\n        ==========\n        subs : dictionary\n            Python dictionary containing Symbols as key and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 8 meters and area of cross section 2 square\n        meters. A constant distributed load of 10 KN/m is applied from half of\n        the beam till the end. There are two simple supports below the beam,\n        one at the starting point and another at the ending point of the beam.\n        A pointload of magnitude 5 KN is also applied from top of the\n        beam, at a distance of 4 meters from the starting point.\n        Take E = 200 GPa and I = 400*(10**-6) meter**4.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> from sympy import symbols\n            >>> R1, R2 = symbols('R1, R2')\n            >>> b = Beam(8, 200*(10**9), 400*(10**-6), 2)\n            >>> b.apply_load(5000, 2, -1)\n            >>> b.apply_load(R1, 0, -1)\n            >>> b.apply_load(R2, 8, -1)\n            >>> b.apply_load(10000, 4, 0, end=8)\n            >>> b.bc_deflection = [(0, 0), (8, 0)]\n            >>> b.solve_for_reaction_loads(R1, R2)\n            >>> b.plot_shear_stress()\n            Plot object containing:\n            [0]: cartesian line: 6875*SingularityFunction(x, 0, 0) - 2500*SingularityFunction(x, 2, 0)\n            - 5000*SingularityFunction(x, 4, 1) + 15625*SingularityFunction(x, 8, 0)\n            + 5000*SingularityFunction(x, 8, 1) for x over (0.0, 8.0)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_slope",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.plot_slope",
    "type": "method",
    "description": "\n\n        Returns a plot for slope of deflection curve of the Beam object.\n\n        Parameters\n        ==========\n        subs : dictionary\n            Python dictionary containing Symbols as key and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 8 meters. A constant distributed load of 10 KN/m\n        is applied from half of the beam till the end. There are two simple supports\n        below the beam, one at the starting point and another at the ending point\n        of the beam. A pointload of magnitude 5 KN is also applied from top of the\n        beam, at a distance of 4 meters from the starting point.\n        Take E = 200 GPa and I = 400*(10**-6) meter**4.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> from sympy import symbols\n            >>> R1, R2 = symbols('R1, R2')\n            >>> b = Beam(8, 200*(10**9), 400*(10**-6))\n            >>> b.apply_load(5000, 2, -1)\n            >>> b.apply_load(R1, 0, -1)\n            >>> b.apply_load(R2, 8, -1)\n            >>> b.apply_load(10000, 4, 0, end=8)\n            >>> b.bc_deflection = [(0, 0), (8, 0)]\n            >>> b.solve_for_reaction_loads(R1, R2)\n            >>> b.plot_slope()\n            Plot object containing:\n            [0]: cartesian line: -8.59375e-5*SingularityFunction(x, 0, 2) + 3.125e-5*SingularityFunction(x, 2, 2)\n            + 2.08333333333333e-5*SingularityFunction(x, 4, 3) - 0.0001953125*SingularityFunction(x, 8, 2)\n            - 2.08333333333333e-5*SingularityFunction(x, 8, 3) + 0.00138541666666667 for x over (0.0, 8.0)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "point_cflexure",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.point_cflexure",
    "type": "method",
    "description": "\n        Returns a Set of point(s) with zero bending moment and\n        where bending moment curve of the beam object changes\n        its sign from negative to positive or vice versa.\n\n        Examples\n        ========\n        There is is 10 meter long overhanging beam. There are\n        two simple supports below the beam. One at the start\n        and another one at a distance of 6 meters from the start.\n        Point loads of magnitude 10KN and 20KN are applied at\n        2 meters and 4 meters from start respectively. A Uniformly\n        distribute load of magnitude of magnitude 3KN/m is also\n        applied on top starting from 6 meters away from starting\n        point till end.\n        Using the sign convention of upward forces and clockwise moment\n        being positive.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> b = Beam(10, E, I)\n        >>> b.apply_load(-4, 0, -1)\n        >>> b.apply_load(-46, 6, -1)\n        >>> b.apply_load(10, 2, -1)\n        >>> b.apply_load(20, 4, -1)\n        >>> b.apply_load(3, 6, 0)\n        >>> b.point_cflexure()\n        [10/3]\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "reaction_loads",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.reaction_loads",
    "type": "property",
    "description": "Returns the reaction forces in a dictionary.",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "remove_load",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.remove_load",
    "type": "method",
    "description": "\n        This method removes a particular load present on the beam object.\n        Returns a ValueError if the load passed as an argument is not\n        present on the beam.\n\n        Parameters\n        ==========\n        value : Sympifyable\n            The magnitude of an applied load.\n        start : Sympifyable\n            The starting point of the applied load. For point moments and\n            point forces this is the location of application.\n        order : Integer\n            The order of the applied load.\n            - For moments, order= -2\n            - For point loads, order=-1\n            - For constant distributed load, order=0\n            - For ramp loads, order=1\n            - For parabolic ramp loads, order=2\n            - ... so on.\n        end : Sympifyable, optional\n            An optional argument that can be used if the load has an end point\n            within the length of the beam.\n\n        Examples\n        ========\n        There is a beam of length 4 meters. A moment of magnitude 3 Nm is\n        applied in the clockwise direction at the starting point of the beam.\n        A pointload of magnitude 4 N is applied from the top of the beam at\n        2 meters from the starting point and a parabolic ramp load of magnitude\n        2 N/m is applied below the beam starting from 2 meters to 3 meters\n        away from the starting point of the beam.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> b = Beam(4, E, I)\n        >>> b.apply_load(-3, 0, -2)\n        >>> b.apply_load(4, 2, -1)\n        >>> b.apply_load(-2, 2, 2, end=3)\n        >>> b.load\n        -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2)\n        >>> b.remove_load(-2, 2, 2, end = 3)\n        >>> b.load\n        -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "second_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.second_moment",
    "type": "property",
    "description": "Second moment of area of the Beam.",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "shear_force",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.shear_force",
    "type": "method",
    "description": "\n        Returns a Singularity Function expression which represents\n        the shear force curve of the Beam object.\n\n        Examples\n        ========\n        There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n        applied in the clockwise direction at the end of the beam. A pointload\n        of magnitude 8 N is applied from the top of the beam at the starting\n        point. There are two simple supports below the beam. One at the end\n        and another one at a distance of 10 meters from the start. The\n        deflection is restricted at both the supports.\n\n        Using the sign convention of upward forces and clockwise moment\n        being positive.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> R1, R2 = symbols('R1, R2')\n        >>> b = Beam(30, E, I)\n        >>> b.apply_load(-8, 0, -1)\n        >>> b.apply_load(R1, 10, -1)\n        >>> b.apply_load(R2, 30, -1)\n        >>> b.apply_load(120, 30, -2)\n        >>> b.bc_deflection = [(10, 0), (30, 0)]\n        >>> b.solve_for_reaction_loads(R1, R2)\n        >>> b.shear_force()\n        8*SingularityFunction(x, 0, 0) - 6*SingularityFunction(x, 10, 0) - 120*SingularityFunction(x, 30, -1) - 2*SingularityFunction(x, 30, 0)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "shear_stress",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.shear_stress",
    "type": "method",
    "description": "\n        Returns an expression representing the Shear Stress\n        curve of the Beam object.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "slope",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.slope",
    "type": "method",
    "description": "\n        Returns a Singularity Function expression which represents\n        the slope the elastic curve of the Beam object.\n\n        Examples\n        ========\n        There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n        applied in the clockwise direction at the end of the beam. A pointload\n        of magnitude 8 N is applied from the top of the beam at the starting\n        point. There are two simple supports below the beam. One at the end\n        and another one at a distance of 10 meters from the start. The\n        deflection is restricted at both the supports.\n\n        Using the sign convention of upward forces and clockwise moment\n        being positive.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> R1, R2 = symbols('R1, R2')\n        >>> b = Beam(30, E, I)\n        >>> b.apply_load(-8, 0, -1)\n        >>> b.apply_load(R1, 10, -1)\n        >>> b.apply_load(R2, 30, -1)\n        >>> b.apply_load(120, 30, -2)\n        >>> b.bc_deflection = [(10, 0), (30, 0)]\n        >>> b.solve_for_reaction_loads(R1, R2)\n        >>> b.slope()\n        (-4*SingularityFunction(x, 0, 2) + 3*SingularityFunction(x, 10, 2)\n            + 120*SingularityFunction(x, 30, 1) + SingularityFunction(x, 30, 2) + 4000/3)/(E*I)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "solve_for_ild_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.solve_for_ild_moment",
    "type": "method",
    "description": "\n\n        Determines the Influence Line Diagram equations for moment at a\n        specified point under the effect of a moving load.\n\n        Parameters\n        ==========\n        distance : Integer\n            Distance of the point from the start of the beam\n            for which equations are to be determined\n        value : Integer\n            Magnitude of moving load\n        reactions :\n            The reaction forces applied on the beam.\n\n        Examples\n        ========\n\n        There is a beam of length 12 meters. There are two simple supports\n        below the beam, one at the starting point and another at a distance\n        of 8 meters. Calculate the I.L.D. equations for Moment at a distance\n        of 4 meters under the effect of a moving load of magnitude 1kN.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy import symbols\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> E, I = symbols('E, I')\n            >>> R_0, R_8 = symbols('R_0, R_8')\n            >>> b = Beam(12, E, I)\n            >>> p0 = b.apply_support(0, 'roller')\n            >>> p8 = b.apply_support(8, 'roller')\n            >>> b.solve_for_ild_reactions(1, R_0, R_8)\n            >>> b.solve_for_ild_moment(4, 1, R_0, R_8)\n            >>> b.ild_moment\n            Piecewise((-x/2, x < 4), (x/2 - 4, x > 4))\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "solve_for_ild_reactions",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.solve_for_ild_reactions",
    "type": "method",
    "description": "\n\n        Determines the Influence Line Diagram equations for reaction\n        forces under the effect of a moving load.\n\n        Parameters\n        ==========\n        value : Integer\n            Magnitude of moving load\n        reactions :\n            The reaction forces applied on the beam.\n\n        Examples\n        ========\n\n        There is a beam of length 10 meters. There are two simple supports\n        below the beam, one at the starting point and another at the ending\n        point of the beam. Calculate the I.L.D. equations for reaction forces\n        under the effect of a moving load of magnitude 1kN.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy import symbols\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> E, I = symbols('E, I')\n            >>> R_0, R_10 = symbols('R_0, R_10')\n            >>> b = Beam(10, E, I)\n            >>> p0 = b.apply_support(0, 'roller')\n            >>> p10 = b.apply_support(10, 'roller')\n            >>> b.solve_for_ild_reactions(1,R_0,R_10)\n            >>> b.ild_reactions\n            {R_0: x/10 - 1, R_10: -x/10}\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "solve_for_ild_shear",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.solve_for_ild_shear",
    "type": "method",
    "description": "\n\n        Determines the Influence Line Diagram equations for shear at a\n        specified point under the effect of a moving load.\n\n        Parameters\n        ==========\n        distance : Integer\n            Distance of the point from the start of the beam\n            for which equations are to be determined\n        value : Integer\n            Magnitude of moving load\n        reactions :\n            The reaction forces applied on the beam.\n\n        Examples\n        ========\n\n        There is a beam of length 12 meters. There are two simple supports\n        below the beam, one at the starting point and another at a distance\n        of 8 meters. Calculate the I.L.D. equations for Shear at a distance\n        of 4 meters under the effect of a moving load of magnitude 1kN.\n\n        Using the sign convention of downwards forces being positive.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy import symbols\n            >>> from sympy.physics.continuum_mechanics.beam import Beam\n            >>> E, I = symbols('E, I')\n            >>> R_0, R_8 = symbols('R_0, R_8')\n            >>> b = Beam(12, E, I)\n            >>> p0 = b.apply_support(0, 'roller')\n            >>> p8 = b.apply_support(8, 'roller')\n            >>> b.solve_for_ild_reactions(1, R_0, R_8)\n            >>> b.solve_for_ild_shear(4, 1, R_0, R_8)\n            >>> b.ild_shear\n            Piecewise((x/8, x < 4), (x/8 - 1, x > 4))\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "solve_for_reaction_loads",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.solve_for_reaction_loads",
    "type": "method",
    "description": "\n        Solves for the reaction forces.\n\n        Examples\n        ========\n        There is a beam of length 30 meters. A moment of magnitude 120 Nm is\n        applied in the clockwise direction at the end of the beam. A pointload\n        of magnitude 8 N is applied from the top of the beam at the starting\n        point. There are two simple supports below the beam. One at the end\n        and another one at a distance of 10 meters from the start. The\n        deflection is restricted at both the supports.\n\n        Using the sign convention of upward forces and clockwise moment\n        being positive.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I = symbols('E, I')\n        >>> R1, R2 = symbols('R1, R2')\n        >>> b = Beam(30, E, I)\n        >>> b.apply_load(-8, 0, -1)\n        >>> b.apply_load(R1, 10, -1)  # Reaction force at x = 10\n        >>> b.apply_load(R2, 30, -1)  # Reaction force at x = 30\n        >>> b.apply_load(120, 30, -2)\n        >>> b.bc_deflection = [(10, 0), (30, 0)]\n        >>> b.load\n        R1*SingularityFunction(x, 10, -1) + R2*SingularityFunction(x, 30, -1)\n            - 8*SingularityFunction(x, 0, -1) + 120*SingularityFunction(x, 30, -2)\n        >>> b.solve_for_reaction_loads(R1, R2)\n        >>> b.reaction_loads\n        {R1: 6, R2: 2}\n        >>> b.load\n        -8*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 10, -1)\n            + 120*SingularityFunction(x, 30, -2) + 2*SingularityFunction(x, 30, -1)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "variable",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam.variable",
    "type": "property",
    "description": "\n        A symbol that can be used as a variable along the length of the beam\n        while representing load distribution, shear force curve, bending\n        moment, slope curve and the deflection curve. By default, it is set\n        to ``Symbol('x')``, but this property is mutable.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam\n        >>> from sympy import symbols\n        >>> E, I, A = symbols('E, I, A')\n        >>> x, y, z = symbols('x, y, z')\n        >>> b = Beam(4, E, I)\n        >>> b.variable\n        x\n        >>> b.variable = y\n        >>> b.variable\n        y\n        >>> b = Beam(4, E, I, A, z)\n        >>> b.variable\n        z\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "angular_deflection",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.angular_deflection",
    "type": "method",
    "description": "\n        Returns a function in x depicting how the angular deflection, due to moments\n        in the x-axis on the beam, varies with x.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "apply_load",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.apply_load",
    "type": "method",
    "description": "\n        This method adds up the force load to a particular beam object.\n\n        Parameters\n        ==========\n        value : Sympifyable\n            The magnitude of an applied load.\n        dir : String\n            Axis along which load is applied.\n        order : Integer\n            The order of the applied load.\n            - For point loads, order=-1\n            - For constant distributed load, order=0\n            - For ramp loads, order=1\n            - For parabolic ramp loads, order=2\n            - ... so on.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "apply_moment_load",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.apply_moment_load",
    "type": "method",
    "description": "\n        This method adds up the moment loads to a particular beam object.\n\n        Parameters\n        ==========\n        value : Sympifyable\n            The magnitude of an applied moment.\n        dir : String\n            Axis along which moment is applied.\n        order : Integer\n            The order of the applied load.\n            - For point moments, order=-2\n            - For constant distributed moment, order=-1\n            - For ramp moments, order=0\n            - For parabolic ramp moments, order=1\n            - ... so on.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "axial_force",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.axial_force",
    "type": "method",
    "description": "\n        Returns expression of Axial shear force present inside the Beam object.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "axial_stress",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.axial_stress",
    "type": "method",
    "description": "\n        Returns expression of Axial stress present inside the Beam object.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "bending_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.bending_moment",
    "type": "method",
    "description": "\n        Returns a list of three expressions which represents the bending moment\n        curve of the Beam object along all three axes.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "boundary_conditions",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.boundary_conditions",
    "type": "property",
    "description": "\n        Returns a dictionary of boundary conditions applied on the beam.\n        The dictionary has two keywords namely slope and deflection.\n        The value of each keyword is a list of tuple, where each tuple\n        contains location and value of a boundary condition in the format\n        (location, value). Further each value is a list corresponding to\n        slope or deflection(s) values along three axes at that location.\n\n        Examples\n        ========\n        There is a beam of length 4 meters. The slope at 0 should be 4 along\n        the x-axis and 0 along others. At the other end of beam, deflection\n        along all the three axes should be zero.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n        >>> from sympy import symbols\n        >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n        >>> b = Beam3D(30, E, G, I, A, x)\n        >>> b.bc_slope = [(0, (4, 0, 0))]\n        >>> b.bc_deflection = [(4, [0, 0, 0])]\n        >>> b.boundary_conditions\n        {'deflection': [(4, [0, 0, 0])], 'slope': [(0, (4, 0, 0))]}\n\n        Here the deflection of the beam should be ``0`` along all the three axes at ``4``.\n        Similarly, the slope of the beam should be ``4`` along x-axis and ``0``\n        along y and z axis at ``0``.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "deflection",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.deflection",
    "type": "method",
    "description": "\n        Returns a three element list representing deflection curve along all\n        the three axes.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "load_vector",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.load_vector",
    "type": "property",
    "description": "\n        Returns a three element list representing the load vector.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "max_bending_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.max_bending_moment",
    "type": "method",
    "description": "\n        Returns point of max bending moment and its corresponding bending moment value\n        along all directions in a Beam object as a list.\n        solve_for_reaction_loads() must be called before using this function.\n\n        Examples\n        ========\n        There is a beam of length 20 meters. It is supported by rollers\n        at both of its ends. A linear load having slope equal to 12 is applied\n        along y-axis. A constant distributed load of magnitude 15 N is\n        applied from start till its end along z-axis.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n            >>> from sympy import symbols\n            >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n            >>> b = Beam3D(20, 40, 21, 100, 25, x)\n            >>> b.apply_load(15, start=0, order=0, dir=\"z\")\n            >>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n            >>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n            >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n            >>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n            >>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n            >>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n            >>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n            >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n            >>> b.max_bending_moment()\n            [(0, 0), (20, 3000), (20, 16000)]\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "max_deflection",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.max_deflection",
    "type": "method",
    "description": "\n        Returns point of max deflection and its corresponding deflection value\n        along all directions in a Beam object as a list.\n        solve_for_reaction_loads() and solve_slope_deflection() must be called\n        before using this function.\n\n        Examples\n        ========\n        There is a beam of length 20 meters. It is supported by rollers\n        at both of its ends. A linear load having slope equal to 12 is applied\n        along y-axis. A constant distributed load of magnitude 15 N is\n        applied from start till its end along z-axis.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n            >>> from sympy import symbols\n            >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n            >>> b = Beam3D(20, 40, 21, 100, 25, x)\n            >>> b.apply_load(15, start=0, order=0, dir=\"z\")\n            >>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n            >>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n            >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n            >>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n            >>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n            >>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n            >>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n            >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n            >>> b.solve_slope_deflection()\n            >>> b.max_deflection()\n            [(0, 0), (10, 495/14), (-10 + 10*sqrt(10793)/43, (10 - 10*sqrt(10793)/43)**3/160 - 20/7 + (10 - 10*sqrt(10793)/43)**4/6400 + 20*sqrt(10793)/301 + 27*(10 - 10*sqrt(10793)/43)**2/560)]\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "max_shear_force",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.max_shear_force",
    "type": "method",
    "description": "\n        Returns point of max shear force and its corresponding shear value\n        along all directions in a Beam object as a list.\n        solve_for_reaction_loads() must be called before using this function.\n\n        Examples\n        ========\n        There is a beam of length 20 meters. It is supported by rollers\n        at both of its ends. A linear load having slope equal to 12 is applied\n        along y-axis. A constant distributed load of magnitude 15 N is\n        applied from start till its end along z-axis.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n            >>> from sympy import symbols\n            >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n            >>> b = Beam3D(20, 40, 21, 100, 25, x)\n            >>> b.apply_load(15, start=0, order=0, dir=\"z\")\n            >>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n            >>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n            >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n            >>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n            >>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n            >>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n            >>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n            >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n            >>> b.max_shear_force()\n            [(0, 0), (20, 2400), (20, 300)]\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "moment_load_vector",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.moment_load_vector",
    "type": "property",
    "description": "\n        Returns a three element list representing moment loads on Beam.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_bending_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.plot_bending_moment",
    "type": "method",
    "description": "\n\n        Returns a plot for bending moment along all three directions\n        present in the Beam object.\n\n        Parameters\n        ==========\n        dir : string (default : \"all\")\n            Direction along which bending moment plot is required.\n            If no direction is specified, all plots are displayed.\n        subs : dictionary\n            Python dictionary containing Symbols as key and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 20 meters. It is supported by rollers\n        at both of its ends. A linear load having slope equal to 12 is applied\n        along y-axis. A constant distributed load of magnitude 15 N is\n        applied from start till its end along z-axis.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n            >>> from sympy import symbols\n            >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n            >>> b = Beam3D(20, E, G, I, A, x)\n            >>> b.apply_load(15, start=0, order=0, dir=\"z\")\n            >>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n            >>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n            >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n            >>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n            >>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n            >>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n            >>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n            >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n            >>> b.plot_bending_moment()\n            PlotGrid object containing:\n            Plot[0]:Plot object containing:\n            [0]: cartesian line: 0 for x over (0.0, 20.0)\n            Plot[1]:Plot object containing:\n            [0]: cartesian line: -15*x**2/2 for x over (0.0, 20.0)\n            Plot[2]:Plot object containing:\n            [0]: cartesian line: 2*x**3 for x over (0.0, 20.0)\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_deflection",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.plot_deflection",
    "type": "method",
    "description": "\n\n        Returns a plot for Deflection along all three directions\n        present in the Beam object.\n\n        Parameters\n        ==========\n        dir : string (default : \"all\")\n            Direction along which deflection plot is required.\n            If no direction is specified, all plots are displayed.\n        subs : dictionary\n            Python dictionary containing Symbols as keys and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 20 meters. It is supported by rollers\n        at both of its ends. A linear load having slope equal to 12 is applied\n        along y-axis. A constant distributed load of magnitude 15 N is\n        applied from start till its end along z-axis.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n            >>> from sympy import symbols\n            >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n            >>> b = Beam3D(20, 40, 21, 100, 25, x)\n            >>> b.apply_load(15, start=0, order=0, dir=\"z\")\n            >>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n            >>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n            >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n            >>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n            >>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n            >>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n            >>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n            >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n            >>> b.solve_slope_deflection()\n            >>> b.plot_deflection()\n            PlotGrid object containing:\n            Plot[0]:Plot object containing:\n            [0]: cartesian line: 0 for x over (0.0, 20.0)\n            Plot[1]:Plot object containing:\n            [0]: cartesian line: x**5/40000 - 4013*x**3/90300 + 26*x**2/43 + 1520*x/903 for x over (0.0, 20.0)\n            Plot[2]:Plot object containing:\n            [0]: cartesian line: x**4/6400 - x**3/160 + 27*x**2/560 + 2*x/7 for x over (0.0, 20.0)\n\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_loading_results",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.plot_loading_results",
    "type": "method",
    "description": "\n\n        Returns a subplot of Shear Force, Bending Moment,\n        Slope and Deflection of the Beam object along the direction specified.\n\n        Parameters\n        ==========\n\n        dir : string (default : \"x\")\n               Direction along which plots are required.\n               If no direction is specified, plots along x-axis are displayed.\n        subs : dictionary\n               Python dictionary containing Symbols as key and their\n               corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 20 meters. It is supported by rollers\n        at both of its ends. A linear load having slope equal to 12 is applied\n        along y-axis. A constant distributed load of magnitude 15 N is\n        applied from start till its end along z-axis.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n            >>> from sympy import symbols\n            >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n            >>> b = Beam3D(20, E, G, I, A, x)\n            >>> subs = {E:40, G:21, I:100, A:25}\n            >>> b.apply_load(15, start=0, order=0, dir=\"z\")\n            >>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n            >>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n            >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n            >>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n            >>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n            >>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n            >>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n            >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n            >>> b.solve_slope_deflection()\n            >>> b.plot_loading_results('y',subs)\n            PlotGrid object containing:\n            Plot[0]:Plot object containing:\n            [0]: cartesian line: -6*x**2 for x over (0.0, 20.0)\n            Plot[1]:Plot object containing:\n            [0]: cartesian line: -15*x**2/2 for x over (0.0, 20.0)\n            Plot[2]:Plot object containing:\n            [0]: cartesian line: -x**3/1600 + 3*x**2/160 - x/8 for x over (0.0, 20.0)\n            Plot[3]:Plot object containing:\n            [0]: cartesian line: x**5/40000 - 4013*x**3/90300 + 26*x**2/43 + 1520*x/903 for x over (0.0, 20.0)\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_shear_force",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.plot_shear_force",
    "type": "method",
    "description": "\n\n        Returns a plot for Shear force along all three directions\n        present in the Beam object.\n\n        Parameters\n        ==========\n        dir : string (default : \"all\")\n            Direction along which shear force plot is required.\n            If no direction is specified, all plots are displayed.\n        subs : dictionary\n            Python dictionary containing Symbols as key and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 20 meters. It is supported by rollers\n        at both of its ends. A linear load having slope equal to 12 is applied\n        along y-axis. A constant distributed load of magnitude 15 N is\n        applied from start till its end along z-axis.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n            >>> from sympy import symbols\n            >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n            >>> b = Beam3D(20, E, G, I, A, x)\n            >>> b.apply_load(15, start=0, order=0, dir=\"z\")\n            >>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n            >>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n            >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n            >>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n            >>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n            >>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n            >>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n            >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n            >>> b.plot_shear_force()\n            PlotGrid object containing:\n            Plot[0]:Plot object containing:\n            [0]: cartesian line: 0 for x over (0.0, 20.0)\n            Plot[1]:Plot object containing:\n            [0]: cartesian line: -6*x**2 for x over (0.0, 20.0)\n            Plot[2]:Plot object containing:\n            [0]: cartesian line: -15*x for x over (0.0, 20.0)\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_shear_stress",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.plot_shear_stress",
    "type": "method",
    "description": "\n\n        Returns a plot for Shear Stress along all three directions\n        present in the Beam object.\n\n        Parameters\n        ==========\n        dir : string (default : \"all\")\n            Direction along which shear stress plot is required.\n            If no direction is specified, all plots are displayed.\n        subs : dictionary\n            Python dictionary containing Symbols as key and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 20 meters and area of cross section 2 square\n        meters. It is supported by rollers at both of its ends. A linear load having\n        slope equal to 12 is applied along y-axis. A constant distributed load\n        of magnitude 15 N is applied from start till its end along z-axis.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n            >>> from sympy import symbols\n            >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n            >>> b = Beam3D(20, E, G, I, 2, x)\n            >>> b.apply_load(15, start=0, order=0, dir=\"z\")\n            >>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n            >>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n            >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n            >>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n            >>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n            >>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n            >>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n            >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n            >>> b.plot_shear_stress()\n            PlotGrid object containing:\n            Plot[0]:Plot object containing:\n            [0]: cartesian line: 0 for x over (0.0, 20.0)\n            Plot[1]:Plot object containing:\n            [0]: cartesian line: -3*x**2 for x over (0.0, 20.0)\n            Plot[2]:Plot object containing:\n            [0]: cartesian line: -15*x/2 for x over (0.0, 20.0)\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "plot_slope",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.plot_slope",
    "type": "method",
    "description": "\n\n        Returns a plot for Slope along all three directions\n        present in the Beam object.\n\n        Parameters\n        ==========\n        dir : string (default : \"all\")\n            Direction along which Slope plot is required.\n            If no direction is specified, all plots are displayed.\n        subs : dictionary\n            Python dictionary containing Symbols as keys and their\n            corresponding values.\n\n        Examples\n        ========\n        There is a beam of length 20 meters. It is supported by rollers\n        at both of its ends. A linear load having slope equal to 12 is applied\n        along y-axis. A constant distributed load of magnitude 15 N is\n        applied from start till its end along z-axis.\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n            >>> from sympy import symbols\n            >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n            >>> b = Beam3D(20, 40, 21, 100, 25, x)\n            >>> b.apply_load(15, start=0, order=0, dir=\"z\")\n            >>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n            >>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n            >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n            >>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n            >>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n            >>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n            >>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n            >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n            >>> b.solve_slope_deflection()\n            >>> b.plot_slope()\n            PlotGrid object containing:\n            Plot[0]:Plot object containing:\n            [0]: cartesian line: 0 for x over (0.0, 20.0)\n            Plot[1]:Plot object containing:\n            [0]: cartesian line: -x**3/1600 + 3*x**2/160 - x/8 for x over (0.0, 20.0)\n            Plot[2]:Plot object containing:\n            [0]: cartesian line: x**4/8000 - 19*x**2/172 + 52*x/43 for x over (0.0, 20.0)\n\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "polar_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.polar_moment",
    "type": "method",
    "description": "\n        Returns the polar moment of area of the beam\n        about the X axis with respect to the centroid.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n        >>> from sympy import symbols\n        >>> l, E, G, I, A = symbols('l, E, G, I, A')\n        >>> b = Beam3D(l, E, G, I, A)\n        >>> b.polar_moment()\n        2*I\n        >>> I1 = [9, 15]\n        >>> b = Beam3D(l, E, G, I1, A)\n        >>> b.polar_moment()\n        24\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "shear_force",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.shear_force",
    "type": "method",
    "description": "\n        Returns a list of three expressions which represents the shear force\n        curve of the Beam object along all three axes.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "shear_stress",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.shear_stress",
    "type": "method",
    "description": "\n        Returns a list of three expressions which represents the shear stress\n        curve of the Beam object along all three axes.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "slope",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.slope",
    "type": "method",
    "description": "\n        Returns a three element list representing slope of deflection curve\n        along all the three axes.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "solve_for_reaction_loads",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.solve_for_reaction_loads",
    "type": "method",
    "description": "\n        Solves for the reaction forces.\n\n        Examples\n        ========\n        There is a beam of length 30 meters. It it supported by rollers at\n        of its end. A constant distributed load of magnitude 8 N is applied\n        from start till its end along y-axis. Another linear load having\n        slope equal to 9 is applied along z-axis.\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n        >>> from sympy import symbols\n        >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n        >>> b = Beam3D(30, E, G, I, A, x)\n        >>> b.apply_load(8, start=0, order=0, dir=\"y\")\n        >>> b.apply_load(9*x, start=0, order=0, dir=\"z\")\n        >>> b.bc_deflection = [(0, [0, 0, 0]), (30, [0, 0, 0])]\n        >>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n        >>> b.apply_load(R1, start=0, order=-1, dir=\"y\")\n        >>> b.apply_load(R2, start=30, order=-1, dir=\"y\")\n        >>> b.apply_load(R3, start=0, order=-1, dir=\"z\")\n        >>> b.apply_load(R4, start=30, order=-1, dir=\"z\")\n        >>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n        >>> b.reaction_loads\n        {R1: -120, R2: -120, R3: -1350, R4: -2700}\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "solve_for_torsion",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.solve_for_torsion",
    "type": "method",
    "description": "\n        Solves for the angular deflection due to the torsional effects of\n        moments being applied in the x-direction i.e. out of or into the beam.\n\n        Here, a positive torque means the direction of the torque is positive\n        i.e. out of the beam along the beam-axis. Likewise, a negative torque\n        signifies a torque into the beam cross-section.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.beam import Beam3D\n        >>> from sympy import symbols\n        >>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n        >>> b = Beam3D(20, E, G, I, A, x)\n        >>> b.apply_moment_load(4, 4, -2, dir='x')\n        >>> b.apply_moment_load(4, 8, -2, dir='x')\n        >>> b.apply_moment_load(4, 8, -2, dir='x')\n        >>> b.solve_for_torsion()\n        >>> b.angular_deflection().subs(x, 3)\n        18/(G*I)\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "torsional_moment",
    "full_id": "sympy.physics.continuum_mechanics.beam.Beam3D.torsional_moment",
    "type": "method",
    "description": "\n        Returns expression of Torsional moment present inside the Beam object.\n        ",
    "section": "Beam (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html"
  },
  {
    "name": "add_member",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.add_member",
    "type": "method",
    "description": "\n        This method adds a member between any two nodes in the given truss.\n\n        Parameters\n        ==========\n        The input(s) of the method are tuple(s) of the form (label, start, end).\n\n        label: String or Symbol\n            The label for a member. It is the only way to identify a particular member.\n\n        start: String or Symbol\n            The label of the starting point/node of the member.\n\n        end: String or Symbol\n            The label of the ending point/node of the member.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0), ('B', 3, 0), ('C', 2, 2))\n        >>> t.add_member(('AB', 'A', 'B'), ('BC', 'B', 'C'))\n        >>> t.members\n        {'AB': ['A', 'B'], 'BC': ['B', 'C']}\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "add_node",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.add_node",
    "type": "method",
    "description": "\n        This method adds a node to the truss along with its name/label and its location.\n        Multiple nodes can be added at the same time.\n\n        Parameters\n        ==========\n        The input(s) for this method are tuples of the form (label, x, y).\n\n        label:  String or a Symbol\n            The label for a node. It is the only way to identify a particular node.\n\n        x: Sympifyable\n            The x-coordinate of the position of the node.\n\n        y: Sympifyable\n            The y-coordinate of the position of the node.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0))\n        >>> t.nodes\n        [('A', 0, 0)]\n        >>> t.add_node(('B', 3, 0), ('C', 4, 1))\n        >>> t.nodes\n        [('A', 0, 0), ('B', 3, 0), ('C', 4, 1)]\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "apply_load",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.apply_load",
    "type": "method",
    "description": "\n        This method applies external load(s) at the specified node(s).\n\n        Parameters\n        ==========\n        The input(s) of the method are tuple(s) of the form (location, magnitude, direction).\n\n        location: String or Symbol\n            Label of the Node at which load is applied.\n\n        magnitude: Sympifyable\n            Magnitude of the load applied. It must always be positive and any changes in\n            the direction of the load are not reflected here.\n\n        direction: Sympifyable\n            The angle, in degrees, that the load vector makes with the horizontal\n            in the counter-clockwise direction. It takes the values 0 to 360,\n            inclusive.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> from sympy import symbols\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0), ('B', 3, 0))\n        >>> P = symbols('P')\n        >>> t.apply_load(('A', P, 90), ('A', P/2, 45), ('A', P/4, 90))\n        >>> t.loads\n        {'A': [[P, 90], [P/2, 45], [P/4, 90]]}\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "apply_support",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.apply_support",
    "type": "method",
    "description": "\n        This method adds a pinned or roller support at specified node(s).\n\n        Parameters\n        ==========\n        The input(s) of this method are of the form (location, type).\n\n        location: String or Symbol\n            Label of the Node at which support is added.\n\n        type: String\n            Type of the support being provided at the node.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0), ('B', 3, 0))\n        >>> t.apply_support(('A', 'pinned'), ('B', 'roller'))\n        >>> t.supports\n        {'A': 'pinned', 'B': 'roller'}\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "change_member_label",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.change_member_label",
    "type": "method",
    "description": "\n        This method changes the label(s) of the specified member(s).\n\n        Parameters\n        ==========\n        The input(s) of this method are tuple(s) of the form (label, new_label)\n\n        label: String or Symbol\n            The label of the member for which the label has\n            to be changed.\n\n        new_label: String or Symbol\n            The new label of the member.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0), ('B', 3, 0), ('D', 5, 0))\n        >>> t.nodes\n        [('A', 0, 0), ('B', 3, 0), ('D', 5, 0)]\n        >>> t.change_node_label(('A', 'C'))\n        >>> t.nodes\n        [('C', 0, 0), ('B', 3, 0), ('D', 5, 0)]\n        >>> t.add_member(('BC', 'B', 'C'), ('BD', 'B', 'D'))\n        >>> t.members\n        {'BC': ['B', 'C'], 'BD': ['B', 'D']}\n        >>> t.change_member_label(('BC', 'BC_new'), ('BD', 'BD_new'))\n        >>> t.members\n        {'BC_new': ['B', 'C'], 'BD_new': ['B', 'D']}\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "change_node_label",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.change_node_label",
    "type": "method",
    "description": "\n        This method changes the label(s) of the specified node(s).\n\n        Parameters\n        ==========\n        The input(s) of this method are tuple(s) of the form (label, new_label).\n\n        label: String or Symbol\n            The label of the node for which the label has\n            to be changed.\n\n        new_label: String or Symbol\n            The new label of the node.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0), ('B', 3, 0))\n        >>> t.nodes\n        [('A', 0, 0), ('B', 3, 0)]\n        >>> t.change_node_label(('A', 'C'), ('B', 'D'))\n        >>> t.nodes\n        [('C', 0, 0), ('D', 3, 0)]\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "draw",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.draw",
    "type": "method",
    "description": "\n        Returns a plot object of the Truss with all its nodes, members,\n        supports and loads.\n\n        .. note::\n            The user must be careful while entering load values in their\n            directions. The draw function assumes a sign convention that\n            is used for plotting loads.\n\n            Given a right-handed coordinate system with XYZ coordinates,\n            the supports are assumed to be such that the reaction forces of a\n            pinned support is in the +X and +Y direction while those of a\n            roller support is in the +Y direction. For the load, the range\n            of angles, one can input goes all the way to 360 degrees which, in the\n            the plot is the angle that the load vector makes with the positive x-axis in the anticlockwise direction.\n\n            For example, for a 90-degree angle, the load will be a vertically\n            directed along +Y while a 270-degree angle denotes a vertical\n            load as well but along -Y.\n\n        Examples\n        ========\n\n        .. plot::\n            :context: close-figs\n            :format: doctest\n            :include-source: True\n\n            >>> from sympy.physics.continuum_mechanics.truss import Truss\n            >>> import math\n            >>> t = Truss()\n            >>> t.add_node((\"A\", -4, 0), (\"B\", 0, 0), (\"C\", 4, 0), (\"D\", 8, 0))\n            >>> t.add_node((\"E\", 6, 2/math.sqrt(3)))\n            >>> t.add_node((\"F\", 2, 2*math.sqrt(3)))\n            >>> t.add_node((\"G\", -2, 2/math.sqrt(3)))\n            >>> t.add_member((\"AB\",\"A\",\"B\"), (\"BC\",\"B\",\"C\"), (\"CD\",\"C\",\"D\"))\n            >>> t.add_member((\"AG\",\"A\",\"G\"), (\"GB\",\"G\",\"B\"), (\"GF\",\"G\",\"F\"))\n            >>> t.add_member((\"BF\",\"B\",\"F\"), (\"FC\",\"F\",\"C\"), (\"CE\",\"C\",\"E\"))\n            >>> t.add_member((\"FE\",\"F\",\"E\"), (\"DE\",\"D\",\"E\"))\n            >>> t.apply_support((\"A\",\"pinned\"), (\"D\",\"roller\"))\n            >>> t.apply_load((\"G\", 3, 90), (\"E\", 3, 90), (\"F\", 2, 90))\n            >>> p = t.draw()\n            >>> p  # doctest: +ELLIPSIS\n            Plot object containing:\n            [0]: cartesian line: 1 for x over (1.0, 1.0)\n            ...\n            >>> p.show()\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "internal_forces",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.internal_forces",
    "type": "property",
    "description": "\n        Returns the internal forces for all members which are all initialized to 0.\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "loads",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.loads",
    "type": "property",
    "description": "\n        Returns the loads acting on the truss.\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "member_lengths",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.member_lengths",
    "type": "property",
    "description": "\n        Returns the length of each member of the truss.\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "members",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.members",
    "type": "property",
    "description": "\n        Returns the members of the truss along with the start and end points.\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "node_labels",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.node_labels",
    "type": "property",
    "description": "\n        Returns the node labels of the truss.\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "node_positions",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.node_positions",
    "type": "property",
    "description": "\n        Returns the positions of the nodes of the truss.\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "nodes",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.nodes",
    "type": "property",
    "description": "\n        Returns the nodes of the truss along with their positions.\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "reaction_loads",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.reaction_loads",
    "type": "property",
    "description": "\n        Returns the reaction forces for all supports which are all initialized to 0.\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "remove_load",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.remove_load",
    "type": "method",
    "description": "\n        This method removes already\n        present external load(s) at specified node(s).\n\n        Parameters\n        ==========\n        The input(s) of this method are tuple(s) of the form (location, magnitude, direction).\n\n        location: String or Symbol\n            Label of the Node at which load is applied and is to be removed.\n\n        magnitude: Sympifyable\n            Magnitude of the load applied.\n\n        direction: Sympifyable\n            The angle, in degrees, that the load vector makes with the horizontal\n            in the counter-clockwise direction. It takes the values 0 to 360,\n            inclusive.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> from sympy import symbols\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0), ('B', 3, 0))\n        >>> P = symbols('P')\n        >>> t.apply_load(('A', P, 90), ('A', P/2, 45), ('A', P/4, 90))\n        >>> t.loads\n        {'A': [[P, 90], [P/2, 45], [P/4, 90]]}\n        >>> t.remove_load(('A', P/4, 90), ('A', P/2, 45))\n        >>> t.loads\n        {'A': [[P, 90]]}\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "remove_member",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.remove_member",
    "type": "method",
    "description": "\n        This method removes members from the given truss.\n\n        Parameters\n        ==========\n        labels: String or Symbol\n            The label for the member to be removed.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0), ('B', 3, 0), ('C', 2, 2))\n        >>> t.add_member(('AB', 'A', 'B'), ('AC', 'A', 'C'), ('BC', 'B', 'C'))\n        >>> t.members\n        {'AB': ['A', 'B'], 'AC': ['A', 'C'], 'BC': ['B', 'C']}\n        >>> t.remove_member('AC', 'BC')\n        >>> t.members\n        {'AB': ['A', 'B']}\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "remove_node",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.remove_node",
    "type": "method",
    "description": "\n        This method removes a node from the truss.\n        Multiple nodes can be removed at the same time.\n\n        Parameters\n        ==========\n        The input(s) for this method are the labels of the nodes to be removed.\n\n        label:  String or Symbol\n            The label of the node to be removed.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0), ('B', 3, 0), ('C', 5, 0))\n        >>> t.nodes\n        [('A', 0, 0), ('B', 3, 0), ('C', 5, 0)]\n        >>> t.remove_node('A', 'C')\n        >>> t.nodes\n        [('B', 3, 0)]\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "remove_support",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.remove_support",
    "type": "method",
    "description": "\n        This method removes support from specified node(s.)\n\n        Parameters\n        ==========\n\n        locations: String or Symbol\n            Label of the Node(s) at which support is to be removed.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> t = Truss()\n        >>> t.add_node(('A', 0, 0), ('B', 3, 0))\n        >>> t.apply_support(('A', 'pinned'), ('B', 'roller'))\n        >>> t.supports\n        {'A': 'pinned', 'B': 'roller'}\n        >>> t.remove_support('A','B')\n        >>> t.supports\n        {}\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "solve",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.solve",
    "type": "method",
    "description": "\n        This method solves for all reaction forces of all supports and all internal forces\n        of all the members in the truss, provided the Truss is solvable.\n\n        A Truss is solvable if the following condition is met,\n\n        2n >= r + m\n\n        Where n is the number of nodes, r is the number of reaction forces, where each pinned\n        support has 2 reaction forces and each roller has 1, and m is the number of members.\n\n        The given condition is derived from the fact that a system of equations is solvable\n        only when the number of variables is lesser than or equal to the number of equations.\n        Equilibrium Equations in x and y directions give two equations per node giving 2n number\n        equations. However, the truss needs to be stable as well and may be unstable if 2n > r + m.\n        The number of variables is simply the sum of the number of reaction forces and member\n        forces.\n\n        .. note::\n           The sign convention for the internal forces present in a member revolves around whether each\n           force is compressive or tensile. While forming equations for each node, internal force due\n           to a member on the node is assumed to be away from the node i.e. each force is assumed to\n           be compressive by default. Hence, a positive value for an internal force implies the\n           presence of compressive force in the member and a negative value implies a tensile force.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.truss import Truss\n        >>> t = Truss()\n        >>> t.add_node((\"node_1\", 0, 0), (\"node_2\", 6, 0), (\"node_3\", 2, 2), (\"node_4\", 2, 0))\n        >>> t.add_member((\"member_1\", \"node_1\", \"node_4\"), (\"member_2\", \"node_2\", \"node_4\"), (\"member_3\", \"node_1\", \"node_3\"))\n        >>> t.add_member((\"member_4\", \"node_2\", \"node_3\"), (\"member_5\", \"node_3\", \"node_4\"))\n        >>> t.apply_load((\"node_4\", 10, 270))\n        >>> t.apply_support((\"node_1\", \"pinned\"), (\"node_2\", \"roller\"))\n        >>> t.solve()\n        >>> t.reaction_loads\n        {'R_node_1_x': 0, 'R_node_1_y': 20/3, 'R_node_2_y': 10/3}\n        >>> t.internal_forces\n        {'member_1': 20/3, 'member_2': 20/3, 'member_3': -20*sqrt(2)/3, 'member_4': -10*sqrt(5)/3, 'member_5': 10}\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "supports",
    "full_id": "sympy.physics.continuum_mechanics.truss.Truss.supports",
    "type": "property",
    "description": "\n        Returns the nodes with provided supports along with the kind of support provided i.e.\n        pinned or roller.\n        ",
    "section": "Truss (Docstrings)",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/truss.html"
  },
  {
    "name": "apply_length",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.apply_length",
    "type": "method",
    "description": "\n        This method specifies the length of the cable\n\n        Parameters\n        ==========\n\n        length : Sympifyable\n            The length of the cable\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.cable import Cable\n        >>> c = Cable(('A', 0, 10), ('B', 10, 10))\n        >>> c.apply_length(20)\n        >>> c.length\n        20\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "apply_load",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.apply_load",
    "type": "method",
    "description": "\n        This method adds load to the cable.\n\n        Parameters\n        ==========\n\n        order : Integer\n            The order of the applied load.\n\n                - For point loads, order = -1\n                - For distributed load, order = 0\n\n        load : tuple\n\n            * For point loads, load is of the form (label, x, y, magnitude, direction), where:\n\n            label : String or symbol\n                The label of the load\n\n            x : Sympifyable\n                The x coordinate of the position of the load\n\n            y : Sympifyable\n                The y coordinate of the position of the load\n\n            magnitude : Sympifyable\n                The magnitude of the load. It must always be positive\n\n            direction : Sympifyable\n                The angle, in degrees, that the load vector makes with the horizontal\n                in the counter-clockwise direction. It takes the values 0 to 360,\n                inclusive.\n\n\n            * For uniformly distributed load, load is of the form (label, magnitude)\n\n            label : String or symbol\n                The label of the load\n\n            magnitude : Sympifyable\n                The magnitude of the load. It must always be positive\n\n        Examples\n        ========\n\n        For a point load of magnitude 12 units inclined at 30 degrees with the horizontal:\n\n        >>> from sympy.physics.continuum_mechanics.cable import Cable\n        >>> c = Cable(('A', 0, 10), ('B', 10, 10))\n        >>> c.apply_load(-1, ('Z', 5, 5, 12, 30))\n        >>> c.loads\n        {'distributed': {}, 'point_load': {'Z': [12, 30]}}\n        >>> c.loads_position\n        {'Z': [5, 5]}\n\n\n        For a uniformly distributed load of magnitude 9 units:\n\n        >>> from sympy.physics.continuum_mechanics.cable import Cable\n        >>> c = Cable(('A', 0, 10), ('B', 10, 10))\n        >>> c.apply_load(0, ('X', 9))\n        >>> c.loads\n        {'distributed': {'X': 9}, 'point_load': {}}\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "change_support",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.change_support",
    "type": "method",
    "description": "\n        This method changes the mentioned support with a new support.\n\n        Parameters\n        ==========\n        label: String or symbol\n            The label of the support to be changed\n\n        new_support: Tuple of the form (new_label, x, y)\n            new_label: String or symbol\n                The label of the new support\n\n            x: Sympifyable\n                The x-coordinate of the position of the new support.\n\n            y: Sympifyable\n                The y-coordinate of the position of the new support.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.cable import Cable\n        >>> c = Cable(('A', 0, 10), ('B', 10, 10))\n        >>> c.supports\n        {'A': [0, 10], 'B': [10, 10]}\n        >>> c.change_support('B', ('C', 5, 6))\n        >>> c.supports\n        {'A': [0, 10], 'C': [5, 6]}\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "left_support",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.left_support",
    "type": "property",
    "description": "\n        Returns the position of the left support.\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "length",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.length",
    "type": "property",
    "description": "\n        Returns the length of the cable.\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "loads",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.loads",
    "type": "property",
    "description": "\n        Returns the magnitude and direction of the loads\n        acting on the cable.\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "loads_position",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.loads_position",
    "type": "property",
    "description": "\n        Returns the position of the point loads acting on the\n        cable.\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "reaction_loads",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.reaction_loads",
    "type": "property",
    "description": "\n        Returns the reaction forces at the supports, which are\n        initialized to 0.\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "remove_loads",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.remove_loads",
    "type": "method",
    "description": "\n        This methods removes the specified loads.\n\n        Parameters\n        ==========\n        This input takes multiple label(s) as input\n        label(s): String or symbol\n            The label(s) of the loads to be removed.\n\n        Examples\n        ========\n\n        >>> from sympy.physics.continuum_mechanics.cable import Cable\n        >>> c = Cable(('A', 0, 10), ('B', 10, 10))\n        >>> c.apply_load(-1, ('Z', 5, 5, 12, 30))\n        >>> c.loads\n        {'distributed': {}, 'point_load': {'Z': [12, 30]}}\n        >>> c.remove_loads('Z')\n        >>> c.loads\n        {'distributed': {}, 'point_load': {}}\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "right_support",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.right_support",
    "type": "property",
    "description": "\n        Returns the position of the right support.\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "solve",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.solve",
    "type": "method",
    "description": "\n        This method solves for the reaction forces at the supports, the tension developed in\n        the cable, and updates the length of the cable.\n\n        Parameters\n        ==========\n        This method requires no input when solving for point loads\n        For distributed load, the x and y coordinates of the lowest point of the cable are\n        required as\n\n        x: Sympifyable\n            The x coordinate of the lowest point\n\n        y: Sympifyable\n            The y coordinate of the lowest point\n\n        Examples\n        ========\n        For point loads,\n\n        >>> from sympy.physics.continuum_mechanics.cable import Cable\n        >>> c = Cable((\"A\", 0, 10), (\"B\", 10, 10))\n        >>> c.apply_load(-1, ('Z', 2, 7.26, 3, 270))\n        >>> c.apply_load(-1, ('X', 4, 6, 8, 270))\n        >>> c.solve()\n        >>> c.tension\n        {A_Z: 8.91403453669861, X_B: 19*sqrt(13)/10, Z_X: 4.79150773600774}\n        >>> c.reaction_loads\n        {R_A_x: -5.25547445255474, R_A_y: 7.2, R_B_x: 5.25547445255474, R_B_y: 3.8}\n        >>> c.length\n        5.7560958484519 + 2*sqrt(13)\n\n        For distributed load,\n\n        >>> from sympy.physics.continuum_mechanics.cable import Cable\n        >>> c=Cable((\"A\", 0, 40),(\"B\", 100, 20))\n        >>> c.apply_load(0, (\"X\", 850))\n        >>> c.solve(58.58, 0)\n        >>> c.tension\n        {'distributed': 36456.8485*sqrt(0.000543529004799705*(X + 0.00135624381275735)**2 + 1)}\n        >>> c.tension_at(0)\n        61709.0363315913\n        >>> c.reaction_loads\n        {R_A_x: 36456.8485, R_A_y: -49788.5866682485, R_B_x: 44389.8401587246, R_B_y: 42866.621696333}\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "supports",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.supports",
    "type": "property",
    "description": "\n        Returns the supports of the cable along with their\n        positions.\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "tension",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.tension",
    "type": "property",
    "description": "\n        Returns the tension developed in the cable due to the loads\n        applied.\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "tension_at",
    "full_id": "sympy.physics.continuum_mechanics.cable.Cable.tension_at",
    "type": "method",
    "description": "\n        Returns the tension at a given value of x developed due to\n        distributed load.\n        ",
    "section": "Cable",
    "url": "https://docs.sympy.org/latest/modules/physics/continuum_mechanics/cable.html"
  },
  {
    "name": "SKIP",
    "full_id": "sympy.testing.pytest.SKIP",
    "type": "function",
    "description": "Similar to ``skip()``, but this is a decorator. ",
    "section": "pytest",
    "url": "https://docs.sympy.org/latest/modules/testing/pytest.html"
  },
  {
    "name": "nocache_fail",
    "full_id": "sympy.testing.pytest.nocache_fail",
    "type": "function",
    "description": "Dummy decorator for marking tests that fail when cache is disabled",
    "section": "pytest",
    "url": "https://docs.sympy.org/latest/modules/testing/pytest.html"
  },
  {
    "name": "raises",
    "full_id": "sympy.testing.pytest.raises",
    "type": "function",
    "description": "\n        Tests that ``code`` raises the exception ``expectedException``.\n\n        ``code`` may be a callable, such as a lambda expression or function\n        name.\n\n        If ``code`` is not given or None, ``raises`` will return a context\n        manager for use in ``with`` statements; the code to execute then\n        comes from the scope of the ``with``.\n\n        ``raises()`` does nothing if the callable raises the expected exception,\n        otherwise it raises an AssertionError.\n\n        Examples\n        ========\n\n        >>> from sympy.testing.pytest import raises\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ZeroDivisionError(...)>\n        >>> raises(ZeroDivisionError, lambda: 1/2)\n        Traceback (most recent call last):\n        ...\n        Failed: DID NOT RAISE\n\n        >>> with raises(ZeroDivisionError):\n        ...     n = 1/0\n        >>> with raises(ZeroDivisionError):\n        ...     n = 1/2\n        Traceback (most recent call last):\n        ...\n        Failed: DID NOT RAISE\n\n        Note that you cannot test multiple statements via\n        ``with raises``:\n\n        >>> with raises(ZeroDivisionError):\n        ...     n = 1/0    # will execute and raise, aborting the ``with``\n        ...     n = 9999/0 # never executed\n\n        This is just what ``with`` is supposed to do: abort the\n        contained statement sequence at the first exception and let\n        the context manager deal with the exception.\n\n        To test multiple statements, you'll need a separate ``with``\n        for each:\n\n        >>> with raises(ZeroDivisionError):\n        ...     n = 1/0    # will execute and raise\n        >>> with raises(ZeroDivisionError):\n        ...     n = 9999/0 # will also execute and raise\n\n        ",
    "section": "pytest",
    "url": "https://docs.sympy.org/latest/modules/testing/pytest.html"
  },
  {
    "name": "skip_under_pyodide",
    "full_id": "sympy.testing.pytest.skip_under_pyodide",
    "type": "function",
    "description": "Decorator to skip a test if running under pyodide.",
    "section": "pytest",
    "url": "https://docs.sympy.org/latest/modules/testing/pytest.html"
  },
  {
    "name": "warns",
    "full_id": "sympy.testing.pytest.warns",
    "type": "function",
    "description": "\n    Like raises but tests that warnings are emitted.\n\n    >>> from sympy.testing.pytest import warns\n    >>> import warnings\n\n    >>> with warns(UserWarning):\n    ...     warnings.warn('deprecated', UserWarning, stacklevel=2)\n\n    >>> with warns(UserWarning):\n    ...     pass\n    Traceback (most recent call last):\n    ...\n    Failed: DID NOT WARN. No warnings of type UserWarning    was emitted. The list of emitted warnings is: [].\n\n    ``test_stacklevel`` makes it check that the ``stacklevel`` parameter to\n    ``warn()`` is set so that the warning shows the user line of code (the\n    code under the warns() context manager). Set this to False if this is\n    ambiguous or if the context manager does not test the direct user code\n    that emits the warning.\n\n    If the warning is a ``SymPyDeprecationWarning``, this additionally tests\n    that the ``active_deprecations_target`` is a real target in the\n    ``active-deprecations.md`` file.\n\n    ",
    "section": "pytest",
    "url": "https://docs.sympy.org/latest/modules/testing/pytest.html"
  },
  {
    "name": "warns_deprecated_sympy",
    "full_id": "sympy.testing.pytest.warns_deprecated_sympy",
    "type": "function",
    "description": "\n    Shorthand for ``warns(SymPyDeprecationWarning)``\n\n    This is the recommended way to test that ``SymPyDeprecationWarning`` is\n    emitted for deprecated features in SymPy. To test for other warnings use\n    ``warns``. To suppress warnings without asserting that they are emitted\n    use ``ignore_warnings``.\n\n    .. note::\n\n       ``warns_deprecated_sympy()`` is only intended for internal use in the\n       SymPy test suite to test that a deprecation warning triggers properly.\n       All other code in the SymPy codebase, including documentation examples,\n       should not use deprecated behavior.\n\n       If you are a user of SymPy and you want to disable\n       SymPyDeprecationWarnings, use ``warnings`` filters (see\n       :ref:`silencing-sympy-deprecation-warnings`).\n\n    >>> from sympy.testing.pytest import warns_deprecated_sympy\n    >>> from sympy.utilities.exceptions import sympy_deprecation_warning\n    >>> with warns_deprecated_sympy():\n    ...     sympy_deprecation_warning(\"Don't use\",\n    ...        deprecated_since_version=\"1.0\",\n    ...        active_deprecations_target=\"active-deprecations\")\n\n    >>> with warns_deprecated_sympy():\n    ...     pass\n    Traceback (most recent call last):\n    ...\n    Failed: DID NOT WARN. No warnings of type     SymPyDeprecationWarning was emitted. The list of emitted warnings is: [].\n\n    .. note::\n\n       Sometimes the stacklevel test will fail because the same warning is\n       emitted multiple times. In this case, you can use\n       :func:`sympy.utilities.exceptions.ignore_warnings` in the code to\n       prevent the ``SymPyDeprecationWarning`` from being emitted again\n       recursively. In rare cases it is impossible to have a consistent\n       ``stacklevel`` for deprecation warnings because different ways of\n       calling a function will produce different call stacks.. In those cases,\n       use ``warns(SymPyDeprecationWarning)`` instead.\n\n    See Also\n    ========\n    sympy.utilities.exceptions.SymPyDeprecationWarning\n    sympy.utilities.exceptions.sympy_deprecation_warning\n    sympy.utilities.decorator.deprecated\n\n    ",
    "section": "pytest",
    "url": "https://docs.sympy.org/latest/modules/testing/pytest.html"
  },
  {
    "name": "write",
    "full_id": "sympy.testing.runtests.PyTestReporter.write",
    "type": "method",
    "description": "\n        Prints a text on the screen.\n\n        It uses sys.stdout.write(), so no readline library is necessary.\n\n        Parameters\n        ==========\n\n        color : choose from the colors below, \"\" means default color\n        align : \"left\"/\"right\", \"left\" is a normal print, \"right\" is aligned on\n                the right-hand side of the screen, filled with spaces if\n                necessary\n        width : the screen width\n\n        ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "run",
    "full_id": "sympy.testing.runtests.SymPyDocTestRunner.run",
    "type": "method",
    "description": "\n        Run the examples in ``test``, and display the results using the\n        writer function ``out``.\n\n        The examples are run in the namespace ``test.globs``.  If\n        ``clear_globs`` is true (the default), then this namespace will\n        be cleared after the test runs, to help with garbage\n        collection.  If you would like to examine the namespace after\n        the test completes, then use ``clear_globs=False``.\n\n        ``compileflags`` gives the set of flags that should be used by\n        the Python compiler when running the examples.  If not\n        specified, then it will default to the set of future-import\n        flags that apply to ``globs``.\n\n        The output of each example is checked using\n        ``SymPyDocTestRunner.check_output``, and the results are\n        formatted by the ``SymPyDocTestRunner.report_*`` methods.\n        ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "check_output",
    "full_id": "sympy.testing.runtests.SymPyOutputChecker.check_output",
    "type": "method",
    "description": "\n        Return True iff the actual output from an example (`got`)\n        matches the expected output (`want`).  These strings are\n        always considered to match if they are identical; but\n        depending on what option flags the test runner is using,\n        several non-exact match types are also possible.  See the\n        documentation for `TestRunner` for more information about\n        option flags.\n        ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "convert_to_native_paths",
    "full_id": "sympy.testing.runtests.convert_to_native_paths",
    "type": "function",
    "description": "\n    Converts a list of '/' separated paths into a list of\n    native (os.sep separated) paths and converts to lowercase\n    if the system is case insensitive.\n    ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "doctest",
    "full_id": "sympy.testing.runtests.doctest",
    "type": "function",
    "description": "\n    Runs doctests in all \\*.py files in the SymPy directory which match\n    any of the given strings in ``paths`` or all tests if paths=[].\n\n    Notes:\n\n    - Paths can be entered in native system format or in unix,\n      forward-slash format.\n    - Files that are on the blacklist can be tested by providing\n      their path; they are only excluded if no paths are given.\n\n    Examples\n    ========\n\n    >>> import sympy\n\n    Run all tests:\n\n    >>> sympy.doctest() # doctest: +SKIP\n\n    Run one file:\n\n    >>> sympy.doctest(\"sympy/core/basic.py\") # doctest: +SKIP\n    >>> sympy.doctest(\"polynomial.rst\") # doctest: +SKIP\n\n    Run all tests in sympy/functions/ and some particular file:\n\n    >>> sympy.doctest(\"/functions\", \"basic.py\") # doctest: +SKIP\n\n    Run any file having polynomial in its name, doc/src/modules/polynomial.rst,\n    sympy/functions/special/polynomials.py, and sympy/polys/polynomial.py:\n\n    >>> sympy.doctest(\"polynomial\") # doctest: +SKIP\n\n    The ``split`` option can be passed to split the test run into parts. The\n    split currently only splits the test files, though this may change in the\n    future. ``split`` should be a string of the form 'a/b', which will run\n    part ``a`` of ``b``. Note that the regular doctests and the Sphinx\n    doctests are split independently. For instance, to run the first half of\n    the test suite:\n\n    >>> sympy.doctest(split='1/2')  # doctest: +SKIP\n\n    The ``subprocess`` and ``verbose`` options are the same as with the function\n    ``test()`` (see the docstring of that function for more information) except\n    that ``verbose`` may also be set equal to ``2`` in order to print\n    individual doctest lines, as they are being tested.\n    ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "get_sympy_dir",
    "full_id": "sympy.testing.runtests.get_sympy_dir",
    "type": "function",
    "description": "\n    Returns the root SymPy directory and set the global value\n    indicating whether the system is case sensitive or not.\n    ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "raise_on_deprecated",
    "full_id": "sympy.testing.runtests.raise_on_deprecated",
    "type": "function",
    "description": "Context manager to make DeprecationWarning raise an error\n\n    This is to catch SymPyDeprecationWarning from library code while running\n    tests and doctests. It is important to use this context manager around\n    each individual test/doctest in case some tests modify the warning\n    filters.\n    ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "run_all_tests",
    "full_id": "sympy.testing.runtests.run_all_tests",
    "type": "function",
    "description": "\n    Run all tests.\n\n    Right now, this runs the regular tests (bin/test), the doctests\n    (bin/doctest), and the examples (examples/all.py).\n\n    This is what ``setup.py test`` uses.\n\n    You can pass arguments and keyword arguments to the test functions that\n    support them (for now, test,  doctest, and the examples). See the\n    docstrings of those functions for a description of the available options.\n\n    For example, to run the solvers tests with colors turned off:\n\n    >>> from sympy.testing.runtests import run_all_tests\n    >>> run_all_tests(test_args=(\"solvers\",),\n    ... test_kwargs={\"colors:False\"}) # doctest: +SKIP\n\n    ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "run_in_subprocess_with_hash_randomization",
    "full_id": "sympy.testing.runtests.run_in_subprocess_with_hash_randomization",
    "type": "function",
    "description": "\n    Run a function in a Python subprocess with hash randomization enabled.\n\n    If hash randomization is not supported by the version of Python given, it\n    returns False.  Otherwise, it returns the exit value of the command.  The\n    function is passed to sys.exit(), so the return value of the function will\n    be the return value.\n\n    The environment variable PYTHONHASHSEED is used to seed Python's hash\n    randomization.  If it is set, this function will return False, because\n    starting a new subprocess is unnecessary in that case.  If it is not set,\n    one is set at random, and the tests are run.  Note that if this\n    environment variable is set when Python starts, hash randomization is\n    automatically enabled.  To force a subprocess to be created even if\n    PYTHONHASHSEED is set, pass ``force=True``.  This flag will not force a\n    subprocess in Python versions that do not support hash randomization (see\n    below), because those versions of Python do not support the ``-R`` flag.\n\n    ``function`` should be a string name of a function that is importable from\n    the module ``module``, like \"_test\".  The default for ``module`` is\n    \"sympy.testing.runtests\".  ``function_args`` and ``function_kwargs``\n    should be a repr-able tuple and dict, respectively.  The default Python\n    command is sys.executable, which is the currently running Python command.\n\n    This function is necessary because the seed for hash randomization must be\n    set by the environment variable before Python starts.  Hence, in order to\n    use a predetermined seed for tests, we must start Python in a separate\n    subprocess.\n\n    Hash randomization was added in the minor Python versions 2.6.8, 2.7.3,\n    3.1.5, and 3.2.3, and is enabled by default in all Python versions after\n    and including 3.3.0.\n\n    Examples\n    ========\n\n    >>> from sympy.testing.runtests import (\n    ... run_in_subprocess_with_hash_randomization)\n    >>> # run the core tests in verbose mode\n    >>> run_in_subprocess_with_hash_randomization(\"_test\",\n    ... function_args=(\"core\",),\n    ... function_kwargs={'verbose': True}) # doctest: +SKIP\n    # Will return 0 if sys.executable supports hash randomization and tests\n    # pass, 1 if they fail, and False if it does not support hash\n    # randomization.\n\n    ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "split_list",
    "full_id": "sympy.testing.runtests.split_list",
    "type": "function",
    "description": "\n    Splits a list into part a of b\n\n    split should be a string of the form 'a/b'. For instance, '1/3' would give\n    the split one of three.\n\n    If the length of the list is not divisible by the number of splits, the\n    last split will have more items.\n\n    `density` may be specified as a list.  If specified,\n    tests will be balanced so that each split has as equal-as-possible\n    amount of mass according to `density`.\n\n    >>> from sympy.testing.runtests import split_list\n    >>> a = list(range(10))\n    >>> split_list(a, '1/3')\n    [0, 1, 2]\n    >>> split_list(a, '2/3')\n    [3, 4, 5]\n    >>> split_list(a, '3/3')\n    [6, 7, 8, 9]\n    ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "sympytestfile",
    "full_id": "sympy.testing.runtests.sympytestfile",
    "type": "function",
    "description": "\n    Test examples in the given file.  Return (#failures, #tests).\n\n    Optional keyword arg ``module_relative`` specifies how filenames\n    should be interpreted:\n\n    - If ``module_relative`` is True (the default), then ``filename``\n      specifies a module-relative path.  By default, this path is\n      relative to the calling module's directory; but if the\n      ``package`` argument is specified, then it is relative to that\n      package.  To ensure os-independence, ``filename`` should use\n      \"/\" characters to separate path segments, and should not\n      be an absolute path (i.e., it may not begin with \"/\").\n\n    - If ``module_relative`` is False, then ``filename`` specifies an\n      os-specific path.  The path may be absolute or relative (to\n      the current working directory).\n\n    Optional keyword arg ``name`` gives the name of the test; by default\n    use the file's basename.\n\n    Optional keyword argument ``package`` is a Python package or the\n    name of a Python package whose directory should be used as the\n    base directory for a module relative filename.  If no package is\n    specified, then the calling module's directory is used as the base\n    directory for module relative filenames.  It is an error to\n    specify ``package`` if ``module_relative`` is False.\n\n    Optional keyword arg ``globs`` gives a dict to be used as the globals\n    when executing examples; by default, use {}.  A copy of this dict\n    is actually used for each docstring, so that each docstring's\n    examples start with a clean slate.\n\n    Optional keyword arg ``extraglobs`` gives a dictionary that should be\n    merged into the globals that are used to execute examples.  By\n    default, no extra globals are used.\n\n    Optional keyword arg ``verbose`` prints lots of stuff if true, prints\n    only failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\n    Optional keyword arg ``report`` prints a summary at the end when true,\n    else prints nothing at the end.  In verbose mode, the summary is\n    detailed, else very brief (in fact, empty if all tests passed).\n\n    Optional keyword arg ``optionflags`` or's together module constants,\n    and defaults to 0.  Possible values (see the docs for details):\n\n    - DONT_ACCEPT_TRUE_FOR_1\n    - DONT_ACCEPT_BLANKLINE\n    - NORMALIZE_WHITESPACE\n    - ELLIPSIS\n    - SKIP\n    - IGNORE_EXCEPTION_DETAIL\n    - REPORT_UDIFF\n    - REPORT_CDIFF\n    - REPORT_NDIFF\n    - REPORT_ONLY_FIRST_FAILURE\n\n    Optional keyword arg ``raise_on_error`` raises an exception on the\n    first unexpected exception or failure. This allows failures to be\n    post-mortem debugged.\n\n    Optional keyword arg ``parser`` specifies a DocTestParser (or\n    subclass) that should be used to extract tests from the files.\n\n    Optional keyword arg ``encoding`` specifies an encoding that should\n    be used to convert the file to unicode.\n\n    Advanced tomfoolery:  testmod runs methods of a local instance of\n    class doctest.Tester, then merges the results into (or creates)\n    global Tester instance doctest.master.  Methods of doctest.master\n    can be called directly too, if you want to do something unusual.\n    Passing report=0 to testmod is especially useful then, to delay\n    displaying a summary.  Invoke doctest.master.summarize(verbose)\n    when you're done fiddling.\n    ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "test",
    "full_id": "sympy.testing.runtests.test",
    "type": "function",
    "description": "\n    Run tests in the specified test_*.py files.\n\n    Tests in a particular test_*.py file are run if any of the given strings\n    in ``paths`` matches a part of the test file's path. If ``paths=[]``,\n    tests in all test_*.py files are run.\n\n    Notes:\n\n    - If sort=False, tests are run in random order (not default).\n    - Paths can be entered in native system format or in unix,\n      forward-slash format.\n    - Files that are on the blacklist can be tested by providing\n      their path; they are only excluded if no paths are given.\n\n    **Explanation of test results**\n\n    ======  ===============================================================\n    Output  Meaning\n    ======  ===============================================================\n    .       passed\n    F       failed\n    X       XPassed (expected to fail but passed)\n    f       XFAILed (expected to fail and indeed failed)\n    s       skipped\n    w       slow\n    T       timeout (e.g., when ``--timeout`` is used)\n    K       KeyboardInterrupt (when running the slow tests with ``--slow``,\n            you can interrupt one of them without killing the test runner)\n    ======  ===============================================================\n\n\n    Colors have no additional meaning and are used just to facilitate\n    interpreting the output.\n\n    Examples\n    ========\n\n    >>> import sympy\n\n    Run all tests:\n\n    >>> sympy.test()    # doctest: +SKIP\n\n    Run one file:\n\n    >>> sympy.test(\"sympy/core/tests/test_basic.py\")    # doctest: +SKIP\n    >>> sympy.test(\"_basic\")    # doctest: +SKIP\n\n    Run all tests in sympy/functions/ and some particular file:\n\n    >>> sympy.test(\"sympy/core/tests/test_basic.py\",\n    ...        \"sympy/functions\")    # doctest: +SKIP\n\n    Run all tests in sympy/core and sympy/utilities:\n\n    >>> sympy.test(\"/core\", \"/util\")    # doctest: +SKIP\n\n    Run specific test from a file:\n\n    >>> sympy.test(\"sympy/core/tests/test_basic.py\",\n    ...        kw=\"test_equality\")    # doctest: +SKIP\n\n    Run specific test from any file:\n\n    >>> sympy.test(kw=\"subs\")    # doctest: +SKIP\n\n    Run the tests with verbose mode on:\n\n    >>> sympy.test(verbose=True)    # doctest: +SKIP\n\n    Do not sort the test output:\n\n    >>> sympy.test(sort=False)    # doctest: +SKIP\n\n    Turn on post-mortem pdb:\n\n    >>> sympy.test(pdb=True)    # doctest: +SKIP\n\n    Turn off colors:\n\n    >>> sympy.test(colors=False)    # doctest: +SKIP\n\n    Force colors, even when the output is not to a terminal (this is useful,\n    e.g., if you are piping to ``less -r`` and you still want colors)\n\n    >>> sympy.test(force_colors=False)    # doctest: +SKIP\n\n    The traceback verboseness can be set to \"short\" or \"no\" (default is\n    \"short\")\n\n    >>> sympy.test(tb='no')    # doctest: +SKIP\n\n    The ``split`` option can be passed to split the test run into parts. The\n    split currently only splits the test files, though this may change in the\n    future. ``split`` should be a string of the form 'a/b', which will run\n    part ``a`` of ``b``. For instance, to run the first half of the test suite:\n\n    >>> sympy.test(split='1/2')  # doctest: +SKIP\n\n    The ``time_balance`` option can be passed in conjunction with ``split``.\n    If ``time_balance=True`` (the default for ``sympy.test``), SymPy will attempt\n    to split the tests such that each split takes equal time.  This heuristic\n    for balancing is based on pre-recorded test data.\n\n    >>> sympy.test(split='1/2', time_balance=True)  # doctest: +SKIP\n\n    You can disable running the tests in a separate subprocess using\n    ``subprocess=False``.  This is done to support seeding hash randomization,\n    which is enabled by default in the Python versions where it is supported.\n    If subprocess=False, hash randomization is enabled/disabled according to\n    whether it has been enabled or not in the calling Python process.\n    However, even if it is enabled, the seed cannot be printed unless it is\n    called from a new Python process.\n\n    Hash randomization was added in the minor Python versions 2.6.8, 2.7.3,\n    3.1.5, and 3.2.3, and is enabled by default in all Python versions after\n    and including 3.3.0.\n\n    If hash randomization is not supported ``subprocess=False`` is used\n    automatically.\n\n    >>> sympy.test(subprocess=False)     # doctest: +SKIP\n\n    To set the hash randomization seed, set the environment variable\n    ``PYTHONHASHSEED`` before running the tests.  This can be done from within\n    Python using\n\n    >>> import os\n    >>> os.environ['PYTHONHASHSEED'] = '42' # doctest: +SKIP\n\n    Or from the command line using\n\n    $ PYTHONHASHSEED=42 ./bin/test\n\n    If the seed is not set, a random seed will be chosen.\n\n    Note that to reproduce the same hash values, you must use both the same seed\n    as well as the same architecture (32-bit vs. 64-bit).\n\n    ",
    "section": "Run Tests",
    "url": "https://docs.sympy.org/latest/modules/testing/runtests.html"
  },
  {
    "name": "dump_pyx",
    "full_id": "sympy.utilities.autowrap.CythonCodeWrapper.dump_pyx",
    "type": "method",
    "description": "Write a Cython file with Python wrappers\n\n        This file contains all the definitions of the routines in c code and\n        refers to the header file.\n\n        Arguments\n        ---------\n        routines\n            List of Routine instances\n        f\n            File-like object to write the file to\n        prefix\n            The filename prefix, used to refer to the proper header file.\n            Only the basename of the prefix is used.\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/autowrap.html"
  },
  {
    "name": "dump_c",
    "full_id": "sympy.utilities.autowrap.UfuncifyCodeWrapper.dump_c",
    "type": "method",
    "description": "Write a C file with Python wrappers\n\n        This file contains all the definitions of the routines in c code.\n\n        Arguments\n        ---------\n        routines\n            List of Routine instances\n        f\n            File-like object to write the file to\n        prefix\n            The filename prefix, used to name the imported module.\n        funcname\n            Name of the main function to be returned.\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/autowrap.html"
  },
  {
    "name": "autowrap",
    "full_id": "sympy.utilities.autowrap.autowrap",
    "type": "function",
    "description": "Generates Python callable binaries based on the math expression.\n\n    Parameters\n    ==========\n\n    expr\n        The SymPy expression that should be wrapped as a binary routine.\n    language : string, optional\n        If supplied, (options: 'C' or 'F95'), specifies the language of the\n        generated code. If ``None`` [default], the language is inferred based\n        upon the specified backend.\n    backend : string, optional\n        Backend used to wrap the generated code. Either 'f2py' [default],\n        or 'cython'.\n    tempdir : string, optional\n        Path to directory for temporary files. If this argument is supplied,\n        the generated code and the wrapper input files are left intact in the\n        specified path.\n    args : iterable, optional\n        An ordered iterable of symbols. Specifies the argument sequence for the\n        function.\n    flags : iterable, optional\n        Additional option flags that will be passed to the backend.\n    verbose : bool, optional\n        If True, autowrap will not mute the command line backends. This can be\n        helpful for debugging.\n    helpers : 3-tuple or iterable of 3-tuples, optional\n        Used to define auxiliary expressions needed for the main expr. If the\n        main expression needs to call a specialized function it should be\n        passed in via ``helpers``. Autowrap will then make sure that the\n        compiled main expression can link to the helper routine. Items should\n        be 3-tuples with (<function_name>, <sympy_expression>,\n        <argument_tuple>). It is mandatory to supply an argument sequence to\n        helper routines.\n    code_gen : CodeGen instance\n        An instance of a CodeGen subclass. Overrides ``language``.\n    include_dirs : [string]\n        A list of directories to search for C/C++ header files (in Unix form\n        for portability).\n    library_dirs : [string]\n        A list of directories to search for C/C++ libraries at link time.\n    libraries : [string]\n        A list of library names (not filenames or paths) to link against.\n    extra_compile_args : [string]\n        Any extra platform- and compiler-specific information to use when\n        compiling the source files in 'sources'.  For platforms and compilers\n        where \"command line\" makes sense, this is typically a list of\n        command-line arguments, but for other platforms it could be anything.\n    extra_link_args : [string]\n        Any extra platform- and compiler-specific information to use when\n        linking object files together to create the extension (or to create a\n        new static Python interpreter).  Similar interpretation as for\n        'extra_compile_args'.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> from sympy.utilities.autowrap import autowrap\n    >>> expr = ((x - y + z)**(13)).expand()\n    >>> binary_func = autowrap(expr)\n    >>> binary_func(1, 4, 2)\n    -1.0\n\n    ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/autowrap.html"
  },
  {
    "name": "binary_function",
    "full_id": "sympy.utilities.autowrap.binary_function",
    "type": "function",
    "description": "Returns a SymPy function with expr as binary implementation\n\n    This is a convenience function that automates the steps needed to\n    autowrap the SymPy expression and attaching it to a Function object\n    with implemented_function().\n\n    Parameters\n    ==========\n\n    symfunc : SymPy Function\n        The function to bind the callable to.\n    expr : SymPy Expression\n        The expression used to generate the function.\n    kwargs : dict\n        Any kwargs accepted by autowrap.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy.utilities.autowrap import binary_function\n    >>> expr = ((x - y)**(25)).expand()\n    >>> f = binary_function('f', expr)\n    >>> type(f)\n    <class 'sympy.core.function.UndefinedFunction'>\n    >>> 2*f(x, y)\n    2*f(x, y)\n    >>> f(x, y).evalf(2, subs={x: 1, y: 2})\n    -1.0\n\n    ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/autowrap.html"
  },
  {
    "name": "ufuncify",
    "full_id": "sympy.utilities.autowrap.ufuncify",
    "type": "function",
    "description": "Generates a binary function that supports broadcasting on numpy arrays.\n\n    Parameters\n    ==========\n\n    args : iterable\n        Either a Symbol or an iterable of symbols. Specifies the argument\n        sequence for the function.\n    expr\n        A SymPy expression that defines the element wise operation.\n    language : string, optional\n        If supplied, (options: 'C' or 'F95'), specifies the language of the\n        generated code. If ``None`` [default], the language is inferred based\n        upon the specified backend.\n    backend : string, optional\n        Backend used to wrap the generated code. Either 'numpy' [default],\n        'cython', or 'f2py'.\n    tempdir : string, optional\n        Path to directory for temporary files. If this argument is supplied,\n        the generated code and the wrapper input files are left intact in\n        the specified path.\n    flags : iterable, optional\n        Additional option flags that will be passed to the backend.\n    verbose : bool, optional\n        If True, autowrap will not mute the command line backends. This can\n        be helpful for debugging.\n    helpers : iterable, optional\n        Used to define auxiliary expressions needed for the main expr. If\n        the main expression needs to call a specialized function it should\n        be put in the ``helpers`` iterable. Autowrap will then make sure\n        that the compiled main expression can link to the helper routine.\n        Items should be tuples with (<funtion_name>, <sympy_expression>,\n        <arguments>). It is mandatory to supply an argument sequence to\n        helper routines.\n    kwargs : dict\n        These kwargs will be passed to autowrap if the `f2py` or `cython`\n        backend is used and ignored if the `numpy` backend is used.\n\n    Notes\n    =====\n\n    The default backend ('numpy') will create actual instances of\n    ``numpy.ufunc``. These support ndimensional broadcasting, and implicit type\n    conversion. Use of the other backends will result in a \"ufunc-like\"\n    function, which requires equal length 1-dimensional arrays for all\n    arguments, and will not perform any type conversions.\n\n    References\n    ==========\n\n    .. [1] https://numpy.org/doc/stable/reference/ufuncs.html\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.autowrap import ufuncify\n    >>> from sympy.abc import x, y\n    >>> import numpy as np\n    >>> f = ufuncify((x, y), y + x**2)\n    >>> type(f)\n    <class 'numpy.ufunc'>\n    >>> f([1, 2, 3], 2)\n    array([  3.,   6.,  11.])\n    >>> f(np.arange(5), 3)\n    array([  3.,   4.,   7.,  12.,  19.])\n\n    For the 'f2py' and 'cython' backends, inputs are required to be equal length\n    1-dimensional arrays. The 'f2py' backend will perform type conversion, but\n    the Cython backend will error if the inputs are not of the expected type.\n\n    >>> f_fortran = ufuncify((x, y), y + x**2, backend='f2py')\n    >>> f_fortran(1, 2)\n    array([ 3.])\n    >>> f_fortran(np.array([1, 2, 3]), np.array([1.0, 2.0, 3.0]))\n    array([  2.,   6.,  12.])\n    >>> f_cython = ufuncify((x, y), y + x**2, backend='Cython')\n    >>> f_cython(1, 2)  # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    TypeError: Argument '_x' has incorrect type (expected numpy.ndarray, got int)\n    >>> f_cython(np.array([1.0]), np.array([2.0]))\n    array([ 3.])\n\n    ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/autowrap.html"
  },
  {
    "name": "dump_c",
    "full_id": "sympy.utilities.codegen.CCodeGen.dump_c",
    "type": "method",
    "description": "Write the code by calling language specific methods.\n\n        The generated file contains all the definitions of the routines in\n        low-level code and refers to the header file if appropriate.\n\n        Parameters\n        ==========\n\n        routines : list\n            A list of Routine instances.\n\n        f : file-like\n            Where to write the file.\n\n        prefix : string\n            The filename prefix, used to refer to the proper header file.\n            Only the basename of the prefix is used.\n\n        header : bool, optional\n            When True, a header comment is included on top of each source\n            file.  [default : True]\n\n        empty : bool, optional\n            When True, empty lines are included to structure the source\n            files.  [default : True]\n\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "dump_h",
    "full_id": "sympy.utilities.codegen.CCodeGen.dump_h",
    "type": "method",
    "description": "Writes the C header file.\n\n        This file contains all the function declarations.\n\n        Parameters\n        ==========\n\n        routines : list\n            A list of Routine instances.\n\n        f : file-like\n            Where to write the file.\n\n        prefix : string\n            The filename prefix, used to construct the include guards.\n            Only the basename of the prefix is used.\n\n        header : bool, optional\n            When True, a header comment is included on top of each source\n            file.  [default : True]\n\n        empty : bool, optional\n            When True, empty lines are included to structure the source\n            files.  [default : True]\n\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "get_prototype",
    "full_id": "sympy.utilities.codegen.CCodeGen.get_prototype",
    "type": "method",
    "description": "Returns a string for the function prototype of the routine.\n\n        If the routine has multiple result objects, an CodeGenError is\n        raised.\n\n        See: https://en.wikipedia.org/wiki/Function_prototype\n\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "routine",
    "full_id": "sympy.utilities.codegen.CodeGen.routine",
    "type": "method",
    "description": "Creates an Routine object that is appropriate for this language.\n\n        This implementation is appropriate for at least C/Fortran.  Subclasses\n        can override this if necessary.\n\n        Here, we assume at most one return value (the l-value) which must be\n        scalar.  Additional outputs are OutputArguments (e.g., pointers on\n        right-hand-side or pass-by-reference).  Matrices are always returned\n        via OutputArguments.  If ``argument_sequence`` is None, arguments will\n        be ordered alphabetically, but with all InputArguments first, and then\n        OutputArgument and InOutArguments.\n\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "write",
    "full_id": "sympy.utilities.codegen.CodeGen.write",
    "type": "method",
    "description": "Writes all the source code files for the given routines.\n\n        The generated source is returned as a list of (filename, contents)\n        tuples, or is written to files (see below).  Each filename consists\n        of the given prefix, appended with an appropriate extension.\n\n        Parameters\n        ==========\n\n        routines : list\n            A list of Routine instances to be written\n\n        prefix : string\n            The prefix for the output files\n\n        to_files : bool, optional\n            When True, the output is written to files.  Otherwise, a list\n            of (filename, contents) tuples is returned.  [default: False]\n\n        header : bool, optional\n            When True, a header comment is included on top of each source\n            file. [default: True]\n\n        empty : bool, optional\n            When True, empty lines are included to structure the source\n            files. [default: True]\n\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "dump_h",
    "full_id": "sympy.utilities.codegen.FCodeGen.dump_h",
    "type": "method",
    "description": "Writes the interface to a header file.\n\n        This file contains all the function declarations.\n\n        Parameters\n        ==========\n\n        routines : list\n            A list of Routine instances.\n\n        f : file-like\n            Where to write the file.\n\n        prefix : string\n            The filename prefix.\n\n        header : bool, optional\n            When True, a header comment is included on top of each source\n            file.  [default : True]\n\n        empty : bool, optional\n            When True, empty lines are included to structure the source\n            files.  [default : True]\n\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "get_interface",
    "full_id": "sympy.utilities.codegen.FCodeGen.get_interface",
    "type": "method",
    "description": "Returns a string for the function interface.\n\n        The routine should have a single result object, which can be None.\n        If the routine has multiple result objects, a CodeGenError is\n        raised.\n\n        See: https://en.wikipedia.org/wiki/Function_prototype\n\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "routine",
    "full_id": "sympy.utilities.codegen.JuliaCodeGen.routine",
    "type": "method",
    "description": "Specialized Routine creation for Julia.",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "routine",
    "full_id": "sympy.utilities.codegen.OctaveCodeGen.routine",
    "type": "method",
    "description": "Specialized Routine creation for Octave.",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "result_variables",
    "full_id": "sympy.utilities.codegen.Routine.result_variables",
    "type": "property",
    "description": "Returns a list of OutputArgument, InOutArgument and Result.\n\n        If return values are present, they are at the end of the list.\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "variables",
    "full_id": "sympy.utilities.codegen.Routine.variables",
    "type": "property",
    "description": "Returns a set of all variables possibly used in the routine.\n\n        For routines with unnamed return values, the dummies that may or\n        may not be used will be included in the set.\n\n        ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "routine",
    "full_id": "sympy.utilities.codegen.RustCodeGen.routine",
    "type": "method",
    "description": "Specialized Routine creation for Rust.",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "codegen",
    "full_id": "sympy.utilities.codegen.codegen",
    "type": "function",
    "description": "Generate source code for expressions in a given language.\n\n    Parameters\n    ==========\n\n    name_expr : tuple, or list of tuples\n        A single (name, expression) tuple or a list of (name, expression)\n        tuples.  Each tuple corresponds to a routine.  If the expression is\n        an equality (an instance of class Equality) the left hand side is\n        considered an output argument.  If expression is an iterable, then\n        the routine will have multiple outputs.\n\n    language : string,\n        A string that indicates the source code language.  This is case\n        insensitive.  Currently, 'C', 'F95' and 'Octave' are supported.\n        'Octave' generates code compatible with both Octave and Matlab.\n\n    prefix : string, optional\n        A prefix for the names of the files that contain the source code.\n        Language-dependent suffixes will be appended.  If omitted, the name\n        of the first name_expr tuple is used.\n\n    project : string, optional\n        A project name, used for making unique preprocessor instructions.\n        [default: \"project\"]\n\n    to_files : bool, optional\n        When True, the code will be written to one or more files with the\n        given prefix, otherwise strings with the names and contents of\n        these files are returned. [default: False]\n\n    header : bool, optional\n        When True, a header is written on top of each source file.\n        [default: True]\n\n    empty : bool, optional\n        When True, empty lines are used to structure the code.\n        [default: True]\n\n    argument_sequence : iterable, optional\n        Sequence of arguments for the routine in a preferred order.  A\n        CodeGenError is raised if required arguments are missing.\n        Redundant arguments are used without warning.  If omitted,\n        arguments will be ordered alphabetically, but with all input\n        arguments first, and then output or in-out arguments.\n\n    global_vars : iterable, optional\n        Sequence of global variables used by the routine.  Variables\n        listed here will not show up as function arguments.\n\n    standard : string, optional\n\n    code_gen : CodeGen instance, optional\n        An instance of a CodeGen subclass. Overrides ``language``.\n\n    printer : Printer instance, optional\n        An instance of a Printer subclass.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.codegen import codegen\n    >>> from sympy.abc import x, y, z\n    >>> [(c_name, c_code), (h_name, c_header)] = codegen(\n    ...     (\"f\", x+y*z), \"C89\", \"test\", header=False, empty=False)\n    >>> print(c_name)\n    test.c\n    >>> print(c_code)\n    #include \"test.h\"\n    #include <math.h>\n    double f(double x, double y, double z) {\n       double f_result;\n       f_result = x + y*z;\n       return f_result;\n    }\n    <BLANKLINE>\n    >>> print(h_name)\n    test.h\n    >>> print(c_header)\n    #ifndef PROJECT__TEST__H\n    #define PROJECT__TEST__H\n    double f(double x, double y, double z);\n    #endif\n    <BLANKLINE>\n\n    Another example using Equality objects to give named outputs.  Here the\n    filename (prefix) is taken from the first (name, expr) pair.\n\n    >>> from sympy.abc import f, g\n    >>> from sympy import Eq\n    >>> [(c_name, c_code), (h_name, c_header)] = codegen(\n    ...      [(\"myfcn\", x + y), (\"fcn2\", [Eq(f, 2*x), Eq(g, y)])],\n    ...      \"C99\", header=False, empty=False)\n    >>> print(c_name)\n    myfcn.c\n    >>> print(c_code)\n    #include \"myfcn.h\"\n    #include <math.h>\n    double myfcn(double x, double y) {\n       double myfcn_result;\n       myfcn_result = x + y;\n       return myfcn_result;\n    }\n    void fcn2(double x, double y, double *f, double *g) {\n       (*f) = 2*x;\n       (*g) = y;\n    }\n    <BLANKLINE>\n\n    If the generated function(s) will be part of a larger project where various\n    global variables have been defined, the 'global_vars' option can be used\n    to remove the specified variables from the function signature\n\n    >>> from sympy.utilities.codegen import codegen\n    >>> from sympy.abc import x, y, z\n    >>> [(f_name, f_code), header] = codegen(\n    ...     (\"f\", x+y*z), \"F95\", header=False, empty=False,\n    ...     argument_sequence=(x, y), global_vars=(z,))\n    >>> print(f_code)\n    REAL*8 function f(x, y)\n    implicit none\n    REAL*8, intent(in) :: x\n    REAL*8, intent(in) :: y\n    f = x + y*z\n    end function\n    <BLANKLINE>\n\n    ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "get_default_datatype",
    "full_id": "sympy.utilities.codegen.get_default_datatype",
    "type": "function",
    "description": "Derives an appropriate datatype based on the expression.",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "make_routine",
    "full_id": "sympy.utilities.codegen.make_routine",
    "type": "function",
    "description": "A factory that makes an appropriate Routine from an expression.\n\n    Parameters\n    ==========\n\n    name : string\n        The name of this routine in the generated code.\n\n    expr : expression or list/tuple of expressions\n        A SymPy expression that the Routine instance will represent.  If\n        given a list or tuple of expressions, the routine will be\n        considered to have multiple return values and/or output arguments.\n\n    argument_sequence : list or tuple, optional\n        List arguments for the routine in a preferred order.  If omitted,\n        the results are language dependent, for example, alphabetical order\n        or in the same order as the given expressions.\n\n    global_vars : iterable, optional\n        Sequence of global variables used by the routine.  Variables\n        listed here will not show up as function arguments.\n\n    language : string, optional\n        Specify a target language.  The Routine itself should be\n        language-agnostic but the precise way one is created, error\n        checking, etc depend on the language.  [default: \"F95\"].\n\n    Notes\n    =====\n\n    A decision about whether to use output arguments or return values is made\n    depending on both the language and the particular mathematical expressions.\n    For an expression of type Equality, the left hand side is typically made\n    into an OutputArgument (or perhaps an InOutArgument if appropriate).\n    Otherwise, typically, the calculated expression is made a return values of\n    the routine.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.codegen import make_routine\n    >>> from sympy.abc import x, y, f, g\n    >>> from sympy import Eq\n    >>> r = make_routine('test', [Eq(f, 2*x), Eq(g, x + y)])\n    >>> [arg.result_var for arg in r.results]\n    []\n    >>> [arg.name for arg in r.arguments]\n    [x, y, f, g]\n    >>> [arg.name for arg in r.result_variables]\n    [f, g]\n    >>> r.local_vars\n    set()\n\n    Another more complicated example with a mixture of specified and\n    automatically-assigned names.  Also has Matrix output.\n\n    >>> from sympy import Matrix\n    >>> r = make_routine('fcn', [x*y, Eq(f, 1), Eq(g, x + g), Matrix([[x, 2]])])\n    >>> [arg.result_var for arg in r.results]  # doctest: +SKIP\n    [result_5397460570204848505]\n    >>> [arg.expr for arg in r.results]\n    [x*y]\n    >>> [arg.name for arg in r.arguments]  # doctest: +SKIP\n    [x, y, f, g, out_8598435338387848786]\n\n    We can examine the various arguments more closely:\n\n    >>> from sympy.utilities.codegen import (InputArgument, OutputArgument,\n    ...                                      InOutArgument)\n    >>> [a.name for a in r.arguments if isinstance(a, InputArgument)]\n    [x, y]\n\n    >>> [a.name for a in r.arguments if isinstance(a, OutputArgument)]  # doctest: +SKIP\n    [f, out_8598435338387848786]\n    >>> [a.expr for a in r.arguments if isinstance(a, OutputArgument)]\n    [1, Matrix([[x, 2]])]\n\n    >>> [a.name for a in r.arguments if isinstance(a, InOutArgument)]\n    [g]\n    >>> [a.expr for a in r.arguments if isinstance(a, InOutArgument)]\n    [g + x]\n\n    ",
    "section": "API Reference",
    "url": "https://docs.sympy.org/latest/modules/utilities/codegen.html"
  },
  {
    "name": "deprecated",
    "full_id": "sympy.utilities.decorator.deprecated",
    "type": "function",
    "description": "\n    Mark a function as deprecated.\n\n    This decorator should be used if an entire function or class is\n    deprecated. If only a certain functionality is deprecated, you should use\n    :func:`~.warns_deprecated_sympy` directly. This decorator is just a\n    convenience. There is no functional difference between using this\n    decorator and calling ``warns_deprecated_sympy()`` at the top of the\n    function.\n\n    The decorator takes the same arguments as\n    :func:`~.warns_deprecated_sympy`. See its\n    documentation for details on what the keywords to this decorator do.\n\n    See the :ref:`deprecation-policy` document for details on when and how\n    things should be deprecated in SymPy.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.decorator import deprecated\n    >>> from sympy import simplify\n    >>> @deprecated(\"\"\"    ... The simplify_this(expr) function is deprecated. Use simplify(expr)\n    ... instead.\"\"\", deprecated_since_version=\"1.1\",\n    ... active_deprecations_target='simplify-this-deprecation')\n    ... def simplify_this(expr):\n    ...     \"\"\"\n    ...     Simplify ``expr``.\n    ...\n    ...     .. deprecated:: 1.1\n    ...\n    ...        The ``simplify_this`` function is deprecated. Use :func:`simplify`\n    ...        instead. See its documentation for more information. See\n    ...        :ref:`simplify-this-deprecation` for details.\n    ...\n    ...     \"\"\"\n    ...     return simplify(expr)\n    >>> from sympy.abc import x\n    >>> simplify_this(x*(x + 1) - x**2) # doctest: +SKIP\n    <stdin>:1: SymPyDeprecationWarning:\n    <BLANKLINE>\n    The simplify_this(expr) function is deprecated. Use simplify(expr)\n    instead.\n    <BLANKLINE>\n    See https://docs.sympy.org/latest/explanation/active-deprecations.html#simplify-this-deprecation\n    for details.\n    <BLANKLINE>\n    This has been deprecated since SymPy version 1.1. It\n    will be removed in a future version of SymPy.\n    <BLANKLINE>\n      simplify_this(x)\n    x\n\n    See Also\n    ========\n    sympy.utilities.exceptions.SymPyDeprecationWarning\n    sympy.utilities.exceptions.sympy_deprecation_warning\n    sympy.utilities.exceptions.ignore_warnings\n    sympy.testing.pytest.warns_deprecated_sympy\n\n    ",
    "section": "Decorator",
    "url": "https://docs.sympy.org/latest/modules/utilities/decorator.html"
  },
  {
    "name": "conserve_mpmath_dps",
    "full_id": "sympy.utilities.decorator.conserve_mpmath_dps",
    "type": "function",
    "description": "After the function finishes, resets the value of ``mpmath.mp.dps`` to\n    the value it had before the function was run.",
    "section": "Decorator",
    "url": "https://docs.sympy.org/latest/modules/utilities/decorator.html"
  },
  {
    "name": "doctest_depends_on",
    "full_id": "sympy.utilities.decorator.doctest_depends_on",
    "type": "function",
    "description": "\n    Adds metadata about the dependencies which need to be met for doctesting\n    the docstrings of the decorated objects.\n\n    ``exe`` should be a list of executables\n\n    ``modules`` should be a list of modules\n\n    ``disable_viewers`` should be a list of viewers for :func:`~sympy.printing.preview.preview` to disable\n\n    ``python_version`` should be the minimum Python version required, as a tuple\n    (like ``(3, 0)``)\n    ",
    "section": "Decorator",
    "url": "https://docs.sympy.org/latest/modules/utilities/decorator.html"
  },
  {
    "name": "memoize_property",
    "full_id": "sympy.utilities.decorator.memoize_property",
    "type": "function",
    "description": "Property decorator that caches the value of potentially expensive\n    ``propfunc`` after the first evaluation. The cached value is stored in\n    the corresponding property name with an attached underscore.",
    "section": "Decorator",
    "url": "https://docs.sympy.org/latest/modules/utilities/decorator.html"
  },
  {
    "name": "public",
    "full_id": "sympy.utilities.decorator.public",
    "type": "function",
    "description": "\n    Append ``obj``'s name to global ``__all__`` variable (call site).\n\n    By using this decorator on functions or classes you achieve the same goal\n    as by filling ``__all__`` variables manually, you just do not have to repeat\n    yourself (object's name). You also know if object is public at definition\n    site, not at some random location (where ``__all__`` was set).\n\n    Note that in multiple decorator setup (in almost all cases) ``@public``\n    decorator must be applied before any other decorators, because it relies\n    on the pointer to object's global namespace. If you apply other decorators\n    first, ``@public`` may end up modifying the wrong namespace.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.decorator import public\n\n    >>> __all__ # noqa: F821\n    Traceback (most recent call last):\n    ...\n    NameError: name '__all__' is not defined\n\n    >>> @public\n    ... def some_function():\n    ...     pass\n\n    >>> __all__ # noqa: F821\n    ['some_function']\n\n    ",
    "section": "Decorator",
    "url": "https://docs.sympy.org/latest/modules/utilities/decorator.html"
  },
  {
    "name": "threaded",
    "full_id": "sympy.utilities.decorator.threaded",
    "type": "function",
    "description": "Apply ``func`` to sub--elements of an object, including :class:`~.Add`.\n\n    This decorator is intended to make it uniformly possible to apply a\n    function to all elements of composite objects, e.g. matrices, lists, tuples\n    and other iterable containers, or just expressions.\n\n    This version of :func:`threaded` decorator allows threading over\n    elements of :class:`~.Add` class. If this behavior is not desirable\n    use :func:`xthreaded` decorator.\n\n    Functions using this decorator must have the following signature::\n\n      @threaded\n      def function(expr, *args, **kwargs):\n\n    ",
    "section": "Decorator",
    "url": "https://docs.sympy.org/latest/modules/utilities/decorator.html"
  },
  {
    "name": "threaded_factory",
    "full_id": "sympy.utilities.decorator.threaded_factory",
    "type": "function",
    "description": "A factory for ``threaded`` decorators. ",
    "section": "Decorator",
    "url": "https://docs.sympy.org/latest/modules/utilities/decorator.html"
  },
  {
    "name": "xthreaded",
    "full_id": "sympy.utilities.decorator.xthreaded",
    "type": "function",
    "description": "Apply ``func`` to sub--elements of an object, excluding :class:`~.Add`.\n\n    This decorator is intended to make it uniformly possible to apply a\n    function to all elements of composite objects, e.g. matrices, lists, tuples\n    and other iterable containers, or just expressions.\n\n    This version of :func:`threaded` decorator disallows threading over\n    elements of :class:`~.Add` class. If this behavior is not desirable\n    use :func:`threaded` decorator.\n\n    Functions using this decorator must have the following signature::\n\n      @xthreaded\n      def function(expr, *args, **kwargs):\n\n    ",
    "section": "Decorator",
    "url": "https://docs.sympy.org/latest/modules/utilities/decorator.html"
  },
  {
    "name": "multiset_partitions_taocp",
    "full_id": "sympy.utilities.enumerative.multiset_partitions_taocp",
    "type": "function",
    "description": "Enumerates partitions of a multiset.\n\n    Parameters\n    ==========\n\n    multiplicities\n         list of integer multiplicities of the components of the multiset.\n\n    Yields\n    ======\n\n    state\n        Internal data structure which encodes a particular partition.\n        This output is then usually processed by a visitor function\n        which combines the information from this data structure with\n        the components themselves to produce an actual partition.\n\n        Unless they wish to create their own visitor function, users will\n        have little need to look inside this data structure.  But, for\n        reference, it is a 3-element list with components:\n\n        f\n            is a frame array, which is used to divide pstack into parts.\n\n        lpart\n            points to the base of the topmost part.\n\n        pstack\n            is an array of PartComponent objects.\n\n        The ``state`` output offers a peek into the internal data\n        structures of the enumeration function.  The client should\n        treat this as read-only; any modification of the data\n        structure will cause unpredictable (and almost certainly\n        incorrect) results.  Also, the components of ``state`` are\n        modified in place at each iteration.  Hence, the visitor must\n        be called at each loop iteration.  Accumulating the ``state``\n        instances and processing them later will not work.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.enumerative import list_visitor\n    >>> from sympy.utilities.enumerative import multiset_partitions_taocp\n    >>> # variables components and multiplicities represent the multiset 'abb'\n    >>> components = 'ab'\n    >>> multiplicities = [1, 2]\n    >>> states = multiset_partitions_taocp(multiplicities)\n    >>> list(list_visitor(state, components) for state in states)\n    [[['a', 'b', 'b']],\n    [['a', 'b'], ['b']],\n    [['a'], ['b', 'b']],\n    [['a'], ['b'], ['b']]]\n\n    See Also\n    ========\n\n    sympy.utilities.iterables.multiset_partitions: Takes a multiset\n        as input and directly yields multiset partitions.  It\n        dispatches to a number of functions, including this one, for\n        implementation.  Most users will find it more convenient to\n        use than multiset_partitions_taocp.\n\n    ",
    "section": "Enumerative",
    "url": "https://docs.sympy.org/latest/modules/utilities/enumerative.html"
  },
  {
    "name": "factoring_visitor",
    "full_id": "sympy.utilities.enumerative.factoring_visitor",
    "type": "function",
    "description": "Use with multiset_partitions_taocp to enumerate the ways a\n    number can be expressed as a product of factors.  For this usage,\n    the exponents of the prime factors of a number are arguments to\n    the partition enumerator, while the corresponding prime factors\n    are input here.\n\n    Examples\n    ========\n\n    To enumerate the factorings of a number we can think of the elements of the\n    partition as being the prime factors and the multiplicities as being their\n    exponents.\n\n    >>> from sympy.utilities.enumerative import factoring_visitor\n    >>> from sympy.utilities.enumerative import multiset_partitions_taocp\n    >>> from sympy import factorint\n    >>> primes, multiplicities = zip(*factorint(24).items())\n    >>> primes\n    (2, 3)\n    >>> multiplicities\n    (3, 1)\n    >>> states = multiset_partitions_taocp(multiplicities)\n    >>> list(factoring_visitor(state, primes) for state in states)\n    [[24], [8, 3], [12, 2], [4, 6], [4, 2, 3], [6, 2, 2], [2, 2, 2, 3]]\n    ",
    "section": "Enumerative",
    "url": "https://docs.sympy.org/latest/modules/utilities/enumerative.html"
  },
  {
    "name": "list_visitor",
    "full_id": "sympy.utilities.enumerative.list_visitor",
    "type": "function",
    "description": "Return a list of lists to represent the partition.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.enumerative import list_visitor\n    >>> from sympy.utilities.enumerative import multiset_partitions_taocp\n    >>> states = multiset_partitions_taocp([1, 2, 1])\n    >>> s = next(states)\n    >>> list_visitor(s, 'abc')  # for multiset 'a b b c'\n    [['a', 'b', 'b', 'c']]\n    >>> s = next(states)\n    >>> list_visitor(s, [1, 2, 3])  # for multiset '1 2 2 3\n    [[1, 2, 2], [3]]\n    ",
    "section": "Enumerative",
    "url": "https://docs.sympy.org/latest/modules/utilities/enumerative.html"
  },
  {
    "name": "count_partitions",
    "full_id": "sympy.utilities.enumerative.MultisetPartitionTraverser.count_partitions",
    "type": "method",
    "description": "Returns the number of partitions of a multiset whose components\n        have the multiplicities given in ``multiplicities``.\n\n        For larger counts, this method is much faster than calling one\n        of the enumerators and counting the result.  Uses dynamic\n        programming to cut down on the number of nodes actually\n        explored.  The dictionary used in order to accelerate the\n        counting process is stored in the ``MultisetPartitionTraverser``\n        object and persists across calls.  If the user does not\n        expect to call ``count_partitions`` for any additional\n        multisets, the object should be cleared to save memory.  On\n        the other hand, the cache built up from one count run can\n        significantly speed up subsequent calls to ``count_partitions``,\n        so it may be advantageous not to clear the object.\n\n        Examples\n        ========\n\n        >>> from sympy.utilities.enumerative import MultisetPartitionTraverser\n        >>> m = MultisetPartitionTraverser()\n        >>> m.count_partitions([9,8,2])\n        288716\n        >>> m.count_partitions([2,2])\n        9\n        >>> del m\n\n        Notes\n        =====\n\n        If one looks at the workings of Knuth's algorithm M [AOCP]_, it\n        can be viewed as a traversal of a binary tree of parts.  A\n        part has (up to) two children, the left child resulting from\n        the spread operation, and the right child from the decrement\n        operation.  The ordinary enumeration of multiset partitions is\n        an in-order traversal of this tree, and with the partitions\n        corresponding to paths from the root to the leaves. The\n        mapping from paths to partitions is a little complicated,\n        since the partition would contain only those parts which are\n        leaves or the parents of a spread link, not those which are\n        parents of a decrement link.\n\n        For counting purposes, it is sufficient to count leaves, and\n        this can be done with a recursive in-order traversal.  The\n        number of leaves of a subtree rooted at a particular part is a\n        function only of that part itself, so memoizing has the\n        potential to speed up the counting dramatically.\n\n        This method follows a computational approach which is similar\n        to the hypothetical memoized recursive function, but with two\n        differences:\n\n        1) This method is iterative, borrowing its structure from the\n           other enumerations and maintaining an explicit stack of\n           parts which are in the process of being counted.  (There\n           may be multisets which can be counted reasonably quickly by\n           this implementation, but which would overflow the default\n           Python recursion limit with a recursive implementation.)\n\n        2) Instead of using the part data structure directly, a more\n           compact key is constructed.  This saves space, but more\n           importantly coalesces some parts which would remain\n           separate with physical keys.\n\n        Unlike the enumeration functions, there is currently no _range\n        version of count_partitions.  If someone wants to stretch\n        their brain, it should be possible to construct one by\n        memoizing with a histogram of counts rather than a single\n        count, and combining the histograms.\n        ",
    "section": "Enumerative",
    "url": "https://docs.sympy.org/latest/modules/utilities/enumerative.html"
  },
  {
    "name": "enum_all",
    "full_id": "sympy.utilities.enumerative.MultisetPartitionTraverser.enum_all",
    "type": "method",
    "description": "Enumerate the partitions of a multiset.\n\n        Examples\n        ========\n\n        >>> from sympy.utilities.enumerative import list_visitor\n        >>> from sympy.utilities.enumerative import MultisetPartitionTraverser\n        >>> m = MultisetPartitionTraverser()\n        >>> states = m.enum_all([2,2])\n        >>> list(list_visitor(state, 'ab') for state in states)\n        [[['a', 'a', 'b', 'b']],\n        [['a', 'a', 'b'], ['b']],\n        [['a', 'a'], ['b', 'b']],\n        [['a', 'a'], ['b'], ['b']],\n        [['a', 'b', 'b'], ['a']],\n        [['a', 'b'], ['a', 'b']],\n        [['a', 'b'], ['a'], ['b']],\n        [['a'], ['a'], ['b', 'b']],\n        [['a'], ['a'], ['b'], ['b']]]\n\n        See Also\n        ========\n\n        multiset_partitions_taocp:\n            which provides the same result as this method, but is\n            about twice as fast.  Hence, enum_all is primarily useful\n            for testing.  Also see the function for a discussion of\n            states and visitors.\n\n        ",
    "section": "Enumerative",
    "url": "https://docs.sympy.org/latest/modules/utilities/enumerative.html"
  },
  {
    "name": "enum_large",
    "full_id": "sympy.utilities.enumerative.MultisetPartitionTraverser.enum_large",
    "type": "method",
    "description": "Enumerate the partitions of a multiset with lb < num(parts)\n\n        Equivalent to enum_range(multiplicities, lb, sum(multiplicities))\n\n        Parameters\n        ==========\n\n        multiplicities\n            list of multiplicities of the components of the multiset.\n\n        lb\n            Number of parts in the partition must be greater than\n            this lower bound.\n\n\n        Examples\n        ========\n\n        >>> from sympy.utilities.enumerative import list_visitor\n        >>> from sympy.utilities.enumerative import MultisetPartitionTraverser\n        >>> m = MultisetPartitionTraverser()\n        >>> states = m.enum_large([2,2], 2)\n        >>> list(list_visitor(state, 'ab') for state in states)\n        [[['a', 'a'], ['b'], ['b']],\n        [['a', 'b'], ['a'], ['b']],\n        [['a'], ['a'], ['b', 'b']],\n        [['a'], ['a'], ['b'], ['b']]]\n\n        See Also\n        ========\n\n        enum_all, enum_small, enum_range\n\n        ",
    "section": "Enumerative",
    "url": "https://docs.sympy.org/latest/modules/utilities/enumerative.html"
  },
  {
    "name": "enum_range",
    "full_id": "sympy.utilities.enumerative.MultisetPartitionTraverser.enum_range",
    "type": "method",
    "description": "Enumerate the partitions of a multiset with\n        ``lb < num(parts) <= ub``.\n\n        In particular, if partitions with exactly ``k`` parts are\n        desired, call with ``(multiplicities, k - 1, k)``.  This\n        method generalizes enum_all, enum_small, and enum_large.\n\n        Examples\n        ========\n\n        >>> from sympy.utilities.enumerative import list_visitor\n        >>> from sympy.utilities.enumerative import MultisetPartitionTraverser\n        >>> m = MultisetPartitionTraverser()\n        >>> states = m.enum_range([2,2], 1, 2)\n        >>> list(list_visitor(state, 'ab') for state in states)\n        [[['a', 'a', 'b'], ['b']],\n        [['a', 'a'], ['b', 'b']],\n        [['a', 'b', 'b'], ['a']],\n        [['a', 'b'], ['a', 'b']]]\n\n        ",
    "section": "Enumerative",
    "url": "https://docs.sympy.org/latest/modules/utilities/enumerative.html"
  },
  {
    "name": "enum_small",
    "full_id": "sympy.utilities.enumerative.MultisetPartitionTraverser.enum_small",
    "type": "method",
    "description": "Enumerate multiset partitions with no more than ``ub`` parts.\n\n        Equivalent to enum_range(multiplicities, 0, ub)\n\n        Parameters\n        ==========\n\n        multiplicities\n             list of multiplicities of the components of the multiset.\n\n        ub\n            Maximum number of parts\n\n        Examples\n        ========\n\n        >>> from sympy.utilities.enumerative import list_visitor\n        >>> from sympy.utilities.enumerative import MultisetPartitionTraverser\n        >>> m = MultisetPartitionTraverser()\n        >>> states = m.enum_small([2,2], 2)\n        >>> list(list_visitor(state, 'ab') for state in states)\n        [[['a', 'a', 'b', 'b']],\n        [['a', 'a', 'b'], ['b']],\n        [['a', 'a'], ['b', 'b']],\n        [['a', 'b', 'b'], ['a']],\n        [['a', 'b'], ['a', 'b']]]\n\n        The implementation is based, in part, on the answer given to\n        exercise 69, in Knuth [AOCP]_.\n\n        See Also\n        ========\n\n        enum_all, enum_large, enum_range\n\n        ",
    "section": "Enumerative",
    "url": "https://docs.sympy.org/latest/modules/utilities/enumerative.html"
  },
  {
    "name": "ignore_warnings",
    "full_id": "sympy.utilities.exceptions.ignore_warnings",
    "type": "function",
    "description": "\n    Context manager to suppress warnings during tests.\n\n    .. note::\n\n       Do not use this with SymPyDeprecationWarning in the tests.\n       warns_deprecated_sympy() should be used instead.\n\n    This function is useful for suppressing warnings during tests. The warns\n    function should be used to assert that a warning is raised. The\n    ignore_warnings function is useful in situation when the warning is not\n    guaranteed to be raised (e.g. on importing a module) or if the warning\n    comes from third-party code.\n\n    This function is also useful to prevent the same or similar warnings from\n    being issue twice due to recursive calls.\n\n    When the warning is coming (reliably) from SymPy the warns function should\n    be preferred to ignore_warnings.\n\n    >>> from sympy.utilities.exceptions import ignore_warnings\n    >>> import warnings\n\n    Here's a warning:\n\n    >>> with warnings.catch_warnings():  # reset warnings in doctest\n    ...     warnings.simplefilter('error')\n    ...     warnings.warn('deprecated', UserWarning)\n    Traceback (most recent call last):\n      ...\n    UserWarning: deprecated\n\n    Let's suppress it with ignore_warnings:\n\n    >>> with warnings.catch_warnings():  # reset warnings in doctest\n    ...     warnings.simplefilter('error')\n    ...     with ignore_warnings(UserWarning):\n    ...         warnings.warn('deprecated', UserWarning)\n\n    (No warning emitted)\n\n    See Also\n    ========\n    sympy.utilities.exceptions.SymPyDeprecationWarning\n    sympy.utilities.exceptions.sympy_deprecation_warning\n    sympy.utilities.decorator.deprecated\n    sympy.testing.pytest.warns_deprecated_sympy\n\n    ",
    "section": "Exceptions and Warnings",
    "url": "https://docs.sympy.org/latest/modules/utilities/exceptions.html"
  },
  {
    "name": "sympy_deprecation_warning",
    "full_id": "sympy.utilities.exceptions.sympy_deprecation_warning",
    "type": "function",
    "description": "\n    Warn that a feature is deprecated in SymPy.\n\n    See the :ref:`deprecation-policy` document for details on when and how\n    things should be deprecated in SymPy.\n\n    To mark an entire function or class as deprecated, you can use the\n    :func:`@deprecated <sympy.utilities.decorator.deprecated>` decorator.\n\n    Parameters\n    ==========\n\n    message : str\n         The deprecation message. This may span multiple lines and contain\n         code examples. Messages should be wrapped to 80 characters. The\n         message is automatically dedented and leading and trailing whitespace\n         stripped. Messages may include dynamic content based on the user\n         input, but avoid using ``str(expression)`` if an expression can be\n         arbitrary, as it might be huge and make the warning message\n         unreadable.\n\n    deprecated_since_version : str\n         The version of SymPy the feature has been deprecated since. For new\n         deprecations, this should be the version in `sympy/release.py\n         <https://github.com/sympy/sympy/blob/master/sympy/release.py>`_\n         without the ``.dev``. If the next SymPy version ends up being\n         different from this, the release manager will need to update any\n         ``SymPyDeprecationWarning``\\s using the incorrect version. This\n         argument is required and must be passed as a keyword argument.\n         (example:  ``deprecated_since_version=\"1.10\"``).\n\n    active_deprecations_target : str\n        The Sphinx target corresponding to the section for the deprecation in\n        the :ref:`active-deprecations` document (see\n        ``doc/src/explanation/active-deprecations.md``). This is used to\n        automatically generate a URL to the page in the warning message. This\n        argument is required and must be passed as a keyword argument.\n        (example: ``active_deprecations_target=\"deprecated-feature-abc\"``)\n\n    stacklevel : int, default: 3\n        The ``stacklevel`` parameter that is passed to ``warnings.warn``. If\n        you create a wrapper that calls this function, this should be\n        increased so that the warning message shows the user line of code that\n        produced the warning. Note that in some cases there will be multiple\n        possible different user code paths that could result in the warning.\n        In that case, just choose the smallest common stacklevel.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.exceptions import sympy_deprecation_warning\n    >>> def is_this_zero(x, y=0):\n    ...     \"\"\"\n    ...     Determine if x = 0.\n    ...\n    ...     Parameters\n    ...     ==========\n    ...\n    ...     x : Expr\n    ...       The expression to check.\n    ...\n    ...     y : Expr, optional\n    ...       If provided, check if x = y.\n    ...\n    ...       .. deprecated:: 1.1\n    ...\n    ...          The ``y`` argument to ``is_this_zero`` is deprecated. Use\n    ...          ``is_this_zero(x - y)`` instead.\n    ...\n    ...     \"\"\"\n    ...     from sympy import simplify\n    ...\n    ...     if y != 0:\n    ...         sympy_deprecation_warning(\"\"\"\n    ...     The y argument to is_zero() is deprecated. Use is_zero(x - y) instead.\"\"\",\n    ...             deprecated_since_version=\"1.1\",\n    ...             active_deprecations_target='is-this-zero-y-deprecation')\n    ...     return simplify(x - y) == 0\n    >>> is_this_zero(0)\n    True\n    >>> is_this_zero(1, 1) # doctest: +SKIP\n    <stdin>:1: SymPyDeprecationWarning:\n    <BLANKLINE>\n    The y argument to is_zero() is deprecated. Use is_zero(x - y) instead.\n    <BLANKLINE>\n    See https://docs.sympy.org/latest/explanation/active-deprecations.html#is-this-zero-y-deprecation\n    for details.\n    <BLANKLINE>\n    This has been deprecated since SymPy version 1.1. It\n    will be removed in a future version of SymPy.\n    <BLANKLINE>\n      is_this_zero(1, 1)\n    True\n\n    See Also\n    ========\n\n    sympy.utilities.exceptions.SymPyDeprecationWarning\n    sympy.utilities.exceptions.ignore_warnings\n    sympy.utilities.decorator.deprecated\n    sympy.testing.pytest.warns_deprecated_sympy\n\n    ",
    "section": "Exceptions and Warnings",
    "url": "https://docs.sympy.org/latest/modules/utilities/exceptions.html"
  },
  {
    "name": "binary_partitions",
    "full_id": "sympy.utilities.iterables.binary_partitions",
    "type": "function",
    "description": "\n    Generates the binary partition of *n*.\n\n    A binary partition consists only of numbers that are\n    powers of two. Each step reduces a `2^{k+1}` to `2^k` and\n    `2^k`. Thus 16 is converted to 8 and 8.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import binary_partitions\n    >>> for i in binary_partitions(5):\n    ...     print(i)\n    ...\n    [4, 1]\n    [2, 2, 1]\n    [2, 1, 1, 1]\n    [1, 1, 1, 1, 1]\n\n    References\n    ==========\n\n    .. [1] TAOCP 4, section 7.2.1.5, problem 64\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "bracelets",
    "full_id": "sympy.utilities.iterables.bracelets",
    "type": "function",
    "description": "Wrapper to necklaces to return a free (unrestricted) necklace.",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "capture",
    "full_id": "sympy.utilities.iterables.capture",
    "type": "function",
    "description": "Return the printed output of func().\n\n    ``func`` should be a function without arguments that produces output with\n    print statements.\n\n    >>> from sympy.utilities.iterables import capture\n    >>> from sympy import pprint\n    >>> from sympy.abc import x\n    >>> def foo():\n    ...     print('hello world!')\n    ...\n    >>> 'hello' in capture(foo) # foo, not foo()\n    True\n    >>> capture(lambda: pprint(2/x))\n    '2\\n-\\nx\\n'\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "common_prefix",
    "full_id": "sympy.utilities.iterables.common_prefix",
    "type": "function",
    "description": "Return the subsequence that is a common start of sequences in ``seqs``.\n\n    >>> from sympy.utilities.iterables import common_prefix\n    >>> common_prefix(list(range(3)))\n    [0, 1, 2]\n    >>> common_prefix(list(range(3)), list(range(4)))\n    [0, 1, 2]\n    >>> common_prefix([1, 2, 3], [1, 2, 5])\n    [1, 2]\n    >>> common_prefix([1, 2, 3], [1, 3, 5])\n    [1]\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "common_suffix",
    "full_id": "sympy.utilities.iterables.common_suffix",
    "type": "function",
    "description": "Return the subsequence that is a common ending of sequences in ``seqs``.\n\n    >>> from sympy.utilities.iterables import common_suffix\n    >>> common_suffix(list(range(3)))\n    [0, 1, 2]\n    >>> common_suffix(list(range(3)), list(range(4)))\n    []\n    >>> common_suffix([1, 2, 3], [9, 2, 3])\n    [2, 3]\n    >>> common_suffix([1, 2, 3], [9, 7, 3])\n    [3]\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "connected_components",
    "full_id": "sympy.utilities.iterables.connected_components",
    "type": "function",
    "description": "\n    Connected components of an undirected graph or weakly connected components\n    of a directed graph.\n\n\n    Parameters\n    ==========\n\n    G : tuple[list, list[tuple[T, T]]\n        A tuple consisting of a list of vertices and a list of edges of\n        a graph whose connected components are to be found.\n\n\n    Examples\n    ========\n\n\n    Given an undirected graph::\n\n        graph {\n            A -- B\n            C -- D\n        }\n\n    .. graphviz::\n\n        graph {\n            A -- B\n            C -- D\n        }\n\n    We can find the connected components using this function if we include\n    each edge in both directions::\n\n        >>> from sympy.utilities.iterables import connected_components\n\n        >>> V = ['A', 'B', 'C', 'D']\n        >>> E = [('A', 'B'), ('B', 'A'), ('C', 'D'), ('D', 'C')]\n        >>> connected_components((V, E))\n        [['A', 'B'], ['C', 'D']]\n\n    The weakly connected components of a directed graph can found the same\n    way.\n\n\n    Notes\n    =====\n\n    The vertices of the graph must be hashable for the data structures used.\n    If the vertices are unhashable replace them with integer indices.\n\n    This function uses Tarjan's algorithm to compute the connected components\n    in `O(|V|+|E|)` (linear) time.\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Component_%28graph_theory%29\n    .. [2] https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\n\n    See Also\n    ========\n\n    sympy.utilities.iterables.strongly_connected_components\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "dict_merge",
    "full_id": "sympy.utilities.iterables.dict_merge",
    "type": "function",
    "description": "Merge dictionaries into a single dictionary. ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "filter_symbols",
    "full_id": "sympy.utilities.iterables.filter_symbols",
    "type": "function",
    "description": "\n    Only yield elements from `iterator` that do not occur in `exclude`.\n\n    Parameters\n    ==========\n\n    iterator : iterable\n        iterator to take elements from\n\n    exclude : iterable\n        elements to exclude\n\n    Returns\n    =======\n\n    iterator : iterator\n        filtered iterator\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "flatten",
    "full_id": "sympy.utilities.iterables.flatten",
    "type": "function",
    "description": "\n    Recursively denest iterable containers.\n\n    >>> from sympy import flatten\n\n    >>> flatten([1, 2, 3])\n    [1, 2, 3]\n    >>> flatten([1, 2, [3]])\n    [1, 2, 3]\n    >>> flatten([1, [2, 3], [4, 5]])\n    [1, 2, 3, 4, 5]\n    >>> flatten([1.0, 2, (1, None)])\n    [1.0, 2, 1, None]\n\n    If you want to denest only a specified number of levels of\n    nested containers, then set ``levels`` flag to the desired\n    number of levels::\n\n    >>> ls = [[(-2, -1), (1, 2)], [(0, 0)]]\n\n    >>> flatten(ls, levels=1)\n    [(-2, -1), (1, 2), (0, 0)]\n\n    If cls argument is specified, it will only flatten instances of that\n    class, for example:\n\n    >>> from sympy import Basic, S\n    >>> class MyOp(Basic):\n    ...     pass\n    ...\n    >>> flatten([MyOp(S(1), MyOp(S(2), S(3)))], cls=MyOp)\n    [1, 2, 3]\n\n    adapted from https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "generate_bell",
    "full_id": "sympy.utilities.iterables.generate_bell",
    "type": "function",
    "description": "Return permutations of [0, 1, ..., n - 1] such that each permutation\n    differs from the last by the exchange of a single pair of neighbors.\n    The ``n!`` permutations are returned as an iterator. In order to obtain\n    the next permutation from a random starting permutation, use the\n    ``next_trotterjohnson`` method of the Permutation class (which generates\n    the same sequence in a different manner).\n\n    Examples\n    ========\n\n    >>> from itertools import permutations\n    >>> from sympy.utilities.iterables import generate_bell\n    >>> from sympy import zeros, Matrix\n\n    This is the sort of permutation used in the ringing of physical bells,\n    and does not produce permutations in lexicographical order. Rather, the\n    permutations differ from each other by exactly one inversion, and the\n    position at which the swapping occurs varies periodically in a simple\n    fashion. Consider the first few permutations of 4 elements generated\n    by ``permutations`` and ``generate_bell``:\n\n    >>> list(permutations(range(4)))[:5]\n    [(0, 1, 2, 3), (0, 1, 3, 2), (0, 2, 1, 3), (0, 2, 3, 1), (0, 3, 1, 2)]\n    >>> list(generate_bell(4))[:5]\n    [(0, 1, 2, 3), (0, 1, 3, 2), (0, 3, 1, 2), (3, 0, 1, 2), (3, 0, 2, 1)]\n\n    Notice how the 2nd and 3rd lexicographical permutations have 3 elements\n    out of place whereas each \"bell\" permutation always has only two\n    elements out of place relative to the previous permutation (and so the\n    signature (+/-1) of a permutation is opposite of the signature of the\n    previous permutation).\n\n    How the position of inversion varies across the elements can be seen\n    by tracing out where the largest number appears in the permutations:\n\n    >>> m = zeros(4, 24)\n    >>> for i, p in enumerate(generate_bell(4)):\n    ...     m[:, i] = Matrix([j - 3 for j in list(p)])  # make largest zero\n    >>> m.print_nonzero('X')\n    [XXX  XXXXXX  XXXXXX  XXX]\n    [XX XX XXXX XX XXXX XX XX]\n    [X XXXX XX XXXX XX XXXX X]\n    [ XXXXXX  XXXXXX  XXXXXX ]\n\n    See Also\n    ========\n\n    sympy.combinatorics.permutations.Permutation.next_trotterjohnson\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Method_ringing\n\n    .. [2] https://stackoverflow.com/questions/4856615/recursive-permutation/4857018\n\n    .. [3] https://web.archive.org/web/20160313023044/http://programminggeeks.com/bell-algorithm-for-permutation/\n\n    .. [4] https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm\n\n    .. [5] Generating involutions, derangements, and relatives by ECO\n           Vincent Vajnovszki, DMTCS vol 1 issue 12, 2010\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "generate_derangements",
    "full_id": "sympy.utilities.iterables.generate_derangements",
    "type": "function",
    "description": "\n    Return unique derangements of the elements of iterable ``s``.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import generate_derangements\n    >>> list(generate_derangements([0, 1, 2]))\n    [[1, 2, 0], [2, 0, 1]]\n    >>> list(generate_derangements([0, 1, 2, 2]))\n    [[2, 2, 0, 1], [2, 2, 1, 0]]\n    >>> list(generate_derangements([0, 1, 1]))\n    []\n\n    See Also\n    ========\n\n    sympy.functions.combinatorial.factorials.subfactorial\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "generate_involutions",
    "full_id": "sympy.utilities.iterables.generate_involutions",
    "type": "function",
    "description": "\n    Generates involutions.\n\n    An involution is a permutation that when multiplied\n    by itself equals the identity permutation. In this\n    implementation the involutions are generated using\n    Fixed Points.\n\n    Alternatively, an involution can be considered as\n    a permutation that does not contain any cycles with\n    a length that is greater than two.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import generate_involutions\n    >>> list(generate_involutions(3))\n    [(0, 1, 2), (0, 2, 1), (1, 0, 2), (2, 1, 0)]\n    >>> len(list(generate_involutions(4)))\n    10\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/PermutationInvolution.html\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "generate_oriented_forest",
    "full_id": "sympy.utilities.iterables.generate_oriented_forest",
    "type": "function",
    "description": "\n    This algorithm generates oriented forests.\n\n    An oriented graph is a directed graph having no symmetric pair of directed\n    edges. A forest is an acyclic graph, i.e., it has no cycles. A forest can\n    also be described as a disjoint union of trees, which are graphs in which\n    any two vertices are connected by exactly one simple path.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import generate_oriented_forest\n    >>> list(generate_oriented_forest(4))\n    [[0, 1, 2, 3], [0, 1, 2, 2], [0, 1, 2, 1], [0, 1, 2, 0],     [0, 1, 1, 1], [0, 1, 1, 0], [0, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0]]\n\n    References\n    ==========\n\n    .. [1] T. Beyer and S.M. Hedetniemi: constant time generation of\n           rooted trees, SIAM J. Computing Vol. 9, No. 4, November 1980\n\n    .. [2] https://stackoverflow.com/questions/1633833/oriented-forest-taocp-algorithm-in-python\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "group",
    "full_id": "sympy.utilities.iterables.group",
    "type": "function",
    "description": "\n    Splits a sequence into a list of lists of equal, adjacent elements.\n\n    Examples\n    ========\n\n    >>> from sympy import group\n\n    >>> group([1, 1, 1, 2, 2, 3])\n    [[1, 1, 1], [2, 2], [3]]\n    >>> group([1, 1, 1, 2, 2, 3], multiple=False)\n    [(1, 3), (2, 2), (3, 1)]\n    >>> group([1, 1, 3, 2, 2, 1], multiple=False)\n    [(1, 2), (3, 1), (2, 2), (1, 1)]\n\n    See Also\n    ========\n\n    multiset\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "has_dups",
    "full_id": "sympy.utilities.iterables.has_dups",
    "type": "function",
    "description": "Return True if there are any duplicate elements in ``seq``.\n\n    Examples\n    ========\n\n    >>> from sympy import has_dups, Dict, Set\n    >>> has_dups((1, 2, 1))\n    True\n    >>> has_dups(range(3))\n    False\n    >>> all(has_dups(c) is False for c in (set(), Set(), dict(), Dict()))\n    True\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "has_variety",
    "full_id": "sympy.utilities.iterables.has_variety",
    "type": "function",
    "description": "Return True if there are any different elements in ``seq``.\n\n    Examples\n    ========\n\n    >>> from sympy import has_variety\n\n    >>> has_variety((1, 2, 1))\n    True\n    >>> has_variety((1, 1, 1))\n    False\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "iproduct",
    "full_id": "sympy.utilities.iterables.iproduct",
    "type": "function",
    "description": "\n    Cartesian product of iterables.\n\n    Generator of the Cartesian product of iterables. This is analogous to\n    itertools.product except that it works with infinite iterables and will\n    yield any item from the infinite product eventually.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import iproduct\n    >>> sorted(iproduct([1,2], [3,4]))\n    [(1, 3), (1, 4), (2, 3), (2, 4)]\n\n    With an infinite iterator:\n\n    >>> from sympy import S\n    >>> (3,) in iproduct(S.Integers)\n    True\n    >>> (3, 4) in iproduct(S.Integers, S.Integers)\n    True\n\n    .. seealso::\n\n       `itertools.product\n       <https://docs.python.org/3/library/itertools.html#itertools.product>`_\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "is_palindromic",
    "full_id": "sympy.utilities.iterables.is_palindromic",
    "type": "function",
    "description": "\n    Return True if the sequence is the same from left to right as it\n    is from right to left in the whole sequence (default) or in the\n    Python slice ``s[i: j]``; else False.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import is_palindromic\n    >>> is_palindromic([1, 0, 1])\n    True\n    >>> is_palindromic('abcbb')\n    False\n    >>> is_palindromic('abcbb', 1)\n    False\n\n    Normal Python slicing is performed in place so there is no need to\n    create a slice of the sequence for testing:\n\n    >>> is_palindromic('abcbb', 1, -1)\n    True\n    >>> is_palindromic('abcbb', -4, -1)\n    True\n\n    See Also\n    ========\n\n    sympy.ntheory.digits.is_palindromic: tests integers\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "is_sequence",
    "full_id": "sympy.utilities.iterables.is_sequence",
    "type": "function",
    "description": "\n    Return a boolean indicating whether ``i`` is a sequence in the SymPy\n    sense. If anything that fails the test below should be included as\n    being a sequence for your application, set 'include' to that object's\n    type; multiple types should be passed as a tuple of types.\n\n    Note: although generators can generate a sequence, they often need special\n    handling to make sure their elements are captured before the generator is\n    exhausted, so these are not included by default in the definition of a\n    sequence.\n\n    See also: iterable\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import is_sequence\n    >>> from types import GeneratorType\n    >>> is_sequence([])\n    True\n    >>> is_sequence(set())\n    False\n    >>> is_sequence('abc')\n    False\n    >>> is_sequence('abc', include=str)\n    True\n    >>> generator = (c for c in 'abc')\n    >>> is_sequence(generator)\n    False\n    >>> is_sequence(generator, include=(str, GeneratorType))\n    True\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "iterable",
    "full_id": "sympy.utilities.iterables.iterable",
    "type": "function",
    "description": "\n    Return a boolean indicating whether ``i`` is SymPy iterable.\n    True also indicates that the iterator is finite, e.g. you can\n    call list(...) on the instance.\n\n    When SymPy is working with iterables, it is almost always assuming\n    that the iterable is not a string or a mapping, so those are excluded\n    by default. If you want a pure Python definition, make exclude=None. To\n    exclude multiple items, pass them as a tuple.\n\n    You can also set the _iterable attribute to True or False on your class,\n    which will override the checks here, including the exclude test.\n\n    As a rule of thumb, some SymPy functions use this to check if they should\n    recursively map over an object. If an object is technically iterable in\n    the Python sense but does not desire this behavior (e.g., because its\n    iteration is not finite, or because iteration might induce an unwanted\n    computation), it should disable it by setting the _iterable attribute to False.\n\n    See also: is_sequence\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import iterable\n    >>> from sympy import Tuple\n    >>> things = [[1], (1,), set([1]), Tuple(1), (j for j in [1, 2]), {1:2}, '1', 1]\n    >>> for i in things:\n    ...     print('%s %s' % (iterable(i), type(i)))\n    True <... 'list'>\n    True <... 'tuple'>\n    True <... 'set'>\n    True <class 'sympy.core.containers.Tuple'>\n    True <... 'generator'>\n    False <... 'dict'>\n    False <... 'str'>\n    False <... 'int'>\n\n    >>> iterable({}, exclude=None)\n    True\n    >>> iterable({}, exclude=str)\n    True\n    >>> iterable(\"no\", exclude=str)\n    False\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "kbins",
    "full_id": "sympy.utilities.iterables.kbins",
    "type": "function",
    "description": "\n    Return sequence ``l`` partitioned into ``k`` bins.\n\n    Examples\n    ========\n\n    The default is to give the items in the same order, but grouped\n    into k partitions without any reordering:\n\n    >>> from sympy.utilities.iterables import kbins\n    >>> for p in kbins(list(range(5)), 2):\n    ...     print(p)\n    ...\n    [[0], [1, 2, 3, 4]]\n    [[0, 1], [2, 3, 4]]\n    [[0, 1, 2], [3, 4]]\n    [[0, 1, 2, 3], [4]]\n\n    The ``ordered`` flag is either None (to give the simple partition\n    of the elements) or is a 2 digit integer indicating whether the order of\n    the bins and the order of the items in the bins matters. Given::\n\n        A = [[0], [1, 2]]\n        B = [[1, 2], [0]]\n        C = [[2, 1], [0]]\n        D = [[0], [2, 1]]\n\n    the following values for ``ordered`` have the shown meanings::\n\n        00 means A == B == C == D\n        01 means A == B\n        10 means A == D\n        11 means A == A\n\n    >>> for ordered_flag in [None, 0, 1, 10, 11]:\n    ...     print('ordered = %s' % ordered_flag)\n    ...     for p in kbins(list(range(3)), 2, ordered=ordered_flag):\n    ...         print('     %s' % p)\n    ...\n    ordered = None\n         [[0], [1, 2]]\n         [[0, 1], [2]]\n    ordered = 0\n         [[0, 1], [2]]\n         [[0, 2], [1]]\n         [[0], [1, 2]]\n    ordered = 1\n         [[0], [1, 2]]\n         [[0], [2, 1]]\n         [[1], [0, 2]]\n         [[1], [2, 0]]\n         [[2], [0, 1]]\n         [[2], [1, 0]]\n    ordered = 10\n         [[0, 1], [2]]\n         [[2], [0, 1]]\n         [[0, 2], [1]]\n         [[1], [0, 2]]\n         [[0], [1, 2]]\n         [[1, 2], [0]]\n    ordered = 11\n         [[0], [1, 2]]\n         [[0, 1], [2]]\n         [[0], [2, 1]]\n         [[0, 2], [1]]\n         [[1], [0, 2]]\n         [[1, 0], [2]]\n         [[1], [2, 0]]\n         [[1, 2], [0]]\n         [[2], [0, 1]]\n         [[2, 0], [1]]\n         [[2], [1, 0]]\n         [[2, 1], [0]]\n\n    See Also\n    ========\n\n    partitions, multiset_partitions\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "least_rotation",
    "full_id": "sympy.utilities.iterables.least_rotation",
    "type": "function",
    "description": "\n    Returns the number of steps of left rotation required to\n    obtain lexicographically minimal string/list/tuple, etc.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import least_rotation, rotate_left\n    >>> a = [3, 1, 5, 1, 2]\n    >>> least_rotation(a)\n    3\n    >>> rotate_left(a, _)\n    [1, 2, 3, 1, 5]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "minlex",
    "full_id": "sympy.utilities.iterables.minlex",
    "type": "function",
    "description": "\n    Return the rotation of the sequence in which the lexically smallest\n    elements appear first, e.g. `cba \\rightarrow acb`.\n\n    The sequence returned is a tuple, unless the input sequence is a string\n    in which case a string is returned.\n\n    If ``directed`` is False then the smaller of the sequence and the\n    reversed sequence is returned, e.g. `cba \\rightarrow abc`.\n\n    If ``key`` is not None then it is used to extract a comparison key from each element in iterable.\n\n    Examples\n    ========\n\n    >>> from sympy.combinatorics.polyhedron import minlex\n    >>> minlex((1, 2, 0))\n    (0, 1, 2)\n    >>> minlex((1, 0, 2))\n    (0, 2, 1)\n    >>> minlex((1, 0, 2), directed=False)\n    (0, 1, 2)\n\n    >>> minlex('11010011000', directed=True)\n    '00011010011'\n    >>> minlex('11010011000', directed=False)\n    '00011001011'\n\n    >>> minlex(('bb', 'aaa', 'c', 'a'))\n    ('a', 'bb', 'aaa', 'c')\n    >>> minlex(('bb', 'aaa', 'c', 'a'), key=len)\n    ('c', 'a', 'bb', 'aaa')\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "multiset",
    "full_id": "sympy.utilities.iterables.multiset",
    "type": "function",
    "description": "Return the hashable sequence in multiset form with values being the\n    multiplicity of the item in the sequence.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import multiset\n    >>> multiset('mississippi')\n    {'i': 4, 'm': 1, 'p': 2, 's': 4}\n\n    See Also\n    ========\n\n    group\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "multiset_combinations",
    "full_id": "sympy.utilities.iterables.multiset_combinations",
    "type": "function",
    "description": "\n    Return the unique combinations of size ``n`` from multiset ``m``.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import multiset_combinations\n    >>> from itertools import combinations\n    >>> [''.join(i) for i in  multiset_combinations('baby', 3)]\n    ['abb', 'aby', 'bby']\n\n    >>> def count(f, s): return len(list(f(s, 3)))\n\n    The number of combinations depends on the number of letters; the\n    number of unique combinations depends on how the letters are\n    repeated.\n\n    >>> s1 = 'abracadabra'\n    >>> s2 = 'banana tree'\n    >>> count(combinations, s1), count(multiset_combinations, s1)\n    (165, 23)\n    >>> count(combinations, s2), count(multiset_combinations, s2)\n    (165, 54)\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "multiset_derangements",
    "full_id": "sympy.utilities.iterables.multiset_derangements",
    "type": "function",
    "description": "Generate derangements of the elements of s *in place*.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import multiset_derangements, uniq\n\n    Because the derangements of multisets (not sets) are generated\n    in place, copies of the return value must be made if a collection\n    of derangements is desired or else all values will be the same:\n\n    >>> list(uniq([i for i in multiset_derangements('1233')]))\n    [[None, None, None, None]]\n    >>> [i.copy() for i in multiset_derangements('1233')]\n    [['3', '3', '1', '2'], ['3', '3', '2', '1']]\n    >>> [''.join(i) for i in multiset_derangements('1233')]\n    ['3312', '3321']\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "multiset_partitions",
    "full_id": "sympy.utilities.iterables.multiset_partitions",
    "type": "function",
    "description": "\n    Return unique partitions of the given multiset (in list form).\n    If ``m`` is None, all multisets will be returned, otherwise only\n    partitions with ``m`` parts will be returned.\n\n    If ``multiset`` is an integer, a range [0, 1, ..., multiset - 1]\n    will be supplied.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import multiset_partitions\n    >>> list(multiset_partitions([1, 2, 3, 4], 2))\n    [[[1, 2, 3], [4]], [[1, 2, 4], [3]], [[1, 2], [3, 4]],\n    [[1, 3, 4], [2]], [[1, 3], [2, 4]], [[1, 4], [2, 3]],\n    [[1], [2, 3, 4]]]\n    >>> list(multiset_partitions([1, 2, 3, 4], 1))\n    [[[1, 2, 3, 4]]]\n\n    Only unique partitions are returned and these will be returned in a\n    canonical order regardless of the order of the input:\n\n    >>> a = [1, 2, 2, 1]\n    >>> ans = list(multiset_partitions(a, 2))\n    >>> a.sort()\n    >>> list(multiset_partitions(a, 2)) == ans\n    True\n    >>> a = range(3, 1, -1)\n    >>> (list(multiset_partitions(a)) ==\n    ...  list(multiset_partitions(sorted(a))))\n    True\n\n    If m is omitted then all partitions will be returned:\n\n    >>> list(multiset_partitions([1, 1, 2]))\n    [[[1, 1, 2]], [[1, 1], [2]], [[1, 2], [1]], [[1], [1], [2]]]\n    >>> list(multiset_partitions([1]*3))\n    [[[1, 1, 1]], [[1], [1, 1]], [[1], [1], [1]]]\n\n    Counting\n    ========\n\n    The number of partitions of a set is given by the bell number:\n\n    >>> from sympy import bell\n    >>> len(list(multiset_partitions(5))) == bell(5) == 52\n    True\n\n    The number of partitions of length k from a set of size n is given by the\n    Stirling Number of the 2nd kind:\n\n    >>> from sympy.functions.combinatorial.numbers import stirling\n    >>> stirling(5, 2) == len(list(multiset_partitions(5, 2))) == 15\n    True\n\n    These comments on counting apply to *sets*, not multisets.\n\n    Notes\n    =====\n\n    When all the elements are the same in the multiset, the order\n    of the returned partitions is determined by the ``partitions``\n    routine. If one is counting partitions then it is better to use\n    the ``nT`` function.\n\n    See Also\n    ========\n\n    partitions\n    sympy.combinatorics.partitions.Partition\n    sympy.combinatorics.partitions.IntegerPartition\n    sympy.functions.combinatorial.numbers.nT\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "multiset_permutations",
    "full_id": "sympy.utilities.iterables.multiset_permutations",
    "type": "function",
    "description": "\n    Return the unique permutations of multiset ``m``.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import multiset_permutations\n    >>> from sympy import factorial\n    >>> [''.join(i) for i in multiset_permutations('aab')]\n    ['aab', 'aba', 'baa']\n    >>> factorial(len('banana'))\n    720\n    >>> len(list(multiset_permutations('banana')))\n    60\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "necklaces",
    "full_id": "sympy.utilities.iterables.necklaces",
    "type": "function",
    "description": "\n    A routine to generate necklaces that may (free=True) or may not\n    (free=False) be turned over to be viewed. The \"necklaces\" returned\n    are comprised of ``n`` integers (beads) with ``k`` different\n    values (colors). Only unique necklaces are returned.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import necklaces, bracelets\n    >>> def show(s, i):\n    ...     return ''.join(s[j] for j in i)\n\n    The \"unrestricted necklace\" is sometimes also referred to as a\n    \"bracelet\" (an object that can be turned over, a sequence that can\n    be reversed) and the term \"necklace\" is used to imply a sequence\n    that cannot be reversed. So ACB == ABC for a bracelet (rotate and\n    reverse) while the two are different for a necklace since rotation\n    alone cannot make the two sequences the same.\n\n    (mnemonic: Bracelets can be viewed Backwards, but Not Necklaces.)\n\n    >>> B = [show('ABC', i) for i in bracelets(3, 3)]\n    >>> N = [show('ABC', i) for i in necklaces(3, 3)]\n    >>> set(N) - set(B)\n    {'ACB'}\n\n    >>> list(necklaces(4, 2))\n    [(0, 0, 0, 0), (0, 0, 0, 1), (0, 0, 1, 1),\n     (0, 1, 0, 1), (0, 1, 1, 1), (1, 1, 1, 1)]\n\n    >>> [show('.o', i) for i in bracelets(4, 2)]\n    ['....', '...o', '..oo', '.o.o', '.ooo', 'oooo']\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/Necklace.html\n\n    .. [2] Frank Ruskey, Carla Savage, and Terry Min Yih Wang,\n        Generating necklaces, Journal of Algorithms 13 (1992), 414-430;\n        https://doi.org/10.1016/0196-6774(92)90047-G\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "numbered_symbols",
    "full_id": "sympy.utilities.iterables.numbered_symbols",
    "type": "function",
    "description": "\n    Generate an infinite stream of Symbols consisting of a prefix and\n    increasing subscripts provided that they do not occur in ``exclude``.\n\n    Parameters\n    ==========\n\n    prefix : str, optional\n        The prefix to use. By default, this function will generate symbols of\n        the form \"x0\", \"x1\", etc.\n\n    cls : class, optional\n        The class to use. By default, it uses ``Symbol``, but you can also use ``Wild``\n        or ``Dummy``.\n\n    start : int, optional\n        The start number.  By default, it is 0.\n\n    exclude : list, tuple, set of cls, optional\n        Symbols to be excluded.\n\n    *args, **kwargs\n        Additional positional and keyword arguments are passed to the *cls* class.\n\n    Returns\n    =======\n\n    sym : Symbol\n        The subscripted symbols.\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "ordered_partitions",
    "full_id": "sympy.utilities.iterables.ordered_partitions",
    "type": "function",
    "description": "Generates ordered partitions of integer *n*.\n\n    Parameters\n    ==========\n    n : int\n    m : int, optional\n        The default value gives partitions of all sizes else only\n        those with size m. In addition, if *m* is not None then\n        partitions are generated *in place* (see examples).\n    sort : bool, default: True\n        Controls whether partitions are\n        returned in sorted order when *m* is not None; when False,\n        the partitions are returned as fast as possible with elements\n        sorted, but when m|n the partitions will not be in\n        ascending lexicographical order.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import ordered_partitions\n\n    All partitions of 5 in ascending lexicographical:\n\n    >>> for p in ordered_partitions(5):\n    ...     print(p)\n    [1, 1, 1, 1, 1]\n    [1, 1, 1, 2]\n    [1, 1, 3]\n    [1, 2, 2]\n    [1, 4]\n    [2, 3]\n    [5]\n\n    Only partitions of 5 with two parts:\n\n    >>> for p in ordered_partitions(5, 2):\n    ...     print(p)\n    [1, 4]\n    [2, 3]\n\n    When ``m`` is given, a given list objects will be used more than\n    once for speed reasons so you will not see the correct partitions\n    unless you make a copy of each as it is generated:\n\n    >>> [p for p in ordered_partitions(7, 3)]\n    [[1, 1, 1], [1, 1, 1], [1, 1, 1], [2, 2, 2]]\n    >>> [list(p) for p in ordered_partitions(7, 3)]\n    [[1, 1, 5], [1, 2, 4], [1, 3, 3], [2, 2, 3]]\n\n    When ``n`` is a multiple of ``m``, the elements are still sorted\n    but the partitions themselves will be *unordered* if sort is False;\n    the default is to return them in ascending lexicographical order.\n\n    >>> for p in ordered_partitions(6, 2):\n    ...     print(p)\n    [1, 5]\n    [2, 4]\n    [3, 3]\n\n    But if speed is more important than ordering, sort can be set to\n    False:\n\n    >>> for p in ordered_partitions(6, 2, sort=False):\n    ...     print(p)\n    [1, 5]\n    [3, 3]\n    [2, 4]\n\n    References\n    ==========\n\n    .. [1] Generating Integer Partitions, [online],\n        Available: https://jeromekelleher.net/generating-integer-partitions.html\n    .. [2] Jerome Kelleher and Barry O'Sullivan, \"Generating All\n        Partitions: A Comparison Of Two Encodings\", [online],\n        Available: https://arxiv.org/pdf/0909.2331v2.pdf\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "partitions",
    "full_id": "sympy.utilities.iterables.partitions",
    "type": "function",
    "description": "Generate all partitions of positive integer, n.\n\n    Each partition is represented as a dictionary, mapping an integer\n    to the number of copies of that integer in the partition.  For example,\n    the first partition of 4 returned is {4: 1}, \"4: one of them\".\n\n    Parameters\n    ==========\n    n : int\n    m : int, optional\n        limits number of parts in partition (mnemonic: m, maximum parts)\n    k : int, optional\n        limits the numbers that are kept in the partition (mnemonic: k, keys)\n    size : bool, default: False\n        If ``True``, (M, P) is returned where M is the sum of the\n        multiplicities and P is the generated partition.\n        If ``False``, only the generated partition is returned.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import partitions\n\n    The numbers appearing in the partition (the key of the returned dict)\n    are limited with k:\n\n    >>> for p in partitions(6, k=2):  # doctest: +SKIP\n    ...     print(p)\n    {2: 3}\n    {1: 2, 2: 2}\n    {1: 4, 2: 1}\n    {1: 6}\n\n    The maximum number of parts in the partition (the sum of the values in\n    the returned dict) are limited with m (default value, None, gives\n    partitions from 1 through n):\n\n    >>> for p in partitions(6, m=2):  # doctest: +SKIP\n    ...     print(p)\n    ...\n    {6: 1}\n    {1: 1, 5: 1}\n    {2: 1, 4: 1}\n    {3: 2}\n\n    References\n    ==========\n\n    .. [1] modified from Tim Peter's version to allow for k and m values:\n           https://code.activestate.com/recipes/218332-generator-for-integer-partitions/\n\n    See Also\n    ========\n\n    sympy.combinatorics.partitions.Partition\n    sympy.combinatorics.partitions.IntegerPartition\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "permute_signs",
    "full_id": "sympy.utilities.iterables.permute_signs",
    "type": "function",
    "description": "Return iterator in which the signs of non-zero elements\n    of t are permuted.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import permute_signs\n    >>> list(permute_signs((0, 1, 2)))\n    [(0, 1, 2), (0, -1, 2), (0, 1, -2), (0, -1, -2)]\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "postfixes",
    "full_id": "sympy.utilities.iterables.postfixes",
    "type": "function",
    "description": "\n    Generate all postfixes of a sequence.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import postfixes\n\n    >>> list(postfixes([1,2,3,4]))\n    [[4], [3, 4], [2, 3, 4], [1, 2, 3, 4]]\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "prefixes",
    "full_id": "sympy.utilities.iterables.prefixes",
    "type": "function",
    "description": "\n    Generate all prefixes of a sequence.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import prefixes\n\n    >>> list(prefixes([1,2,3,4]))\n    [[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "random_derangement",
    "full_id": "sympy.utilities.iterables.random_derangement",
    "type": "function",
    "description": "Return a list of elements in which none are in the same positions\n    as they were originally. If an element fills more than half of the positions\n    then an error will be raised since no derangement is possible. To obtain\n    a derangement of as many items as possible--with some of the most numerous\n    remaining in their original positions--pass `strict=False`. To produce a\n    pseudorandom derangment, pass a pseudorandom selector like `choice` (see\n    below).\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import random_derangement\n    >>> t = 'SymPy: a CAS in pure Python'\n    >>> d = random_derangement(t)\n    >>> all(i != j for i, j in zip(d, t))\n    True\n\n    A predictable result can be obtained by using a pseudorandom\n    generator for the choice:\n\n    >>> from sympy.core.random import seed, choice as c\n    >>> seed(1)\n    >>> d = [''.join(random_derangement(t, c)) for i in range(5)]\n    >>> assert len(set(d)) != 1  # we got different values\n\n    By reseeding, the same sequence can be obtained:\n\n    >>> seed(1)\n    >>> d2 = [''.join(random_derangement(t, c)) for i in range(5)]\n    >>> assert d == d2\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "reshape",
    "full_id": "sympy.utilities.iterables.reshape",
    "type": "function",
    "description": "Reshape the sequence according to the template in ``how``.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities import reshape\n    >>> seq = list(range(1, 9))\n\n    >>> reshape(seq, [4]) # lists of 4\n    [[1, 2, 3, 4], [5, 6, 7, 8]]\n\n    >>> reshape(seq, (4,)) # tuples of 4\n    [(1, 2, 3, 4), (5, 6, 7, 8)]\n\n    >>> reshape(seq, (2, 2)) # tuples of 4\n    [(1, 2, 3, 4), (5, 6, 7, 8)]\n\n    >>> reshape(seq, (2, [2])) # (i, i, [i, i])\n    [(1, 2, [3, 4]), (5, 6, [7, 8])]\n\n    >>> reshape(seq, ((2,), [2])) # etc....\n    [((1, 2), [3, 4]), ((5, 6), [7, 8])]\n\n    >>> reshape(seq, (1, [2], 1))\n    [(1, [2, 3], 4), (5, [6, 7], 8)]\n\n    >>> reshape(tuple(seq), ([[1], 1, (2,)],))\n    (([[1], 2, (3, 4)],), ([[5], 6, (7, 8)],))\n\n    >>> reshape(tuple(seq), ([1], 1, (2,)))\n    (([1], 2, (3, 4)), ([5], 6, (7, 8)))\n\n    >>> reshape(list(range(12)), [2, [3], {2}, (1, (3,), 1)])\n    [[0, 1, [2, 3, 4], {5, 6}, (7, (8, 9, 10), 11)]]\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "rotate_left",
    "full_id": "sympy.utilities.iterables.rotate_left",
    "type": "function",
    "description": "\n    Left rotates a list x by the number of steps specified\n    in y.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import rotate_left\n    >>> a = [0, 1, 2]\n    >>> rotate_left(a, 1)\n    [1, 2, 0]\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "rotate_right",
    "full_id": "sympy.utilities.iterables.rotate_right",
    "type": "function",
    "description": "\n    Right rotates a list x by the number of steps specified\n    in y.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import rotate_right\n    >>> a = [0, 1, 2]\n    >>> rotate_right(a, 1)\n    [2, 0, 1]\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "rotations",
    "full_id": "sympy.utilities.iterables.rotations",
    "type": "function",
    "description": "Return a generator giving the items in s as list where\n    each subsequent list has the items rotated to the left (default)\n    or right (``dir=-1``) relative to the previous list.\n\n    Examples\n    ========\n\n    >>> from sympy import rotations\n    >>> list(rotations([1,2,3]))\n    [[1, 2, 3], [2, 3, 1], [3, 1, 2]]\n    >>> list(rotations([1,2,3], -1))\n    [[1, 2, 3], [3, 1, 2], [2, 3, 1]]\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "roundrobin",
    "full_id": "sympy.utilities.iterables.roundrobin",
    "type": "function",
    "description": "roundrobin recipe taken from itertools documentation:\n    https://docs.python.org/3/library/itertools.html#itertools-recipes\n\n    roundrobin('ABC', 'D', 'EF') --> A D E B F C\n\n    Recipe credited to George Sakkis\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "runs",
    "full_id": "sympy.utilities.iterables.runs",
    "type": "function",
    "description": "Group the sequence into lists in which successive elements\n    all compare the same with the comparison operator, ``op``:\n    op(seq[i + 1], seq[i]) is True from all elements in a run.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import runs\n    >>> from operator import ge\n    >>> runs([0, 1, 2, 2, 1, 4, 3, 2, 2])\n    [[0, 1, 2], [2], [1, 4], [3], [2], [2]]\n    >>> runs([0, 1, 2, 2, 1, 4, 3, 2, 2], op=ge)\n    [[0, 1, 2, 2], [1, 4], [3], [2, 2]]\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "sequence_partitions",
    "full_id": "sympy.utilities.iterables.sequence_partitions",
    "type": "function",
    "description": "Returns the partition of sequence $l$ into $n$ bins\n\n    Explanation\n    ===========\n\n    Given the sequence $l_1 \\cdots l_m \\in V^+$ where\n    $V^+$ is the Kleene plus of $V$\n\n    The set of $n$ partitions of $l$ is defined as:\n\n    .. math::\n        \\{(s_1, \\cdots, s_n) | s_1 \\in V^+, \\cdots, s_n \\in V^+,\n        s_1 \\cdots s_n = l_1 \\cdots l_m\\}\n\n    Parameters\n    ==========\n\n    l : Sequence[T]\n        A nonempty sequence of any Python objects\n\n    n : int\n        A positive integer\n\n    Yields\n    ======\n\n    out : list[Sequence[T]]\n        A list of sequences with concatenation equals $l$.\n        This should conform with the type of $l$.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import sequence_partitions\n    >>> for out in sequence_partitions([1, 2, 3, 4], 2):\n    ...     print(out)\n    [[1], [2, 3, 4]]\n    [[1, 2], [3, 4]]\n    [[1, 2, 3], [4]]\n\n    Notes\n    =====\n\n    This is modified version of EnricoGiampieri's partition generator\n    from https://stackoverflow.com/questions/13131491/partition-n-items-into-k-bins-in-python-lazily\n\n    See Also\n    ========\n\n    sequence_partitions_empty\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "sequence_partitions_empty",
    "full_id": "sympy.utilities.iterables.sequence_partitions_empty",
    "type": "function",
    "description": "Returns the partition of sequence $l$ into $n$ bins with\n    empty sequence\n\n    Explanation\n    ===========\n\n    Given the sequence $l_1 \\cdots l_m \\in V^*$ where\n    $V^*$ is the Kleene star of $V$\n\n    The set of $n$ partitions of $l$ is defined as:\n\n    .. math::\n        \\{(s_1, \\cdots, s_n) | s_1 \\in V^*, \\cdots, s_n \\in V^*,\n        s_1 \\cdots s_n = l_1 \\cdots l_m\\}\n\n    There are more combinations than :func:`sequence_partitions` because\n    empty sequence can fill everywhere, so we try to provide different\n    utility for this.\n\n    Parameters\n    ==========\n\n    l : Sequence[T]\n        A sequence of any Python objects (can be possibly empty)\n\n    n : int\n        A positive integer\n\n    Yields\n    ======\n\n    out : list[Sequence[T]]\n        A list of sequences with concatenation equals $l$.\n        This should conform with the type of $l$.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import sequence_partitions_empty\n    >>> for out in sequence_partitions_empty([1, 2, 3, 4], 2):\n    ...     print(out)\n    [[], [1, 2, 3, 4]]\n    [[1], [2, 3, 4]]\n    [[1, 2], [3, 4]]\n    [[1, 2, 3], [4]]\n    [[1, 2, 3, 4], []]\n\n    See Also\n    ========\n\n    sequence_partitions\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "sift",
    "full_id": "sympy.utilities.iterables.sift",
    "type": "function",
    "description": "\n    Sift the sequence, ``seq`` according to ``keyfunc``.\n\n    Returns\n    =======\n\n    When ``binary`` is ``False`` (default), the output is a dictionary\n    where elements of ``seq`` are stored in a list keyed to the value\n    of keyfunc for that element. If ``binary`` is True then a tuple\n    with lists ``T`` and ``F`` are returned where ``T`` is a list\n    containing elements of seq for which ``keyfunc`` was ``True`` and\n    ``F`` containing those elements for which ``keyfunc`` was ``False``;\n    a ValueError is raised if the ``keyfunc`` is not binary.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities import sift\n    >>> from sympy.abc import x, y\n    >>> from sympy import sqrt, exp, pi, Tuple\n\n    >>> sift(range(5), lambda x: x % 2)\n    {0: [0, 2, 4], 1: [1, 3]}\n\n    sift() returns a defaultdict() object, so any key that has no matches will\n    give [].\n\n    >>> sift([x], lambda x: x.is_commutative)\n    {True: [x]}\n    >>> _[False]\n    []\n\n    Sometimes you will not know how many keys you will get:\n\n    >>> sift([sqrt(x), exp(x), (y**x)**2],\n    ...      lambda x: x.as_base_exp()[0])\n    {E: [exp(x)], x: [sqrt(x)], y: [y**(2*x)]}\n\n    Sometimes you expect the results to be binary; the\n    results can be unpacked by setting ``binary`` to True:\n\n    >>> sift(range(4), lambda x: x % 2, binary=True)\n    ([1, 3], [0, 2])\n    >>> sift(Tuple(1, pi), lambda x: x.is_rational, binary=True)\n    ([1], [pi])\n\n    A ValueError is raised if the predicate was not actually binary\n    (which is a good test for the logic where sifting is used and\n    binary results were expected):\n\n    >>> unknown = exp(1) - pi  # the rationality of this is unknown\n    >>> args = Tuple(1, pi, unknown)\n    >>> sift(args, lambda x: x.is_rational, binary=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: keyfunc gave non-binary output\n\n    The non-binary sifting shows that there were 3 keys generated:\n\n    >>> set(sift(args, lambda x: x.is_rational).keys())\n    {None, False, True}\n\n    If you need to sort the sifted items it might be better to use\n    ``ordered`` which can economically apply multiple sort keys\n    to a sequence while sorting.\n\n    See Also\n    ========\n\n    ordered\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "signed_permutations",
    "full_id": "sympy.utilities.iterables.signed_permutations",
    "type": "function",
    "description": "Return iterator in which the signs of non-zero elements\n    of t and the order of the elements are permuted and all\n    returned values are unique.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import signed_permutations\n    >>> list(signed_permutations((0, 1, 2)))\n    [(0, 1, 2), (0, -1, 2), (0, 1, -2), (0, -1, -2), (0, 2, 1),\n    (0, -2, 1), (0, 2, -1), (0, -2, -1), (1, 0, 2), (-1, 0, 2),\n    (1, 0, -2), (-1, 0, -2), (1, 2, 0), (-1, 2, 0), (1, -2, 0),\n    (-1, -2, 0), (2, 0, 1), (-2, 0, 1), (2, 0, -1), (-2, 0, -1),\n    (2, 1, 0), (-2, 1, 0), (2, -1, 0), (-2, -1, 0)]\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "strongly_connected_components",
    "full_id": "sympy.utilities.iterables.strongly_connected_components",
    "type": "function",
    "description": "\n    Strongly connected components of a directed graph in reverse topological\n    order.\n\n\n    Parameters\n    ==========\n\n    G : tuple[list, list[tuple[T, T]]\n        A tuple consisting of a list of vertices and a list of edges of\n        a graph whose strongly connected components are to be found.\n\n\n    Examples\n    ========\n\n    Consider a directed graph (in dot notation)::\n\n        digraph {\n            A -> B\n            A -> C\n            B -> C\n            C -> B\n            B -> D\n        }\n\n    .. graphviz::\n\n        digraph {\n            A -> B\n            A -> C\n            B -> C\n            C -> B\n            B -> D\n        }\n\n    where vertices are the letters A, B, C and D. This graph can be encoded\n    using Python's elementary data structures as follows::\n\n        >>> V = ['A', 'B', 'C', 'D']\n        >>> E = [('A', 'B'), ('A', 'C'), ('B', 'C'), ('C', 'B'), ('B', 'D')]\n\n    The strongly connected components of this graph can be computed as\n\n        >>> from sympy.utilities.iterables import strongly_connected_components\n\n        >>> strongly_connected_components((V, E))\n        [['D'], ['B', 'C'], ['A']]\n\n    This also gives the components in reverse topological order.\n\n    Since the subgraph containing B and C has a cycle they must be together in\n    a strongly connected component. A and D are connected to the rest of the\n    graph but not in a cyclic manner so they appear as their own strongly\n    connected components.\n\n\n    Notes\n    =====\n\n    The vertices of the graph must be hashable for the data structures used.\n    If the vertices are unhashable replace them with integer indices.\n\n    This function uses Tarjan's algorithm to compute the strongly connected\n    components in `O(|V|+|E|)` (linear) time.\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Strongly_connected_component\n    .. [2] https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\n\n    See Also\n    ========\n\n    sympy.utilities.iterables.connected_components\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "subsets",
    "full_id": "sympy.utilities.iterables.subsets",
    "type": "function",
    "description": "Generates all `k`-subsets (combinations) from an `n`-element set, ``seq``.\n\n    A `k`-subset of an `n`-element set is any subset of length exactly `k`. The\n    number of `k`-subsets of an `n`-element set is given by ``binomial(n, k)``,\n    whereas there are `2^n` subsets all together. If `k` is ``None`` then all\n    `2^n` subsets will be returned from shortest to longest.\n\n    Examples\n    ========\n\n    >>> from sympy import subsets\n\n    ``subsets(seq, k)`` will return the\n    `\\frac{n!}{k!(n - k)!}` `k`-subsets (combinations)\n    without repetition, i.e. once an item has been removed, it can no\n    longer be \"taken\":\n\n        >>> list(subsets([1, 2], 2))\n        [(1, 2)]\n        >>> list(subsets([1, 2]))\n        [(), (1,), (2,), (1, 2)]\n        >>> list(subsets([1, 2, 3], 2))\n        [(1, 2), (1, 3), (2, 3)]\n\n\n    ``subsets(seq, k, repetition=True)`` will return the\n    `\\frac{(n - 1 + k)!}{k!(n - 1)!}`\n    combinations *with* repetition:\n\n        >>> list(subsets([1, 2], 2, repetition=True))\n        [(1, 1), (1, 2), (2, 2)]\n\n    If you ask for more items than are in the set you get the empty set unless\n    you allow repetitions:\n\n        >>> list(subsets([0, 1], 3, repetition=False))\n        []\n        >>> list(subsets([0, 1], 3, repetition=True))\n        [(0, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 1)]\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "take",
    "full_id": "sympy.utilities.iterables.take",
    "type": "function",
    "description": "Return ``n`` items from ``iter`` iterator. ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "topological_sort",
    "full_id": "sympy.utilities.iterables.topological_sort",
    "type": "function",
    "description": "\n    Topological sort of graph's vertices.\n\n    Parameters\n    ==========\n\n    graph : tuple[list, list[tuple[T, T]]\n        A tuple consisting of a list of vertices and a list of edges of\n        a graph to be sorted topologically.\n\n    key : callable[T] (optional)\n        Ordering key for vertices on the same level. By default the natural\n        (e.g. lexicographic) ordering is used (in this case the base type\n        must implement ordering relations).\n\n    Examples\n    ========\n\n    Consider a graph::\n\n        +---+     +---+     +---+\n        | 7 |\\    | 5 |     | 3 |\n        +---+ \\   +---+     +---+\n          |   _\\___/ ____   _/ |\n          |  /  \\___/    \\ /   |\n          V  V           V V   |\n         +----+         +---+  |\n         | 11 |         | 8 |  |\n         +----+         +---+  |\n          | | \\____   ___/ _   |\n          | \\      \\ /    / \\  |\n          V  \\     V V   /  V  V\n        +---+ \\   +---+ |  +----+\n        | 2 |  |  | 9 | |  | 10 |\n        +---+  |  +---+ |  +----+\n               \\________/\n\n    where vertices are integers. This graph can be encoded using\n    elementary Python's data structures as follows::\n\n        >>> V = [2, 3, 5, 7, 8, 9, 10, 11]\n        >>> E = [(7, 11), (7, 8), (5, 11), (3, 8), (3, 10),\n        ...      (11, 2), (11, 9), (11, 10), (8, 9)]\n\n    To compute a topological sort for graph ``(V, E)`` issue::\n\n        >>> from sympy.utilities.iterables import topological_sort\n\n        >>> topological_sort((V, E))\n        [3, 5, 7, 8, 11, 2, 9, 10]\n\n    If specific tie breaking approach is needed, use ``key`` parameter::\n\n        >>> topological_sort((V, E), key=lambda v: -v)\n        [7, 5, 11, 3, 10, 8, 9, 2]\n\n    Only acyclic graphs can be sorted. If the input graph has a cycle,\n    then ``ValueError`` will be raised::\n\n        >>> topological_sort((V, E + [(10, 7)]))\n        Traceback (most recent call last):\n        ...\n        ValueError: cycle detected\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Topological_sorting\n\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "unflatten",
    "full_id": "sympy.utilities.iterables.unflatten",
    "type": "function",
    "description": "Group ``iter`` into tuples of length ``n``. Raise an error if\n    the length of ``iter`` is not a multiple of ``n``.\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "uniq",
    "full_id": "sympy.utilities.iterables.uniq",
    "type": "function",
    "description": "\n    Yield unique elements from ``seq`` as an iterator. The second\n    parameter ``result``  is used internally; it is not necessary\n    to pass anything for this.\n\n    Note: changing the sequence during iteration will raise a\n    RuntimeError if the size of the sequence is known; if you pass\n    an iterator and advance the iterator you will change the\n    output of this routine but there will be no warning.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.iterables import uniq\n    >>> dat = [1, 4, 1, 5, 4, 2, 1, 2]\n    >>> type(uniq(dat)) in (list, tuple)\n    False\n\n    >>> list(uniq(dat))\n    [1, 4, 5, 2]\n    >>> list(uniq(x for x in dat))\n    [1, 4, 5, 2]\n    >>> list(uniq([[1], [2, 1], [1]]))\n    [[1], [2, 1]]\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "variations",
    "full_id": "sympy.utilities.iterables.variations",
    "type": "function",
    "description": "Returns an iterator over the n-sized variations of ``seq`` (size N).\n    ``repetition`` controls whether items in ``seq`` can appear more than once;\n\n    Examples\n    ========\n\n    ``variations(seq, n)`` will return `\\frac{N!}{(N - n)!}` permutations without\n    repetition of ``seq``'s elements:\n\n        >>> from sympy import variations\n        >>> list(variations([1, 2], 2))\n        [(1, 2), (2, 1)]\n\n    ``variations(seq, n, True)`` will return the `N^n` permutations obtained\n    by allowing repetition of elements:\n\n        >>> list(variations([1, 2], 2, repetition=True))\n        [(1, 1), (1, 2), (2, 1), (2, 2)]\n\n    If you ask for more items than are in the set you get the empty set unless\n    you allow repetitions:\n\n        >>> list(variations([0, 1], 3, repetition=False))\n        []\n        >>> list(variations([0, 1], 3, repetition=True))[:4]\n        [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1)]\n\n    .. seealso::\n\n       `itertools.permutations\n       <https://docs.python.org/3/library/itertools.html#itertools.permutations>`_,\n       `itertools.product\n       <https://docs.python.org/3/library/itertools.html#itertools.product>`_\n    ",
    "section": "Iterables",
    "url": "https://docs.sympy.org/latest/modules/utilities/iterables.html"
  },
  {
    "name": "implemented_function",
    "full_id": "sympy.utilities.lambdify.implemented_function",
    "type": "function",
    "description": " Add numerical ``implementation`` to function ``symfunc``.\n\n    ``symfunc`` can be an ``UndefinedFunction`` instance, or a name string.\n    In the latter case we create an ``UndefinedFunction`` instance with that\n    name.\n\n    Be aware that this is a quick workaround, not a general method to create\n    special symbolic functions. If you want to create a symbolic function to be\n    used by all the machinery of SymPy you should subclass the ``Function``\n    class.\n\n    Parameters\n    ----------\n    symfunc : ``str`` or ``UndefinedFunction`` instance\n       If ``str``, then create new ``UndefinedFunction`` with this as\n       name.  If ``symfunc`` is an Undefined function, create a new function\n       with the same name and the implemented function attached.\n    implementation : callable\n       numerical implementation to be called by ``evalf()`` or ``lambdify``\n\n    Returns\n    -------\n    afunc : sympy.FunctionClass instance\n       function with attached implementation\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x\n    >>> from sympy.utilities.lambdify import implemented_function\n    >>> from sympy import lambdify\n    >>> f = implemented_function('f', lambda x: x+1)\n    >>> lam_f = lambdify(x, f(x))\n    >>> lam_f(4)\n    5\n    ",
    "section": "Lambdify",
    "url": "https://docs.sympy.org/latest/modules/utilities/lambdify.html"
  },
  {
    "name": "lambdastr",
    "full_id": "sympy.utilities.lambdify.lambdastr",
    "type": "function",
    "description": "\n    Returns a string that can be evaluated to a lambda function.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> from sympy.utilities.lambdify import lambdastr\n    >>> lambdastr(x, x**2)\n    'lambda x: (x**2)'\n    >>> lambdastr((x,y,z), [z,y,x])\n    'lambda x,y,z: ([z, y, x])'\n\n    Although tuples may not appear as arguments to lambda in Python 3,\n    lambdastr will create a lambda function that will unpack the original\n    arguments so that nested arguments can be handled:\n\n    >>> lambdastr((x, (y, z)), x + y)\n    'lambda _0,_1: (lambda x,y,z: (x + y))(_0,_1[0],_1[1])'\n    ",
    "section": "Lambdify",
    "url": "https://docs.sympy.org/latest/modules/utilities/lambdify.html"
  },
  {
    "name": "lambdify",
    "full_id": "sympy.utilities.lambdify.lambdify",
    "type": "function",
    "description": "Convert a SymPy expression into a function that allows for fast\n    numeric evaluation.\n\n    .. warning::\n       This function uses ``exec``, and thus should not be used on\n       unsanitized input.\n\n    .. deprecated:: 1.7\n       Passing a set for the *args* parameter is deprecated as sets are\n       unordered. Use an ordered iterable such as a list or tuple.\n\n    Explanation\n    ===========\n\n    For example, to convert the SymPy expression ``sin(x) + cos(x)`` to an\n    equivalent NumPy function that numerically evaluates it:\n\n    >>> from sympy import sin, cos, symbols, lambdify\n    >>> import numpy as np\n    >>> x = symbols('x')\n    >>> expr = sin(x) + cos(x)\n    >>> expr\n    sin(x) + cos(x)\n    >>> f = lambdify(x, expr, 'numpy')\n    >>> a = np.array([1, 2])\n    >>> f(a)\n    [1.38177329 0.49315059]\n\n    The primary purpose of this function is to provide a bridge from SymPy\n    expressions to numerical libraries such as NumPy, SciPy, NumExpr, mpmath,\n    and tensorflow. In general, SymPy functions do not work with objects from\n    other libraries, such as NumPy arrays, and functions from numeric\n    libraries like NumPy or mpmath do not work on SymPy expressions.\n    ``lambdify`` bridges the two by converting a SymPy expression to an\n    equivalent numeric function.\n\n    The basic workflow with ``lambdify`` is to first create a SymPy expression\n    representing whatever mathematical function you wish to evaluate. This\n    should be done using only SymPy functions and expressions. Then, use\n    ``lambdify`` to convert this to an equivalent function for numerical\n    evaluation. For instance, above we created ``expr`` using the SymPy symbol\n    ``x`` and SymPy functions ``sin`` and ``cos``, then converted it to an\n    equivalent NumPy function ``f``, and called it on a NumPy array ``a``.\n\n    Parameters\n    ==========\n\n    args : List[Symbol]\n        A variable or a list of variables whose nesting represents the\n        nesting of the arguments that will be passed to the function.\n\n        Variables can be symbols, undefined functions, or matrix symbols.\n\n        >>> from sympy import Eq\n        >>> from sympy.abc import x, y, z\n\n        The list of variables should match the structure of how the\n        arguments will be passed to the function. Simply enclose the\n        parameters as they will be passed in a list.\n\n        To call a function like ``f(x)`` then ``[x]``\n        should be the first argument to ``lambdify``; for this\n        case a single ``x`` can also be used:\n\n        >>> f = lambdify(x, x + 1)\n        >>> f(1)\n        2\n        >>> f = lambdify([x], x + 1)\n        >>> f(1)\n        2\n\n        To call a function like ``f(x, y)`` then ``[x, y]`` will\n        be the first argument of the ``lambdify``:\n\n        >>> f = lambdify([x, y], x + y)\n        >>> f(1, 1)\n        2\n\n        To call a function with a single 3-element tuple like\n        ``f((x, y, z))`` then ``[(x, y, z)]`` will be the first\n        argument of the ``lambdify``:\n\n        >>> f = lambdify([(x, y, z)], Eq(z**2, x**2 + y**2))\n        >>> f((3, 4, 5))\n        True\n\n        If two args will be passed and the first is a scalar but\n        the second is a tuple with two arguments then the items\n        in the list should match that structure:\n\n        >>> f = lambdify([x, (y, z)], x + y + z)\n        >>> f(1, (2, 3))\n        6\n\n    expr : Expr\n        An expression, list of expressions, or matrix to be evaluated.\n\n        Lists may be nested.\n        If the expression is a list, the output will also be a list.\n\n        >>> f = lambdify(x, [x, [x + 1, x + 2]])\n        >>> f(1)\n        [1, [2, 3]]\n\n        If it is a matrix, an array will be returned (for the NumPy module).\n\n        >>> from sympy import Matrix\n        >>> f = lambdify(x, Matrix([x, x + 1]))\n        >>> f(1)\n        [[1]\n        [2]]\n\n        Note that the argument order here (variables then expression) is used\n        to emulate the Python ``lambda`` keyword. ``lambdify(x, expr)`` works\n        (roughly) like ``lambda x: expr``\n        (see :ref:`lambdify-how-it-works` below).\n\n    modules : str, optional\n        Specifies the numeric library to use.\n\n        If not specified, *modules* defaults to:\n\n        - ``[\"scipy\", \"numpy\"]`` if SciPy is installed\n        - ``[\"numpy\"]`` if only NumPy is installed\n        - ``[\"math\", \"mpmath\", \"sympy\"]`` if neither is installed.\n\n        That is, SymPy functions are replaced as far as possible by\n        either ``scipy`` or ``numpy`` functions if available, and Python's\n        standard library ``math``, or ``mpmath`` functions otherwise.\n\n        *modules* can be one of the following types:\n\n        - The strings ``\"math\"``, ``\"mpmath\"``, ``\"numpy\"``, ``\"numexpr\"``,\n          ``\"scipy\"``, ``\"sympy\"``, or ``\"tensorflow\"`` or ``\"jax\"``. This uses the\n          corresponding printer and namespace mapping for that module.\n        - A module (e.g., ``math``). This uses the global namespace of the\n          module. If the module is one of the above known modules, it will\n          also use the corresponding printer and namespace mapping\n          (i.e., ``modules=numpy`` is equivalent to ``modules=\"numpy\"``).\n        - A dictionary that maps names of SymPy functions to arbitrary\n          functions\n          (e.g., ``{'sin': custom_sin}``).\n        - A list that contains a mix of the arguments above, with higher\n          priority given to entries appearing first\n          (e.g., to use the NumPy module but override the ``sin`` function\n          with a custom version, you can use\n          ``[{'sin': custom_sin}, 'numpy']``).\n\n    dummify : bool, optional\n        Whether or not the variables in the provided expression that are not\n        valid Python identifiers are substituted with dummy symbols.\n\n        This allows for undefined functions like ``Function('f')(t)`` to be\n        supplied as arguments. By default, the variables are only dummified\n        if they are not valid Python identifiers.\n\n        Set ``dummify=True`` to replace all arguments with dummy symbols\n        (if ``args`` is not a string) - for example, to ensure that the\n        arguments do not redefine any built-in names.\n\n    cse : bool, or callable, optional\n        Large expressions can be computed more efficiently when\n        common subexpressions are identified and precomputed before\n        being used multiple time. Finding the subexpressions will make\n        creation of the 'lambdify' function slower, however.\n\n        When ``True``, ``sympy.simplify.cse`` is used, otherwise (the default)\n        the user may pass a function matching the ``cse`` signature.\n\n    docstring_limit : int or None\n        When lambdifying large expressions, a significant proportion of the time\n        spent inside ``lambdify`` is spent producing a string representation of\n        the expression for use in the automatically generated docstring of the\n        returned function. For expressions containing hundreds or more nodes the\n        resulting docstring often becomes so long and dense that it is difficult\n        to read. To reduce the runtime of lambdify, the rendering of the full\n        expression inside the docstring can be disabled.\n\n        When ``None``, the full expression is rendered in the docstring. When\n        ``0`` or a negative ``int``, an ellipsis is rendering in the docstring\n        instead of the expression. When a strictly positive ``int``, if the\n        number of nodes in the expression exceeds ``docstring_limit`` an\n        ellipsis is rendered in the docstring, otherwise a string representation\n        of the expression is rendered as normal. The default is ``1000``.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.lambdify import implemented_function\n    >>> from sympy import sqrt, sin, Matrix\n    >>> from sympy import Function\n    >>> from sympy.abc import w, x, y, z\n\n    >>> f = lambdify(x, x**2)\n    >>> f(2)\n    4\n    >>> f = lambdify((x, y, z), [z, y, x])\n    >>> f(1,2,3)\n    [3, 2, 1]\n    >>> f = lambdify(x, sqrt(x))\n    >>> f(4)\n    2.0\n    >>> f = lambdify((x, y), sin(x*y)**2)\n    >>> f(0, 5)\n    0.0\n    >>> row = lambdify((x, y), Matrix((x, x + y)).T, modules='sympy')\n    >>> row(1, 2)\n    Matrix([[1, 3]])\n\n    ``lambdify`` can be used to translate SymPy expressions into mpmath\n    functions. This may be preferable to using ``evalf`` (which uses mpmath on\n    the backend) in some cases.\n\n    >>> f = lambdify(x, sin(x), 'mpmath')\n    >>> f(1)\n    0.8414709848078965\n\n    Tuple arguments are handled and the lambdified function should\n    be called with the same type of arguments as were used to create\n    the function:\n\n    >>> f = lambdify((x, (y, z)), x + y)\n    >>> f(1, (2, 4))\n    3\n\n    The ``flatten`` function can be used to always work with flattened\n    arguments:\n\n    >>> from sympy.utilities.iterables import flatten\n    >>> args = w, (x, (y, z))\n    >>> vals = 1, (2, (3, 4))\n    >>> f = lambdify(flatten(args), w + x + y + z)\n    >>> f(*flatten(vals))\n    10\n\n    Functions present in ``expr`` can also carry their own numerical\n    implementations, in a callable attached to the ``_imp_`` attribute. This\n    can be used with undefined functions using the ``implemented_function``\n    factory:\n\n    >>> f = implemented_function(Function('f'), lambda x: x+1)\n    >>> func = lambdify(x, f(x))\n    >>> func(4)\n    5\n\n    ``lambdify`` always prefers ``_imp_`` implementations to implementations\n    in other namespaces, unless the ``use_imps`` input parameter is False.\n\n    Usage with Tensorflow:\n\n    >>> import tensorflow as tf\n    >>> from sympy import Max, sin, lambdify\n    >>> from sympy.abc import x\n\n    >>> f = Max(x, sin(x))\n    >>> func = lambdify(x, f, 'tensorflow')\n\n    After tensorflow v2, eager execution is enabled by default.\n    If you want to get the compatible result across tensorflow v1 and v2\n    as same as this tutorial, run this line.\n\n    >>> tf.compat.v1.enable_eager_execution()\n\n    If you have eager execution enabled, you can get the result out\n    immediately as you can use numpy.\n\n    If you pass tensorflow objects, you may get an ``EagerTensor``\n    object instead of value.\n\n    >>> result = func(tf.constant(1.0))\n    >>> print(result)\n    tf.Tensor(1.0, shape=(), dtype=float32)\n    >>> print(result.__class__)\n    <class 'tensorflow.python.framework.ops.EagerTensor'>\n\n    You can use ``.numpy()`` to get the numpy value of the tensor.\n\n    >>> result.numpy()\n    1.0\n\n    >>> var = tf.Variable(2.0)\n    >>> result = func(var) # also works for tf.Variable and tf.Placeholder\n    >>> result.numpy()\n    2.0\n\n    And it works with any shape array.\n\n    >>> tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]])\n    >>> result = func(tensor)\n    >>> result.numpy()\n    [[1. 2.]\n     [3. 4.]]\n\n    Notes\n    =====\n\n    - For functions involving large array calculations, numexpr can provide a\n      significant speedup over numpy. Please note that the available functions\n      for numexpr are more limited than numpy but can be expanded with\n      ``implemented_function`` and user defined subclasses of Function. If\n      specified, numexpr may be the only option in modules. The official list\n      of numexpr functions can be found at:\n      https://numexpr.readthedocs.io/en/latest/user_guide.html#supported-functions\n\n    - In the above examples, the generated functions can accept scalar\n      values or numpy arrays as arguments.  However, in some cases\n      the generated function relies on the input being a numpy array:\n\n      >>> import numpy\n      >>> from sympy import Piecewise\n      >>> from sympy.testing.pytest import ignore_warnings\n      >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), \"numpy\")\n\n      >>> with ignore_warnings(RuntimeWarning):\n      ...     f(numpy.array([-1, 0, 1, 2]))\n      [-1.   0.   1.   0.5]\n\n      >>> f(0)\n      Traceback (most recent call last):\n          ...\n      ZeroDivisionError: division by zero\n\n      In such cases, the input should be wrapped in a numpy array:\n\n      >>> with ignore_warnings(RuntimeWarning):\n      ...     float(f(numpy.array([0])))\n      0.0\n\n      Or if numpy functionality is not required another module can be used:\n\n      >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), \"math\")\n      >>> f(0)\n      0\n\n    .. _lambdify-how-it-works:\n\n    How it works\n    ============\n\n    When using this function, it helps a great deal to have an idea of what it\n    is doing. At its core, lambdify is nothing more than a namespace\n    translation, on top of a special printer that makes some corner cases work\n    properly.\n\n    To understand lambdify, first we must properly understand how Python\n    namespaces work. Say we had two files. One called ``sin_cos_sympy.py``,\n    with\n\n    .. code:: python\n\n        # sin_cos_sympy.py\n\n        from sympy.functions.elementary.trigonometric import (cos, sin)\n\n        def sin_cos(x):\n            return sin(x) + cos(x)\n\n\n    and one called ``sin_cos_numpy.py`` with\n\n    .. code:: python\n\n        # sin_cos_numpy.py\n\n        from numpy import sin, cos\n\n        def sin_cos(x):\n            return sin(x) + cos(x)\n\n    The two files define an identical function ``sin_cos``. However, in the\n    first file, ``sin`` and ``cos`` are defined as the SymPy ``sin`` and\n    ``cos``. In the second, they are defined as the NumPy versions.\n\n    If we were to import the first file and use the ``sin_cos`` function, we\n    would get something like\n\n    >>> from sin_cos_sympy import sin_cos # doctest: +SKIP\n    >>> sin_cos(1) # doctest: +SKIP\n    cos(1) + sin(1)\n\n    On the other hand, if we imported ``sin_cos`` from the second file, we\n    would get\n\n    >>> from sin_cos_numpy import sin_cos # doctest: +SKIP\n    >>> sin_cos(1) # doctest: +SKIP\n    1.38177329068\n\n    In the first case we got a symbolic output, because it used the symbolic\n    ``sin`` and ``cos`` functions from SymPy. In the second, we got a numeric\n    result, because ``sin_cos`` used the numeric ``sin`` and ``cos`` functions\n    from NumPy. But notice that the versions of ``sin`` and ``cos`` that were\n    used was not inherent to the ``sin_cos`` function definition. Both\n    ``sin_cos`` definitions are exactly the same. Rather, it was based on the\n    names defined at the module where the ``sin_cos`` function was defined.\n\n    The key point here is that when function in Python references a name that\n    is not defined in the function, that name is looked up in the \"global\"\n    namespace of the module where that function is defined.\n\n    Now, in Python, we can emulate this behavior without actually writing a\n    file to disk using the ``exec`` function. ``exec`` takes a string\n    containing a block of Python code, and a dictionary that should contain\n    the global variables of the module. It then executes the code \"in\" that\n    dictionary, as if it were the module globals. The following is equivalent\n    to the ``sin_cos`` defined in ``sin_cos_sympy.py``:\n\n    >>> import sympy\n    >>> module_dictionary = {'sin': sympy.sin, 'cos': sympy.cos}\n    >>> exec('''\n    ... def sin_cos(x):\n    ...     return sin(x) + cos(x)\n    ... ''', module_dictionary)\n    >>> sin_cos = module_dictionary['sin_cos']\n    >>> sin_cos(1)\n    cos(1) + sin(1)\n\n    and similarly with ``sin_cos_numpy``:\n\n    >>> import numpy\n    >>> module_dictionary = {'sin': numpy.sin, 'cos': numpy.cos}\n    >>> exec('''\n    ... def sin_cos(x):\n    ...     return sin(x) + cos(x)\n    ... ''', module_dictionary)\n    >>> sin_cos = module_dictionary['sin_cos']\n    >>> sin_cos(1)\n    1.38177329068\n\n    So now we can get an idea of how ``lambdify`` works. The name \"lambdify\"\n    comes from the fact that we can think of something like ``lambdify(x,\n    sin(x) + cos(x), 'numpy')`` as ``lambda x: sin(x) + cos(x)``, where\n    ``sin`` and ``cos`` come from the ``numpy`` namespace. This is also why\n    the symbols argument is first in ``lambdify``, as opposed to most SymPy\n    functions where it comes after the expression: to better mimic the\n    ``lambda`` keyword.\n\n    ``lambdify`` takes the input expression (like ``sin(x) + cos(x)``) and\n\n    1. Converts it to a string\n    2. Creates a module globals dictionary based on the modules that are\n       passed in (by default, it uses the NumPy module)\n    3. Creates the string ``\"def func({vars}): return {expr}\"``, where ``{vars}`` is the\n       list of variables separated by commas, and ``{expr}`` is the string\n       created in step 1., then ``exec``s that string with the module globals\n       namespace and returns ``func``.\n\n    In fact, functions returned by ``lambdify`` support inspection. So you can\n    see exactly how they are defined by using ``inspect.getsource``, or ``??`` if you\n    are using IPython or the Jupyter notebook.\n\n    >>> f = lambdify(x, sin(x) + cos(x))\n    >>> import inspect\n    >>> print(inspect.getsource(f))\n    def _lambdifygenerated(x):\n        return sin(x) + cos(x)\n\n    This shows us the source code of the function, but not the namespace it\n    was defined in. We can inspect that by looking at the ``__globals__``\n    attribute of ``f``:\n\n    >>> f.__globals__['sin']\n    <ufunc 'sin'>\n    >>> f.__globals__['cos']\n    <ufunc 'cos'>\n    >>> f.__globals__['sin'] is numpy.sin\n    True\n\n    This shows us that ``sin`` and ``cos`` in the namespace of ``f`` will be\n    ``numpy.sin`` and ``numpy.cos``.\n\n    Note that there are some convenience layers in each of these steps, but at\n    the core, this is how ``lambdify`` works. Step 1 is done using the\n    ``LambdaPrinter`` printers defined in the printing module (see\n    :mod:`sympy.printing.lambdarepr`). This allows different SymPy expressions\n    to define how they should be converted to a string for different modules.\n    You can change which printer ``lambdify`` uses by passing a custom printer\n    in to the ``printer`` argument.\n\n    Step 2 is augmented by certain translations. There are default\n    translations for each module, but you can provide your own by passing a\n    list to the ``modules`` argument. For instance,\n\n    >>> def mysin(x):\n    ...     print('taking the sin of', x)\n    ...     return numpy.sin(x)\n    ...\n    >>> f = lambdify(x, sin(x), [{'sin': mysin}, 'numpy'])\n    >>> f(1)\n    taking the sin of 1\n    0.8414709848078965\n\n    The globals dictionary is generated from the list by merging the\n    dictionary ``{'sin': mysin}`` and the module dictionary for NumPy. The\n    merging is done so that earlier items take precedence, which is why\n    ``mysin`` is used above instead of ``numpy.sin``.\n\n    If you want to modify the way ``lambdify`` works for a given function, it\n    is usually easiest to do so by modifying the globals dictionary as such.\n    In more complicated cases, it may be necessary to create and pass in a\n    custom printer.\n\n    Finally, step 3 is augmented with certain convenience operations, such as\n    the addition of a docstring.\n\n    Understanding how ``lambdify`` works can make it easier to avoid certain\n    gotchas when using it. For instance, a common mistake is to create a\n    lambdified function for one module (say, NumPy), and pass it objects from\n    another (say, a SymPy expression).\n\n    For instance, say we create\n\n    >>> from sympy.abc import x\n    >>> f = lambdify(x, x + 1, 'numpy')\n\n    Now if we pass in a NumPy array, we get that array plus 1\n\n    >>> import numpy\n    >>> a = numpy.array([1, 2])\n    >>> f(a)\n    [2 3]\n\n    But what happens if you make the mistake of passing in a SymPy expression\n    instead of a NumPy array:\n\n    >>> f(x + 1)\n    x + 2\n\n    This worked, but it was only by accident. Now take a different lambdified\n    function:\n\n    >>> from sympy import sin\n    >>> g = lambdify(x, x + sin(x), 'numpy')\n\n    This works as expected on NumPy arrays:\n\n    >>> g(a)\n    [1.84147098 2.90929743]\n\n    But if we try to pass in a SymPy expression, it fails\n\n    >>> g(x + 1)\n    Traceback (most recent call last):\n    ...\n    TypeError: loop of ufunc does not support argument 0 of type Add which has\n               no callable sin method\n\n    Now, let's look at what happened. The reason this fails is that ``g``\n    calls ``numpy.sin`` on the input expression, and ``numpy.sin`` does not\n    know how to operate on a SymPy object. **As a general rule, NumPy\n    functions do not know how to operate on SymPy expressions, and SymPy\n    functions do not know how to operate on NumPy arrays. This is why lambdify\n    exists: to provide a bridge between SymPy and NumPy.**\n\n    However, why is it that ``f`` did work? That's because ``f`` does not call\n    any functions, it only adds 1. So the resulting function that is created,\n    ``def _lambdifygenerated(x): return x + 1`` does not depend on the globals\n    namespace it is defined in. Thus it works, but only by accident. A future\n    version of ``lambdify`` may remove this behavior.\n\n    Be aware that certain implementation details described here may change in\n    future versions of SymPy. The API of passing in custom modules and\n    printers will not change, but the details of how a lambda function is\n    created may change. However, the basic idea will remain the same, and\n    understanding it will be helpful to understanding the behavior of\n    lambdify.\n\n    **In general: you should create lambdified functions for one module (say,\n    NumPy), and only pass it input types that are compatible with that module\n    (say, NumPy arrays).** Remember that by default, if the ``module``\n    argument is not provided, ``lambdify`` creates functions using the NumPy\n    and SciPy namespaces.\n    ",
    "section": "Lambdify",
    "url": "https://docs.sympy.org/latest/modules/utilities/lambdify.html"
  },
  {
    "name": "assoc_recurrence_memo",
    "full_id": "sympy.utilities.memoization.assoc_recurrence_memo",
    "type": "function",
    "description": "\n    Memo decorator for associated sequences defined by recurrence starting from base\n\n    base_seq(n) -- callable to get base sequence elements\n\n    XXX works only for Pn0 = base_seq(0) cases\n    XXX works only for m <= n cases\n    ",
    "section": "Memoization",
    "url": "https://docs.sympy.org/latest/modules/utilities/memoization.html"
  },
  {
    "name": "recurrence_memo",
    "full_id": "sympy.utilities.memoization.recurrence_memo",
    "type": "function",
    "description": "\n    Memo decorator for sequences defined by recurrence\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.memoization import recurrence_memo\n    >>> @recurrence_memo([1]) # 0! = 1\n    ... def factorial(n, prev):\n    ...     return n * prev[-1]\n    >>> factorial(4)\n    24\n    >>> factorial(3) # use cache values\n    6\n    >>> factorial.cache_length() # cache length can be obtained\n    5\n    >>> factorial.fetch_item(slice(2, 4))\n    [2, 6]\n\n    ",
    "section": "Memoization",
    "url": "https://docs.sympy.org/latest/modules/utilities/memoization.html"
  },
  {
    "name": "as_int",
    "full_id": "sympy.utilities.misc.as_int",
    "type": "function",
    "description": "\n    Convert the argument to a builtin integer.\n\n    The return value is guaranteed to be equal to the input. ValueError is\n    raised if the input has a non-integral value. When ``strict`` is True, this\n    uses `__index__ <https://docs.python.org/3/reference/datamodel.html#object.__index__>`_\n    and when it is False it uses ``int``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import as_int\n    >>> from sympy import sqrt, S\n\n    The function is primarily concerned with sanitizing input for\n    functions that need to work with builtin integers, so anything that\n    is unambiguously an integer should be returned as an int:\n\n    >>> as_int(S(3))\n    3\n\n    Floats, being of limited precision, are not assumed to be exact and\n    will raise an error unless the ``strict`` flag is False. This\n    precision issue becomes apparent for large floating point numbers:\n\n    >>> big = 1e23\n    >>> type(big) is float\n    True\n    >>> big == int(big)\n    True\n    >>> as_int(big)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    >>> as_int(big, strict=False)\n    99999999999999991611392\n\n    Input that might be a complex representation of an integer value is\n    also rejected by default:\n\n    >>> one = sqrt(3 + 2*sqrt(2)) - sqrt(2)\n    >>> int(one) == 1\n    True\n    >>> as_int(one)\n    Traceback (most recent call last):\n    ...\n    ValueError: ... is not an integer\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "debug",
    "full_id": "sympy.utilities.misc.debug",
    "type": "function",
    "description": "\n    Print ``*args`` if SYMPY_DEBUG is True, else do nothing.\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "debug_decorator",
    "full_id": "sympy.utilities.misc.debug_decorator",
    "type": "function",
    "description": "If SYMPY_DEBUG is True, it will print a nice execution tree with\n    arguments and results of all decorated functions, else do nothing.\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "debugf",
    "full_id": "sympy.utilities.misc.debugf",
    "type": "function",
    "description": "\n    Print ``string%args`` if SYMPY_DEBUG is True, else do nothing. This is\n    intended for debug messages using formatted strings.\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "filldedent",
    "full_id": "sympy.utilities.misc.filldedent",
    "type": "function",
    "description": "\n    Strips leading and trailing empty lines from a copy of ``s``, then dedents,\n    fills and returns it.\n\n    Empty line stripping serves to deal with docstrings like this one that\n    start with a newline after the initial triple quote, inserting an empty\n    line at the beginning of the string.\n\n    Additional keyword arguments will be passed to ``textwrap.fill()``.\n\n    See Also\n    ========\n    strlines, rawlines\n\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "find_executable",
    "full_id": "sympy.utilities.misc.find_executable",
    "type": "function",
    "description": "Try to find 'executable' in the directories listed in 'path' (a\n    string listing directories separated by 'os.pathsep'; defaults to\n    os.environ['PATH']).  Returns the complete filename or None if not\n    found\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "func_name",
    "full_id": "sympy.utilities.misc.func_name",
    "type": "function",
    "description": "Return function name of `x` (if defined) else the `type(x)`.\n    If short is True and there is a shorter alias for the result,\n    return the alias.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import func_name\n    >>> from sympy import Matrix\n    >>> from sympy.abc import x\n    >>> func_name(Matrix.eye(3))\n    'MutableDenseMatrix'\n    >>> func_name(x < 1)\n    'StrictLessThan'\n    >>> func_name(x < 1, short=True)\n    'Lt'\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "ordinal",
    "full_id": "sympy.utilities.misc.ordinal",
    "type": "function",
    "description": "Return ordinal number string of num, e.g. 1 becomes 1st.\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "rawlines",
    "full_id": "sympy.utilities.misc.rawlines",
    "type": "function",
    "description": "Return a cut-and-pastable string that, when printed, is equivalent\n    to the input. Use this when there is more than one line in the\n    string. The string returned is formatted so it can be indented\n    nicely within tests; in some cases it is wrapped in the dedent\n    function which has to be imported from textwrap.\n\n    Examples\n    ========\n\n    Note: because there are characters in the examples below that need\n    to be escaped because they are themselves within a triple quoted\n    docstring, expressions below look more complicated than they would\n    be if they were printed in an interpreter window.\n\n    >>> from sympy.utilities.misc import rawlines\n    >>> from sympy import TableForm\n    >>> s = str(TableForm([[1, 10]], headings=(None, ['a', 'bee'])))\n    >>> print(rawlines(s))\n    (\n        'a bee\\n'\n        '-----\\n'\n        '1 10 '\n    )\n    >>> print(rawlines('''this\n    ... that'''))\n    dedent('''\\\n        this\n        that''')\n\n    >>> print(rawlines('''this\n    ... that\n    ... '''))\n    dedent('''\\\n        this\n        that\n        ''')\n\n    >>> s = \"\"\"this\n    ... is a triple '''\n    ... \"\"\"\n    >>> print(rawlines(s))\n    dedent(\"\"\"\\\n        this\n        is a triple '''\n        \"\"\")\n\n    >>> print(rawlines('''this\n    ... that\n    ...     '''))\n    (\n        'this\\n'\n        'that\\n'\n        '    '\n    )\n\n    See Also\n    ========\n    filldedent, strlines\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "replace",
    "full_id": "sympy.utilities.misc.replace",
    "type": "function",
    "description": "Return ``string`` with all keys in ``reps`` replaced with\n    their corresponding values, longer strings first, irrespective\n    of the order they are given.  ``reps`` may be passed as tuples\n    or a single mapping.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import replace\n    >>> replace('foo', {'oo': 'ar', 'f': 'b'})\n    'bar'\n    >>> replace(\"spamham sha\", (\"spam\", \"eggs\"), (\"sha\",\"md5\"))\n    'eggsham md5'\n\n    There is no guarantee that a unique answer will be\n    obtained if keys in a mapping overlap (i.e. are the same\n    length and have some identical sequence at the\n    beginning/end):\n\n    >>> reps = [\n    ...     ('ab', 'x'),\n    ...     ('bc', 'y')]\n    >>> replace('abc', *reps) in ('xc', 'ay')\n    True\n\n    References\n    ==========\n\n    .. [1] https://stackoverflow.com/questions/6116978/how-to-replace-multiple-substrings-of-a-string\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "strlines",
    "full_id": "sympy.utilities.misc.strlines",
    "type": "function",
    "description": "Return a cut-and-pastable string that, when printed, is\n    equivalent to the input.  The lines will be surrounded by\n    parentheses and no line will be longer than c (default 64)\n    characters. If the line contains newlines characters, the\n    `rawlines` result will be returned.  If ``short`` is True\n    (default is False) then if there is one line it will be\n    returned without bounding parentheses.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import strlines\n    >>> q = 'this is a long string that should be broken into shorter lines'\n    >>> print(strlines(q, 40))\n    (\n    'this is a long string that should be b'\n    'roken into shorter lines'\n    )\n    >>> q == (\n    ... 'this is a long string that should be b'\n    ... 'roken into shorter lines'\n    ... )\n    True\n\n    See Also\n    ========\n    filldedent, rawlines\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "translate",
    "full_id": "sympy.utilities.misc.translate",
    "type": "function",
    "description": "Return ``s`` where characters have been replaced or deleted.\n\n    SYNTAX\n    ======\n\n    translate(s, None, deletechars):\n        all characters in ``deletechars`` are deleted\n    translate(s, map [,deletechars]):\n        all characters in ``deletechars`` (if provided) are deleted\n        then the replacements defined by map are made; if the keys\n        of map are strings then the longer ones are handled first.\n        Multicharacter deletions should have a value of ''.\n    translate(s, oldchars, newchars, deletechars)\n        all characters in ``deletechars`` are deleted\n        then each character in ``oldchars`` is replaced with the\n        corresponding character in ``newchars``\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.misc import translate\n    >>> abc = 'abc'\n    >>> translate(abc, None, 'a')\n    'bc'\n    >>> translate(abc, {'a': 'x'}, 'c')\n    'xb'\n    >>> translate(abc, {'abc': 'x', 'a': 'y'})\n    'x'\n\n    >>> translate('abcd', 'ac', 'AC', 'd')\n    'AbC'\n\n    There is no guarantee that a unique answer will be\n    obtained if keys in a mapping overlap are the same\n    length and have some identical sequences at the\n    beginning/end:\n\n    >>> translate(abc, {'ab': 'x', 'bc': 'y'}) in ('xc', 'ay')\n    True\n    ",
    "section": "Miscellaneous",
    "url": "https://docs.sympy.org/latest/modules/utilities/misc.html"
  },
  {
    "name": "get_class",
    "full_id": "sympy.utilities.source.get_class",
    "type": "function",
    "description": "\n    Convert a string version of a class name to the object.\n\n    For example, get_class('sympy.core.Basic') will return\n    class Basic located in module sympy.core\n    ",
    "section": "Source Code Inspection",
    "url": "https://docs.sympy.org/latest/modules/utilities/source.html"
  },
  {
    "name": "get_mod_func",
    "full_id": "sympy.utilities.source.get_mod_func",
    "type": "function",
    "description": "\n    splits the string path to a class into a string path to the module\n    and the name of the class.\n\n    Examples\n    ========\n\n    >>> from sympy.utilities.source import get_mod_func\n    >>> get_mod_func('sympy.core.basic.Basic')\n    ('sympy.core.basic', 'Basic')\n\n    ",
    "section": "Source Code Inspection",
    "url": "https://docs.sympy.org/latest/modules/utilities/source.html"
  },
  {
    "name": "timed",
    "full_id": "sympy.utilities.timeutils.timed",
    "type": "function",
    "description": "Adaptively measure execution time of a function. ",
    "section": "Timing Utilities",
    "url": "https://docs.sympy.org/latest/modules/utilities/timeutils.html"
  },
  {
    "name": "enable_automatic_int_sympification",
    "full_id": "sympy.interactive.session.enable_automatic_int_sympification",
    "type": "function",
    "description": "\n    Allow IPython to automatically convert integer literals to Integer.\n    ",
    "section": "Session",
    "url": "https://docs.sympy.org/latest/modules/interactive.html"
  },
  {
    "name": "enable_automatic_symbols",
    "full_id": "sympy.interactive.session.enable_automatic_symbols",
    "type": "function",
    "description": "Allow IPython to automatically create symbols (``isympy -a``).",
    "section": "Session",
    "url": "https://docs.sympy.org/latest/modules/interactive.html"
  },
  {
    "name": "init_ipython_session",
    "full_id": "sympy.interactive.session.init_ipython_session",
    "type": "function",
    "description": "Construct new IPython session.",
    "section": "Session",
    "url": "https://docs.sympy.org/latest/modules/interactive.html"
  },
  {
    "name": "init_python_session",
    "full_id": "sympy.interactive.session.init_python_session",
    "type": "function",
    "description": "Construct new Python session.",
    "section": "Session",
    "url": "https://docs.sympy.org/latest/modules/interactive.html"
  },
  {
    "name": "init_session",
    "full_id": "sympy.interactive.session.init_session",
    "type": "function",
    "description": "\n    Initialize an embedded IPython or Python session. The IPython session is\n    initiated with the --pylab option, without the numpy imports, so that\n    matplotlib plotting can be interactive.\n\n    Parameters\n    ==========\n\n    pretty_print: boolean\n        If True, use pretty_print to stringify;\n        if False, use sstrrepr to stringify.\n    order: string or None\n        There are a few different settings for this parameter:\n        lex (default), which is lexographic order;\n        grlex, which is graded lexographic order;\n        grevlex, which is reversed graded lexographic order;\n        old, which is used for compatibility reasons and for long expressions;\n        None, which sets it to lex.\n    use_unicode: boolean or None\n        If True, use unicode characters;\n        if False, do not use unicode characters.\n    use_latex: boolean or None\n        If True, use latex rendering if IPython GUI's;\n        if False, do not use latex rendering.\n    quiet: boolean\n        If True, init_session will not print messages regarding its status;\n        if False, init_session will print messages regarding its status.\n    auto_symbols: boolean\n        If True, IPython will automatically create symbols for you.\n        If False, it will not.\n        The default is False.\n    auto_int_to_Integer: boolean\n        If True, IPython will automatically wrap int literals with Integer, so\n        that things like 1/2 give Rational(1, 2).\n        If False, it will not.\n        The default is False.\n    ipython: boolean or None\n        If True, printing will initialize for an IPython console;\n        if False, printing will initialize for a normal console;\n        The default is None, which automatically determines whether we are in\n        an ipython instance or not.\n    str_printer: function, optional, default=None\n        A custom string printer function. This should mimic\n        sympy.printing.sstrrepr().\n    pretty_printer: function, optional, default=None\n        A custom pretty printer. This should mimic sympy.printing.pretty().\n    latex_printer: function, optional, default=None\n        A custom LaTeX printer. This should mimic sympy.printing.latex()\n        This should mimic sympy.printing.latex().\n    argv: list of arguments for IPython\n        See sympy.bin.isympy for options that can be used to initialize IPython.\n\n    See Also\n    ========\n\n    sympy.interactive.printing.init_printing: for examples and the rest of the parameters.\n\n\n    Examples\n    ========\n\n    >>> from sympy import init_session, Symbol, sin, sqrt\n    >>> sin(x) #doctest: +SKIP\n    NameError: name 'x' is not defined\n    >>> init_session() #doctest: +SKIP\n    >>> sin(x) #doctest: +SKIP\n    sin(x)\n    >>> sqrt(5) #doctest: +SKIP\n      ___\n    \\/ 5\n    >>> init_session(pretty_print=False) #doctest: +SKIP\n    >>> sqrt(5) #doctest: +SKIP\n    sqrt(5)\n    >>> y + x + y**2 + x**2 #doctest: +SKIP\n    x**2 + x + y**2 + y\n    >>> init_session(order='grlex') #doctest: +SKIP\n    >>> y + x + y**2 + x**2 #doctest: +SKIP\n    x**2 + y**2 + x + y\n    >>> init_session(order='grevlex') #doctest: +SKIP\n    >>> y * x**2 + x * y**2 #doctest: +SKIP\n    x**2*y + x*y**2\n    >>> init_session(order='old') #doctest: +SKIP\n    >>> x**2 + y**2 + x + y #doctest: +SKIP\n    x + y + x**2 + y**2\n    >>> theta = Symbol('theta') #doctest: +SKIP\n    >>> theta #doctest: +SKIP\n    theta\n    >>> init_session(use_unicode=True) #doctest: +SKIP\n    >>> theta # doctest: +SKIP\n    \u03b8\n    ",
    "section": "Session",
    "url": "https://docs.sympy.org/latest/modules/interactive.html"
  },
  {
    "name": "int_to_Integer",
    "full_id": "sympy.interactive.session.int_to_Integer",
    "type": "function",
    "description": "\n    Wrap integer literals with Integer.\n\n    This is based on the decistmt example from\n    https://docs.python.org/3/library/tokenize.html.\n\n    Only integer literals are converted.  Float literals are left alone.\n\n    Examples\n    ========\n\n    >>> from sympy import Integer # noqa: F401\n    >>> from sympy.interactive.session import int_to_Integer\n    >>> s = '1.2 + 1/2 - 0x12 + a1'\n    >>> int_to_Integer(s)\n    '1.2 +Integer (1 )/Integer (2 )-Integer (0x12 )+a1 '\n    >>> s = 'print (1/2)'\n    >>> int_to_Integer(s)\n    'print (Integer (1 )/Integer (2 ))'\n    >>> exec(s)\n    0.5\n    >>> exec(int_to_Integer(s))\n    1/2\n    ",
    "section": "Session",
    "url": "https://docs.sympy.org/latest/modules/interactive.html"
  },
  {
    "name": "init_printing",
    "full_id": "sympy.interactive.printing.init_printing",
    "type": "function",
    "description": "\n    Initializes pretty-printer depending on the environment.\n\n    Parameters\n    ==========\n\n    pretty_print : bool, default=True\n        If ``True``, use :func:`~.pretty_print` to stringify or the provided pretty\n        printer; if ``False``, use :func:`~.sstrrepr` to stringify or the provided string\n        printer.\n    order : string or None, default='lex'\n        There are a few different settings for this parameter:\n        ``'lex'`` (default), which is lexographic order;\n        ``'grlex'``, which is graded lexographic order;\n        ``'grevlex'``, which is reversed graded lexographic order;\n        ``'old'``, which is used for compatibility reasons and for long expressions;\n        ``None``, which sets it to lex.\n    use_unicode : bool or None, default=None\n        If ``True``, use unicode characters;\n        if ``False``, do not use unicode characters;\n        if ``None``, make a guess based on the environment.\n    use_latex : string, bool, or None, default=None\n        If ``True``, use default LaTeX rendering in GUI interfaces (png and\n        mathjax);\n        if ``False``, do not use LaTeX rendering;\n        if ``None``, make a guess based on the environment;\n        if ``'png'``, enable LaTeX rendering with an external LaTeX compiler,\n        falling back to matplotlib if external compilation fails;\n        if ``'matplotlib'``, enable LaTeX rendering with matplotlib;\n        if ``'mathjax'``, enable LaTeX text generation, for example MathJax\n        rendering in IPython notebook or text rendering in LaTeX documents;\n        if ``'svg'``, enable LaTeX rendering with an external latex compiler,\n        no fallback\n    wrap_line : bool\n        If True, lines will wrap at the end; if False, they will not wrap\n        but continue as one line. This is only relevant if ``pretty_print`` is\n        True.\n    num_columns : int or None, default=None\n        If ``int``, number of columns before wrapping is set to num_columns; if\n        ``None``, number of columns before wrapping is set to terminal width.\n        This is only relevant if ``pretty_print`` is ``True``.\n    no_global : bool, default=False\n        If ``True``, the settings become system wide;\n        if ``False``, use just for this console/session.\n    ip : An interactive console\n        This can either be an instance of IPython,\n        or a class that derives from code.InteractiveConsole.\n    euler : bool, optional, default=False\n        Loads the euler package in the LaTeX preamble for handwritten style\n        fonts (https://www.ctan.org/pkg/euler).\n    forecolor : string or None, optional, default=None\n        DVI setting for foreground color. ``None`` means that either ``'Black'``,\n        ``'White'``, or ``'Gray'`` will be selected based on a guess of the IPython\n        terminal color setting. See notes.\n    backcolor : string, optional, default='Transparent'\n        DVI setting for background color. See notes.\n    fontsize : string or int, optional, default='10pt'\n        A font size to pass to the LaTeX documentclass function in the\n        preamble. Note that the options are limited by the documentclass.\n        Consider using scale instead.\n    latex_mode : string, optional, default='plain'\n        The mode used in the LaTeX printer. Can be one of:\n        ``{'inline'|'plain'|'equation'|'equation*'}``.\n    print_builtin : boolean, optional, default=True\n        If ``True`` then floats and integers will be printed. If ``False`` the\n        printer will only print SymPy types.\n    str_printer : function, optional, default=None\n        A custom string printer function. This should mimic\n        :func:`~.sstrrepr`.\n    pretty_printer : function, optional, default=None\n        A custom pretty printer. This should mimic :func:`~.pretty`.\n    latex_printer : function, optional, default=None\n        A custom LaTeX printer. This should mimic :func:`~.latex`.\n    scale : float, optional, default=1.0\n        Scale the LaTeX output when using the ``'png'`` or ``'svg'`` backends.\n        Useful for high dpi screens.\n    settings :\n        Any additional settings for the ``latex`` and ``pretty`` commands can\n        be used to fine-tune the output.\n\n    Examples\n    ========\n\n    >>> from sympy.interactive import init_printing\n    >>> from sympy import Symbol, sqrt\n    >>> from sympy.abc import x, y\n    >>> sqrt(5)\n    sqrt(5)\n    >>> init_printing(pretty_print=True) # doctest: +SKIP\n    >>> sqrt(5) # doctest: +SKIP\n      ___\n    \\/ 5\n    >>> theta = Symbol('theta') # doctest: +SKIP\n    >>> init_printing(use_unicode=True) # doctest: +SKIP\n    >>> theta # doctest: +SKIP\n    \\u03b8\n    >>> init_printing(use_unicode=False) # doctest: +SKIP\n    >>> theta # doctest: +SKIP\n    theta\n    >>> init_printing(order='lex') # doctest: +SKIP\n    >>> str(y + x + y**2 + x**2) # doctest: +SKIP\n    x**2 + x + y**2 + y\n    >>> init_printing(order='grlex') # doctest: +SKIP\n    >>> str(y + x + y**2 + x**2) # doctest: +SKIP\n    x**2 + x + y**2 + y\n    >>> init_printing(order='grevlex') # doctest: +SKIP\n    >>> str(y * x**2 + x * y**2) # doctest: +SKIP\n    x**2*y + x*y**2\n    >>> init_printing(order='old') # doctest: +SKIP\n    >>> str(x**2 + y**2 + x + y) # doctest: +SKIP\n    x**2 + x + y**2 + y\n    >>> init_printing(num_columns=10) # doctest: +SKIP\n    >>> x**2 + x + y**2 + y # doctest: +SKIP\n    x + y +\n    x**2 + y**2\n\n    Notes\n    =====\n\n    The foreground and background colors can be selected when using ``'png'`` or\n    ``'svg'`` LaTeX rendering. Note that before the ``init_printing`` command is\n    executed, the LaTeX rendering is handled by the IPython console and not SymPy.\n\n    The colors can be selected among the 68 standard colors known to ``dvips``,\n    for a list see [1]_. In addition, the background color can be\n    set to  ``'Transparent'`` (which is the default value).\n\n    When using the ``'Auto'`` foreground color, the guess is based on the\n    ``colors`` variable in the IPython console, see [2]_. Hence, if\n    that variable is set correctly in your IPython console, there is a high\n    chance that the output will be readable, although manual settings may be\n    needed.\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikibooks.org/wiki/LaTeX/Colors#The_68_standard_colors_known_to_dvips\n\n    .. [2] https://ipython.readthedocs.io/en/stable/config/details.html#terminal-colors\n\n    See Also\n    ========\n\n    sympy.printing.latex\n    sympy.printing.pretty\n\n    ",
    "section": "Printing",
    "url": "https://docs.sympy.org/latest/modules/interactive.html"
  },
  {
    "name": "parse_expr",
    "full_id": "sympy.parsing.sympy_parser.parse_expr",
    "type": "function",
    "description": "Converts the string ``s`` to a SymPy expression, in ``local_dict``.\n\n    Parameters\n    ==========\n\n    s : str\n        The string to parse.\n\n    local_dict : dict, optional\n        A dictionary of local variables to use when parsing.\n\n    global_dict : dict, optional\n        A dictionary of global variables. By default, this is initialized\n        with ``from sympy import *``; provide this parameter to override\n        this behavior (for instance, to parse ``\"Q & S\"``).\n\n    transformations : tuple or str\n        A tuple of transformation functions used to modify the tokens of the\n        parsed expression before evaluation. The default transformations\n        convert numeric literals into their SymPy equivalents, convert\n        undefined variables into SymPy symbols, and allow the use of standard\n        mathematical factorial notation (e.g. ``x!``). Selection via\n        string is available (see below).\n\n    evaluate : bool, optional\n        When False, the order of the arguments will remain as they were in the\n        string and automatic simplification that would normally occur is\n        suppressed. (see examples)\n\n    Examples\n    ========\n\n    >>> from sympy.parsing.sympy_parser import parse_expr\n    >>> parse_expr(\"1/2\")\n    1/2\n    >>> type(_)\n    <class 'sympy.core.numbers.Half'>\n    >>> from sympy.parsing.sympy_parser import standard_transformations,\\\n    ... implicit_multiplication_application\n    >>> transformations = (standard_transformations +\n    ...     (implicit_multiplication_application,))\n    >>> parse_expr(\"2x\", transformations=transformations)\n    2*x\n\n    When evaluate=False, some automatic simplifications will not occur:\n\n    >>> parse_expr(\"2**3\"), parse_expr(\"2**3\", evaluate=False)\n    (8, 2**3)\n\n    In addition the order of the arguments will not be made canonical.\n    This feature allows one to tell exactly how the expression was entered:\n\n    >>> a = parse_expr('1 + x', evaluate=False)\n    >>> b = parse_expr('x + 1', evaluate=0)\n    >>> a == b\n    False\n    >>> a.args\n    (1, x)\n    >>> b.args\n    (x, 1)\n\n    Note, however, that when these expressions are printed they will\n    appear the same:\n\n    >>> assert str(a) == str(b)\n\n    As a convenience, transformations can be seen by printing ``transformations``:\n\n    >>> from sympy.parsing.sympy_parser import transformations\n\n    >>> print(transformations)\n    0: lambda_notation\n    1: auto_symbol\n    2: repeated_decimals\n    3: auto_number\n    4: factorial_notation\n    5: implicit_multiplication_application\n    6: convert_xor\n    7: implicit_application\n    8: implicit_multiplication\n    9: convert_equals_signs\n    10: function_exponentiation\n    11: rationalize\n\n    The ``T`` object provides a way to select these transformations:\n\n    >>> from sympy.parsing.sympy_parser import T\n\n    If you print it, you will see the same list as shown above.\n\n    >>> str(T) == str(transformations)\n    True\n\n    Standard slicing will return a tuple of transformations:\n\n    >>> T[:5] == standard_transformations\n    True\n\n    So ``T`` can be used to specify the parsing transformations:\n\n    >>> parse_expr(\"2x\", transformations=T[:5])\n    Traceback (most recent call last):\n    ...\n    SyntaxError: invalid syntax\n    >>> parse_expr(\"2x\", transformations=T[:6])\n    2*x\n    >>> parse_expr('.3', transformations=T[3, 11])\n    3/10\n    >>> parse_expr('.3x', transformations=T[:])\n    3*x/10\n\n    As a further convenience, strings 'implicit' and 'all' can be used\n    to select 0-5 and all the transformations, respectively.\n\n    >>> parse_expr('.3x', transformations='all')\n    3*x/10\n\n    See Also\n    ========\n\n    stringify_expr, eval_expr, standard_transformations,\n    implicit_multiplication_application\n\n    ",
    "section": "Parsing Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "stringify_expr",
    "full_id": "sympy.parsing.sympy_parser.stringify_expr",
    "type": "function",
    "description": "\n    Converts the string ``s`` to Python code, in ``local_dict``\n\n    Generally, ``parse_expr`` should be used.\n    ",
    "section": "Parsing Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "eval_expr",
    "full_id": "sympy.parsing.sympy_parser.eval_expr",
    "type": "function",
    "description": "\n    Evaluate Python code generated by ``stringify_expr``.\n\n    Generally, ``parse_expr`` should be used.\n    ",
    "section": "Parsing Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "parse_mathematica",
    "full_id": "sympy.parsing.mathematica.parse_mathematica",
    "type": "function",
    "description": "\n    Translate a string containing a Wolfram Mathematica expression to a SymPy\n    expression.\n\n    If the translator is unable to find a suitable SymPy expression, the\n    ``FullForm`` of the Mathematica expression will be output, using SymPy\n    ``Function`` objects as nodes of the syntax tree.\n\n    Examples\n    ========\n\n    >>> from sympy.parsing.mathematica import parse_mathematica\n    >>> parse_mathematica(\"Sin[x]^2 Tan[y]\")\n    sin(x)**2*tan(y)\n    >>> e = parse_mathematica(\"F[7,5,3]\")\n    >>> e\n    F(7, 5, 3)\n    >>> from sympy import Function, Max, Min\n    >>> e.replace(Function(\"F\"), lambda *x: Max(*x)*Min(*x))\n    21\n\n    Both standard input form and Mathematica full form are supported:\n\n    >>> parse_mathematica(\"x*(a + b)\")\n    x*(a + b)\n    >>> parse_mathematica(\"Times[x, Plus[a, b]]\")\n    x*(a + b)\n\n    To get a matrix from Wolfram's code:\n\n    >>> m = parse_mathematica(\"{{a, b}, {c, d}}\")\n    >>> m\n    ((a, b), (c, d))\n    >>> from sympy import Matrix\n    >>> Matrix(m)\n    Matrix([\n    [a, b],\n    [c, d]])\n\n    If the translation into equivalent SymPy expressions fails, an SymPy\n    expression equivalent to Wolfram Mathematica's \"FullForm\" will be created:\n\n    >>> parse_mathematica(\"x_.\")\n    Optional(Pattern(x, Blank()))\n    >>> parse_mathematica(\"Plus @@ {x, y, z}\")\n    Apply(Plus, (x, y, z))\n    >>> parse_mathematica(\"f[x_, 3] := x^3 /; x > 0\")\n    SetDelayed(f(Pattern(x, Blank()), 3), Condition(x**3, x > 0))\n    ",
    "section": "Parsing Functions Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "split_symbols_custom",
    "full_id": "sympy.parsing.sympy_parser.split_symbols_custom",
    "type": "function",
    "description": "Creates a transformation that splits symbol names.\n\n    ``predicate`` should return True if the symbol name is to be split.\n\n    For instance, to retain the default behavior but avoid splitting certain\n    symbol names, a predicate like this would work:\n\n\n    >>> from sympy.parsing.sympy_parser import (parse_expr, _token_splittable,\n    ... standard_transformations, implicit_multiplication,\n    ... split_symbols_custom)\n    >>> def can_split(symbol):\n    ...     if symbol not in ('list', 'of', 'unsplittable', 'names'):\n    ...             return _token_splittable(symbol)\n    ...     return False\n    ...\n    >>> transformation = split_symbols_custom(can_split)\n    >>> parse_expr('unsplittable', transformations=standard_transformations +\n    ... (transformation, implicit_multiplication))\n    unsplittable\n    ",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "implicit_multiplication",
    "full_id": "sympy.parsing.sympy_parser.implicit_multiplication",
    "type": "function",
    "description": "Makes the multiplication operator optional in most cases.\n\n    Use this before :func:`implicit_application`, otherwise expressions like\n    ``sin 2x`` will be parsed as ``x * sin(2)`` rather than ``sin(2*x)``.\n\n    Examples\n    ========\n\n    >>> from sympy.parsing.sympy_parser import (parse_expr,\n    ... standard_transformations, implicit_multiplication)\n    >>> transformations = standard_transformations + (implicit_multiplication,)\n    >>> parse_expr('3 x y', transformations=transformations)\n    3*x*y\n    ",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "implicit_application",
    "full_id": "sympy.parsing.sympy_parser.implicit_application",
    "type": "function",
    "description": "Makes parentheses optional in some cases for function calls.\n\n    Use this after :func:`implicit_multiplication`, otherwise expressions\n    like ``sin 2x`` will be parsed as ``x * sin(2)`` rather than\n    ``sin(2*x)``.\n\n    Examples\n    ========\n\n    >>> from sympy.parsing.sympy_parser import (parse_expr,\n    ... standard_transformations, implicit_application)\n    >>> transformations = standard_transformations + (implicit_application,)\n    >>> parse_expr('cot z + csc z', transformations=transformations)\n    cot(z) + csc(z)\n    ",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "function_exponentiation",
    "full_id": "sympy.parsing.sympy_parser.function_exponentiation",
    "type": "function",
    "description": "Allows functions to be exponentiated, e.g. ``cos**2(x)``.\n\n    Examples\n    ========\n\n    >>> from sympy.parsing.sympy_parser import (parse_expr,\n    ... standard_transformations, function_exponentiation)\n    >>> transformations = standard_transformations + (function_exponentiation,)\n    >>> parse_expr('sin**4(x)', transformations=transformations)\n    sin(x)**4\n    ",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "implicit_multiplication_application",
    "full_id": "sympy.parsing.sympy_parser.implicit_multiplication_application",
    "type": "function",
    "description": "Allows a slightly relaxed syntax.\n\n    - Parentheses for single-argument method calls are optional.\n\n    - Multiplication is implicit.\n\n    - Symbol names can be split (i.e. spaces are not needed between\n      symbols).\n\n    - Functions can be exponentiated.\n\n    Examples\n    ========\n\n    >>> from sympy.parsing.sympy_parser import (parse_expr,\n    ... standard_transformations, implicit_multiplication_application)\n    >>> parse_expr(\"10sin**2 x**2 + 3xyz + tan theta\",\n    ... transformations=(standard_transformations +\n    ... (implicit_multiplication_application,)))\n    3*x*y*z + 10*sin(x**2)**2 + tan(theta)\n\n    ",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "rationalize",
    "full_id": "sympy.parsing.sympy_parser.rationalize",
    "type": "function",
    "description": "Converts floats into ``Rational``. Run AFTER ``auto_number``.",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "convert_xor",
    "full_id": "sympy.parsing.sympy_parser.convert_xor",
    "type": "function",
    "description": "Treats XOR, ``^``, as exponentiation, ``**``.",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "lambda_notation",
    "full_id": "sympy.parsing.sympy_parser.lambda_notation",
    "type": "function",
    "description": "Substitutes \"lambda\" with its SymPy equivalent Lambda().\n    However, the conversion does not take place if only \"lambda\"\n    is passed because that is a syntax error.\n\n    ",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "auto_symbol",
    "full_id": "sympy.parsing.sympy_parser.auto_symbol",
    "type": "function",
    "description": "Inserts calls to ``Symbol``/``Function`` for undefined variables.",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "repeated_decimals",
    "full_id": "sympy.parsing.sympy_parser.repeated_decimals",
    "type": "function",
    "description": "\n    Allows 0.2[1] notation to represent the repeated decimal 0.2111... (19/90)\n\n    Run this before auto_number.\n\n    ",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "auto_number",
    "full_id": "sympy.parsing.sympy_parser.auto_number",
    "type": "function",
    "description": "\n    Converts numeric literals to use SymPy equivalents.\n\n    Complex numbers use ``I``, integer literals use ``Integer``, and float\n    literals use ``Float``.\n\n    ",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "factorial_notation",
    "full_id": "sympy.parsing.sympy_parser.factorial_notation",
    "type": "function",
    "description": "Allows standard notation for factorial.",
    "section": "Parsing Transformations Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "parse_latex",
    "full_id": "sympy.parsing.latex.parse_latex",
    "type": "function",
    "description": "Converts the input LaTeX string ``s`` to a SymPy ``Expr``.\n\n    Parameters\n    ==========\n\n    s : str\n        The LaTeX string to parse. In Python source containing LaTeX,\n        *raw strings* (denoted with ``r\"``, like this one) are preferred,\n        as LaTeX makes liberal use of the ``\\`` character, which would\n        trigger escaping in normal Python strings.\n    backend : str, optional\n        Currently, there are two backends supported: ANTLR, and Lark.\n        The default setting is to use the ANTLR backend, which can be\n        changed to Lark if preferred.\n\n        Use ``backend=\"antlr\"`` for the ANTLR-based parser, and\n        ``backend=\"lark\"`` for the Lark-based parser.\n\n        The ``backend`` option is case-sensitive, and must be in\n        all lowercase.\n    strict : bool, optional\n        This option is only available with the ANTLR backend.\n\n        If True, raise an exception if the string cannot be parsed as\n        valid LaTeX. If False, try to recover gracefully from common\n        mistakes.\n\n    Examples\n    ========\n\n    >>> from sympy.parsing.latex import parse_latex\n    >>> expr = parse_latex(r\"\\frac {1 + \\sqrt {\\a}} {\\b}\")\n    >>> expr\n    (sqrt(a) + 1)/b\n    >>> expr.evalf(4, subs=dict(a=5, b=2))\n    1.618\n    >>> func = parse_latex(r\"\\int_1^\\alpha \\dfrac{\\mathrm{d}t}{t}\", backend=\"lark\")\n    >>> func.evalf(subs={\"alpha\": 2})\n    0.693147180559945\n    ",
    "section": "\\(\\mathrm{\\LaTeX}\\)",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "parse_latex_lark",
    "full_id": "sympy.parsing.latex.parse_latex_lark",
    "type": "function",
    "description": "\n    Experimental LaTeX parser using Lark.\n\n    This function is still under development and its API may change with the\n    next releases of SymPy.\n    ",
    "section": "Lark",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "convert_to_c",
    "full_id": "sympy.parsing.sym_expr.SymPyExpression.convert_to_c",
    "type": "method",
    "description": "Returns a list with the c source code for the SymPy expressions\n\n\n        Examples\n        ========\n\n        >>> from sympy.parsing.sym_expr import SymPyExpression\n        >>> src2 = '''\n        ... integer :: a, b, c, d\n        ... real :: p, q, r, s\n        ... c = a/b\n        ... d = c/a\n        ... s = p/q\n        ... r = q/p\n        ... '''\n        >>> p = SymPyExpression()\n        >>> p.convert_to_expr(src2, 'f')\n        >>> p.convert_to_c()\n        ['int a = 0', 'int b = 0', 'int c = 0', 'int d = 0', 'double p = 0.0', 'double q = 0.0', 'double r = 0.0', 'double s = 0.0', 'c = a/b;', 'd = c/a;', 's = p/q;', 'r = q/p;']\n\n        ",
    "section": "SymPy Expression Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "convert_to_expr",
    "full_id": "sympy.parsing.sym_expr.SymPyExpression.convert_to_expr",
    "type": "method",
    "description": "Converts the given source code to SymPy Expressions\n\n        Attributes\n        ==========\n\n        src_code : String\n            the source code or filename of the source code that is to be\n            converted\n\n        mode: String\n            the mode to determine which parser is to be used according to\n            the language of the source code\n            f or F for Fortran\n            c or C for C/C++\n\n        Examples\n        ========\n\n        >>> from sympy.parsing.sym_expr import SymPyExpression\n        >>> src3 = '''\n        ... integer function f(a,b) result(r)\n        ... integer, intent(in) :: a, b\n        ... integer :: x\n        ... r = a + b -x\n        ... end function\n        ... '''\n        >>> p = SymPyExpression()\n        >>> p.convert_to_expr(src3, 'f')\n        >>> p.return_expr()\n        [FunctionDefinition(integer, name=f, parameters=(Variable(a), Variable(b)), body=CodeBlock(\n        Declaration(Variable(r, type=integer, value=0)),\n        Declaration(Variable(x, type=integer, value=0)),\n        Assignment(Variable(r), a + b - x),\n        Return(Variable(r))\n        ))]\n\n\n\n\n        ",
    "section": "SymPy Expression Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "convert_to_fortran",
    "full_id": "sympy.parsing.sym_expr.SymPyExpression.convert_to_fortran",
    "type": "method",
    "description": "Returns a list with the fortran source code for the SymPy expressions\n\n        Examples\n        ========\n\n        >>> from sympy.parsing.sym_expr import SymPyExpression\n        >>> src2 = '''\n        ... integer :: a, b, c, d\n        ... real :: p, q, r, s\n        ... c = a/b\n        ... d = c/a\n        ... s = p/q\n        ... r = q/p\n        ... '''\n        >>> p = SymPyExpression(src2, 'f')\n        >>> p.convert_to_fortran()\n        ['      integer*4 a', '      integer*4 b', '      integer*4 c', '      integer*4 d', '      real*8 p', '      real*8 q', '      real*8 r', '      real*8 s', '      c = a/b', '      d = c/a', '      s = p/q', '      r = q/p']\n\n        ",
    "section": "SymPy Expression Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "convert_to_python",
    "full_id": "sympy.parsing.sym_expr.SymPyExpression.convert_to_python",
    "type": "method",
    "description": "Returns a list with Python code for the SymPy expressions\n\n        Examples\n        ========\n\n        >>> from sympy.parsing.sym_expr import SymPyExpression\n        >>> src2 = '''\n        ... integer :: a, b, c, d\n        ... real :: p, q, r, s\n        ... c = a/b\n        ... d = c/a\n        ... s = p/q\n        ... r = q/p\n        ... '''\n        >>> p = SymPyExpression(src2, 'f')\n        >>> p.convert_to_python()\n        ['a = 0', 'b = 0', 'c = 0', 'd = 0', 'p = 0.0', 'q = 0.0', 'r = 0.0', 's = 0.0', 'c = a/b', 'd = c/a', 's = p/q', 'r = q/p']\n\n        ",
    "section": "SymPy Expression Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "return_expr",
    "full_id": "sympy.parsing.sym_expr.SymPyExpression.return_expr",
    "type": "method",
    "description": "Returns the expression list\n\n        Examples\n        ========\n\n        >>> from sympy.parsing.sym_expr import SymPyExpression\n        >>> src3 = '''\n        ... integer function f(a,b)\n        ... integer, intent(in) :: a, b\n        ... integer :: r\n        ... r = a+b\n        ... f = r\n        ... end function\n        ... '''\n        >>> p = SymPyExpression()\n        >>> p.convert_to_expr(src3, 'f')\n        >>> p.return_expr()\n        [FunctionDefinition(integer, name=f, parameters=(Variable(a), Variable(b)), body=CodeBlock(\n        Declaration(Variable(f, type=integer, value=0)),\n        Declaration(Variable(r, type=integer, value=0)),\n        Assignment(Variable(f), Variable(r)),\n        Return(Variable(f))\n        ))]\n\n        ",
    "section": "SymPy Expression Reference",
    "url": "https://docs.sympy.org/latest/modules/parsing.html"
  },
  {
    "name": "_print",
    "full_id": "sympy.printing.printer.Printer._print",
    "type": "method",
    "description": "Internal dispatcher\n\n        Tries the following concepts to print an expression:\n            1. Let the object print itself if it knows how.\n            2. Take the best fitting method defined in the printer.\n            3. As fall-back use the emptyPrinter method for the printer.\n        ",
    "section": "Common mistakes",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "doprint",
    "full_id": "sympy.printing.printer.Printer.doprint",
    "type": "method",
    "description": "Returns printer's representation for expr (as a string)",
    "section": "Common mistakes",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "set_global_settings",
    "full_id": "sympy.printing.printer.Printer.set_global_settings",
    "type": "method",
    "description": "Set system-wide printing settings.",
    "section": "Common mistakes",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "pretty",
    "full_id": "sympy.printing.pretty.pretty.pretty",
    "type": "function",
    "description": "Returns a string containing the prettified form of expr.\n\n    For information on keyword arguments see pretty_print function.\n\n    ",
    "section": "PrettyPrinter Class",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "pretty_print",
    "full_id": "sympy.printing.pretty.pretty.pretty_print",
    "type": "function",
    "description": "Prints expr in pretty form.\n\n    pprint is just a shortcut for this function.\n\n    Parameters\n    ==========\n\n    expr : expression\n        The expression to print.\n\n    wrap_line : bool, optional (default=True)\n        Line wrapping enabled/disabled.\n\n    num_columns : int or None, optional (default=None)\n        Number of columns before line breaking (default to None which reads\n        the terminal width), useful when using SymPy without terminal.\n\n    use_unicode : bool or None, optional (default=None)\n        Use unicode characters, such as the Greek letter pi instead of\n        the string pi.\n\n    full_prec : bool or string, optional (default=\"auto\")\n        Use full precision.\n\n    order : bool or string, optional (default=None)\n        Set to 'none' for long expressions if slow; default is None.\n\n    use_unicode_sqrt_char : bool, optional (default=True)\n        Use compact single-character square root symbol (when unambiguous).\n\n    root_notation : bool, optional (default=True)\n        Set to 'False' for printing exponents of the form 1/n in fractional form.\n        By default exponent is printed in root form.\n\n    mat_symbol_style : string, optional (default=\"plain\")\n        Set to \"bold\" for printing MatrixSymbols using a bold mathematical symbol face.\n        By default the standard face is used.\n\n    imaginary_unit : string, optional (default=\"i\")\n        Letter to use for imaginary unit when use_unicode is True.\n        Can be \"i\" (default) or \"j\".\n    ",
    "section": "PrettyPrinter Class",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "indent_code",
    "full_id": "sympy.printing.c.C89CodePrinter.indent_code",
    "type": "method",
    "description": "Accepts a string of code or a list of code lines",
    "section": "C code printers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "ccode",
    "full_id": "sympy.printing.c.ccode",
    "type": "function",
    "description": "Converts an expr to a string of c code\n\n    Parameters\n    ==========\n\n    expr : Expr\n        A SymPy expression to be converted.\n    assign_to : optional\n        When given, the argument is used as the name of the variable to which\n        the expression is assigned. Can be a string, ``Symbol``,\n        ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of\n        line-wrapping, or for expressions that generate multi-line statements.\n    standard : str, optional\n        String specifying the standard. If your compiler supports a more modern\n        standard you may set this to 'c99' to allow the printer to use more math\n        functions. [default='c89'].\n    precision : integer, optional\n        The precision for numbers such as pi [default=17].\n    user_functions : dict, optional\n        A dictionary where the keys are string representations of either\n        ``FunctionClass`` or ``UndefinedFunction`` instances and the values\n        are their desired C string representations. Alternatively, the\n        dictionary value can be a list of tuples i.e. [(argument_test,\n        cfunction_string)] or [(argument_test, cfunction_formater)]. See below\n        for examples.\n    dereference : iterable, optional\n        An iterable of symbols that should be dereferenced in the printed code\n        expression. These would be values passed by address to the function.\n        For example, if ``dereference=[a]``, the resulting code would print\n        ``(*a)`` instead of ``a``.\n    human : bool, optional\n        If True, the result is a single string that may contain some constant\n        declarations for the number symbols. If False, the same information is\n        returned in a tuple of (symbols_to_declare, not_supported_functions,\n        code_text). [default=True].\n    contract: bool, optional\n        If True, ``Indexed`` instances are assumed to obey tensor contraction\n        rules and the corresponding nested loops over indices are generated.\n        Setting contract=False will not generate loops, instead the user is\n        responsible to provide values for the indices in the code.\n        [default=True].\n\n    Examples\n    ========\n\n    >>> from sympy import ccode, symbols, Rational, sin, ceiling, Abs, Function\n    >>> x, tau = symbols(\"x, tau\")\n    >>> expr = (2*tau)**Rational(7, 2)\n    >>> ccode(expr)\n    '8*M_SQRT2*pow(tau, 7.0/2.0)'\n    >>> ccode(expr, math_macros={})\n    '8*sqrt(2)*pow(tau, 7.0/2.0)'\n    >>> ccode(sin(x), assign_to=\"s\")\n    's = sin(x);'\n    >>> from sympy.codegen.ast import real, float80\n    >>> ccode(expr, type_aliases={real: float80})\n    '8*M_SQRT2l*powl(tau, 7.0L/2.0L)'\n\n    Simple custom printing can be defined for certain types by passing a\n    dictionary of {\"type\" : \"function\"} to the ``user_functions`` kwarg.\n    Alternatively, the dictionary value can be a list of tuples i.e.\n    [(argument_test, cfunction_string)].\n\n    >>> custom_functions = {\n    ...   \"ceiling\": \"CEIL\",\n    ...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\"),\n    ...           (lambda x: x.is_integer, \"ABS\")],\n    ...   \"func\": \"f\"\n    ... }\n    >>> func = Function('func')\n    >>> ccode(func(Abs(x) + ceiling(x)), standard='C89', user_functions=custom_functions)\n    'f(fabs(x) + CEIL(x))'\n\n    or if the C-function takes a subset of the original arguments:\n\n    >>> ccode(2**x + 3**x, standard='C99', user_functions={'Pow': [\n    ...   (lambda b, e: b == 2, lambda b, e: 'exp2(%s)' % e),\n    ...   (lambda b, e: b != 2, 'pow')]})\n    'exp2(x) + pow(3, x)'\n\n    ``Piecewise`` expressions are converted into conditionals. If an\n    ``assign_to`` variable is provided an if statement is created, otherwise\n    the ternary operator is used. Note that if the ``Piecewise`` lacks a\n    default term, represented by ``(expr, True)`` then an error will be thrown.\n    This is to prevent generating an expression that may not evaluate to\n    anything.\n\n    >>> from sympy import Piecewise\n    >>> expr = Piecewise((x + 1, x > 0), (x, True))\n    >>> print(ccode(expr, tau, standard='C89'))\n    if (x > 0) {\n    tau = x + 1;\n    }\n    else {\n    tau = x;\n    }\n\n    Support for loops is provided through ``Indexed`` types. With\n    ``contract=True`` these expressions will be turned into loops, whereas\n    ``contract=False`` will just print the assignment expression that should be\n    looped over:\n\n    >>> from sympy import Eq, IndexedBase, Idx\n    >>> len_y = 5\n    >>> y = IndexedBase('y', shape=(len_y,))\n    >>> t = IndexedBase('t', shape=(len_y,))\n    >>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n    >>> i = Idx('i', len_y-1)\n    >>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n    >>> ccode(e.rhs, assign_to=e.lhs, contract=False, standard='C89')\n    'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);'\n\n    Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions\n    must be provided to ``assign_to``. Note that any expression that can be\n    generated normally can also exist inside a Matrix:\n\n    >>> from sympy import Matrix, MatrixSymbol\n    >>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n    >>> A = MatrixSymbol('A', 3, 1)\n    >>> print(ccode(mat, A, standard='C89'))\n    A[0] = pow(x, 2);\n    if (x > 0) {\n       A[1] = x + 1;\n    }\n    else {\n       A[1] = x;\n    }\n    A[2] = sin(x);\n    ",
    "section": "C code printers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "print_ccode",
    "full_id": "sympy.printing.c.print_ccode",
    "type": "function",
    "description": "Prints C representation of the given expression.",
    "section": "C code printers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "cxxcode",
    "full_id": "sympy.printing.codeprinter.cxxcode",
    "type": "function",
    "description": "C++ equivalent of :func:`~.ccode`.",
    "section": "C++ code printers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "rcode",
    "full_id": "sympy.printing.rcode.rcode",
    "type": "function",
    "description": "Converts an expr to a string of r code\n\n    Parameters\n    ==========\n\n    expr : Expr\n        A SymPy expression to be converted.\n    assign_to : optional\n        When given, the argument is used as the name of the variable to which\n        the expression is assigned. Can be a string, ``Symbol``,\n        ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of\n        line-wrapping, or for expressions that generate multi-line statements.\n    precision : integer, optional\n        The precision for numbers such as pi [default=15].\n    user_functions : dict, optional\n        A dictionary where the keys are string representations of either\n        ``FunctionClass`` or ``UndefinedFunction`` instances and the values\n        are their desired R string representations. Alternatively, the\n        dictionary value can be a list of tuples i.e. [(argument_test,\n        rfunction_string)] or [(argument_test, rfunction_formater)]. See below\n        for examples.\n    human : bool, optional\n        If True, the result is a single string that may contain some constant\n        declarations for the number symbols. If False, the same information is\n        returned in a tuple of (symbols_to_declare, not_supported_functions,\n        code_text). [default=True].\n    contract: bool, optional\n        If True, ``Indexed`` instances are assumed to obey tensor contraction\n        rules and the corresponding nested loops over indices are generated.\n        Setting contract=False will not generate loops, instead the user is\n        responsible to provide values for the indices in the code.\n        [default=True].\n\n    Examples\n    ========\n\n    >>> from sympy import rcode, symbols, Rational, sin, ceiling, Abs, Function\n    >>> x, tau = symbols(\"x, tau\")\n    >>> rcode((2*tau)**Rational(7, 2))\n    '8*sqrt(2)*tau^(7.0/2.0)'\n    >>> rcode(sin(x), assign_to=\"s\")\n    's = sin(x);'\n\n    Simple custom printing can be defined for certain types by passing a\n    dictionary of {\"type\" : \"function\"} to the ``user_functions`` kwarg.\n    Alternatively, the dictionary value can be a list of tuples i.e.\n    [(argument_test, cfunction_string)].\n\n    >>> custom_functions = {\n    ...   \"ceiling\": \"CEIL\",\n    ...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\"),\n    ...           (lambda x: x.is_integer, \"ABS\")],\n    ...   \"func\": \"f\"\n    ... }\n    >>> func = Function('func')\n    >>> rcode(func(Abs(x) + ceiling(x)), user_functions=custom_functions)\n    'f(fabs(x) + CEIL(x))'\n\n    or if the R-function takes a subset of the original arguments:\n\n    >>> rcode(2**x + 3**x, user_functions={'Pow': [\n    ...   (lambda b, e: b == 2, lambda b, e: 'exp2(%s)' % e),\n    ...   (lambda b, e: b != 2, 'pow')]})\n    'exp2(x) + pow(3, x)'\n\n    ``Piecewise`` expressions are converted into conditionals. If an\n    ``assign_to`` variable is provided an if statement is created, otherwise\n    the ternary operator is used. Note that if the ``Piecewise`` lacks a\n    default term, represented by ``(expr, True)`` then an error will be thrown.\n    This is to prevent generating an expression that may not evaluate to\n    anything.\n\n    >>> from sympy import Piecewise\n    >>> expr = Piecewise((x + 1, x > 0), (x, True))\n    >>> print(rcode(expr, assign_to=tau))\n    tau = ifelse(x > 0,x + 1,x);\n\n    Support for loops is provided through ``Indexed`` types. With\n    ``contract=True`` these expressions will be turned into loops, whereas\n    ``contract=False`` will just print the assignment expression that should be\n    looped over:\n\n    >>> from sympy import Eq, IndexedBase, Idx\n    >>> len_y = 5\n    >>> y = IndexedBase('y', shape=(len_y,))\n    >>> t = IndexedBase('t', shape=(len_y,))\n    >>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n    >>> i = Idx('i', len_y-1)\n    >>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n    >>> rcode(e.rhs, assign_to=e.lhs, contract=False)\n    'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);'\n\n    Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions\n    must be provided to ``assign_to``. Note that any expression that can be\n    generated normally can also exist inside a Matrix:\n\n    >>> from sympy import Matrix, MatrixSymbol\n    >>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n    >>> A = MatrixSymbol('A', 3, 1)\n    >>> print(rcode(mat, A))\n    A[0] = x^2;\n    A[1] = ifelse(x > 0,x + 1,x);\n    A[2] = sin(x);\n\n    ",
    "section": "RCodePrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "print_rcode",
    "full_id": "sympy.printing.rcode.print_rcode",
    "type": "function",
    "description": "Prints R representation of the given expression.",
    "section": "RCodePrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "fcode",
    "full_id": "sympy.printing.fortran.fcode",
    "type": "function",
    "description": "Converts an expr to a string of fortran code\n\n    Parameters\n    ==========\n\n    expr : Expr\n        A SymPy expression to be converted.\n    assign_to : optional\n        When given, the argument is used as the name of the variable to which\n        the expression is assigned. Can be a string, ``Symbol``,\n        ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of\n        line-wrapping, or for expressions that generate multi-line statements.\n    precision : integer, optional\n        DEPRECATED. Use type_mappings instead. The precision for numbers such\n        as pi [default=17].\n    user_functions : dict, optional\n        A dictionary where keys are ``FunctionClass`` instances and values are\n        their string representations. Alternatively, the dictionary value can\n        be a list of tuples i.e. [(argument_test, cfunction_string)]. See below\n        for examples.\n    human : bool, optional\n        If True, the result is a single string that may contain some constant\n        declarations for the number symbols. If False, the same information is\n        returned in a tuple of (symbols_to_declare, not_supported_functions,\n        code_text). [default=True].\n    contract: bool, optional\n        If True, ``Indexed`` instances are assumed to obey tensor contraction\n        rules and the corresponding nested loops over indices are generated.\n        Setting contract=False will not generate loops, instead the user is\n        responsible to provide values for the indices in the code.\n        [default=True].\n    source_format : optional\n        The source format can be either 'fixed' or 'free'. [default='fixed']\n    standard : integer, optional\n        The Fortran standard to be followed. This is specified as an integer.\n        Acceptable standards are 66, 77, 90, 95, 2003, and 2008. Default is 77.\n        Note that currently the only distinction internally is between\n        standards before 95, and those 95 and after. This may change later as\n        more features are added.\n    name_mangling : bool, optional\n        If True, then the variables that would become identical in\n        case-insensitive Fortran are mangled by appending different number\n        of ``_`` at the end. If False, SymPy Will not interfere with naming of\n        variables. [default=True]\n\n    Examples\n    ========\n\n    >>> from sympy import fcode, symbols, Rational, sin, ceiling, floor\n    >>> x, tau = symbols(\"x, tau\")\n    >>> fcode((2*tau)**Rational(7, 2))\n    '      8*sqrt(2.0d0)*tau**(7.0d0/2.0d0)'\n    >>> fcode(sin(x), assign_to=\"s\")\n    '      s = sin(x)'\n\n    Custom printing can be defined for certain types by passing a dictionary of\n    \"type\" : \"function\" to the ``user_functions`` kwarg. Alternatively, the\n    dictionary value can be a list of tuples i.e. [(argument_test,\n    cfunction_string)].\n\n    >>> custom_functions = {\n    ...   \"ceiling\": \"CEIL\",\n    ...   \"floor\": [(lambda x: not x.is_integer, \"FLOOR1\"),\n    ...             (lambda x: x.is_integer, \"FLOOR2\")]\n    ... }\n    >>> fcode(floor(x) + ceiling(x), user_functions=custom_functions)\n    '      CEIL(x) + FLOOR1(x)'\n\n    ``Piecewise`` expressions are converted into conditionals. If an\n    ``assign_to`` variable is provided an if statement is created, otherwise\n    the ternary operator is used. Note that if the ``Piecewise`` lacks a\n    default term, represented by ``(expr, True)`` then an error will be thrown.\n    This is to prevent generating an expression that may not evaluate to\n    anything.\n\n    >>> from sympy import Piecewise\n    >>> expr = Piecewise((x + 1, x > 0), (x, True))\n    >>> print(fcode(expr, tau))\n          if (x > 0) then\n             tau = x + 1\n          else\n             tau = x\n          end if\n\n    Support for loops is provided through ``Indexed`` types. With\n    ``contract=True`` these expressions will be turned into loops, whereas\n    ``contract=False`` will just print the assignment expression that should be\n    looped over:\n\n    >>> from sympy import Eq, IndexedBase, Idx\n    >>> len_y = 5\n    >>> y = IndexedBase('y', shape=(len_y,))\n    >>> t = IndexedBase('t', shape=(len_y,))\n    >>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n    >>> i = Idx('i', len_y-1)\n    >>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n    >>> fcode(e.rhs, assign_to=e.lhs, contract=False)\n    '      Dy(i) = (y(i + 1) - y(i))/(t(i + 1) - t(i))'\n\n    Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions\n    must be provided to ``assign_to``. Note that any expression that can be\n    generated normally can also exist inside a Matrix:\n\n    >>> from sympy import Matrix, MatrixSymbol\n    >>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n    >>> A = MatrixSymbol('A', 3, 1)\n    >>> print(fcode(mat, A))\n          A(1, 1) = x**2\n             if (x > 0) then\n          A(2, 1) = x + 1\n             else\n          A(2, 1) = x\n             end if\n          A(3, 1) = sin(x)\n    ",
    "section": "Fortran Printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "print_fcode",
    "full_id": "sympy.printing.fortran.print_fcode",
    "type": "function",
    "description": "Prints the Fortran representation of the given expression.\n\n    See fcode for the meaning of the optional arguments.\n    ",
    "section": "Fortran Printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "smtlib_code",
    "full_id": "sympy.printing.smtlib.smtlib_code",
    "type": "function",
    "description": "Converts ``expr`` to a string of smtlib code.\n\n    Parameters\n    ==========\n\n    expr : Expr | List[Expr]\n        A SymPy expression or system to be converted.\n    auto_assert : bool, optional\n        If false, do not modify expr and produce only the S-Expression equivalent of expr.\n        If true, assume expr is a system and assert each boolean element.\n    auto_declare : bool, optional\n        If false, do not produce declarations for the symbols used in expr.\n        If true, prepend all necessary declarations for variables used in expr based on symbol_table.\n    precision : integer, optional\n        The ``evalf(..)`` precision for numbers such as pi.\n    symbol_table : dict, optional\n        A dictionary where keys are ``Symbol`` or ``Function`` instances and values are their Python type i.e. ``bool``, ``int``, ``float``, or ``Callable[...]``.\n        If incomplete, an attempt will be made to infer types from ``expr``.\n    known_types: dict, optional\n        A dictionary where keys are ``bool``, ``int``, ``float`` etc. and values are their corresponding SMT type names.\n        If not given, a partial listing compatible with several solvers will be used.\n    known_functions : dict, optional\n        A dictionary where keys are ``Function``, ``Relational``, ``BooleanFunction``, or ``Expr`` instances and values are their SMT string representations.\n        If not given, a partial listing optimized for dReal solver (but compatible with others) will be used.\n    known_constants: dict, optional\n        A dictionary where keys are ``NumberSymbol`` instances and values are their SMT variable names.\n        When using this feature, extra caution must be taken to avoid naming collisions between user symbols and listed constants.\n        If not given, constants will be expanded inline i.e. ``3.14159`` instead of ``MY_SMT_VARIABLE_FOR_PI``.\n    prefix_expressions: list, optional\n        A list of lists of ``str`` and/or expressions to convert into SMTLib and prefix to the output.\n    suffix_expressions: list, optional\n        A list of lists of ``str`` and/or expressions to convert into SMTLib and postfix to the output.\n    log_warn: lambda function, optional\n        A function to record all warnings during potentially risky operations.\n        Soundness is a core value in SMT solving, so it is good to log all assumptions made.\n\n    Examples\n    ========\n    >>> from sympy import smtlib_code, symbols, sin, Eq\n    >>> x = symbols('x')\n    >>> smtlib_code(sin(x).series(x).removeO(), log_warn=print)\n    Could not infer type of `x`. Defaulting to float.\n    Non-Boolean expression `x**5/120 - x**3/6 + x` will not be asserted. Converting to SMTLib verbatim.\n    '(declare-const x Real)\\n(+ x (* (/ -1 6) (pow x 3)) (* (/ 1 120) (pow x 5)))'\n\n    >>> from sympy import Rational\n    >>> x, y, tau = symbols(\"x, y, tau\")\n    >>> smtlib_code((2*tau)**Rational(7, 2), log_warn=print)\n    Could not infer type of `tau`. Defaulting to float.\n    Non-Boolean expression `8*sqrt(2)*tau**(7/2)` will not be asserted. Converting to SMTLib verbatim.\n    '(declare-const tau Real)\\n(* 8 (pow 2 (/ 1 2)) (pow tau (/ 7 2)))'\n\n    ``Piecewise`` expressions are implemented with ``ite`` expressions by default.\n    Note that if the ``Piecewise`` lacks a default term, represented by\n    ``(expr, True)`` then an error will be thrown.  This is to prevent\n    generating an expression that may not evaluate to anything.\n\n    >>> from sympy import Piecewise\n    >>> pw = Piecewise((x + 1, x > 0), (x, True))\n    >>> smtlib_code(Eq(pw, 3), symbol_table={x: float}, log_warn=print)\n    '(declare-const x Real)\\n(assert (= (ite (> x 0) (+ 1 x) x) 3))'\n\n    Custom printing can be defined for certain types by passing a dictionary of\n    PythonType : \"SMT Name\" to the ``known_types``, ``known_constants``, and ``known_functions`` kwargs.\n\n    >>> from typing import Callable\n    >>> from sympy import Function, Add\n    >>> f = Function('f')\n    >>> g = Function('g')\n    >>> smt_builtin_funcs = {  # functions our SMT solver will understand\n    ...   f: \"existing_smtlib_fcn\",\n    ...   Add: \"sum\",\n    ... }\n    >>> user_def_funcs = {  # functions defined by the user must have their types specified explicitly\n    ...   g: Callable[[int], float],\n    ... }\n    >>> smtlib_code(f(x) + g(x), symbol_table=user_def_funcs, known_functions=smt_builtin_funcs, log_warn=print)\n    Non-Boolean expression `f(x) + g(x)` will not be asserted. Converting to SMTLib verbatim.\n    '(declare-const x Int)\\n(declare-fun g (Int) Real)\\n(sum (existing_smtlib_fcn x) (g x))'\n    ",
    "section": "SMT-Lib printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "mathematica_code",
    "full_id": "sympy.printing.mathematica.mathematica_code",
    "type": "function",
    "description": "Converts an expr to a string of the Wolfram Mathematica code\n\n    Examples\n    ========\n\n    >>> from sympy import mathematica_code as mcode, symbols, sin\n    >>> x = symbols('x')\n    >>> mcode(sin(x).series(x).removeO())\n    '(1/120)*x^5 - 1/6*x^3 + x'\n    ",
    "section": "Mathematica code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "maple_code",
    "full_id": "sympy.printing.maple.maple_code",
    "type": "function",
    "description": "Converts ``expr`` to a string of Maple code.\n\n    Parameters\n    ==========\n\n    expr : Expr\n        A SymPy expression to be converted.\n    assign_to : optional\n        When given, the argument is used as the name of the variable to which\n        the expression is assigned.  Can be a string, ``Symbol``,\n        ``MatrixSymbol``, or ``Indexed`` type.  This can be helpful for\n        expressions that generate multi-line statements.\n    precision : integer, optional\n        The precision for numbers such as pi  [default=16].\n    user_functions : dict, optional\n        A dictionary where keys are ``FunctionClass`` instances and values are\n        their string representations.  Alternatively, the dictionary value can\n        be a list of tuples i.e. [(argument_test, cfunction_string)].  See\n        below for examples.\n    human : bool, optional\n        If True, the result is a single string that may contain some constant\n        declarations for the number symbols.  If False, the same information is\n        returned in a tuple of (symbols_to_declare, not_supported_functions,\n        code_text).  [default=True].\n    contract: bool, optional\n        If True, ``Indexed`` instances are assumed to obey tensor contraction\n        rules and the corresponding nested loops over indices are generated.\n        Setting contract=False will not generate loops, instead the user is\n        responsible to provide values for the indices in the code.\n        [default=True].\n    inline: bool, optional\n        If True, we try to create single-statement code instead of multiple\n        statements.  [default=True].\n\n    ",
    "section": "Maple code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "print_maple_code",
    "full_id": "sympy.printing.maple.print_maple_code",
    "type": "function",
    "description": "Prints the Maple representation of the given expression.\n\n    See :func:`maple_code` for the meaning of the optional arguments.\n\n    Examples\n    ========\n\n    >>> from sympy import print_maple_code, symbols\n    >>> x, y = symbols('x y')\n    >>> print_maple_code(x, assign_to=y)\n    y := x\n    ",
    "section": "Maple code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "jscode",
    "full_id": "sympy.printing.jscode.jscode",
    "type": "function",
    "description": "Converts an expr to a string of javascript code\n\n    Parameters\n    ==========\n\n    expr : Expr\n        A SymPy expression to be converted.\n    assign_to : optional\n        When given, the argument is used as the name of the variable to which\n        the expression is assigned. Can be a string, ``Symbol``,\n        ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of\n        line-wrapping, or for expressions that generate multi-line statements.\n    precision : integer, optional\n        The precision for numbers such as pi [default=15].\n    user_functions : dict, optional\n        A dictionary where keys are ``FunctionClass`` instances and values are\n        their string representations. Alternatively, the dictionary value can\n        be a list of tuples i.e. [(argument_test, js_function_string)]. See\n        below for examples.\n    human : bool, optional\n        If True, the result is a single string that may contain some constant\n        declarations for the number symbols. If False, the same information is\n        returned in a tuple of (symbols_to_declare, not_supported_functions,\n        code_text). [default=True].\n    contract: bool, optional\n        If True, ``Indexed`` instances are assumed to obey tensor contraction\n        rules and the corresponding nested loops over indices are generated.\n        Setting contract=False will not generate loops, instead the user is\n        responsible to provide values for the indices in the code.\n        [default=True].\n\n    Examples\n    ========\n\n    >>> from sympy import jscode, symbols, Rational, sin, ceiling, Abs\n    >>> x, tau = symbols(\"x, tau\")\n    >>> jscode((2*tau)**Rational(7, 2))\n    '8*Math.sqrt(2)*Math.pow(tau, 7/2)'\n    >>> jscode(sin(x), assign_to=\"s\")\n    's = Math.sin(x);'\n\n    Custom printing can be defined for certain types by passing a dictionary of\n    \"type\" : \"function\" to the ``user_functions`` kwarg. Alternatively, the\n    dictionary value can be a list of tuples i.e. [(argument_test,\n    js_function_string)].\n\n    >>> custom_functions = {\n    ...   \"ceiling\": \"CEIL\",\n    ...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\"),\n    ...           (lambda x: x.is_integer, \"ABS\")]\n    ... }\n    >>> jscode(Abs(x) + ceiling(x), user_functions=custom_functions)\n    'fabs(x) + CEIL(x)'\n\n    ``Piecewise`` expressions are converted into conditionals. If an\n    ``assign_to`` variable is provided an if statement is created, otherwise\n    the ternary operator is used. Note that if the ``Piecewise`` lacks a\n    default term, represented by ``(expr, True)`` then an error will be thrown.\n    This is to prevent generating an expression that may not evaluate to\n    anything.\n\n    >>> from sympy import Piecewise\n    >>> expr = Piecewise((x + 1, x > 0), (x, True))\n    >>> print(jscode(expr, tau))\n    if (x > 0) {\n       tau = x + 1;\n    }\n    else {\n       tau = x;\n    }\n\n    Support for loops is provided through ``Indexed`` types. With\n    ``contract=True`` these expressions will be turned into loops, whereas\n    ``contract=False`` will just print the assignment expression that should be\n    looped over:\n\n    >>> from sympy import Eq, IndexedBase, Idx\n    >>> len_y = 5\n    >>> y = IndexedBase('y', shape=(len_y,))\n    >>> t = IndexedBase('t', shape=(len_y,))\n    >>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n    >>> i = Idx('i', len_y-1)\n    >>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n    >>> jscode(e.rhs, assign_to=e.lhs, contract=False)\n    'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);'\n\n    Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions\n    must be provided to ``assign_to``. Note that any expression that can be\n    generated normally can also exist inside a Matrix:\n\n    >>> from sympy import Matrix, MatrixSymbol\n    >>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n    >>> A = MatrixSymbol('A', 3, 1)\n    >>> print(jscode(mat, A))\n    A[0] = Math.pow(x, 2);\n    if (x > 0) {\n       A[1] = x + 1;\n    }\n    else {\n       A[1] = x;\n    }\n    A[2] = Math.sin(x);\n    ",
    "section": "Javascript Code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "julia_code",
    "full_id": "sympy.printing.julia.julia_code",
    "type": "function",
    "description": "Converts `expr` to a string of Julia code.\n\n    Parameters\n    ==========\n\n    expr : Expr\n        A SymPy expression to be converted.\n    assign_to : optional\n        When given, the argument is used as the name of the variable to which\n        the expression is assigned.  Can be a string, ``Symbol``,\n        ``MatrixSymbol``, or ``Indexed`` type.  This can be helpful for\n        expressions that generate multi-line statements.\n    precision : integer, optional\n        The precision for numbers such as pi  [default=16].\n    user_functions : dict, optional\n        A dictionary where keys are ``FunctionClass`` instances and values are\n        their string representations.  Alternatively, the dictionary value can\n        be a list of tuples i.e. [(argument_test, cfunction_string)].  See\n        below for examples.\n    human : bool, optional\n        If True, the result is a single string that may contain some constant\n        declarations for the number symbols.  If False, the same information is\n        returned in a tuple of (symbols_to_declare, not_supported_functions,\n        code_text).  [default=True].\n    contract: bool, optional\n        If True, ``Indexed`` instances are assumed to obey tensor contraction\n        rules and the corresponding nested loops over indices are generated.\n        Setting contract=False will not generate loops, instead the user is\n        responsible to provide values for the indices in the code.\n        [default=True].\n    inline: bool, optional\n        If True, we try to create single-statement code instead of multiple\n        statements.  [default=True].\n\n    Examples\n    ========\n\n    >>> from sympy import julia_code, symbols, sin, pi\n    >>> x = symbols('x')\n    >>> julia_code(sin(x).series(x).removeO())\n    'x .^ 5 / 120 - x .^ 3 / 6 + x'\n\n    >>> from sympy import Rational, ceiling\n    >>> x, y, tau = symbols(\"x, y, tau\")\n    >>> julia_code((2*tau)**Rational(7, 2))\n    '8 * sqrt(2) * tau .^ (7 // 2)'\n\n    Note that element-wise (Hadamard) operations are used by default between\n    symbols.  This is because its possible in Julia to write \"vectorized\"\n    code.  It is harmless if the values are scalars.\n\n    >>> julia_code(sin(pi*x*y), assign_to=\"s\")\n    's = sin(pi * x .* y)'\n\n    If you need a matrix product \"*\" or matrix power \"^\", you can specify the\n    symbol as a ``MatrixSymbol``.\n\n    >>> from sympy import Symbol, MatrixSymbol\n    >>> n = Symbol('n', integer=True, positive=True)\n    >>> A = MatrixSymbol('A', n, n)\n    >>> julia_code(3*pi*A**3)\n    '(3 * pi) * A ^ 3'\n\n    This class uses several rules to decide which symbol to use a product.\n    Pure numbers use \"*\", Symbols use \".*\" and MatrixSymbols use \"*\".\n    A HadamardProduct can be used to specify componentwise multiplication \".*\"\n    of two MatrixSymbols.  There is currently there is no easy way to specify\n    scalar symbols, so sometimes the code might have some minor cosmetic\n    issues.  For example, suppose x and y are scalars and A is a Matrix, then\n    while a human programmer might write \"(x^2*y)*A^3\", we generate:\n\n    >>> julia_code(x**2*y*A**3)\n    '(x .^ 2 .* y) * A ^ 3'\n\n    Matrices are supported using Julia inline notation.  When using\n    ``assign_to`` with matrices, the name can be specified either as a string\n    or as a ``MatrixSymbol``.  The dimensions must align in the latter case.\n\n    >>> from sympy import Matrix, MatrixSymbol\n    >>> mat = Matrix([[x**2, sin(x), ceiling(x)]])\n    >>> julia_code(mat, assign_to='A')\n    'A = [x .^ 2 sin(x) ceil(x)]'\n\n    ``Piecewise`` expressions are implemented with logical masking by default.\n    Alternatively, you can pass \"inline=False\" to use if-else conditionals.\n    Note that if the ``Piecewise`` lacks a default term, represented by\n    ``(expr, True)`` then an error will be thrown.  This is to prevent\n    generating an expression that may not evaluate to anything.\n\n    >>> from sympy import Piecewise\n    >>> pw = Piecewise((x + 1, x > 0), (x, True))\n    >>> julia_code(pw, assign_to=tau)\n    'tau = ((x > 0) ? (x + 1) : (x))'\n\n    Note that any expression that can be generated normally can also exist\n    inside a Matrix:\n\n    >>> mat = Matrix([[x**2, pw, sin(x)]])\n    >>> julia_code(mat, assign_to='A')\n    'A = [x .^ 2 ((x > 0) ? (x + 1) : (x)) sin(x)]'\n\n    Custom printing can be defined for certain types by passing a dictionary of\n    \"type\" : \"function\" to the ``user_functions`` kwarg.  Alternatively, the\n    dictionary value can be a list of tuples i.e., [(argument_test,\n    cfunction_string)].  This can be used to call a custom Julia function.\n\n    >>> from sympy import Function\n    >>> f = Function('f')\n    >>> g = Function('g')\n    >>> custom_functions = {\n    ...   \"f\": \"existing_julia_fcn\",\n    ...   \"g\": [(lambda x: x.is_Matrix, \"my_mat_fcn\"),\n    ...         (lambda x: not x.is_Matrix, \"my_fcn\")]\n    ... }\n    >>> mat = Matrix([[1, x]])\n    >>> julia_code(f(x) + g(x) + g(mat), user_functions=custom_functions)\n    'existing_julia_fcn(x) + my_fcn(x) + my_mat_fcn([1 x])'\n\n    Support for loops is provided through ``Indexed`` types. With\n    ``contract=True`` these expressions will be turned into loops, whereas\n    ``contract=False`` will just print the assignment expression that should be\n    looped over:\n\n    >>> from sympy import Eq, IndexedBase, Idx\n    >>> len_y = 5\n    >>> y = IndexedBase('y', shape=(len_y,))\n    >>> t = IndexedBase('t', shape=(len_y,))\n    >>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n    >>> i = Idx('i', len_y-1)\n    >>> e = Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n    >>> julia_code(e.rhs, assign_to=e.lhs, contract=False)\n    'Dy[i] = (y[i + 1] - y[i]) ./ (t[i + 1] - t[i])'\n    ",
    "section": "Julia code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "octave_code",
    "full_id": "sympy.printing.octave.octave_code",
    "type": "function",
    "description": "Converts `expr` to a string of Octave (or Matlab) code.\n\n    The string uses a subset of the Octave language for Matlab compatibility.\n\n    Parameters\n    ==========\n\n    expr : Expr\n        A SymPy expression to be converted.\n    assign_to : optional\n        When given, the argument is used as the name of the variable to which\n        the expression is assigned.  Can be a string, ``Symbol``,\n        ``MatrixSymbol``, or ``Indexed`` type.  This can be helpful for\n        expressions that generate multi-line statements.\n    precision : integer, optional\n        The precision for numbers such as pi  [default=16].\n    user_functions : dict, optional\n        A dictionary where keys are ``FunctionClass`` instances and values are\n        their string representations.  Alternatively, the dictionary value can\n        be a list of tuples i.e. [(argument_test, cfunction_string)].  See\n        below for examples.\n    human : bool, optional\n        If True, the result is a single string that may contain some constant\n        declarations for the number symbols.  If False, the same information is\n        returned in a tuple of (symbols_to_declare, not_supported_functions,\n        code_text).  [default=True].\n    contract: bool, optional\n        If True, ``Indexed`` instances are assumed to obey tensor contraction\n        rules and the corresponding nested loops over indices are generated.\n        Setting contract=False will not generate loops, instead the user is\n        responsible to provide values for the indices in the code.\n        [default=True].\n    inline: bool, optional\n        If True, we try to create single-statement code instead of multiple\n        statements.  [default=True].\n\n    Examples\n    ========\n\n    >>> from sympy import octave_code, symbols, sin, pi\n    >>> x = symbols('x')\n    >>> octave_code(sin(x).series(x).removeO())\n    'x.^5/120 - x.^3/6 + x'\n\n    >>> from sympy import Rational, ceiling\n    >>> x, y, tau = symbols(\"x, y, tau\")\n    >>> octave_code((2*tau)**Rational(7, 2))\n    '8*sqrt(2)*tau.^(7/2)'\n\n    Note that element-wise (Hadamard) operations are used by default between\n    symbols.  This is because its very common in Octave to write \"vectorized\"\n    code.  It is harmless if the values are scalars.\n\n    >>> octave_code(sin(pi*x*y), assign_to=\"s\")\n    's = sin(pi*x.*y);'\n\n    If you need a matrix product \"*\" or matrix power \"^\", you can specify the\n    symbol as a ``MatrixSymbol``.\n\n    >>> from sympy import Symbol, MatrixSymbol\n    >>> n = Symbol('n', integer=True, positive=True)\n    >>> A = MatrixSymbol('A', n, n)\n    >>> octave_code(3*pi*A**3)\n    '(3*pi)*A^3'\n\n    This class uses several rules to decide which symbol to use a product.\n    Pure numbers use \"*\", Symbols use \".*\" and MatrixSymbols use \"*\".\n    A HadamardProduct can be used to specify componentwise multiplication \".*\"\n    of two MatrixSymbols.  There is currently there is no easy way to specify\n    scalar symbols, so sometimes the code might have some minor cosmetic\n    issues.  For example, suppose x and y are scalars and A is a Matrix, then\n    while a human programmer might write \"(x^2*y)*A^3\", we generate:\n\n    >>> octave_code(x**2*y*A**3)\n    '(x.^2.*y)*A^3'\n\n    Matrices are supported using Octave inline notation.  When using\n    ``assign_to`` with matrices, the name can be specified either as a string\n    or as a ``MatrixSymbol``.  The dimensions must align in the latter case.\n\n    >>> from sympy import Matrix, MatrixSymbol\n    >>> mat = Matrix([[x**2, sin(x), ceiling(x)]])\n    >>> octave_code(mat, assign_to='A')\n    'A = [x.^2 sin(x) ceil(x)];'\n\n    ``Piecewise`` expressions are implemented with logical masking by default.\n    Alternatively, you can pass \"inline=False\" to use if-else conditionals.\n    Note that if the ``Piecewise`` lacks a default term, represented by\n    ``(expr, True)`` then an error will be thrown.  This is to prevent\n    generating an expression that may not evaluate to anything.\n\n    >>> from sympy import Piecewise\n    >>> pw = Piecewise((x + 1, x > 0), (x, True))\n    >>> octave_code(pw, assign_to=tau)\n    'tau = ((x > 0).*(x + 1) + (~(x > 0)).*(x));'\n\n    Note that any expression that can be generated normally can also exist\n    inside a Matrix:\n\n    >>> mat = Matrix([[x**2, pw, sin(x)]])\n    >>> octave_code(mat, assign_to='A')\n    'A = [x.^2 ((x > 0).*(x + 1) + (~(x > 0)).*(x)) sin(x)];'\n\n    Custom printing can be defined for certain types by passing a dictionary of\n    \"type\" : \"function\" to the ``user_functions`` kwarg.  Alternatively, the\n    dictionary value can be a list of tuples i.e., [(argument_test,\n    cfunction_string)].  This can be used to call a custom Octave function.\n\n    >>> from sympy import Function\n    >>> f = Function('f')\n    >>> g = Function('g')\n    >>> custom_functions = {\n    ...   \"f\": \"existing_octave_fcn\",\n    ...   \"g\": [(lambda x: x.is_Matrix, \"my_mat_fcn\"),\n    ...         (lambda x: not x.is_Matrix, \"my_fcn\")]\n    ... }\n    >>> mat = Matrix([[1, x]])\n    >>> octave_code(f(x) + g(x) + g(mat), user_functions=custom_functions)\n    'existing_octave_fcn(x) + my_fcn(x) + my_mat_fcn([1 x])'\n\n    Support for loops is provided through ``Indexed`` types. With\n    ``contract=True`` these expressions will be turned into loops, whereas\n    ``contract=False`` will just print the assignment expression that should be\n    looped over:\n\n    >>> from sympy import Eq, IndexedBase, Idx\n    >>> len_y = 5\n    >>> y = IndexedBase('y', shape=(len_y,))\n    >>> t = IndexedBase('t', shape=(len_y,))\n    >>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n    >>> i = Idx('i', len_y-1)\n    >>> e = Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n    >>> octave_code(e.rhs, assign_to=e.lhs, contract=False)\n    'Dy(i) = (y(i + 1) - y(i))./(t(i + 1) - t(i));'\n    ",
    "section": "Octave (and Matlab) Code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "rust_code",
    "full_id": "sympy.printing.rust.rust_code",
    "type": "function",
    "description": "Converts an expr to a string of Rust code\n\n    Parameters\n    ==========\n\n    expr : Expr\n        A SymPy expression to be converted.\n    assign_to : optional\n        When given, the argument is used as the name of the variable to which\n        the expression is assigned. Can be a string, ``Symbol``,\n        ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of\n        line-wrapping, or for expressions that generate multi-line statements.\n    precision : integer, optional\n        The precision for numbers such as pi [default=15].\n    user_functions : dict, optional\n        A dictionary where the keys are string representations of either\n        ``FunctionClass`` or ``UndefinedFunction`` instances and the values\n        are their desired C string representations. Alternatively, the\n        dictionary value can be a list of tuples i.e. [(argument_test,\n        cfunction_string)].  See below for examples.\n    dereference : iterable, optional\n        An iterable of symbols that should be dereferenced in the printed code\n        expression. These would be values passed by address to the function.\n        For example, if ``dereference=[a]``, the resulting code would print\n        ``(*a)`` instead of ``a``.\n    human : bool, optional\n        If True, the result is a single string that may contain some constant\n        declarations for the number symbols. If False, the same information is\n        returned in a tuple of (symbols_to_declare, not_supported_functions,\n        code_text). [default=True].\n    contract: bool, optional\n        If True, ``Indexed`` instances are assumed to obey tensor contraction\n        rules and the corresponding nested loops over indices are generated.\n        Setting contract=False will not generate loops, instead the user is\n        responsible to provide values for the indices in the code.\n        [default=True].\n\n    Examples\n    ========\n\n    >>> from sympy import rust_code, symbols, Rational, sin, ceiling, Abs, Function\n    >>> x, tau = symbols(\"x, tau\")\n    >>> rust_code((2*tau)**Rational(7, 2))\n    '8*1.4142135623731*tau.powf(7_f64/2.0)'\n    >>> rust_code(sin(x), assign_to=\"s\")\n    's = x.sin();'\n\n    Simple custom printing can be defined for certain types by passing a\n    dictionary of {\"type\" : \"function\"} to the ``user_functions`` kwarg.\n    Alternatively, the dictionary value can be a list of tuples i.e.\n    [(argument_test, cfunction_string)].\n\n    >>> custom_functions = {\n    ...   \"ceiling\": \"CEIL\",\n    ...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\", 4),\n    ...           (lambda x: x.is_integer, \"ABS\", 4)],\n    ...   \"func\": \"f\"\n    ... }\n    >>> func = Function('func')\n    >>> rust_code(func(Abs(x) + ceiling(x)), user_functions=custom_functions)\n    '(fabs(x) + x.CEIL()).f()'\n\n    ``Piecewise`` expressions are converted into conditionals. If an\n    ``assign_to`` variable is provided an if statement is created, otherwise\n    the ternary operator is used. Note that if the ``Piecewise`` lacks a\n    default term, represented by ``(expr, True)`` then an error will be thrown.\n    This is to prevent generating an expression that may not evaluate to\n    anything.\n\n    >>> from sympy import Piecewise\n    >>> expr = Piecewise((x + 1, x > 0), (x, True))\n    >>> print(rust_code(expr, tau))\n    tau = if (x > 0) {\n        x + 1\n    } else {\n        x\n    };\n\n    Support for loops is provided through ``Indexed`` types. With\n    ``contract=True`` these expressions will be turned into loops, whereas\n    ``contract=False`` will just print the assignment expression that should be\n    looped over:\n\n    >>> from sympy import Eq, IndexedBase, Idx\n    >>> len_y = 5\n    >>> y = IndexedBase('y', shape=(len_y,))\n    >>> t = IndexedBase('t', shape=(len_y,))\n    >>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n    >>> i = Idx('i', len_y-1)\n    >>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n    >>> rust_code(e.rhs, assign_to=e.lhs, contract=False)\n    'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);'\n\n    Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions\n    must be provided to ``assign_to``. Note that any expression that can be\n    generated normally can also exist inside a Matrix:\n\n    >>> from sympy import Matrix, MatrixSymbol\n    >>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n    >>> A = MatrixSymbol('A', 3, 1)\n    >>> print(rust_code(mat, A))\n    A = [x.powi(2), if (x > 0) {\n        x + 1\n    } else {\n        x\n    }, x.sin()];\n    ",
    "section": "Rust code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "doprint",
    "full_id": "sympy.printing.aesaracode.AesaraPrinter.doprint",
    "type": "method",
    "description": "Convert a SymPy expression to a Aesara graph variable.\n\n        The ``dtypes`` and ``broadcastables`` arguments are used to specify the\n        data type, dimension, and broadcasting behavior of the Aesara variables\n        corresponding to the free symbols in ``expr``. Each is a mapping from\n        SymPy symbols to the value of the corresponding argument to\n        ``aesara.tensor.var.TensorVariable``.\n\n        See the corresponding `documentation page`__ for more information on\n        broadcasting in Aesara.\n\n\n        .. __: https://aesara.readthedocs.io/en/latest/reference/tensor/shapes.html#broadcasting\n\n        Parameters\n        ==========\n\n        expr : sympy.core.expr.Expr\n            SymPy expression to print.\n\n        dtypes : dict\n            Mapping from SymPy symbols to Aesara datatypes to use when creating\n            new Aesara variables for those symbols. Corresponds to the ``dtype``\n            argument to ``aesara.tensor.var.TensorVariable``. Defaults to ``'floatX'``\n            for symbols not included in the mapping.\n\n        broadcastables : dict\n            Mapping from SymPy symbols to the value of the ``broadcastable``\n            argument to ``aesara.tensor.var.TensorVariable`` to use when creating Aesara\n            variables for those symbols. Defaults to the empty tuple for symbols\n            not included in the mapping (resulting in a scalar).\n\n        Returns\n        =======\n\n        aesara.graph.basic.Variable\n            A variable corresponding to the expression's value in a Aesara\n            symbolic expression graph.\n\n        ",
    "section": "Aesara Code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "aesara_code",
    "full_id": "sympy.printing.aesaracode.aesara_code",
    "type": "function",
    "description": "\n    Convert a SymPy expression into a Aesara graph variable.\n\n    Parameters\n    ==========\n\n    expr : sympy.core.expr.Expr\n        SymPy expression object to convert.\n\n    cache : dict\n        Cached Aesara variables (see :class:`AesaraPrinter.cache\n        <AesaraPrinter>`). Defaults to the module-level global cache.\n\n    dtypes : dict\n        Passed to :meth:`.AesaraPrinter.doprint`.\n\n    broadcastables : dict\n        Passed to :meth:`.AesaraPrinter.doprint`.\n\n    Returns\n    =======\n\n    aesara.graph.basic.Variable\n        A variable corresponding to the expression's value in a Aesara symbolic\n        expression graph.\n\n    ",
    "section": "Aesara Code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "aesara_function",
    "full_id": "sympy.printing.aesaracode.aesara_function",
    "type": "function",
    "description": "\n    Create a Aesara function from SymPy expressions.\n\n    The inputs and outputs are converted to Aesara variables using\n    :func:`.aesara_code` and then passed to ``aesara.function``.\n\n    Parameters\n    ==========\n\n    inputs\n        Sequence of symbols which constitute the inputs of the function.\n\n    outputs\n        Sequence of expressions which constitute the outputs(s) of the\n        function. The free symbols of each expression must be a subset of\n        ``inputs``.\n\n    scalar : bool\n        Convert 0-dimensional arrays in output to scalars. This will return a\n        Python wrapper function around the Aesara function object.\n\n    cache : dict\n        Cached Aesara variables (see :class:`AesaraPrinter.cache\n        <AesaraPrinter>`). Defaults to the module-level global cache.\n\n    dtypes : dict\n        Passed to :meth:`.AesaraPrinter.doprint`.\n\n    broadcastables : dict\n        Passed to :meth:`.AesaraPrinter.doprint`.\n\n    dims : dict\n        Alternative to ``broadcastables`` argument. Mapping from elements of\n        ``inputs`` to integers indicating the dimension of their associated\n        arrays/tensors. Overrides ``broadcastables`` argument if given.\n\n    dim : int\n        Another alternative to the ``broadcastables`` argument. Common number of\n        dimensions to use for all arrays/tensors.\n        ``aesara_function([x, y], [...], dim=2)`` is equivalent to using\n        ``broadcastables={x: (False, False), y: (False, False)}``.\n\n    Returns\n    =======\n    callable\n        A callable object which takes values of ``inputs`` as positional\n        arguments and returns an output array for each of the expressions\n        in ``outputs``. If ``outputs`` is a single expression the function will\n        return a Numpy array, if it is a list of multiple expressions the\n        function will return a list of arrays. See description of the ``squeeze``\n        argument above for the behavior when a single output is passed in a list.\n        The returned object will either be an instance of\n        ``aesara.compile.function.types.Function`` or a Python wrapper\n        function around one. In both cases, the returned value will have a\n        ``aesara_function`` attribute which points to the return value of\n        ``aesara.function``.\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, z\n    >>> from sympy.printing.aesaracode import aesara_function\n\n    A simple function with one input and one output:\n\n    >>> f1 = aesara_function([x], [x**2 - 1], scalar=True)\n    >>> f1(3)\n    8.0\n\n    A function with multiple inputs and one output:\n\n    >>> f2 = aesara_function([x, y, z], [(x**z + y**z)**(1/z)], scalar=True)\n    >>> f2(3, 4, 2)\n    5.0\n\n    A function with multiple inputs and multiple outputs:\n\n    >>> f3 = aesara_function([x, y], [x**2 + y**2, x**2 - y**2], scalar=True)\n    >>> f3(2, 3)\n    [13.0, -5.0]\n\n    See also\n    ========\n\n    dim_handling\n\n    ",
    "section": "Aesara Code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "dim_handling",
    "full_id": "sympy.printing.aesaracode.dim_handling",
    "type": "function",
    "description": "\n    Get value of ``broadcastables`` argument to :func:`.aesara_code` from\n    keyword arguments to :func:`.aesara_function`.\n\n    Included for backwards compatibility.\n\n    Parameters\n    ==========\n\n    inputs\n        Sequence of input symbols.\n\n    dim : int\n        Common number of dimensions for all inputs. Overrides other arguments\n        if given.\n\n    dims : dict\n        Mapping from input symbols to number of dimensions. Overrides\n        ``broadcastables`` argument if given.\n\n    broadcastables : dict\n        Explicit value of ``broadcastables`` argument to\n        :meth:`.AesaraPrinter.doprint`. If not None function will return this value unchanged.\n\n    Returns\n    =======\n    dict\n        Dictionary mapping elements of ``inputs`` to their \"broadcastable\"\n        values (tuple of ``bool``\\ s).\n    ",
    "section": "Aesara Code printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "print_gtk",
    "full_id": "sympy.printing.gtk.print_gtk",
    "type": "function",
    "description": "Print to Gtkmathview, a gtk widget capable of rendering MathML.\n\n    Needs libgtkmathview-bin",
    "section": "Gtk",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "lambdarepr",
    "full_id": "sympy.printing.lambdarepr.lambdarepr",
    "type": "function",
    "description": "\n    Returns a string usable for lambdifying.\n    ",
    "section": "LambdaPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "parenthesize_super",
    "full_id": "sympy.printing.latex.LatexPrinter.parenthesize_super",
    "type": "method",
    "description": "\n        Protect superscripts in s\n\n        If the parenthesize_super option is set, protect with parentheses, else\n        wrap in braces.\n        ",
    "section": "LatexPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "latex",
    "full_id": "sympy.printing.latex.latex",
    "type": "function",
    "description": "Convert the given expression to LaTeX string representation.\n\n    Parameters\n    ==========\n    full_prec: boolean, optional\n        If set to True, a floating point number is printed with full precision.\n    fold_frac_powers : boolean, optional\n        Emit ``^{p/q}`` instead of ``^{\\frac{p}{q}}`` for fractional powers.\n    fold_func_brackets : boolean, optional\n        Fold function brackets where applicable.\n    fold_short_frac : boolean, optional\n        Emit ``p / q`` instead of ``\\frac{p}{q}`` when the denominator is\n        simple enough (at most two terms and no powers). The default value is\n        ``True`` for inline mode, ``False`` otherwise.\n    inv_trig_style : string, optional\n        How inverse trig functions should be displayed. Can be one of\n        ``'abbreviated'``, ``'full'``, or ``'power'``. Defaults to\n        ``'abbreviated'``.\n    itex : boolean, optional\n        Specifies if itex-specific syntax is used, including emitting\n        ``$$...$$``.\n    ln_notation : boolean, optional\n        If set to ``True``, ``\\ln`` is used instead of default ``\\log``.\n    long_frac_ratio : float or None, optional\n        The allowed ratio of the width of the numerator to the width of the\n        denominator before the printer breaks off long fractions. If ``None``\n        (the default value), long fractions are not broken up.\n    mat_delim : string, optional\n        The delimiter to wrap around matrices. Can be one of ``'['``, ``'('``,\n        or the empty string ``''``. Defaults to ``'['``.\n    mat_str : string, optional\n        Which matrix environment string to emit. ``'smallmatrix'``,\n        ``'matrix'``, ``'array'``, etc. Defaults to ``'smallmatrix'`` for\n        inline mode, ``'matrix'`` for matrices of no more than 10 columns, and\n        ``'array'`` otherwise.\n    mode: string, optional\n        Specifies how the generated code will be delimited. ``mode`` can be one\n        of ``'plain'``, ``'inline'``, ``'equation'`` or ``'equation*'``.  If\n        ``mode`` is set to ``'plain'``, then the resulting code will not be\n        delimited at all (this is the default). If ``mode`` is set to\n        ``'inline'`` then inline LaTeX ``$...$`` will be used. If ``mode`` is\n        set to ``'equation'`` or ``'equation*'``, the resulting code will be\n        enclosed in the ``equation`` or ``equation*`` environment (remember to\n        import ``amsmath`` for ``equation*``), unless the ``itex`` option is\n        set. In the latter case, the ``$$...$$`` syntax is used.\n    mul_symbol : string or None, optional\n        The symbol to use for multiplication. Can be one of ``None``,\n        ``'ldot'``, ``'dot'``, or ``'times'``.\n    order: string, optional\n        Any of the supported monomial orderings (currently ``'lex'``,\n        ``'grlex'``, or ``'grevlex'``), ``'old'``, and ``'none'``. This\n        parameter does nothing for `~.Mul` objects. Setting order to ``'old'``\n        uses the compatibility ordering for ``~.Add`` defined in Printer. For\n        very large expressions, set the ``order`` keyword to ``'none'`` if\n        speed is a concern.\n    symbol_names : dictionary of strings mapped to symbols, optional\n        Dictionary of symbols and the custom strings they should be emitted as.\n    root_notation : boolean, optional\n        If set to ``False``, exponents of the form 1/n are printed in fractonal\n        form. Default is ``True``, to print exponent in root form.\n    mat_symbol_style : string, optional\n        Can be either ``'plain'`` (default) or ``'bold'``. If set to\n        ``'bold'``, a `~.MatrixSymbol` A will be printed as ``\\mathbf{A}``,\n        otherwise as ``A``.\n    imaginary_unit : string, optional\n        String to use for the imaginary unit. Defined options are ``'i'``\n        (default) and ``'j'``. Adding ``r`` or ``t`` in front gives ``\\mathrm``\n        or ``\\text``, so ``'ri'`` leads to ``\\mathrm{i}`` which gives\n        `\\mathrm{i}`.\n    gothic_re_im : boolean, optional\n        If set to ``True``, `\\Re` and `\\Im` is used for ``re`` and ``im``, respectively.\n        The default is ``False`` leading to `\\operatorname{re}` and `\\operatorname{im}`.\n    decimal_separator : string, optional\n        Specifies what separator to use to separate the whole and fractional parts of a\n        floating point number as in `2.5` for the default, ``period`` or `2{,}5`\n        when ``comma`` is specified. Lists, sets, and tuple are printed with semicolon\n        separating the elements when ``comma`` is chosen. For example, [1; 2; 3] when\n        ``comma`` is chosen and [1,2,3] for when ``period`` is chosen.\n    parenthesize_super : boolean, optional\n        If set to ``False``, superscripted expressions will not be parenthesized when\n        powered. Default is ``True``, which parenthesizes the expression when powered.\n    min: Integer or None, optional\n        Sets the lower bound for the exponent to print floating point numbers in\n        fixed-point format.\n    max: Integer or None, optional\n        Sets the upper bound for the exponent to print floating point numbers in\n        fixed-point format.\n    diff_operator: string, optional\n        String to use for differential operator. Default is ``'d'``, to print in italic\n        form. ``'rd'``, ``'td'`` are shortcuts for ``\\mathrm{d}`` and ``\\text{d}``.\n    adjoint_style: string, optional\n        String to use for the adjoint symbol. Defined options are ``'dagger'``\n        (default),``'star'``, and ``'hermitian'``.\n\n    Notes\n    =====\n\n    Not using a print statement for printing, results in double backslashes for\n    latex commands since that's the way Python escapes backslashes in strings.\n\n    >>> from sympy import latex, Rational\n    >>> from sympy.abc import tau\n    >>> latex((2*tau)**Rational(7,2))\n    '8 \\\\sqrt{2} \\\\tau^{\\\\frac{7}{2}}'\n    >>> print(latex((2*tau)**Rational(7,2)))\n    8 \\sqrt{2} \\tau^{\\frac{7}{2}}\n\n    Examples\n    ========\n\n    >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational, log\n    >>> from sympy.abc import x, y, mu, r, tau\n\n    Basic usage:\n\n    >>> print(latex((2*tau)**Rational(7,2)))\n    8 \\sqrt{2} \\tau^{\\frac{7}{2}}\n\n    ``mode`` and ``itex`` options:\n\n    >>> print(latex((2*mu)**Rational(7,2), mode='plain'))\n    8 \\sqrt{2} \\mu^{\\frac{7}{2}}\n    >>> print(latex((2*tau)**Rational(7,2), mode='inline'))\n    $8 \\sqrt{2} \\tau^{7 / 2}$\n    >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))\n    \\begin{equation*}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation*}\n    >>> print(latex((2*mu)**Rational(7,2), mode='equation'))\n    \\begin{equation}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation}\n    >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))\n    $$8 \\sqrt{2} \\mu^{\\frac{7}{2}}$$\n    >>> print(latex((2*mu)**Rational(7,2), mode='plain'))\n    8 \\sqrt{2} \\mu^{\\frac{7}{2}}\n    >>> print(latex((2*tau)**Rational(7,2), mode='inline'))\n    $8 \\sqrt{2} \\tau^{7 / 2}$\n    >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))\n    \\begin{equation*}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation*}\n    >>> print(latex((2*mu)**Rational(7,2), mode='equation'))\n    \\begin{equation}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation}\n    >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))\n    $$8 \\sqrt{2} \\mu^{\\frac{7}{2}}$$\n\n    Fraction options:\n\n    >>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))\n    8 \\sqrt{2} \\tau^{7/2}\n    >>> print(latex((2*tau)**sin(Rational(7,2))))\n    \\left(2 \\tau\\right)^{\\sin{\\left(\\frac{7}{2} \\right)}}\n    >>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets=True))\n    \\left(2 \\tau\\right)^{\\sin {\\frac{7}{2}}}\n    >>> print(latex(3*x**2/y))\n    \\frac{3 x^{2}}{y}\n    >>> print(latex(3*x**2/y, fold_short_frac=True))\n    3 x^{2} / y\n    >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))\n    \\frac{\\int r\\, dr}{2 \\pi}\n    >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))\n    \\frac{1}{2 \\pi} \\int r\\, dr\n\n    Multiplication options:\n\n    >>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol=\"times\"))\n    \\left(2 \\times \\tau\\right)^{\\sin{\\left(\\frac{7}{2} \\right)}}\n\n    Trig options:\n\n    >>> print(latex(asin(Rational(7,2))))\n    \\operatorname{asin}{\\left(\\frac{7}{2} \\right)}\n    >>> print(latex(asin(Rational(7,2)), inv_trig_style=\"full\"))\n    \\arcsin{\\left(\\frac{7}{2} \\right)}\n    >>> print(latex(asin(Rational(7,2)), inv_trig_style=\"power\"))\n    \\sin^{-1}{\\left(\\frac{7}{2} \\right)}\n\n    Matrix options:\n\n    >>> print(latex(Matrix(2, 1, [x, y])))\n    \\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]\n    >>> print(latex(Matrix(2, 1, [x, y]), mat_str = \"array\"))\n    \\left[\\begin{array}{c}x\\\\y\\end{array}\\right]\n    >>> print(latex(Matrix(2, 1, [x, y]), mat_delim=\"(\"))\n    \\left(\\begin{matrix}x\\\\y\\end{matrix}\\right)\n\n    Custom printing of symbols:\n\n    >>> print(latex(x**2, symbol_names={x: 'x_i'}))\n    x_i^{2}\n\n    Logarithms:\n\n    >>> print(latex(log(10)))\n    \\log{\\left(10 \\right)}\n    >>> print(latex(log(10), ln_notation=True))\n    \\ln{\\left(10 \\right)}\n\n    ``latex()`` also supports the builtin container types :class:`list`,\n    :class:`tuple`, and :class:`dict`:\n\n    >>> print(latex([2/x, y], mode='inline'))\n    $\\left[ 2 / x, \\  y\\right]$\n\n    Unsupported types are rendered as monospaced plaintext:\n\n    >>> print(latex(int))\n    \\mathtt{\\text{<class 'int'>}}\n    >>> print(latex(\"plain % text\"))\n    \\mathtt{\\text{plain \\% text}}\n\n    See :ref:`printer_method_example` for an example of how to override\n    this behavior for your own types by implementing ``_latex``.\n\n    .. versionchanged:: 1.7.0\n        Unsupported types no longer have their ``str`` representation treated as valid latex.\n\n    ",
    "section": "LatexPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "print_latex",
    "full_id": "sympy.printing.latex.print_latex",
    "type": "function",
    "description": "Prints LaTeX representation of the given expression. Takes the same\n    settings as ``latex()``.",
    "section": "LatexPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "doprint",
    "full_id": "sympy.printing.mathml.MathMLPrinterBase.doprint",
    "type": "method",
    "description": "\n        Prints the expression as MathML.\n        ",
    "section": "MathMLPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "mathml_tag",
    "full_id": "sympy.printing.mathml.MathMLContentPrinter.mathml_tag",
    "type": "method",
    "description": "Returns the MathML tag for an expression.",
    "section": "MathMLPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "mathml",
    "full_id": "sympy.printing.mathml.mathml",
    "type": "function",
    "description": "Returns the MathML representation of expr. If printer is presentation\n    then prints Presentation MathML else prints content MathML.\n    ",
    "section": "MathMLPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "print_mathml",
    "full_id": "sympy.printing.mathml.print_mathml",
    "type": "function",
    "description": "\n    Prints a pretty representation of the MathML code for expr. If printer is\n    presentation then prints Presentation MathML else prints content MathML.\n\n    Examples\n    ========\n\n    >>> ##\n    >>> from sympy import print_mathml\n    >>> from sympy.abc import x\n    >>> print_mathml(x+1) #doctest: +NORMALIZE_WHITESPACE\n    <apply>\n        <plus/>\n        <ci>x</ci>\n        <cn>1</cn>\n    </apply>\n    >>> print_mathml(x+1, printer='presentation')\n    <mrow>\n        <mi>x</mi>\n        <mo>+</mo>\n        <mn>1</mn>\n    </mrow>\n\n    ",
    "section": "MathMLPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "pycode",
    "full_id": "sympy.printing.pycode.pycode",
    "type": "function",
    "description": "Converts an expr to a string of Python code\n\n    Parameters\n    ==========\n\n    expr : Expr\n        A SymPy expression.\n    fully_qualified_modules : bool\n        Whether or not to write out full module names of functions\n        (``math.sin`` vs. ``sin``). default: ``True``.\n    standard : str or None, optional\n        Only 'python3' (default) is supported.\n        This parameter may be removed in the future.\n\n    Examples\n    ========\n\n    >>> from sympy import pycode, tan, Symbol\n    >>> pycode(tan(Symbol('x')) + 1)\n    'math.tan(x) + 1'\n\n    ",
    "section": "PythonCodePrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "emptyPrinter",
    "full_id": "sympy.printing.repr.ReprPrinter.emptyPrinter",
    "type": "method",
    "description": "\n        The fallback printer.\n        ",
    "section": "srepr",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "reprify",
    "full_id": "sympy.printing.repr.ReprPrinter.reprify",
    "type": "method",
    "description": "\n        Prints each item in `args` and joins them with `sep`.\n        ",
    "section": "srepr",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "srepr",
    "full_id": "sympy.printing.repr.srepr",
    "type": "function",
    "description": "return expr in repr form",
    "section": "srepr",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "sstr",
    "full_id": "sympy.printing.str.sstr",
    "type": "function",
    "description": "Returns the expression as a string.\n\n    For large expressions where speed is a concern, use the setting\n    order='none'. If abbrev=True setting is used then units are printed in\n    abbreviated form.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, Eq, sstr\n    >>> a, b = symbols('a b')\n    >>> sstr(Eq(a + b, 0))\n    'Eq(a + b, 0)'\n    ",
    "section": "StrPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "sstrrepr",
    "full_id": "sympy.printing.str.sstrrepr",
    "type": "function",
    "description": "return expr in mixed str/repr form\n\n    i.e. strings are returned in repr form with quotes, and everything else\n    is returned in str form.\n\n    This function could be useful for hooking into sys.displayhook\n    ",
    "section": "StrPrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "pprint_nodes",
    "full_id": "sympy.printing.tree.pprint_nodes",
    "type": "function",
    "description": "\n    Prettyprints systems of nodes.\n\n    Examples\n    ========\n\n    >>> from sympy.printing.tree import pprint_nodes\n    >>> print(pprint_nodes([\"a\", \"b1\\nb2\", \"c\"]))\n    +-a\n    +-b1\n    | b2\n    +-c\n\n    ",
    "section": "Tree Printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "print_node",
    "full_id": "sympy.printing.tree.print_node",
    "type": "function",
    "description": "\n    Returns information about the \"node\".\n\n    This includes class name, string representation and assumptions.\n\n    Parameters\n    ==========\n\n    assumptions : bool, optional\n        See the ``assumptions`` keyword in ``tree``\n    ",
    "section": "Tree Printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "tree",
    "full_id": "sympy.printing.tree.tree",
    "type": "function",
    "description": "\n    Returns a tree representation of \"node\" as a string.\n\n    It uses print_node() together with pprint_nodes() on node.args recursively.\n\n    Parameters\n    ==========\n\n    asssumptions : bool, optional\n        The flag to decide whether to print out all the assumption data\n        (such as ``is_integer`, ``is_real``) associated with the\n        expression or not.\n\n        Enabling the flag makes the result verbose, and the printed\n        result may not be determinisitic because of the randomness used\n        in backtracing the assumptions.\n\n    See Also\n    ========\n\n    print_tree\n\n    ",
    "section": "Tree Printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "print_tree",
    "full_id": "sympy.printing.tree.print_tree",
    "type": "function",
    "description": "\n    Prints a tree representation of \"node\".\n\n    Parameters\n    ==========\n\n    asssumptions : bool, optional\n        The flag to decide whether to print out all the assumption data\n        (such as ``is_integer`, ``is_real``) associated with the\n        expression or not.\n\n        Enabling the flag makes the result verbose, and the printed\n        result may not be determinisitic because of the randomness used\n        in backtracing the assumptions.\n\n    Examples\n    ========\n\n    >>> from sympy.printing import print_tree\n    >>> from sympy import Symbol\n    >>> x = Symbol('x', odd=True)\n    >>> y = Symbol('y', even=True)\n\n    Printing with full assumptions information:\n\n    >>> print_tree(y**x)\n    Pow: y**x\n    +-Symbol: y\n    | algebraic: True\n    | commutative: True\n    | complex: True\n    | even: True\n    | extended_real: True\n    | finite: True\n    | hermitian: True\n    | imaginary: False\n    | infinite: False\n    | integer: True\n    | irrational: False\n    | noninteger: False\n    | odd: False\n    | rational: True\n    | real: True\n    | transcendental: False\n    +-Symbol: x\n      algebraic: True\n      commutative: True\n      complex: True\n      even: False\n      extended_nonzero: True\n      extended_real: True\n      finite: True\n      hermitian: True\n      imaginary: False\n      infinite: False\n      integer: True\n      irrational: False\n      noninteger: False\n      nonzero: True\n      odd: True\n      rational: True\n      real: True\n      transcendental: False\n      zero: False\n\n    Hiding the assumptions:\n\n    >>> print_tree(y**x, assumptions=False)\n    Pow: y**x\n    +-Symbol: y\n    +-Symbol: x\n\n    See Also\n    ========\n\n    tree\n\n    ",
    "section": "Tree Printing",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "preview",
    "full_id": "sympy.printing.preview.preview",
    "type": "function",
    "description": "\n    View expression or LaTeX markup in PNG, DVI, PostScript or PDF form.\n\n    If the expr argument is an expression, it will be exported to LaTeX and\n    then compiled using the available TeX distribution.  The first argument,\n    'expr', may also be a LaTeX string.  The function will then run the\n    appropriate viewer for the given output format or use the user defined\n    one. By default png output is generated.\n\n    By default pretty Euler fonts are used for typesetting (they were used to\n    typeset the well known \"Concrete Mathematics\" book). For that to work, you\n    need the 'eulervm.sty' LaTeX style (in Debian/Ubuntu, install the\n    texlive-fonts-extra package). If you prefer default AMS fonts or your\n    system lacks 'eulervm' LaTeX package then unset the 'euler' keyword\n    argument.\n\n    To use viewer auto-detection, lets say for 'png' output, issue\n\n    >>> from sympy import symbols, preview, Symbol\n    >>> x, y = symbols(\"x,y\")\n\n    >>> preview(x + y, output='png')\n\n    This will choose 'pyglet' by default. To select a different one, do\n\n    >>> preview(x + y, output='png', viewer='gimp')\n\n    The 'png' format is considered special. For all other formats the rules\n    are slightly different. As an example we will take 'dvi' output format. If\n    you would run\n\n    >>> preview(x + y, output='dvi')\n\n    then 'view' will look for available 'dvi' viewers on your system\n    (predefined in the function, so it will try evince, first, then kdvi and\n    xdvi). If nothing is found, it will fall back to using a system file\n    association (via ``open`` and ``xdg-open``). To always use your system file\n    association without searching for the above readers, use\n\n    >>> from sympy.printing.preview import system_default_viewer\n    >>> preview(x + y, output='dvi', viewer=system_default_viewer)\n\n    If this still does not find the viewer you want, it can be set explicitly.\n\n    >>> preview(x + y, output='dvi', viewer='superior-dvi-viewer')\n\n    This will skip auto-detection and will run user specified\n    'superior-dvi-viewer'. If ``view`` fails to find it on your system it will\n    gracefully raise an exception.\n\n    You may also enter ``'file'`` for the viewer argument. Doing so will cause\n    this function to return a file object in read-only mode, if ``filename``\n    is unset. However, if it was set, then 'preview' writes the generated\n    file to this filename instead.\n\n    There is also support for writing to a ``io.BytesIO`` like object, which\n    needs to be passed to the ``outputbuffer`` argument.\n\n    >>> from io import BytesIO\n    >>> obj = BytesIO()\n    >>> preview(x + y, output='png', viewer='BytesIO',\n    ...         outputbuffer=obj)\n\n    The LaTeX preamble can be customized by setting the 'preamble' keyword\n    argument. This can be used, e.g., to set a different font size, use a\n    custom documentclass or import certain set of LaTeX packages.\n\n    >>> preamble = \"\\\\documentclass[10pt]{article}\\n\" \\\n    ...            \"\\\\usepackage{amsmath,amsfonts}\\\\begin{document}\"\n    >>> preview(x + y, output='png', preamble=preamble)\n\n    It is also possible to use the standard preamble and provide additional\n    information to the preamble using the ``extra_preamble`` keyword argument.\n\n    >>> from sympy import sin\n    >>> extra_preamble = \"\\\\renewcommand{\\\\sin}{\\\\cos}\"\n    >>> preview(sin(x), output='png', extra_preamble=extra_preamble)\n\n    If the value of 'output' is different from 'dvi' then command line\n    options can be set ('dvioptions' argument) for the execution of the\n    'dvi'+output conversion tool. These options have to be in the form of a\n    list of strings (see ``subprocess.Popen``).\n\n    Additional keyword args will be passed to the :func:`~sympy.printing.latex.latex` call,\n    e.g., the ``symbol_names`` flag.\n\n    >>> phidd = Symbol('phidd')\n    >>> preview(phidd, symbol_names={phidd: r'\\ddot{\\varphi}'})\n\n    For post-processing the generated TeX File can be written to a file by\n    passing the desired filename to the 'outputTexFile' keyword\n    argument. To write the TeX code to a file named\n    ``\"sample.tex\"`` and run the default png viewer to display the resulting\n    bitmap, do\n\n    >>> preview(x + y, outputTexFile=\"sample.tex\")\n\n\n    ",
    "section": "Preview",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "split_super_sub",
    "full_id": "sympy.printing.conventions.split_super_sub",
    "type": "function",
    "description": "Split a symbol name into a name, superscripts and subscripts\n\n    The first part of the symbol name is considered to be its actual\n    'name', followed by super- and subscripts. Each superscript is\n    preceded with a \"^\" character or by \"__\". Each subscript is preceded\n    by a \"_\" character.  The three return values are the actual name, a\n    list with superscripts and a list with subscripts.\n\n    Examples\n    ========\n\n    >>> from sympy.printing.conventions import split_super_sub\n    >>> split_super_sub('a_x^1')\n    ('a', ['1'], ['x'])\n    >>> split_super_sub('var_sub1__sup_sub2')\n    ('var', ['sup'], ['sub1', 'sub2'])\n\n    ",
    "section": "Implementation - Helper Classes/Functions",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "doprint",
    "full_id": "sympy.printing.codeprinter.CodePrinter.doprint",
    "type": "method",
    "description": "\n        Print the expression as code.\n\n        Parameters\n        ----------\n        expr : Expression\n            The expression to be printed.\n\n        assign_to : Symbol, string, MatrixSymbol, list of strings or Symbols (optional)\n            If provided, the printed code will set the expression to a variable or multiple variables\n            with the name or names given in ``assign_to``.\n        ",
    "section": "CodePrinter",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "precedence",
    "full_id": "sympy.printing.precedence.precedence",
    "type": "function",
    "description": "Returns the precedence of a given object.\n\n    This is the precedence for StrPrinter.\n    ",
    "section": "Precedence",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "U",
    "full_id": "sympy.printing.pretty.pretty_symbology.U",
    "type": "function",
    "description": "\n    Get a unicode character by name or, None if not found.\n\n    This exists because older versions of Python use older unicode databases.\n    ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "pretty_use_unicode",
    "full_id": "sympy.printing.pretty.pretty_symbology.pretty_use_unicode",
    "type": "function",
    "description": "Set whether pretty-printer should use unicode by default",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "pretty_try_use_unicode",
    "full_id": "sympy.printing.pretty.pretty_symbology.pretty_try_use_unicode",
    "type": "function",
    "description": "See if unicode output is available and leverage it if possible",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "xobj",
    "full_id": "sympy.printing.pretty.pretty_symbology.xobj",
    "type": "function",
    "description": "Construct spatial object of given length.\n\n    return: [] of equal-length strings\n    ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "vobj",
    "full_id": "sympy.printing.pretty.pretty_symbology.vobj",
    "type": "function",
    "description": "Construct vertical object of a given height\n\n    see: xobj\n    ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "hobj",
    "full_id": "sympy.printing.pretty.pretty_symbology.hobj",
    "type": "function",
    "description": "Construct horizontal object of a given width\n\n    see: xobj\n    ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "xsym",
    "full_id": "sympy.printing.pretty.pretty_symbology.xsym",
    "type": "function",
    "description": "get symbology for a 'character'",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "pretty_atom",
    "full_id": "sympy.printing.pretty.pretty_symbology.pretty_atom",
    "type": "function",
    "description": "return pretty representation of an atom",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "pretty_symbol",
    "full_id": "sympy.printing.pretty.pretty_symbology.pretty_symbol",
    "type": "function",
    "description": "return pretty representation of a symbol",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "annotated",
    "full_id": "sympy.printing.pretty.pretty_symbology.annotated",
    "type": "function",
    "description": "\n    Return a stylised drawing of the letter ``letter``, together with\n    information on how to put annotations (super- and subscripts to the\n    left and to the right) on it.\n\n    See pretty.py functions _print_meijerg, _print_hyper on how to use this\n    information.\n    ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "above",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.above",
    "type": "method",
    "description": "Put pictures above this picture.\n        Returns string, baseline arguments for stringPict.\n        Baseline is baseline of bottom picture.\n        ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "below",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.below",
    "type": "method",
    "description": "Put pictures under this picture.\n        Returns string, baseline arguments for stringPict.\n        Baseline is baseline of top picture\n\n        Examples\n        ========\n\n        >>> from sympy.printing.pretty.stringpict import stringPict\n        >>> print(stringPict(\"x+3\").below(\n        ...       stringPict.LINE, '3')[0]) #doctest: +NORMALIZE_WHITESPACE\n        x+3\n        ---\n         3\n\n        ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "height",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.height",
    "type": "method",
    "description": "The height of the picture in characters.",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "left",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.left",
    "type": "method",
    "description": "Put pictures (left to right) at left.\n        Returns string, baseline arguments for stringPict.\n        ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "leftslash",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.leftslash",
    "type": "method",
    "description": "Precede object by a slash of the proper size.",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "next",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.next",
    "type": "method",
    "description": "Put a string of stringPicts next to each other.\n        Returns string, baseline arguments for stringPict.\n        ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "parens",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.parens",
    "type": "method",
    "description": "Put parentheses around self.\n        Returns string, baseline arguments for stringPict.\n\n        left or right can be None or empty string which means 'no paren from\n        that side'\n        ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "render",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.render",
    "type": "method",
    "description": "Return the string form of self.\n\n        Unless the argument line_break is set to False, it will\n        break the expression in a form that can be printed\n        on the terminal without being broken up.\n        ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "right",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.right",
    "type": "method",
    "description": "Put pictures next to this one.\n        Returns string, baseline arguments for stringPict.\n        (Multiline) strings are allowed, and are given a baseline of 0.\n\n        Examples\n        ========\n\n        >>> from sympy.printing.pretty.stringpict import stringPict\n        >>> print(stringPict(\"10\").right(\" + \",stringPict(\"1\\r-\\r2\",1))[0])\n             1\n        10 + -\n             2\n\n        ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "root",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.root",
    "type": "method",
    "description": "Produce a nice root symbol.\n        Produces ugly results for big n inserts.\n        ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "stack",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.stack",
    "type": "method",
    "description": "Put pictures on top of each other,\n        from top to bottom.\n        Returns string, baseline arguments for stringPict.\n        The baseline is the baseline of the second picture.\n        Everything is centered.\n        Baseline is the baseline of the second picture.\n        Strings are allowed.\n        The special value stringPict.LINE is a row of '-' extended to the width.\n        ",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "terminal_width",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.terminal_width",
    "type": "method",
    "description": "Return the terminal width if possible, otherwise return 0.",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "width",
    "full_id": "sympy.printing.pretty.stringpict.stringPict.width",
    "type": "method",
    "description": "The width of the picture in characters.",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "apply",
    "full_id": "sympy.printing.pretty.stringpict.prettyForm.apply",
    "type": "method",
    "description": "Functions of one or more variables.",
    "section": "Pretty-Printing Implementation Helpers",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "dotprint",
    "full_id": "sympy.printing.dot.dotprint",
    "type": "function",
    "description": "DOT description of a SymPy expression tree\n\n    Parameters\n    ==========\n\n    styles : list of lists composed of (Class, mapping), optional\n        Styles for different classes.\n\n        The default is\n\n        .. code-block:: python\n\n            (\n                (Basic, {'color': 'blue', 'shape': 'ellipse'}),\n                (Expr,  {'color': 'black'})\n            )\n\n    atom : function, optional\n        Function used to determine if an arg is an atom.\n\n        A good choice is ``lambda x: not x.args``.\n\n        The default is ``lambda x: not isinstance(x, Basic)``.\n\n    maxdepth : integer, optional\n        The maximum depth.\n\n        The default is ``None``, meaning no limit.\n\n    repeat : boolean, optional\n        Whether to use different nodes for common subexpressions.\n\n        The default is ``True``.\n\n        For example, for ``x + x*y`` with ``repeat=True``, it will have\n        two nodes for ``x``; with ``repeat=False``, it will have one\n        node.\n\n        .. warning::\n            Even if a node appears twice in the same object like ``x`` in\n            ``Pow(x, x)``, it will still only appear once.\n            Hence, with ``repeat=False``, the number of arrows out of an\n            object might not equal the number of args it has.\n\n    labelfunc : function, optional\n        A function to create a label for a given leaf node.\n\n        The default is ``str``.\n\n        Another good option is ``srepr``.\n\n        For example with ``str``, the leaf nodes of ``x + 1`` are labeled,\n        ``x`` and ``1``.  With ``srepr``, they are labeled ``Symbol('x')``\n        and ``Integer(1)``.\n\n    **kwargs : optional\n        Additional keyword arguments are included as styles for the graph.\n\n    Examples\n    ========\n\n    >>> from sympy import dotprint\n    >>> from sympy.abc import x\n    >>> print(dotprint(x+2)) # doctest: +NORMALIZE_WHITESPACE\n    digraph{\n    <BLANKLINE>\n    # Graph style\n    \"ordering\"=\"out\"\n    \"rankdir\"=\"TD\"\n    <BLANKLINE>\n    #########\n    # Nodes #\n    #########\n    <BLANKLINE>\n    \"Add(Integer(2), Symbol('x'))_()\" [\"color\"=\"black\", \"label\"=\"Add\", \"shape\"=\"ellipse\"];\n    \"Integer(2)_(0,)\" [\"color\"=\"black\", \"label\"=\"2\", \"shape\"=\"ellipse\"];\n    \"Symbol('x')_(1,)\" [\"color\"=\"black\", \"label\"=\"x\", \"shape\"=\"ellipse\"];\n    <BLANKLINE>\n    #########\n    # Edges #\n    #########\n    <BLANKLINE>\n    \"Add(Integer(2), Symbol('x'))_()\" -> \"Integer(2)_(0,)\";\n    \"Add(Integer(2), Symbol('x'))_()\" -> \"Symbol('x')_(1,)\";\n    }\n\n    ",
    "section": "dotprint",
    "url": "https://docs.sympy.org/latest/modules/printing.html"
  },
  {
    "name": "ambient_dimension",
    "full_id": "sympy.geometry.entity.GeometryEntity.ambient_dimension",
    "type": "property",
    "description": "What is the dimension of the space that the object is contained in?",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "bounds",
    "full_id": "sympy.geometry.entity.GeometryEntity.bounds",
    "type": "property",
    "description": "Return a tuple (xmin, ymin, xmax, ymax) representing the bounding\n        rectangle for the geometric figure.\n\n        ",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "encloses",
    "full_id": "sympy.geometry.entity.GeometryEntity.encloses",
    "type": "method",
    "description": "\n        Return True if o is inside (not on or outside) the boundaries of self.\n\n        The object will be decomposed into Points and individual Entities need\n        only define an encloses_point method for their class.\n\n        See Also\n        ========\n\n        sympy.geometry.ellipse.Ellipse.encloses_point\n        sympy.geometry.polygon.Polygon.encloses_point\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point, Polygon\n        >>> t  = Polygon(*RegularPolygon(Point(0, 0), 1, 3).vertices)\n        >>> t2 = Polygon(*RegularPolygon(Point(0, 0), 2, 3).vertices)\n        >>> t2.encloses(t)\n        True\n        >>> t.encloses(t2)\n        False\n\n        ",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.geometry.entity.GeometryEntity.intersection",
    "type": "method",
    "description": "\n        Returns a list of all of the intersections of self with o.\n\n        Notes\n        =====\n\n        An entity is not required to implement this method.\n\n        If two different types of entities can intersect, the item with\n        higher index in ordering_of_classes should implement\n        intersections with anything having a lower index.\n\n        See Also\n        ========\n\n        sympy.geometry.util.intersection\n\n        ",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "is_similar",
    "full_id": "sympy.geometry.entity.GeometryEntity.is_similar",
    "type": "method",
    "description": "Is this geometrical entity similar to another geometrical entity?\n\n        Two entities are similar if a uniform scaling (enlarging or\n        shrinking) of one of the entities will allow one to obtain the other.\n\n        Notes\n        =====\n\n        This method is not intended to be used directly but rather\n        through the `are_similar` function found in util.py.\n        An entity is not required to implement this method.\n        If two different types of entities can be similar, it is only\n        required that one of them be able to determine this.\n\n        See Also\n        ========\n\n        scale\n\n        ",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "parameter_value",
    "full_id": "sympy.geometry.entity.GeometryEntity.parameter_value",
    "type": "method",
    "description": "Return the parameter corresponding to the given point.\n        Evaluating an arbitrary point of the entity at this parameter\n        value will return the given point.\n\n        Examples\n        ========\n\n        >>> from sympy import Line, Point\n        >>> from sympy.abc import t\n        >>> a = Point(0, 0)\n        >>> b = Point(2, 2)\n        >>> Line(a, b).parameter_value((1, 1), t)\n        {t: 1/2}\n        >>> Line(a, b).arbitrary_point(t).subs(_)\n        Point2D(1, 1)\n        ",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "reflect",
    "full_id": "sympy.geometry.entity.GeometryEntity.reflect",
    "type": "method",
    "description": "\n        Reflects an object across a line.\n\n        Parameters\n        ==========\n\n        line: Line\n\n        Examples\n        ========\n\n        >>> from sympy import pi, sqrt, Line, RegularPolygon\n        >>> l = Line((0, pi), slope=sqrt(2))\n        >>> pent = RegularPolygon((1, 2), 1, 5)\n        >>> rpent = pent.reflect(l)\n        >>> rpent\n        RegularPolygon(Point2D(-2*sqrt(2)*pi/3 - 1/3 + 4*sqrt(2)/3, 2/3 + 2*sqrt(2)/3 + 2*pi/3), -1, 5, -atan(2*sqrt(2)) + 3*pi/5)\n\n        >>> from sympy import pi, Line, Circle, Point\n        >>> l = Line((0, pi), slope=1)\n        >>> circ = Circle(Point(0, 0), 5)\n        >>> rcirc = circ.reflect(l)\n        >>> rcirc\n        Circle(Point2D(-pi, pi), -5)\n\n        ",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "rotate",
    "full_id": "sympy.geometry.entity.GeometryEntity.rotate",
    "type": "method",
    "description": "Rotate ``angle`` radians counterclockwise about Point ``pt``.\n\n        The default pt is the origin, Point(0, 0)\n\n        See Also\n        ========\n\n        scale, translate\n\n        Examples\n        ========\n\n        >>> from sympy import Point, RegularPolygon, Polygon, pi\n        >>> t = Polygon(*RegularPolygon(Point(0, 0), 1, 3).vertices)\n        >>> t # vertex on x axis\n        Triangle(Point2D(1, 0), Point2D(-1/2, sqrt(3)/2), Point2D(-1/2, -sqrt(3)/2))\n        >>> t.rotate(pi/2) # vertex on y axis now\n        Triangle(Point2D(0, 1), Point2D(-sqrt(3)/2, -1/2), Point2D(sqrt(3)/2, -1/2))\n\n        ",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "scale",
    "full_id": "sympy.geometry.entity.GeometryEntity.scale",
    "type": "method",
    "description": "Scale the object by multiplying the x,y-coordinates by x and y.\n\n        If pt is given, the scaling is done relative to that point; the\n        object is shifted by -pt, scaled, and shifted by pt.\n\n        See Also\n        ========\n\n        rotate, translate\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point, Polygon\n        >>> t = Polygon(*RegularPolygon(Point(0, 0), 1, 3).vertices)\n        >>> t\n        Triangle(Point2D(1, 0), Point2D(-1/2, sqrt(3)/2), Point2D(-1/2, -sqrt(3)/2))\n        >>> t.scale(2)\n        Triangle(Point2D(2, 0), Point2D(-1, sqrt(3)/2), Point2D(-1, -sqrt(3)/2))\n        >>> t.scale(2, 2)\n        Triangle(Point2D(2, 0), Point2D(-1, sqrt(3)), Point2D(-1, -sqrt(3)))\n\n        ",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "translate",
    "full_id": "sympy.geometry.entity.GeometryEntity.translate",
    "type": "method",
    "description": "Shift the object by adding to the x,y-coordinates the values x and y.\n\n        See Also\n        ========\n\n        rotate, scale\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point, Polygon\n        >>> t = Polygon(*RegularPolygon(Point(0, 0), 1, 3).vertices)\n        >>> t\n        Triangle(Point2D(1, 0), Point2D(-1/2, sqrt(3)/2), Point2D(-1/2, -sqrt(3)/2))\n        >>> t.translate(2)\n        Triangle(Point2D(3, 0), Point2D(3/2, sqrt(3)/2), Point2D(3/2, -sqrt(3)/2))\n        >>> t.translate(2, 2)\n        Triangle(Point2D(3, 2), Point2D(3/2, sqrt(3)/2 + 2), Point2D(3/2, 2 - sqrt(3)/2))\n\n        ",
    "section": "Entities",
    "url": "https://docs.sympy.org/latest/modules/geometry/entities.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.geometry.util.intersection",
    "type": "function",
    "description": "The intersection of a collection of GeometryEntity instances.\n\n    Parameters\n    ==========\n    entities : sequence of GeometryEntity\n    pairwise (keyword argument) : Can be either True or False\n\n    Returns\n    =======\n    intersection : list of GeometryEntity\n\n    Raises\n    ======\n    NotImplementedError\n        When unable to calculate intersection.\n\n    Notes\n    =====\n    The intersection of any geometrical entity with itself should return\n    a list with one item: the entity in question.\n    An intersection requires two or more entities. If only a single\n    entity is given then the function will return an empty list.\n    It is possible for `intersection` to miss intersections that one\n    knows exists because the required quantities were not fully\n    simplified internally.\n    Reals should be converted to Rationals, e.g. Rational(str(real_num))\n    or else failures due to floating point issues may result.\n\n    Case 1: When the keyword argument 'pairwise' is False (default value):\n    In this case, the function returns a list of intersections common to\n    all entities.\n\n    Case 2: When the keyword argument 'pairwise' is True:\n    In this case, the functions returns a list intersections that occur\n    between any pair of entities.\n\n    See Also\n    ========\n\n    sympy.geometry.entity.GeometryEntity.intersection\n\n    Examples\n    ========\n\n    >>> from sympy import Ray, Circle, intersection\n    >>> c = Circle((0, 1), 1)\n    >>> intersection(c, c.center)\n    []\n    >>> right = Ray((0, 0), (1, 0))\n    >>> up = Ray((0, 0), (0, 1))\n    >>> intersection(c, right, up)\n    [Point2D(0, 0)]\n    >>> intersection(c, right, up, pairwise=True)\n    [Point2D(0, 0), Point2D(0, 2)]\n    >>> left = Ray((1, 0), (0, 0))\n    >>> intersection(right, left)\n    [Segment2D(Point2D(0, 0), Point2D(1, 0))]\n\n    ",
    "section": "Utils",
    "url": "https://docs.sympy.org/latest/modules/geometry/utils.html"
  },
  {
    "name": "convex_hull",
    "full_id": "sympy.geometry.util.convex_hull",
    "type": "function",
    "description": "The convex hull surrounding the Points contained in the list of entities.\n\n    Parameters\n    ==========\n\n    args : a collection of Points, Segments and/or Polygons\n\n    Optional parameters\n    ===================\n\n    polygon : Boolean. If True, returns a Polygon, if false a tuple, see below.\n              Default is True.\n\n    Returns\n    =======\n\n    convex_hull : Polygon if ``polygon`` is True else as a tuple `(U, L)` where\n                  ``L`` and ``U`` are the lower and upper hulls, respectively.\n\n    Notes\n    =====\n\n    This can only be performed on a set of points whose coordinates can\n    be ordered on the number line.\n\n    See Also\n    ========\n\n    sympy.geometry.point.Point, sympy.geometry.polygon.Polygon\n\n    Examples\n    ========\n\n    >>> from sympy import convex_hull\n    >>> points = [(1, 1), (1, 2), (3, 1), (-5, 2), (15, 4)]\n    >>> convex_hull(*points)\n    Polygon(Point2D(-5, 2), Point2D(1, 1), Point2D(3, 1), Point2D(15, 4))\n    >>> convex_hull(*points, **dict(polygon=False))\n    ([Point2D(-5, 2), Point2D(15, 4)],\n     [Point2D(-5, 2), Point2D(1, 1), Point2D(3, 1), Point2D(15, 4)])\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Graham_scan\n\n    .. [2] Andrew's Monotone Chain Algorithm\n      (A.M. Andrew,\n      \"Another Efficient Algorithm for Convex Hulls in Two Dimensions\", 1979)\n      https://web.archive.org/web/20210511015444/http://geomalgorithms.com/a10-_hull-1.html\n\n    ",
    "section": "Utils",
    "url": "https://docs.sympy.org/latest/modules/geometry/utils.html"
  },
  {
    "name": "are_similar",
    "full_id": "sympy.geometry.util.are_similar",
    "type": "function",
    "description": "Are two geometrical entities similar.\n\n    Can one geometrical entity be uniformly scaled to the other?\n\n    Parameters\n    ==========\n\n    e1 : GeometryEntity\n    e2 : GeometryEntity\n\n    Returns\n    =======\n\n    are_similar : boolean\n\n    Raises\n    ======\n\n    GeometryError\n        When `e1` and `e2` cannot be compared.\n\n    Notes\n    =====\n\n    If the two objects are equal then they are similar.\n\n    See Also\n    ========\n\n    sympy.geometry.entity.GeometryEntity.is_similar\n\n    Examples\n    ========\n\n    >>> from sympy import Point, Circle, Triangle, are_similar\n    >>> c1, c2 = Circle(Point(0, 0), 4), Circle(Point(1, 4), 3)\n    >>> t1 = Triangle(Point(0, 0), Point(1, 0), Point(0, 1))\n    >>> t2 = Triangle(Point(0, 0), Point(2, 0), Point(0, 2))\n    >>> t3 = Triangle(Point(0, 0), Point(3, 0), Point(0, 1))\n    >>> are_similar(t1, t2)\n    True\n    >>> are_similar(t1, t3)\n    False\n\n    ",
    "section": "Utils",
    "url": "https://docs.sympy.org/latest/modules/geometry/utils.html"
  },
  {
    "name": "centroid",
    "full_id": "sympy.geometry.util.centroid",
    "type": "function",
    "description": "Find the centroid (center of mass) of the collection containing only Points,\n    Segments or Polygons. The centroid is the weighted average of the individual centroid\n    where the weights are the lengths (of segments) or areas (of polygons).\n    Overlapping regions will add to the weight of that region.\n\n    If there are no objects (or a mixture of objects) then None is returned.\n\n    See Also\n    ========\n\n    sympy.geometry.point.Point, sympy.geometry.line.Segment,\n    sympy.geometry.polygon.Polygon\n\n    Examples\n    ========\n\n    >>> from sympy import Point, Segment, Polygon\n    >>> from sympy.geometry.util import centroid\n    >>> p = Polygon((0, 0), (10, 0), (10, 10))\n    >>> q = p.translate(0, 20)\n    >>> p.centroid, q.centroid\n    (Point2D(20/3, 10/3), Point2D(20/3, 70/3))\n    >>> centroid(p, q)\n    Point2D(20/3, 40/3)\n    >>> p, q = Segment((0, 0), (2, 0)), Segment((0, 0), (2, 2))\n    >>> centroid(p, q)\n    Point2D(1, 2 - sqrt(2))\n    >>> centroid(Point(0, 0), Point(2, 0))\n    Point2D(1, 0)\n\n    Stacking 3 polygons on top of each other effectively triples the\n    weight of that polygon:\n\n    >>> p = Polygon((0, 0), (1, 0), (1, 1), (0, 1))\n    >>> q = Polygon((1, 0), (3, 0), (3, 1), (1, 1))\n    >>> centroid(p, q)\n    Point2D(3/2, 1/2)\n    >>> centroid(p, p, p, q) # centroid x-coord shifts left\n    Point2D(11/10, 1/2)\n\n    Stacking the squares vertically above and below p has the same\n    effect:\n\n    >>> centroid(p, p.translate(0, 1), p.translate(0, -1), q)\n    Point2D(11/10, 1/2)\n\n    ",
    "section": "Utils",
    "url": "https://docs.sympy.org/latest/modules/geometry/utils.html"
  },
  {
    "name": "idiff",
    "full_id": "sympy.geometry.util.idiff",
    "type": "function",
    "description": "Return ``dy/dx`` assuming that ``eq == 0``.\n\n    Parameters\n    ==========\n\n    y : the dependent variable or a list of dependent variables (with y first)\n    x : the variable that the derivative is being taken with respect to\n    n : the order of the derivative (default is 1)\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y, a\n    >>> from sympy.geometry.util import idiff\n\n    >>> circ = x**2 + y**2 - 4\n    >>> idiff(circ, y, x)\n    -x/y\n    >>> idiff(circ, y, x, 2).simplify()\n    (-x**2 - y**2)/y**3\n\n    Here, ``a`` is assumed to be independent of ``x``:\n\n    >>> idiff(x + a + y, y, x)\n    -1\n\n    Now the x-dependence of ``a`` is made explicit by listing ``a`` after\n    ``y`` in a list.\n\n    >>> idiff(x + a + y, [y, a], x)\n    -Derivative(a, x) - 1\n\n    See Also\n    ========\n\n    sympy.core.function.Derivative: represents unevaluated derivatives\n    sympy.core.function.diff: explicitly differentiates wrt symbols\n\n    ",
    "section": "Utils",
    "url": "https://docs.sympy.org/latest/modules/geometry/utils.html"
  },
  {
    "name": "affine_rank",
    "full_id": "sympy.geometry.point.Point.affine_rank",
    "type": "method",
    "description": "The affine rank of a set of points is the dimension\n        of the smallest affine space containing all the points.\n        For example, if the points lie on a line (and are not all\n        the same) their affine rank is 1.  If the points lie on a plane\n        but not a line, their affine rank is 2.  By convention, the empty\n        set has affine rank -1.",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "ambient_dimension",
    "full_id": "sympy.geometry.point.Point.ambient_dimension",
    "type": "property",
    "description": "Number of components this point has.",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "are_coplanar",
    "full_id": "sympy.geometry.point.Point.are_coplanar",
    "type": "method",
    "description": "Return True if there exists a plane in which all the points\n        lie.  A trivial True value is returned if `len(points) < 3` or\n        all Points are 2-dimensional.\n\n        Parameters\n        ==========\n\n        A set of points\n\n        Raises\n        ======\n\n        ValueError : if less than 3 unique points are given\n\n        Returns\n        =======\n\n        boolean\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> p1 = Point3D(1, 2, 2)\n        >>> p2 = Point3D(2, 7, 2)\n        >>> p3 = Point3D(0, 0, 2)\n        >>> p4 = Point3D(1, 1, 2)\n        >>> Point3D.are_coplanar(p1, p2, p3, p4)\n        True\n        >>> p5 = Point3D(0, 1, 3)\n        >>> Point3D.are_coplanar(p1, p2, p3, p5)\n        False\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "canberra_distance",
    "full_id": "sympy.geometry.point.Point.canberra_distance",
    "type": "method",
    "description": "The Canberra Distance from self to point p.\n\n        Returns the weighted sum of horizontal and vertical distances to\n        point p.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        canberra_distance : The weighted sum of horizontal and vertical\n        distances to point p. The weight used is the sum of absolute values\n        of the coordinates.\n\n        Examples\n        ========\n\n        >>> from sympy import Point\n        >>> p1, p2 = Point(1, 1), Point(3, 3)\n        >>> p1.canberra_distance(p2)\n        1\n        >>> p1, p2 = Point(0, 0), Point(3, 3)\n        >>> p1.canberra_distance(p2)\n        2\n\n        Raises\n        ======\n\n        ValueError when both vectors are zero.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point.distance\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "distance",
    "full_id": "sympy.geometry.point.Point.distance",
    "type": "method",
    "description": "The Euclidean distance between self and another GeometricEntity.\n\n        Returns\n        =======\n\n        distance : number or symbolic expression.\n\n        Raises\n        ======\n\n        TypeError : if other is not recognized as a GeometricEntity or is a\n                    GeometricEntity for which distance is not defined.\n\n        See Also\n        ========\n\n        sympy.geometry.line.Segment.length\n        sympy.geometry.point.Point.taxicab_distance\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(1, 1), Point(4, 5)\n        >>> l = Line((3, 1), (2, 2))\n        >>> p1.distance(p2)\n        5\n        >>> p1.distance(l)\n        sqrt(2)\n\n        The computed distance may be symbolic, too:\n\n        >>> from sympy.abc import x, y\n        >>> p3 = Point(x, y)\n        >>> p3.distance((0, 0))\n        sqrt(x**2 + y**2)\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "dot",
    "full_id": "sympy.geometry.point.Point.dot",
    "type": "method",
    "description": "Return dot product of self with another Point.",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "equals",
    "full_id": "sympy.geometry.point.Point.equals",
    "type": "method",
    "description": "Returns whether the coordinates of self and other agree.",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.geometry.point.Point.intersection",
    "type": "method",
    "description": "The intersection between this point and another GeometryEntity.\n\n        Parameters\n        ==========\n\n        other : GeometryEntity or sequence of coordinates\n\n        Returns\n        =======\n\n        intersection : list of Points\n\n        Notes\n        =====\n\n        The return value will either be an empty list if there is no\n        intersection, otherwise it will contain this point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 1), Point(0, 0)\n        >>> p1.intersection(p2)\n        []\n        >>> p1.intersection(p3)\n        [Point2D(0, 0)]\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "is_collinear",
    "full_id": "sympy.geometry.point.Point.is_collinear",
    "type": "method",
    "description": "Returns `True` if there exists a line\n        that contains `self` and `points`.  Returns `False` otherwise.\n        A trivially True value is returned if no points are given.\n\n        Parameters\n        ==========\n\n        args : sequence of Points\n\n        Returns\n        =======\n\n        is_collinear : boolean\n\n        See Also\n        ========\n\n        sympy.geometry.line.Line\n\n        Examples\n        ========\n\n        >>> from sympy import Point\n        >>> from sympy.abc import x\n        >>> p1, p2 = Point(0, 0), Point(1, 1)\n        >>> p3, p4, p5 = Point(2, 2), Point(x, x), Point(1, 2)\n        >>> Point.is_collinear(p1, p2, p3, p4)\n        True\n        >>> Point.is_collinear(p1, p2, p3, p5)\n        False\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "is_concyclic",
    "full_id": "sympy.geometry.point.Point.is_concyclic",
    "type": "method",
    "description": "Do `self` and the given sequence of points lie in a circle?\n\n        Returns True if the set of points are concyclic and\n        False otherwise. A trivial value of True is returned\n        if there are fewer than 2 other points.\n\n        Parameters\n        ==========\n\n        args : sequence of Points\n\n        Returns\n        =======\n\n        is_concyclic : boolean\n\n\n        Examples\n        ========\n\n        >>> from sympy import Point\n\n        Define 4 points that are on the unit circle:\n\n        >>> p1, p2, p3, p4 = Point(1, 0), (0, 1), (-1, 0), (0, -1)\n\n        >>> p1.is_concyclic() == p1.is_concyclic(p2, p3, p4) == True\n        True\n\n        Define a point not on that circle:\n\n        >>> p = Point(1, 1)\n\n        >>> p.is_concyclic(p1, p2, p3)\n        False\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "is_nonzero",
    "full_id": "sympy.geometry.point.Point.is_nonzero",
    "type": "property",
    "description": "True if any coordinate is nonzero, False if every coordinate is zero,\n        and None if it cannot be determined.",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "is_scalar_multiple",
    "full_id": "sympy.geometry.point.Point.is_scalar_multiple",
    "type": "method",
    "description": "Returns whether each coordinate of `self` is a scalar\n        multiple of the corresponding coordinate in point p.\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.geometry.point.Point.is_zero",
    "type": "property",
    "description": "True if every coordinate is zero, False if any coordinate is not zero,\n        and None if it cannot be determined.",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "length",
    "full_id": "sympy.geometry.point.Point.length",
    "type": "property",
    "description": "\n        Treating a Point as a Line, this returns 0 for the length of a Point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point\n        >>> p = Point(0, 1)\n        >>> p.length\n        0\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "midpoint",
    "full_id": "sympy.geometry.point.Point.midpoint",
    "type": "method",
    "description": "The midpoint between self and point p.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        midpoint : Point\n\n        See Also\n        ========\n\n        sympy.geometry.line.Segment.midpoint\n\n        Examples\n        ========\n\n        >>> from sympy import Point\n        >>> p1, p2 = Point(1, 1), Point(13, 5)\n        >>> p1.midpoint(p2)\n        Point2D(7, 3)\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "origin",
    "full_id": "sympy.geometry.point.Point.origin",
    "type": "property",
    "description": "A point of all zeros of the same ambient dimension\n        as the current point",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "orthogonal_direction",
    "full_id": "sympy.geometry.point.Point.orthogonal_direction",
    "type": "property",
    "description": "Returns a non-zero point that is orthogonal to the\n        line containing `self` and the origin.\n\n        Examples\n        ========\n\n        >>> from sympy import Line, Point\n        >>> a = Point(1, 2, 3)\n        >>> a.orthogonal_direction\n        Point3D(-2, 1, 0)\n        >>> b = _\n        >>> Line(b, b.origin).is_perpendicular(Line(a, a.origin))\n        True\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "project",
    "full_id": "sympy.geometry.point.Point.project",
    "type": "method",
    "description": "Project the point `a` onto the line between the origin\n        and point `b` along the normal direction.\n\n        Parameters\n        ==========\n\n        a : Point\n        b : Point\n\n        Returns\n        =======\n\n        p : Point\n\n        See Also\n        ========\n\n        sympy.geometry.line.LinearEntity.projection\n\n        Examples\n        ========\n\n        >>> from sympy import Line, Point\n        >>> a = Point(1, 2)\n        >>> b = Point(2, 5)\n        >>> z = a.origin\n        >>> p = Point.project(a, b)\n        >>> Line(p, a).is_perpendicular(Line(p, b))\n        True\n        >>> Point.is_collinear(z, p, b)\n        True\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "taxicab_distance",
    "full_id": "sympy.geometry.point.Point.taxicab_distance",
    "type": "method",
    "description": "The Taxicab Distance from self to point p.\n\n        Returns the sum of the horizontal and vertical distances to point p.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        taxicab_distance : The sum of the horizontal\n        and vertical distances to point p.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point.distance\n\n        Examples\n        ========\n\n        >>> from sympy import Point\n        >>> p1, p2 = Point(1, 1), Point(4, 5)\n        >>> p1.taxicab_distance(p2)\n        7\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "unit",
    "full_id": "sympy.geometry.point.Point.unit",
    "type": "property",
    "description": "Return the Point that is in the same direction as `self`\n        and a distance of 1 from the origin",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "coordinates",
    "full_id": "sympy.geometry.point.Point2D.coordinates",
    "type": "property",
    "description": "\n        Returns the two coordinates of the Point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point2D\n        >>> p = Point2D(0, 1)\n        >>> p.coordinates\n        (0, 1)\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "rotate",
    "full_id": "sympy.geometry.point.Point2D.rotate",
    "type": "method",
    "description": "Rotate ``angle`` radians counterclockwise about Point ``pt``.\n\n        See Also\n        ========\n\n        translate, scale\n\n        Examples\n        ========\n\n        >>> from sympy import Point2D, pi\n        >>> t = Point2D(1, 0)\n        >>> t.rotate(pi/2)\n        Point2D(0, 1)\n        >>> t.rotate(pi/2, (2, 0))\n        Point2D(2, -1)\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "scale",
    "full_id": "sympy.geometry.point.Point2D.scale",
    "type": "method",
    "description": "Scale the coordinates of the Point by multiplying by\n        ``x`` and ``y`` after subtracting ``pt`` -- default is (0, 0) --\n        and then adding ``pt`` back again (i.e. ``pt`` is the point of\n        reference for the scaling).\n\n        See Also\n        ========\n\n        rotate, translate\n\n        Examples\n        ========\n\n        >>> from sympy import Point2D\n        >>> t = Point2D(1, 1)\n        >>> t.scale(2)\n        Point2D(2, 1)\n        >>> t.scale(2, 2)\n        Point2D(2, 2)\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "transform",
    "full_id": "sympy.geometry.point.Point2D.transform",
    "type": "method",
    "description": "Return the point after applying the transformation described\n        by the 3x3 Matrix, ``matrix``.\n\n        See Also\n        ========\n        sympy.geometry.point.Point2D.rotate\n        sympy.geometry.point.Point2D.scale\n        sympy.geometry.point.Point2D.translate\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "translate",
    "full_id": "sympy.geometry.point.Point2D.translate",
    "type": "method",
    "description": "Shift the Point by adding x and y to the coordinates of the Point.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point2D.rotate, scale\n\n        Examples\n        ========\n\n        >>> from sympy import Point2D\n        >>> t = Point2D(0, 1)\n        >>> t.translate(2)\n        Point2D(2, 1)\n        >>> t.translate(2, 2)\n        Point2D(2, 3)\n        >>> t + Point2D(2, 2)\n        Point2D(2, 3)\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "x",
    "full_id": "sympy.geometry.point.Point2D.x",
    "type": "property",
    "description": "\n        Returns the X coordinate of the Point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point2D\n        >>> p = Point2D(0, 1)\n        >>> p.x\n        0\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "y",
    "full_id": "sympy.geometry.point.Point2D.y",
    "type": "property",
    "description": "\n        Returns the Y coordinate of the Point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point2D\n        >>> p = Point2D(0, 1)\n        >>> p.y\n        1\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "are_collinear",
    "full_id": "sympy.geometry.point.Point3D.are_collinear",
    "type": "method",
    "description": "Is a sequence of points collinear?\n\n        Test whether or not a set of points are collinear. Returns True if\n        the set of points are collinear, or False otherwise.\n\n        Parameters\n        ==========\n\n        points : sequence of Point\n\n        Returns\n        =======\n\n        are_collinear : boolean\n\n        See Also\n        ========\n\n        sympy.geometry.line.Line3D\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> from sympy.abc import x\n        >>> p1, p2 = Point3D(0, 0, 0), Point3D(1, 1, 1)\n        >>> p3, p4, p5 = Point3D(2, 2, 2), Point3D(x, x, x), Point3D(1, 2, 6)\n        >>> Point3D.are_collinear(p1, p2, p3, p4)\n        True\n        >>> Point3D.are_collinear(p1, p2, p3, p5)\n        False\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "coordinates",
    "full_id": "sympy.geometry.point.Point3D.coordinates",
    "type": "property",
    "description": "\n        Returns the three coordinates of the Point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> p = Point3D(0, 1, 2)\n        >>> p.coordinates\n        (0, 1, 2)\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "direction_cosine",
    "full_id": "sympy.geometry.point.Point3D.direction_cosine",
    "type": "method",
    "description": "\n        Gives the direction cosine between 2 points\n\n        Parameters\n        ==========\n\n        p : Point3D\n\n        Returns\n        =======\n\n        list\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> p1 = Point3D(1, 2, 3)\n        >>> p1.direction_cosine(Point3D(2, 3, 5))\n        [sqrt(6)/6, sqrt(6)/6, sqrt(6)/3]\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "direction_ratio",
    "full_id": "sympy.geometry.point.Point3D.direction_ratio",
    "type": "method",
    "description": "\n        Gives the direction ratio between 2 points\n\n        Parameters\n        ==========\n\n        p : Point3D\n\n        Returns\n        =======\n\n        list\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> p1 = Point3D(1, 2, 3)\n        >>> p1.direction_ratio(Point3D(2, 3, 5))\n        [1, 1, 2]\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.geometry.point.Point3D.intersection",
    "type": "method",
    "description": "The intersection between this point and another GeometryEntity.\n\n        Parameters\n        ==========\n\n        other : GeometryEntity or sequence of coordinates\n\n        Returns\n        =======\n\n        intersection : list of Points\n\n        Notes\n        =====\n\n        The return value will either be an empty list if there is no\n        intersection, otherwise it will contain this point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(1, 1, 1), Point3D(0, 0, 0)\n        >>> p1.intersection(p2)\n        []\n        >>> p1.intersection(p3)\n        [Point3D(0, 0, 0)]\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "scale",
    "full_id": "sympy.geometry.point.Point3D.scale",
    "type": "method",
    "description": "Scale the coordinates of the Point by multiplying by\n        ``x`` and ``y`` after subtracting ``pt`` -- default is (0, 0) --\n        and then adding ``pt`` back again (i.e. ``pt`` is the point of\n        reference for the scaling).\n\n        See Also\n        ========\n\n        translate\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> t = Point3D(1, 1, 1)\n        >>> t.scale(2)\n        Point3D(2, 1, 1)\n        >>> t.scale(2, 2)\n        Point3D(2, 2, 1)\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "transform",
    "full_id": "sympy.geometry.point.Point3D.transform",
    "type": "method",
    "description": "Return the point after applying the transformation described\n        by the 4x4 Matrix, ``matrix``.\n\n        See Also\n        ========\n        sympy.geometry.point.Point3D.scale\n        sympy.geometry.point.Point3D.translate\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "translate",
    "full_id": "sympy.geometry.point.Point3D.translate",
    "type": "method",
    "description": "Shift the Point by adding x and y to the coordinates of the Point.\n\n        See Also\n        ========\n\n        scale\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> t = Point3D(0, 1, 1)\n        >>> t.translate(2)\n        Point3D(2, 1, 1)\n        >>> t.translate(2, 2)\n        Point3D(2, 3, 1)\n        >>> t + Point3D(2, 2, 2)\n        Point3D(2, 3, 3)\n\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "x",
    "full_id": "sympy.geometry.point.Point3D.x",
    "type": "property",
    "description": "\n        Returns the X coordinate of the Point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> p = Point3D(0, 1, 3)\n        >>> p.x\n        0\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "y",
    "full_id": "sympy.geometry.point.Point3D.y",
    "type": "property",
    "description": "\n        Returns the Y coordinate of the Point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> p = Point3D(0, 1, 2)\n        >>> p.y\n        1\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "z",
    "full_id": "sympy.geometry.point.Point3D.z",
    "type": "property",
    "description": "\n        Returns the Z coordinate of the Point.\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D\n        >>> p = Point3D(0, 1, 1)\n        >>> p.z\n        1\n        ",
    "section": "Points",
    "url": "https://docs.sympy.org/latest/modules/geometry/points.html"
  },
  {
    "name": "ambient_dimension",
    "full_id": "sympy.geometry.line.LinearEntity.ambient_dimension",
    "type": "property",
    "description": "A property method that returns the dimension of LinearEntity\n        object.\n\n        Parameters\n        ==========\n\n        p1 : LinearEntity\n\n        Returns\n        =======\n\n        dimension : integer\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(1, 1)\n        >>> l1 = Line(p1, p2)\n        >>> l1.ambient_dimension\n        2\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0, 0), Point(1, 1, 1)\n        >>> l1 = Line(p1, p2)\n        >>> l1.ambient_dimension\n        3\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "angle_between",
    "full_id": "sympy.geometry.line.LinearEntity.angle_between",
    "type": "method",
    "description": "Return the non-reflex angle formed by rays emanating from\n        the origin with directions the same as the direction vectors\n        of the linear entities.\n\n        Parameters\n        ==========\n\n        l1 : LinearEntity\n        l2 : LinearEntity\n\n        Returns\n        =======\n\n        angle : angle in radians\n\n        Notes\n        =====\n\n        From the dot product of vectors v1 and v2 it is known that:\n\n            ``dot(v1, v2) = |v1|*|v2|*cos(A)``\n\n        where A is the angle formed between the two vectors. We can\n        get the directional vectors of the two lines and readily\n        find the angle between the two using the above formula.\n\n        See Also\n        ========\n\n        is_perpendicular, Ray2D.closing_angle\n\n        Examples\n        ========\n\n        >>> from sympy import Line\n        >>> e = Line((0, 0), (1, 0))\n        >>> ne = Line((0, 0), (1, 1))\n        >>> sw = Line((1, 1), (0, 0))\n        >>> ne.angle_between(e)\n        pi/4\n        >>> sw.angle_between(e)\n        3*pi/4\n\n        To obtain the non-obtuse angle at the intersection of lines, use\n        the ``smallest_angle_between`` method:\n\n        >>> sw.smallest_angle_between(e)\n        pi/4\n\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(1, 1, 1), Point3D(-1, 2, 0)\n        >>> l1, l2 = Line3D(p1, p2), Line3D(p2, p3)\n        >>> l1.angle_between(l2)\n        acos(-sqrt(2)/3)\n        >>> l1.smallest_angle_between(l2)\n        acos(sqrt(2)/3)\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "arbitrary_point",
    "full_id": "sympy.geometry.line.LinearEntity.arbitrary_point",
    "type": "method",
    "description": "A parameterized point on the Line.\n\n        Parameters\n        ==========\n\n        parameter : str, optional\n            The name of the parameter which will be used for the parametric\n            point. The default value is 't'. When this parameter is 0, the\n            first point used to define the line will be returned, and when\n            it is 1 the second point will be returned.\n\n        Returns\n        =======\n\n        point : Point\n\n        Raises\n        ======\n\n        ValueError\n            When ``parameter`` already appears in the Line's definition.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(1, 0), Point(5, 3)\n        >>> l1 = Line(p1, p2)\n        >>> l1.arbitrary_point()\n        Point2D(4*t + 1, 3*t)\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2 = Point3D(1, 0, 0), Point3D(5, 3, 1)\n        >>> l1 = Line3D(p1, p2)\n        >>> l1.arbitrary_point()\n        Point3D(4*t + 1, 3*t, t)\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "are_concurrent",
    "full_id": "sympy.geometry.line.LinearEntity.are_concurrent",
    "type": "method",
    "description": "Is a sequence of linear entities concurrent?\n\n        Two or more linear entities are concurrent if they all\n        intersect at a single point.\n\n        Parameters\n        ==========\n\n        lines\n            A sequence of linear entities.\n\n        Returns\n        =======\n\n        True : if the set of linear entities intersect in one point\n        False : otherwise.\n\n        See Also\n        ========\n\n        sympy.geometry.util.intersection\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(3, 5)\n        >>> p3, p4 = Point(-2, -2), Point(0, 2)\n        >>> l1, l2, l3 = Line(p1, p2), Line(p1, p3), Line(p1, p4)\n        >>> Line.are_concurrent(l1, l2, l3)\n        True\n        >>> l4 = Line(p2, p3)\n        >>> Line.are_concurrent(l2, l3, l4)\n        False\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2 = Point3D(0, 0, 0), Point3D(3, 5, 2)\n        >>> p3, p4 = Point3D(-2, -2, -2), Point3D(0, 2, 1)\n        >>> l1, l2, l3 = Line3D(p1, p2), Line3D(p1, p3), Line3D(p1, p4)\n        >>> Line3D.are_concurrent(l1, l2, l3)\n        True\n        >>> l4 = Line3D(p2, p3)\n        >>> Line3D.are_concurrent(l2, l3, l4)\n        False\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "bisectors",
    "full_id": "sympy.geometry.line.LinearEntity.bisectors",
    "type": "method",
    "description": "Returns the perpendicular lines which pass through the intersections\n        of self and other that are in the same plane.\n\n        Parameters\n        ==========\n\n        line : Line3D\n\n        Returns\n        =======\n\n        list: two Line instances\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Line3D\n        >>> r1 = Line3D(Point3D(0, 0, 0), Point3D(1, 0, 0))\n        >>> r2 = Line3D(Point3D(0, 0, 0), Point3D(0, 1, 0))\n        >>> r1.bisectors(r2)\n        [Line3D(Point3D(0, 0, 0), Point3D(1, 1, 0)), Line3D(Point3D(0, 0, 0), Point3D(1, -1, 0))]\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.geometry.line.LinearEntity.contains",
    "type": "method",
    "description": "Subclasses should implement this method and should return\n        True if other is on the boundaries of self;\n        False if not on the boundaries of self;\n        None if a determination cannot be made.",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "direction",
    "full_id": "sympy.geometry.line.LinearEntity.direction",
    "type": "property",
    "description": "The direction vector of the LinearEntity.\n\n        Returns\n        =======\n\n        p : a Point; the ray from the origin to this point is the\n            direction of `self`\n\n        Examples\n        ========\n\n        >>> from sympy import Line\n        >>> a, b = (1, 1), (1, 3)\n        >>> Line(a, b).direction\n        Point2D(0, 2)\n        >>> Line(b, a).direction\n        Point2D(0, -2)\n\n        This can be reported so the distance from the origin is 1:\n\n        >>> Line(b, a).direction.unit\n        Point2D(0, -1)\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point.unit\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.geometry.line.LinearEntity.intersection",
    "type": "method",
    "description": "The intersection with another geometrical entity.\n\n        Parameters\n        ==========\n\n        o : Point or LinearEntity\n\n        Returns\n        =======\n\n        intersection : list of geometrical entities\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line, Segment\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 1), Point(7, 7)\n        >>> l1 = Line(p1, p2)\n        >>> l1.intersection(p3)\n        [Point2D(7, 7)]\n        >>> p4, p5 = Point(5, 0), Point(0, 3)\n        >>> l2 = Line(p4, p5)\n        >>> l1.intersection(l2)\n        [Point2D(15/8, 15/8)]\n        >>> p6, p7 = Point(0, 5), Point(2, 6)\n        >>> s1 = Segment(p6, p7)\n        >>> l1.intersection(s1)\n        []\n        >>> from sympy import Point3D, Line3D, Segment3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(1, 1, 1), Point3D(7, 7, 7)\n        >>> l1 = Line3D(p1, p2)\n        >>> l1.intersection(p3)\n        [Point3D(7, 7, 7)]\n        >>> l1 = Line3D(Point3D(4,19,12), Point3D(5,25,17))\n        >>> l2 = Line3D(Point3D(-3, -15, -19), direction_ratio=[2,8,8])\n        >>> l1.intersection(l2)\n        [Point3D(1, 1, -3)]\n        >>> p6, p7 = Point3D(0, 5, 2), Point3D(2, 6, 3)\n        >>> s1 = Segment3D(p6, p7)\n        >>> l1.intersection(s1)\n        []\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "is_parallel",
    "full_id": "sympy.geometry.line.LinearEntity.is_parallel",
    "type": "method",
    "description": "Are two linear entities parallel?\n\n        Parameters\n        ==========\n\n        l1 : LinearEntity\n        l2 : LinearEntity\n\n        Returns\n        =======\n\n        True : if l1 and l2 are parallel,\n        False : otherwise.\n\n        See Also\n        ========\n\n        coefficients\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(1, 1)\n        >>> p3, p4 = Point(3, 4), Point(6, 7)\n        >>> l1, l2 = Line(p1, p2), Line(p3, p4)\n        >>> Line.is_parallel(l1, l2)\n        True\n        >>> p5 = Point(6, 6)\n        >>> l3 = Line(p3, p5)\n        >>> Line.is_parallel(l1, l3)\n        False\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2 = Point3D(0, 0, 0), Point3D(3, 4, 5)\n        >>> p3, p4 = Point3D(2, 1, 1), Point3D(8, 9, 11)\n        >>> l1, l2 = Line3D(p1, p2), Line3D(p3, p4)\n        >>> Line3D.is_parallel(l1, l2)\n        True\n        >>> p5 = Point3D(6, 6, 6)\n        >>> l3 = Line3D(p3, p5)\n        >>> Line3D.is_parallel(l1, l3)\n        False\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "is_perpendicular",
    "full_id": "sympy.geometry.line.LinearEntity.is_perpendicular",
    "type": "method",
    "description": "Are two linear entities perpendicular?\n\n        Parameters\n        ==========\n\n        l1 : LinearEntity\n        l2 : LinearEntity\n\n        Returns\n        =======\n\n        True : if l1 and l2 are perpendicular,\n        False : otherwise.\n\n        See Also\n        ========\n\n        coefficients\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 1), Point(-1, 1)\n        >>> l1, l2 = Line(p1, p2), Line(p1, p3)\n        >>> l1.is_perpendicular(l2)\n        True\n        >>> p4 = Point(5, 3)\n        >>> l3 = Line(p1, p4)\n        >>> l1.is_perpendicular(l3)\n        False\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(1, 1, 1), Point3D(-1, 2, 0)\n        >>> l1, l2 = Line3D(p1, p2), Line3D(p2, p3)\n        >>> l1.is_perpendicular(l2)\n        False\n        >>> p4 = Point3D(5, 3, 7)\n        >>> l3 = Line3D(p1, p4)\n        >>> l1.is_perpendicular(l3)\n        False\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "is_similar",
    "full_id": "sympy.geometry.line.LinearEntity.is_similar",
    "type": "method",
    "description": "\n        Return True if self and other are contained in the same line.\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2, p3 = Point(0, 1), Point(3, 4), Point(2, 3)\n        >>> l1 = Line(p1, p2)\n        >>> l2 = Line(p1, p3)\n        >>> l1.is_similar(l2)\n        True\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "length",
    "full_id": "sympy.geometry.line.LinearEntity.length",
    "type": "property",
    "description": "\n        The length of the line.\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(3, 5)\n        >>> l1 = Line(p1, p2)\n        >>> l1.length\n        oo\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "p1",
    "full_id": "sympy.geometry.line.LinearEntity.p1",
    "type": "property",
    "description": "The first defining point of a linear entity.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(5, 3)\n        >>> l = Line(p1, p2)\n        >>> l.p1\n        Point2D(0, 0)\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "p2",
    "full_id": "sympy.geometry.line.LinearEntity.p2",
    "type": "property",
    "description": "The second defining point of a linear entity.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(5, 3)\n        >>> l = Line(p1, p2)\n        >>> l.p2\n        Point2D(5, 3)\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "parallel_line",
    "full_id": "sympy.geometry.line.LinearEntity.parallel_line",
    "type": "method",
    "description": "Create a new Line parallel to this linear entity which passes\n        through the point `p`.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        line : Line\n\n        See Also\n        ========\n\n        is_parallel\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2, p3 = Point(0, 0), Point(2, 3), Point(-2, 2)\n        >>> l1 = Line(p1, p2)\n        >>> l2 = l1.parallel_line(p3)\n        >>> p3 in l2\n        True\n        >>> l1.is_parallel(l2)\n        True\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(2, 3, 4), Point3D(-2, 2, 0)\n        >>> l1 = Line3D(p1, p2)\n        >>> l2 = l1.parallel_line(p3)\n        >>> p3 in l2\n        True\n        >>> l1.is_parallel(l2)\n        True\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "perpendicular_line",
    "full_id": "sympy.geometry.line.LinearEntity.perpendicular_line",
    "type": "method",
    "description": "Create a new Line perpendicular to this linear entity which passes\n        through the point `p`.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        line : Line\n\n        See Also\n        ========\n\n        sympy.geometry.line.LinearEntity.is_perpendicular, perpendicular_segment\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(2, 3, 4), Point3D(-2, 2, 0)\n        >>> L = Line3D(p1, p2)\n        >>> P = L.perpendicular_line(p3); P\n        Line3D(Point3D(-2, 2, 0), Point3D(4/29, 6/29, 8/29))\n        >>> L.is_perpendicular(P)\n        True\n\n        In 3D the, the first point used to define the line is the point\n        through which the perpendicular was required to pass; the\n        second point is (arbitrarily) contained in the given line:\n\n        >>> P.p2 in L\n        True\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "perpendicular_segment",
    "full_id": "sympy.geometry.line.LinearEntity.perpendicular_segment",
    "type": "method",
    "description": "Create a perpendicular line segment from `p` to this line.\n\n        The endpoints of the segment are ``p`` and the closest point in\n        the line containing self. (If self is not a line, the point might\n        not be in self.)\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        segment : Segment\n\n        Notes\n        =====\n\n        Returns `p` itself if `p` is on this linear entity.\n\n        See Also\n        ========\n\n        perpendicular_line\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 1), Point(0, 2)\n        >>> l1 = Line(p1, p2)\n        >>> s1 = l1.perpendicular_segment(p3)\n        >>> l1.is_perpendicular(s1)\n        True\n        >>> p3 in s1\n        True\n        >>> l1.perpendicular_segment(Point(4, 0))\n        Segment2D(Point2D(4, 0), Point2D(2, 2))\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(1, 1, 1), Point3D(0, 2, 0)\n        >>> l1 = Line3D(p1, p2)\n        >>> s1 = l1.perpendicular_segment(p3)\n        >>> l1.is_perpendicular(s1)\n        True\n        >>> p3 in s1\n        True\n        >>> l1.perpendicular_segment(Point3D(4, 0, 0))\n        Segment3D(Point3D(4, 0, 0), Point3D(4/3, 4/3, 4/3))\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "points",
    "full_id": "sympy.geometry.line.LinearEntity.points",
    "type": "property",
    "description": "The two points used to define this linear entity.\n\n        Returns\n        =======\n\n        points : tuple of Points\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(5, 11)\n        >>> l1 = Line(p1, p2)\n        >>> l1.points\n        (Point2D(0, 0), Point2D(5, 11))\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "projection",
    "full_id": "sympy.geometry.line.LinearEntity.projection",
    "type": "method",
    "description": "Project a point, line, ray, or segment onto this linear entity.\n\n        Parameters\n        ==========\n\n        other : Point or LinearEntity (Line, Ray, Segment)\n\n        Returns\n        =======\n\n        projection : Point or LinearEntity (Line, Ray, Segment)\n            The return type matches the type of the parameter ``other``.\n\n        Raises\n        ======\n\n        GeometryError\n            When method is unable to perform projection.\n\n        Notes\n        =====\n\n        A projection involves taking the two points that define\n        the linear entity and projecting those points onto a\n        Line and then reforming the linear entity using these\n        projections.\n        A point P is projected onto a line L by finding the point\n        on L that is closest to P. This point is the intersection\n        of L and the line perpendicular to L that passes through P.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, perpendicular_line\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line, Segment, Rational\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 1), Point(Rational(1, 2), 0)\n        >>> l1 = Line(p1, p2)\n        >>> l1.projection(p3)\n        Point2D(1/4, 1/4)\n        >>> p4, p5 = Point(10, 0), Point(12, 1)\n        >>> s1 = Segment(p4, p5)\n        >>> l1.projection(s1)\n        Segment2D(Point2D(5, 5), Point2D(13/2, 13/2))\n        >>> p1, p2, p3 = Point(0, 0, 1), Point(1, 1, 2), Point(2, 0, 1)\n        >>> l1 = Line(p1, p2)\n        >>> l1.projection(p3)\n        Point3D(2/3, 2/3, 5/3)\n        >>> p4, p5 = Point(10, 0, 1), Point(12, 1, 3)\n        >>> s1 = Segment(p4, p5)\n        >>> l1.projection(s1)\n        Segment3D(Point3D(10/3, 10/3, 13/3), Point3D(5, 5, 6))\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "random_point",
    "full_id": "sympy.geometry.line.LinearEntity.random_point",
    "type": "method",
    "description": "A random point on a LinearEntity.\n\n        Returns\n        =======\n\n        point : Point\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line, Ray, Segment\n        >>> p1, p2 = Point(0, 0), Point(5, 3)\n        >>> line = Line(p1, p2)\n        >>> r = line.random_point(seed=42)  # seed value is optional\n        >>> r.n(3)\n        Point2D(-0.72, -0.432)\n        >>> r in line\n        True\n        >>> Ray(p1, p2).random_point(seed=42).n(3)\n        Point2D(0.72, 0.432)\n        >>> Segment(p1, p2).random_point(seed=42).n(3)\n        Point2D(3.2, 1.92)\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "smallest_angle_between",
    "full_id": "sympy.geometry.line.LinearEntity.smallest_angle_between",
    "type": "method",
    "description": "Return the smallest angle formed at the intersection of the\n        lines containing the linear entities.\n\n        Parameters\n        ==========\n\n        l1 : LinearEntity\n        l2 : LinearEntity\n\n        Returns\n        =======\n\n        angle : angle in radians\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2, p3 = Point(0, 0), Point(0, 4), Point(2, -2)\n        >>> l1, l2 = Line(p1, p2), Line(p1, p3)\n        >>> l1.smallest_angle_between(l2)\n        pi/4\n\n        See Also\n        ========\n\n        angle_between, is_perpendicular, Ray2D.closing_angle\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.geometry.line.Line.contains",
    "type": "method",
    "description": "\n        Return True if `other` is on this Line, or False otherwise.\n\n        Examples\n        ========\n\n        >>> from sympy import Line,Point\n        >>> p1, p2 = Point(0, 1), Point(3, 4)\n        >>> l = Line(p1, p2)\n        >>> l.contains(p1)\n        True\n        >>> l.contains((0, 1))\n        True\n        >>> l.contains((0, 0))\n        False\n        >>> a = (0, 0, 0)\n        >>> b = (1, 1, 1)\n        >>> c = (2, 2, 2)\n        >>> l1 = Line(a, b)\n        >>> l2 = Line(b, a)\n        >>> l1 == l2\n        False\n        >>> l1 in l2\n        True\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "distance",
    "full_id": "sympy.geometry.line.Line.distance",
    "type": "method",
    "description": "\n        Finds the shortest distance between a line and a point.\n\n        Raises\n        ======\n\n        NotImplementedError is raised if `other` is not a Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(1, 1)\n        >>> s = Line(p1, p2)\n        >>> s.distance(Point(-1, 1))\n        sqrt(2)\n        >>> s.distance((-1, 2))\n        3*sqrt(2)/2\n        >>> p1, p2 = Point(0, 0, 0), Point(1, 1, 1)\n        >>> s = Line(p1, p2)\n        >>> s.distance(Point(-1, 1, 1))\n        2*sqrt(6)/3\n        >>> s.distance((-1, 1, 1))\n        2*sqrt(6)/3\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "equals",
    "full_id": "sympy.geometry.line.Line.equals",
    "type": "method",
    "description": "Returns True if self and other are the same mathematical entities",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "plot_interval",
    "full_id": "sympy.geometry.line.Line.plot_interval",
    "type": "method",
    "description": "The plot interval for the default geometric plot of line. Gives\n        values that will produce a line that is +/- 5 units long (where a\n        unit is the distance between the two points that define the line).\n\n        Parameters\n        ==========\n\n        parameter : str, optional\n            Default value is 't'.\n\n        Returns\n        =======\n\n        plot_interval : list (plot interval)\n            [parameter, lower_bound, upper_bound]\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(5, 3)\n        >>> l1 = Line(p1, p2)\n        >>> l1.plot_interval()\n        [t, -5, 5]\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.geometry.line.Ray.contains",
    "type": "method",
    "description": "\n        Is other GeometryEntity contained in this Ray?\n\n        Examples\n        ========\n\n        >>> from sympy import Ray,Point,Segment\n        >>> p1, p2 = Point(0, 0), Point(4, 4)\n        >>> r = Ray(p1, p2)\n        >>> r.contains(p1)\n        True\n        >>> r.contains((1, 1))\n        True\n        >>> r.contains((1, 3))\n        False\n        >>> s = Segment((1, 1), (2, 2))\n        >>> r.contains(s)\n        True\n        >>> s = Segment((1, 2), (2, 5))\n        >>> r.contains(s)\n        False\n        >>> r1 = Ray((2, 2), (3, 3))\n        >>> r.contains(r1)\n        True\n        >>> r1 = Ray((2, 2), (3, 5))\n        >>> r.contains(r1)\n        False\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "distance",
    "full_id": "sympy.geometry.line.Ray.distance",
    "type": "method",
    "description": "\n        Finds the shortest distance between the ray and a point.\n\n        Raises\n        ======\n\n        NotImplementedError is raised if `other` is not a Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ray\n        >>> p1, p2 = Point(0, 0), Point(1, 1)\n        >>> s = Ray(p1, p2)\n        >>> s.distance(Point(-1, -1))\n        sqrt(2)\n        >>> s.distance((-1, 2))\n        3*sqrt(2)/2\n        >>> p1, p2 = Point(0, 0, 0), Point(1, 1, 2)\n        >>> s = Ray(p1, p2)\n        >>> s\n        Ray3D(Point3D(0, 0, 0), Point3D(1, 1, 2))\n        >>> s.distance(Point(-1, -1, 2))\n        4*sqrt(3)/3\n        >>> s.distance((-1, -1, 2))\n        4*sqrt(3)/3\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "plot_interval",
    "full_id": "sympy.geometry.line.Ray.plot_interval",
    "type": "method",
    "description": "The plot interval for the default geometric plot of the Ray. Gives\n        values that will produce a ray that is 10 units long (where a unit is\n        the distance between the two points that define the ray).\n\n        Parameters\n        ==========\n\n        parameter : str, optional\n            Default value is 't'.\n\n        Returns\n        =======\n\n        plot_interval : list\n            [parameter, lower_bound, upper_bound]\n\n        Examples\n        ========\n\n        >>> from sympy import Ray, pi\n        >>> r = Ray((0, 0), angle=pi/4)\n        >>> r.plot_interval()\n        [t, 0, 10]\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "source",
    "full_id": "sympy.geometry.line.Ray.source",
    "type": "property",
    "description": "The point from which the ray emanates.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ray\n        >>> p1, p2 = Point(0, 0), Point(4, 1)\n        >>> r1 = Ray(p1, p2)\n        >>> r1.source\n        Point2D(0, 0)\n        >>> p1, p2 = Point(0, 0, 0), Point(4, 1, 5)\n        >>> r1 = Ray(p2, p1)\n        >>> r1.source\n        Point3D(4, 1, 5)\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.geometry.line.Segment.contains",
    "type": "method",
    "description": "\n        Is the other GeometryEntity contained within this Segment?\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Segment\n        >>> p1, p2 = Point(0, 1), Point(3, 4)\n        >>> s = Segment(p1, p2)\n        >>> s2 = Segment(p2, p1)\n        >>> s.contains(s2)\n        True\n        >>> from sympy import Point3D, Segment3D\n        >>> p1, p2 = Point3D(0, 1, 1), Point3D(3, 4, 5)\n        >>> s = Segment3D(p1, p2)\n        >>> s2 = Segment3D(p2, p1)\n        >>> s.contains(s2)\n        True\n        >>> s.contains((p1 + p2)/2)\n        True\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "distance",
    "full_id": "sympy.geometry.line.Segment.distance",
    "type": "method",
    "description": "\n        Finds the shortest distance between a line segment and a point.\n\n        Raises\n        ======\n\n        NotImplementedError is raised if `other` is not a Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Segment\n        >>> p1, p2 = Point(0, 1), Point(3, 4)\n        >>> s = Segment(p1, p2)\n        >>> s.distance(Point(10, 15))\n        sqrt(170)\n        >>> s.distance((0, 12))\n        sqrt(73)\n        >>> from sympy import Point3D, Segment3D\n        >>> p1, p2 = Point3D(0, 0, 3), Point3D(1, 1, 4)\n        >>> s = Segment3D(p1, p2)\n        >>> s.distance(Point3D(10, 15, 12))\n        sqrt(341)\n        >>> s.distance((10, 15, 12))\n        sqrt(341)\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "length",
    "full_id": "sympy.geometry.line.Segment.length",
    "type": "property",
    "description": "The length of the line segment.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point.distance\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Segment\n        >>> p1, p2 = Point(0, 0), Point(4, 3)\n        >>> s1 = Segment(p1, p2)\n        >>> s1.length\n        5\n        >>> from sympy import Point3D, Segment3D\n        >>> p1, p2 = Point3D(0, 0, 0), Point3D(4, 3, 3)\n        >>> s1 = Segment3D(p1, p2)\n        >>> s1.length\n        sqrt(34)\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "midpoint",
    "full_id": "sympy.geometry.line.Segment.midpoint",
    "type": "property",
    "description": "The midpoint of the line segment.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point.midpoint\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Segment\n        >>> p1, p2 = Point(0, 0), Point(4, 3)\n        >>> s1 = Segment(p1, p2)\n        >>> s1.midpoint\n        Point2D(2, 3/2)\n        >>> from sympy import Point3D, Segment3D\n        >>> p1, p2 = Point3D(0, 0, 0), Point3D(4, 3, 3)\n        >>> s1 = Segment3D(p1, p2)\n        >>> s1.midpoint\n        Point3D(2, 3/2, 3/2)\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "perpendicular_bisector",
    "full_id": "sympy.geometry.line.Segment.perpendicular_bisector",
    "type": "method",
    "description": "The perpendicular bisector of this segment.\n\n        If no point is specified or the point specified is not on the\n        bisector then the bisector is returned as a Line. Otherwise a\n        Segment is returned that joins the point specified and the\n        intersection of the bisector and the segment.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        bisector : Line or Segment\n\n        See Also\n        ========\n\n        LinearEntity.perpendicular_segment\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Segment\n        >>> p1, p2, p3 = Point(0, 0), Point(6, 6), Point(5, 1)\n        >>> s1 = Segment(p1, p2)\n        >>> s1.perpendicular_bisector()\n        Line2D(Point2D(3, 3), Point2D(-3, 9))\n\n        >>> s1.perpendicular_bisector(p3)\n        Segment2D(Point2D(5, 1), Point2D(3, 3))\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "plot_interval",
    "full_id": "sympy.geometry.line.Segment.plot_interval",
    "type": "method",
    "description": "The plot interval for the default geometric plot of the Segment gives\n        values that will produce the full segment in a plot.\n\n        Parameters\n        ==========\n\n        parameter : str, optional\n            Default value is 't'.\n\n        Returns\n        =======\n\n        plot_interval : list\n            [parameter, lower_bound, upper_bound]\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Segment\n        >>> p1, p2 = Point(0, 0), Point(5, 3)\n        >>> s1 = Segment(p1, p2)\n        >>> s1.plot_interval()\n        [t, 0, 1]\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "perpendicular_line",
    "full_id": "sympy.geometry.line.LinearEntity2D.perpendicular_line",
    "type": "method",
    "description": "Create a new Line perpendicular to this linear entity which passes\n        through the point `p`.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        line : Line\n\n        See Also\n        ========\n\n        sympy.geometry.line.LinearEntity.is_perpendicular, perpendicular_segment\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2, p3 = Point(0, 0), Point(2, 3), Point(-2, 2)\n        >>> L = Line(p1, p2)\n        >>> P = L.perpendicular_line(p3); P\n        Line2D(Point2D(-2, 2), Point2D(-5, 4))\n        >>> L.is_perpendicular(P)\n        True\n\n        In 2D, the first point of the perpendicular line is the\n        point through which was required to pass; the second\n        point is arbitrarily chosen. To get a line that explicitly\n        uses a point in the line, create a line from the perpendicular\n        segment from the line to the point:\n\n        >>> Line(L.perpendicular_segment(p3))\n        Line2D(Point2D(-2, 2), Point2D(4/13, 6/13))\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "slope",
    "full_id": "sympy.geometry.line.LinearEntity2D.slope",
    "type": "property",
    "description": "The slope of this linear entity, or infinity if vertical.\n\n        Returns\n        =======\n\n        slope : number or SymPy expression\n\n        See Also\n        ========\n\n        coefficients\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(0, 0), Point(3, 5)\n        >>> l1 = Line(p1, p2)\n        >>> l1.slope\n        5/3\n\n        >>> p3 = Point(0, 4)\n        >>> l2 = Line(p1, p3)\n        >>> l2.slope\n        oo\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "coefficients",
    "full_id": "sympy.geometry.line.Line2D.coefficients",
    "type": "property",
    "description": "The coefficients (`a`, `b`, `c`) for `ax + by + c = 0`.\n\n        See Also\n        ========\n\n        sympy.geometry.line.Line2D.equation\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> from sympy.abc import x, y\n        >>> p1, p2 = Point(0, 0), Point(5, 3)\n        >>> l = Line(p1, p2)\n        >>> l.coefficients\n        (-3, 5, 0)\n\n        >>> p3 = Point(x, y)\n        >>> l2 = Line(p1, p3)\n        >>> l2.coefficients\n        (-y, x, 0)\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "equation",
    "full_id": "sympy.geometry.line.Line2D.equation",
    "type": "method",
    "description": "The equation of the line: ax + by + c.\n\n        Parameters\n        ==========\n\n        x : str, optional\n            The name to use for the x-axis, default value is 'x'.\n        y : str, optional\n            The name to use for the y-axis, default value is 'y'.\n\n        Returns\n        =======\n\n        equation : SymPy expression\n\n        See Also\n        ========\n\n        sympy.geometry.line.Line2D.coefficients\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Line\n        >>> p1, p2 = Point(1, 0), Point(5, 3)\n        >>> l1 = Line(p1, p2)\n        >>> l1.equation()\n        -3*x + 4*y + 3\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "closing_angle",
    "full_id": "sympy.geometry.line.Ray2D.closing_angle",
    "type": "method",
    "description": "Return the angle by which r2 must be rotated so it faces the same\n        direction as r1.\n\n        Parameters\n        ==========\n\n        r1 : Ray2D\n        r2 : Ray2D\n\n        Returns\n        =======\n\n        angle : angle in radians (ccw angle is positive)\n\n        See Also\n        ========\n\n        LinearEntity.angle_between\n\n        Examples\n        ========\n\n        >>> from sympy import Ray, pi\n        >>> r1 = Ray((0, 0), (1, 0))\n        >>> r2 = r1.rotate(-pi/2)\n        >>> angle = r1.closing_angle(r2); angle\n        pi/2\n        >>> r2.rotate(angle).direction.unit == r1.direction.unit\n        True\n        >>> r2.closing_angle(r1)\n        -pi/2\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "xdirection",
    "full_id": "sympy.geometry.line.Ray2D.xdirection",
    "type": "property",
    "description": "The x direction of the ray.\n\n        Positive infinity if the ray points in the positive x direction,\n        negative infinity if the ray points in the negative x direction,\n        or 0 if the ray is vertical.\n\n        See Also\n        ========\n\n        ydirection\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ray\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 1), Point(0, -1)\n        >>> r1, r2 = Ray(p1, p2), Ray(p1, p3)\n        >>> r1.xdirection\n        oo\n        >>> r2.xdirection\n        0\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "ydirection",
    "full_id": "sympy.geometry.line.Ray2D.ydirection",
    "type": "property",
    "description": "The y direction of the ray.\n\n        Positive infinity if the ray points in the positive y direction,\n        negative infinity if the ray points in the negative y direction,\n        or 0 if the ray is horizontal.\n\n        See Also\n        ========\n\n        xdirection\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ray\n        >>> p1, p2, p3 = Point(0, 0), Point(-1, -1), Point(-1, 0)\n        >>> r1, r2 = Ray(p1, p2), Ray(p1, p3)\n        >>> r1.ydirection\n        -oo\n        >>> r2.ydirection\n        0\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "direction_cosine",
    "full_id": "sympy.geometry.line.LinearEntity3D.direction_cosine",
    "type": "property",
    "description": "The normalized direction ratio of a given line in 3D.\n\n        See Also\n        ========\n\n        sympy.geometry.line.Line3D.equation\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2 = Point3D(0, 0, 0), Point3D(5, 3, 1)\n        >>> l = Line3D(p1, p2)\n        >>> l.direction_cosine\n        [sqrt(35)/7, 3*sqrt(35)/35, sqrt(35)/35]\n        >>> sum(i**2 for i in _)\n        1\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "direction_ratio",
    "full_id": "sympy.geometry.line.LinearEntity3D.direction_ratio",
    "type": "property",
    "description": "The direction ratio of a given line in 3D.\n\n        See Also\n        ========\n\n        sympy.geometry.line.Line3D.equation\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Line3D\n        >>> p1, p2 = Point3D(0, 0, 0), Point3D(5, 3, 1)\n        >>> l = Line3D(p1, p2)\n        >>> l.direction_ratio\n        [5, 3, 1]\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "distance",
    "full_id": "sympy.geometry.line.Line3D.distance",
    "type": "method",
    "description": "\n        Finds the shortest distance between a line and another object.\n\n        Parameters\n        ==========\n\n        Point3D, Line3D, Plane, tuple, list\n\n        Returns\n        =======\n\n        distance\n\n        Notes\n        =====\n\n        This method accepts only 3D entities as it's parameter\n\n        Tuples and lists are converted to Point3D and therefore must be of\n        length 3, 2 or 1.\n\n        NotImplementedError is raised if `other` is not an instance of one\n        of the specified classes: Point3D, Line3D, or Plane.\n\n        Examples\n        ========\n\n        >>> from sympy.geometry import Line3D\n        >>> l1 = Line3D((0, 0, 0), (0, 0, 1))\n        >>> l2 = Line3D((0, 1, 0), (1, 1, 1))\n        >>> l1.distance(l2)\n        1\n\n        The computed distance may be symbolic, too:\n\n        >>> from sympy.abc import x, y\n        >>> l1 = Line3D((0, 0, 0), (0, 0, 1))\n        >>> l2 = Line3D((0, x, 0), (y, x, 1))\n        >>> l1.distance(l2)\n        Abs(x*y)/Abs(sqrt(y**2))\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "equation",
    "full_id": "sympy.geometry.line.Line3D.equation",
    "type": "method",
    "description": "Return the equations that define the line in 3D.\n\n        Parameters\n        ==========\n\n        x : str, optional\n            The name to use for the x-axis, default value is 'x'.\n        y : str, optional\n            The name to use for the y-axis, default value is 'y'.\n        z : str, optional\n            The name to use for the z-axis, default value is 'z'.\n\n        Returns\n        =======\n\n        equation : Tuple of simultaneous equations\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Line3D, solve\n        >>> from sympy.abc import x, y, z\n        >>> p1, p2 = Point3D(1, 0, 0), Point3D(5, 3, 0)\n        >>> l1 = Line3D(p1, p2)\n        >>> eq = l1.equation(x, y, z); eq\n        (-3*x + 4*y + 3, z)\n        >>> solve(eq.subs(z, 0), (x, y, z))\n        {x: 4*y/3 + 1}\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "xdirection",
    "full_id": "sympy.geometry.line.Ray3D.xdirection",
    "type": "property",
    "description": "The x direction of the ray.\n\n        Positive infinity if the ray points in the positive x direction,\n        negative infinity if the ray points in the negative x direction,\n        or 0 if the ray is vertical.\n\n        See Also\n        ========\n\n        ydirection\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Ray3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(1, 1, 1), Point3D(0, -1, 0)\n        >>> r1, r2 = Ray3D(p1, p2), Ray3D(p1, p3)\n        >>> r1.xdirection\n        oo\n        >>> r2.xdirection\n        0\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "ydirection",
    "full_id": "sympy.geometry.line.Ray3D.ydirection",
    "type": "property",
    "description": "The y direction of the ray.\n\n        Positive infinity if the ray points in the positive y direction,\n        negative infinity if the ray points in the negative y direction,\n        or 0 if the ray is horizontal.\n\n        See Also\n        ========\n\n        xdirection\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Ray3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(-1, -1, -1), Point3D(-1, 0, 0)\n        >>> r1, r2 = Ray3D(p1, p2), Ray3D(p1, p3)\n        >>> r1.ydirection\n        -oo\n        >>> r2.ydirection\n        0\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "zdirection",
    "full_id": "sympy.geometry.line.Ray3D.zdirection",
    "type": "property",
    "description": "The z direction of the ray.\n\n        Positive infinity if the ray points in the positive z direction,\n        negative infinity if the ray points in the negative z direction,\n        or 0 if the ray is horizontal.\n\n        See Also\n        ========\n\n        xdirection\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Ray3D\n        >>> p1, p2, p3 = Point3D(0, 0, 0), Point3D(-1, -1, -1), Point3D(-1, 0, 0)\n        >>> r1, r2 = Ray3D(p1, p2), Ray3D(p1, p3)\n        >>> r1.ydirection\n        -oo\n        >>> r2.ydirection\n        0\n        >>> r2.zdirection\n        0\n\n        ",
    "section": "Lines",
    "url": "https://docs.sympy.org/latest/modules/geometry/lines.html"
  },
  {
    "name": "ambient_dimension",
    "full_id": "sympy.geometry.curve.Curve.ambient_dimension",
    "type": "property",
    "description": "The dimension of the curve.\n\n        Returns\n        =======\n\n        int :\n            the dimension of curve.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import t\n        >>> from sympy import Curve\n        >>> C = Curve((t, t**2), (t, 0, 2))\n        >>> C.ambient_dimension\n        2\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "arbitrary_point",
    "full_id": "sympy.geometry.curve.Curve.arbitrary_point",
    "type": "method",
    "description": "A parameterized point on the curve.\n\n        Parameters\n        ==========\n\n        parameter : str or Symbol, optional\n            Default value is 't'.\n            The Curve's parameter is selected with None or self.parameter\n            otherwise the provided symbol is used.\n\n        Returns\n        =======\n\n        Point :\n            Returns a point in parametric form.\n\n        Raises\n        ======\n\n        ValueError\n            When `parameter` already appears in the functions.\n\n        Examples\n        ========\n\n        >>> from sympy import Curve, Symbol\n        >>> from sympy.abc import s\n        >>> C = Curve([2*s, s**2], (s, 0, 2))\n        >>> C.arbitrary_point()\n        Point2D(2*t, t**2)\n        >>> C.arbitrary_point(C.parameter)\n        Point2D(2*s, s**2)\n        >>> C.arbitrary_point(None)\n        Point2D(2*s, s**2)\n        >>> C.arbitrary_point(Symbol('a'))\n        Point2D(2*a, a**2)\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.geometry.curve.Curve.free_symbols",
    "type": "property",
    "description": "Return a set of symbols other than the bound symbols used to\n        parametrically define the Curve.\n\n        Returns\n        =======\n\n        set :\n            Set of all non-parameterized symbols.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import t, a\n        >>> from sympy import Curve\n        >>> Curve((t, t**2), (t, 0, 2)).free_symbols\n        set()\n        >>> Curve((t, t**2), (t, a, 2)).free_symbols\n        {a}\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "functions",
    "full_id": "sympy.geometry.curve.Curve.functions",
    "type": "property",
    "description": "The functions specifying the curve.\n\n        Returns\n        =======\n\n        functions :\n            list of parameterized coordinate functions.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import t\n        >>> from sympy import Curve\n        >>> C = Curve((t, t**2), (t, 0, 2))\n        >>> C.functions\n        (t, t**2)\n\n        See Also\n        ========\n\n        parameter\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "length",
    "full_id": "sympy.geometry.curve.Curve.length",
    "type": "property",
    "description": "The curve length.\n\n        Examples\n        ========\n\n        >>> from sympy import Curve\n        >>> from sympy.abc import t\n        >>> Curve((t, t), (t, 0, 1)).length\n        sqrt(2)\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "limits",
    "full_id": "sympy.geometry.curve.Curve.limits",
    "type": "property",
    "description": "The limits for the curve.\n\n        Returns\n        =======\n\n        limits : tuple\n            Contains parameter and lower and upper limits.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import t\n        >>> from sympy import Curve\n        >>> C = Curve([t, t**3], (t, -2, 2))\n        >>> C.limits\n        (t, -2, 2)\n\n        See Also\n        ========\n\n        plot_interval\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "parameter",
    "full_id": "sympy.geometry.curve.Curve.parameter",
    "type": "property",
    "description": "The curve function variable.\n\n        Returns\n        =======\n\n        Symbol :\n            returns a bound symbol.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import t\n        >>> from sympy import Curve\n        >>> C = Curve([t, t**2], (t, 0, 2))\n        >>> C.parameter\n        t\n\n        See Also\n        ========\n\n        functions\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "plot_interval",
    "full_id": "sympy.geometry.curve.Curve.plot_interval",
    "type": "method",
    "description": "The plot interval for the default geometric plot of the curve.\n\n        Parameters\n        ==========\n\n        parameter : str or Symbol, optional\n            Default value is 't';\n            otherwise the provided symbol is used.\n\n        Returns\n        =======\n\n        List :\n            the plot interval as below:\n                [parameter, lower_bound, upper_bound]\n\n        Examples\n        ========\n\n        >>> from sympy import Curve, sin\n        >>> from sympy.abc import x, s\n        >>> Curve((x, sin(x)), (x, 1, 2)).plot_interval()\n        [t, 1, 2]\n        >>> Curve((x, sin(x)), (x, 1, 2)).plot_interval(s)\n        [s, 1, 2]\n\n        See Also\n        ========\n\n        limits : Returns limits of the parameter interval\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "rotate",
    "full_id": "sympy.geometry.curve.Curve.rotate",
    "type": "method",
    "description": "This function is used to rotate a curve along given point ``pt`` at given angle(in radian).\n\n        Parameters\n        ==========\n\n        angle :\n            the angle at which the curve will be rotated(in radian) in counterclockwise direction.\n            default value of angle is 0.\n\n        pt : Point\n            the point along which the curve will be rotated.\n            If no point given, the curve will be rotated around origin.\n\n        Returns\n        =======\n\n        Curve :\n            returns a curve rotated at given angle along given point.\n\n        Examples\n        ========\n\n        >>> from sympy import Curve, pi\n        >>> from sympy.abc import x\n        >>> Curve((x, x), (x, 0, 1)).rotate(pi/2)\n        Curve((-x, x), (x, 0, 1))\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "scale",
    "full_id": "sympy.geometry.curve.Curve.scale",
    "type": "method",
    "description": "Override GeometryEntity.scale since Curve is not made up of Points.\n\n        Returns\n        =======\n\n        Curve :\n            returns scaled curve.\n\n        Examples\n        ========\n\n        >>> from sympy import Curve\n        >>> from sympy.abc import x\n        >>> Curve((x, x), (x, 0, 1)).scale(2)\n        Curve((2*x, x), (x, 0, 1))\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "translate",
    "full_id": "sympy.geometry.curve.Curve.translate",
    "type": "method",
    "description": "Translate the Curve by (x, y).\n\n        Returns\n        =======\n\n        Curve :\n            returns a translated curve.\n\n        Examples\n        ========\n\n        >>> from sympy import Curve\n        >>> from sympy.abc import x\n        >>> Curve((x, x), (x, 0, 1)).translate(1, 2)\n        Curve((x + 1, x + 2), (x, 0, 1))\n\n        ",
    "section": "Curves",
    "url": "https://docs.sympy.org/latest/modules/geometry/curves.html"
  },
  {
    "name": "apoapsis",
    "full_id": "sympy.geometry.ellipse.Ellipse.apoapsis",
    "type": "property",
    "description": "The apoapsis of the ellipse.\n\n        The greatest distance between the focus and the contour.\n\n        Returns\n        =======\n\n        apoapsis : number\n\n        See Also\n        ========\n\n        periapsis : Returns shortest distance between foci and contour\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.apoapsis\n        2*sqrt(2) + 3\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "arbitrary_point",
    "full_id": "sympy.geometry.ellipse.Ellipse.arbitrary_point",
    "type": "method",
    "description": "A parameterized point on the ellipse.\n\n        Parameters\n        ==========\n\n        parameter : str, optional\n            Default value is 't'.\n\n        Returns\n        =======\n\n        arbitrary_point : Point\n\n        Raises\n        ======\n\n        ValueError\n            When `parameter` already appears in the functions.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> e1 = Ellipse(Point(0, 0), 3, 2)\n        >>> e1.arbitrary_point()\n        Point2D(3*cos(t), 2*sin(t))\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "area",
    "full_id": "sympy.geometry.ellipse.Ellipse.area",
    "type": "property",
    "description": "The area of the ellipse.\n\n        Returns\n        =======\n\n        area : number\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.area\n        3*pi\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "auxiliary_circle",
    "full_id": "sympy.geometry.ellipse.Ellipse.auxiliary_circle",
    "type": "method",
    "description": "Returns a Circle whose diameter is the major axis of the ellipse.\n\n        Examples\n        ========\n\n        >>> from sympy import Ellipse, Point, symbols\n        >>> c = Point(1, 2)\n        >>> Ellipse(c, 8, 7).auxiliary_circle()\n        Circle(Point2D(1, 2), 8)\n        >>> a, b = symbols('a b')\n        >>> Ellipse(c, a, b).auxiliary_circle()\n        Circle(Point2D(1, 2), Max(a, b))\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "center",
    "full_id": "sympy.geometry.ellipse.Ellipse.center",
    "type": "property",
    "description": "The center of the ellipse.\n\n        Returns\n        =======\n\n        center : number\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.center\n        Point2D(0, 0)\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "circumference",
    "full_id": "sympy.geometry.ellipse.Ellipse.circumference",
    "type": "property",
    "description": "The circumference of the ellipse.\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.circumference\n        12*elliptic_e(8/9)\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "director_circle",
    "full_id": "sympy.geometry.ellipse.Ellipse.director_circle",
    "type": "method",
    "description": "\n        Returns a Circle consisting of all points where two perpendicular\n        tangent lines to the ellipse cross each other.\n\n        Returns\n        =======\n\n        Circle\n            A director circle returned as a geometric object.\n\n        Examples\n        ========\n\n        >>> from sympy import Ellipse, Point, symbols\n        >>> c = Point(3,8)\n        >>> Ellipse(c, 7, 9).director_circle()\n        Circle(Point2D(3, 8), sqrt(130))\n        >>> a, b = symbols('a b')\n        >>> Ellipse(c, a, b).director_circle()\n        Circle(Point2D(3, 8), sqrt(a**2 + b**2))\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Director_circle\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "eccentricity",
    "full_id": "sympy.geometry.ellipse.Ellipse.eccentricity",
    "type": "property",
    "description": "The eccentricity of the ellipse.\n\n        Returns\n        =======\n\n        eccentricity : number\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse, sqrt\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, sqrt(2))\n        >>> e1.eccentricity\n        sqrt(7)/3\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "encloses_point",
    "full_id": "sympy.geometry.ellipse.Ellipse.encloses_point",
    "type": "method",
    "description": "\n        Return True if p is enclosed by (is inside of) self.\n\n        Notes\n        -----\n        Being on the border of self is considered False.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        encloses_point : True, False or None\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Ellipse, S\n        >>> from sympy.abc import t\n        >>> e = Ellipse((0, 0), 3, 2)\n        >>> e.encloses_point((0, 0))\n        True\n        >>> e.encloses_point(e.arbitrary_point(t).subs(t, S.Half))\n        False\n        >>> e.encloses_point((4, 0))\n        False\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "equation",
    "full_id": "sympy.geometry.ellipse.Ellipse.equation",
    "type": "method",
    "description": "\n        Returns the equation of an ellipse aligned with the x and y axes;\n        when slope is given, the equation returned corresponds to an ellipse\n        with a major axis having that slope.\n\n        Parameters\n        ==========\n\n        x : str, optional\n            Label for the x-axis. Default value is 'x'.\n        y : str, optional\n            Label for the y-axis. Default value is 'y'.\n        _slope : Expr, optional\n                The slope of the major axis. Ignored when 'None'.\n\n        Returns\n        =======\n\n        equation : SymPy expression\n\n        See Also\n        ========\n\n        arbitrary_point : Returns parameterized point on ellipse\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse, pi\n        >>> from sympy.abc import x, y\n        >>> e1 = Ellipse(Point(1, 0), 3, 2)\n        >>> eq1 = e1.equation(x, y); eq1\n        y**2/4 + (x/3 - 1/3)**2 - 1\n        >>> eq2 = e1.equation(x, y, _slope=1); eq2\n        (-x + y + 1)**2/8 + (x + y - 1)**2/18 - 1\n\n        A point on e1 satisfies eq1. Let's use one on the x-axis:\n\n        >>> p1 = e1.center + Point(e1.major, 0)\n        >>> assert eq1.subs(x, p1.x).subs(y, p1.y) == 0\n\n        When rotated the same as the rotated ellipse, about the center\n        point of the ellipse, it will satisfy the rotated ellipse's\n        equation, too:\n\n        >>> r1 = p1.rotate(pi/4, e1.center)\n        >>> assert eq2.subs(x, r1.x).subs(y, r1.y) == 0\n\n        References\n        ==========\n\n        .. [1] https://math.stackexchange.com/questions/108270/what-is-the-equation-of-an-ellipse-that-is-not-aligned-with-the-axis\n        .. [2] https://en.wikipedia.org/wiki/Ellipse#Shifted_ellipse\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "evolute",
    "full_id": "sympy.geometry.ellipse.Ellipse.evolute",
    "type": "method",
    "description": "The equation of evolute of the ellipse.\n\n        Parameters\n        ==========\n\n        x : str, optional\n            Label for the x-axis. Default value is 'x'.\n        y : str, optional\n            Label for the y-axis. Default value is 'y'.\n\n        Returns\n        =======\n\n        equation : SymPy expression\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> e1 = Ellipse(Point(1, 0), 3, 2)\n        >>> e1.evolute()\n        2**(2/3)*y**(2/3) + (3*x - 3)**(2/3) - 5**(2/3)\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "foci",
    "full_id": "sympy.geometry.ellipse.Ellipse.foci",
    "type": "property",
    "description": "The foci of the ellipse.\n\n        Notes\n        -----\n        The foci can only be calculated if the major/minor axes are known.\n\n        Raises\n        ======\n\n        ValueError\n            When the major and minor axis cannot be determined.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n        focus_distance : Returns the distance between focus and center\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.foci\n        (Point2D(-2*sqrt(2), 0), Point2D(2*sqrt(2), 0))\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "focus_distance",
    "full_id": "sympy.geometry.ellipse.Ellipse.focus_distance",
    "type": "property",
    "description": "The focal distance of the ellipse.\n\n        The distance between the center and one focus.\n\n        Returns\n        =======\n\n        focus_distance : number\n\n        See Also\n        ========\n\n        foci\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.focus_distance\n        2*sqrt(2)\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "hradius",
    "full_id": "sympy.geometry.ellipse.Ellipse.hradius",
    "type": "property",
    "description": "The horizontal radius of the ellipse.\n\n        Returns\n        =======\n\n        hradius : number\n\n        See Also\n        ========\n\n        vradius, major, minor\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.hradius\n        3\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.geometry.ellipse.Ellipse.intersection",
    "type": "method",
    "description": "The intersection of this ellipse and another geometrical entity\n        `o`.\n\n        Parameters\n        ==========\n\n        o : GeometryEntity\n\n        Returns\n        =======\n\n        intersection : list of GeometryEntity objects\n\n        Notes\n        -----\n        Currently supports intersections with Point, Line, Segment, Ray,\n        Circle and Ellipse types.\n\n        See Also\n        ========\n\n        sympy.geometry.entity.GeometryEntity\n\n        Examples\n        ========\n\n        >>> from sympy import Ellipse, Point, Line\n        >>> e = Ellipse(Point(0, 0), 5, 7)\n        >>> e.intersection(Point(0, 0))\n        []\n        >>> e.intersection(Point(5, 0))\n        [Point2D(5, 0)]\n        >>> e.intersection(Line(Point(0,0), Point(0, 1)))\n        [Point2D(0, -7), Point2D(0, 7)]\n        >>> e.intersection(Line(Point(5,0), Point(5, 1)))\n        [Point2D(5, 0)]\n        >>> e.intersection(Line(Point(6,0), Point(6, 1)))\n        []\n        >>> e = Ellipse(Point(-1, 0), 4, 3)\n        >>> e.intersection(Ellipse(Point(1, 0), 4, 3))\n        [Point2D(0, -3*sqrt(15)/4), Point2D(0, 3*sqrt(15)/4)]\n        >>> e.intersection(Ellipse(Point(5, 0), 4, 3))\n        [Point2D(2, -3*sqrt(7)/4), Point2D(2, 3*sqrt(7)/4)]\n        >>> e.intersection(Ellipse(Point(100500, 0), 4, 3))\n        []\n        >>> e.intersection(Ellipse(Point(0, 0), 3, 4))\n        [Point2D(3, 0), Point2D(-363/175, -48*sqrt(111)/175), Point2D(-363/175, 48*sqrt(111)/175)]\n        >>> e.intersection(Ellipse(Point(-1, 0), 3, 4))\n        [Point2D(-17/5, -12/5), Point2D(-17/5, 12/5), Point2D(7/5, -12/5), Point2D(7/5, 12/5)]\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "is_tangent",
    "full_id": "sympy.geometry.ellipse.Ellipse.is_tangent",
    "type": "method",
    "description": "Is `o` tangent to the ellipse?\n\n        Parameters\n        ==========\n\n        o : GeometryEntity\n            An Ellipse, LinearEntity or Polygon\n\n        Raises\n        ======\n\n        NotImplementedError\n            When the wrong type of argument is supplied.\n\n        Returns\n        =======\n\n        is_tangent: boolean\n            True if o is tangent to the ellipse, False otherwise.\n\n        See Also\n        ========\n\n        tangent_lines\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse, Line\n        >>> p0, p1, p2 = Point(0, 0), Point(3, 0), Point(3, 3)\n        >>> e1 = Ellipse(p0, 3, 2)\n        >>> l1 = Line(p1, p2)\n        >>> e1.is_tangent(l1)\n        True\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "major",
    "full_id": "sympy.geometry.ellipse.Ellipse.major",
    "type": "property",
    "description": "Longer axis of the ellipse (if it can be determined) else hradius.\n\n        Returns\n        =======\n\n        major : number or expression\n\n        See Also\n        ========\n\n        hradius, vradius, minor\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse, Symbol\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.major\n        3\n\n        >>> a = Symbol('a')\n        >>> b = Symbol('b')\n        >>> Ellipse(p1, a, b).major\n        a\n        >>> Ellipse(p1, b, a).major\n        b\n\n        >>> m = Symbol('m')\n        >>> M = m + 1\n        >>> Ellipse(p1, m, M).major\n        m + 1\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "minor",
    "full_id": "sympy.geometry.ellipse.Ellipse.minor",
    "type": "property",
    "description": "Shorter axis of the ellipse (if it can be determined) else vradius.\n\n        Returns\n        =======\n\n        minor : number or expression\n\n        See Also\n        ========\n\n        hradius, vradius, major\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse, Symbol\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.minor\n        1\n\n        >>> a = Symbol('a')\n        >>> b = Symbol('b')\n        >>> Ellipse(p1, a, b).minor\n        b\n        >>> Ellipse(p1, b, a).minor\n        a\n\n        >>> m = Symbol('m')\n        >>> M = m + 1\n        >>> Ellipse(p1, m, M).minor\n        m\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "normal_lines",
    "full_id": "sympy.geometry.ellipse.Ellipse.normal_lines",
    "type": "method",
    "description": "Normal lines between `p` and the ellipse.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        normal_lines : list with 1, 2 or 4 Lines\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> e = Ellipse((0, 0), 2, 3)\n        >>> c = e.center\n        >>> e.normal_lines(c + Point(1, 0))\n        [Line2D(Point2D(0, 0), Point2D(1, 0))]\n        >>> e.normal_lines(c)\n        [Line2D(Point2D(0, 0), Point2D(0, 1)), Line2D(Point2D(0, 0), Point2D(1, 0))]\n\n        Off-axis points require the solution of a quartic equation. This\n        often leads to very large expressions that may be of little practical\n        use. An approximate solution of `prec` digits can be obtained by\n        passing in the desired value:\n\n        >>> e.normal_lines((3, 3), prec=2)\n        [Line2D(Point2D(-0.81, -2.7), Point2D(0.19, -1.2)),\n        Line2D(Point2D(1.5, -2.0), Point2D(2.5, -2.7))]\n\n        Whereas the above solution has an operation count of 12, the exact\n        solution has an operation count of 2020.\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "periapsis",
    "full_id": "sympy.geometry.ellipse.Ellipse.periapsis",
    "type": "property",
    "description": "The periapsis of the ellipse.\n\n        The shortest distance between the focus and the contour.\n\n        Returns\n        =======\n\n        periapsis : number\n\n        See Also\n        ========\n\n        apoapsis : Returns greatest distance between focus and contour\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.periapsis\n        3 - 2*sqrt(2)\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "plot_interval",
    "full_id": "sympy.geometry.ellipse.Ellipse.plot_interval",
    "type": "method",
    "description": "The plot interval for the default geometric plot of the Ellipse.\n\n        Parameters\n        ==========\n\n        parameter : str, optional\n            Default value is 't'.\n\n        Returns\n        =======\n\n        plot_interval : list\n            [parameter, lower_bound, upper_bound]\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> e1 = Ellipse(Point(0, 0), 3, 2)\n        >>> e1.plot_interval()\n        [t, -pi, pi]\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "polar_second_moment_of_area",
    "full_id": "sympy.geometry.ellipse.Ellipse.polar_second_moment_of_area",
    "type": "method",
    "description": "Returns the polar second moment of area of an Ellipse\n\n        It is a constituent of the second moment of area, linked through\n        the perpendicular axis theorem. While the planar second moment of\n        area describes an object's resistance to deflection (bending) when\n        subjected to a force applied to a plane parallel to the central\n        axis, the polar second moment of area describes an object's\n        resistance to deflection when subjected to a moment applied in a\n        plane perpendicular to the object's central axis (i.e. parallel to\n        the cross-section)\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, Circle, Ellipse\n        >>> c = Circle((5, 5), 4)\n        >>> c.polar_second_moment_of_area()\n        128*pi\n        >>> a, b = symbols('a, b')\n        >>> e = Ellipse((0, 0), a, b)\n        >>> e.polar_second_moment_of_area()\n        pi*a**3*b/4 + pi*a*b**3/4\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Polar_moment_of_inertia\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "random_point",
    "full_id": "sympy.geometry.ellipse.Ellipse.random_point",
    "type": "method",
    "description": "A random point on the ellipse.\n\n        Returns\n        =======\n\n        point : Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> e1 = Ellipse(Point(0, 0), 3, 2)\n        >>> e1.random_point() # gives some random point\n        Point2D(...)\n        >>> p1 = e1.random_point(seed=0); p1.n(2)\n        Point2D(2.1, 1.4)\n\n        Notes\n        =====\n\n        When creating a random point, one may simply replace the\n        parameter with a random number. When doing so, however, the\n        random number should be made a Rational or else the point\n        may not test as being in the ellipse:\n\n        >>> from sympy.abc import t\n        >>> from sympy import Rational\n        >>> arb = e1.arbitrary_point(t); arb\n        Point2D(3*cos(t), 2*sin(t))\n        >>> arb.subs(t, .1) in e1\n        False\n        >>> arb.subs(t, Rational(.1)) in e1\n        True\n        >>> arb.subs(t, Rational('.1')) in e1\n        True\n\n        See Also\n        ========\n        sympy.geometry.point.Point\n        arbitrary_point : Returns parameterized point on ellipse\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "reflect",
    "full_id": "sympy.geometry.ellipse.Ellipse.reflect",
    "type": "method",
    "description": "Override GeometryEntity.reflect since the radius\n        is not a GeometryEntity.\n\n        Examples\n        ========\n\n        >>> from sympy import Circle, Line\n        >>> Circle((0, 1), 1).reflect(Line((0, 0), (1, 1)))\n        Circle(Point2D(1, 0), -1)\n        >>> from sympy import Ellipse, Line, Point\n        >>> Ellipse(Point(3, 4), 1, 3).reflect(Line(Point(0, -4), Point(5, 0)))\n        Traceback (most recent call last):\n        ...\n        NotImplementedError:\n        General Ellipse is not supported but the equation of the reflected\n        Ellipse is given by the zeros of: f(x, y) = (9*x/41 + 40*y/41 +\n        37/41)**2 + (40*x/123 - 3*y/41 - 364/123)**2 - 1\n\n        Notes\n        =====\n\n        Until the general ellipse (with no axis parallel to the x-axis) is\n        supported a NotImplemented error is raised and the equation whose\n        zeros define the rotated ellipse is given.\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "rotate",
    "full_id": "sympy.geometry.ellipse.Ellipse.rotate",
    "type": "method",
    "description": "Rotate ``angle`` radians counterclockwise about Point ``pt``.\n\n        Note: since the general ellipse is not supported, only rotations that\n        are integer multiples of pi/2 are allowed.\n\n        Examples\n        ========\n\n        >>> from sympy import Ellipse, pi\n        >>> Ellipse((1, 0), 2, 1).rotate(pi/2)\n        Ellipse(Point2D(0, 1), 1, 2)\n        >>> Ellipse((1, 0), 2, 1).rotate(pi)\n        Ellipse(Point2D(-1, 0), 2, 1)\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "scale",
    "full_id": "sympy.geometry.ellipse.Ellipse.scale",
    "type": "method",
    "description": "Override GeometryEntity.scale since it is the major and minor\n        axes which must be scaled and they are not GeometryEntities.\n\n        Examples\n        ========\n\n        >>> from sympy import Ellipse\n        >>> Ellipse((0, 0), 2, 1).scale(2, 4)\n        Circle(Point2D(0, 0), 4)\n        >>> Ellipse((0, 0), 2, 1).scale(2)\n        Ellipse(Point2D(0, 0), 4, 1)\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "second_moment_of_area",
    "full_id": "sympy.geometry.ellipse.Ellipse.second_moment_of_area",
    "type": "method",
    "description": "Returns the second moment and product moment area of an ellipse.\n\n        Parameters\n        ==========\n\n        point : Point, two-tuple of sympifiable objects, or None(default=None)\n            point is the point about which second moment of area is to be found.\n            If \"point=None\" it will be calculated about the axis passing through the\n            centroid of the ellipse.\n\n        Returns\n        =======\n\n        I_xx, I_yy, I_xy : number or SymPy expression\n            I_xx, I_yy are second moment of area of an ellise.\n            I_xy is product moment of area of an ellipse.\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.second_moment_of_area()\n        (3*pi/4, 27*pi/4, 0)\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/List_of_second_moments_of_area\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "section_modulus",
    "full_id": "sympy.geometry.ellipse.Ellipse.section_modulus",
    "type": "method",
    "description": "Returns a tuple with the section modulus of an ellipse\n\n        Section modulus is a geometric property of an ellipse defined as the\n        ratio of second moment of area to the distance of the extreme end of\n        the ellipse from the centroidal axis.\n\n        Parameters\n        ==========\n\n        point : Point, two-tuple of sympifyable objects, or None(default=None)\n            point is the point at which section modulus is to be found.\n            If \"point=None\" section modulus will be calculated for the\n            point farthest from the centroidal axis of the ellipse.\n\n        Returns\n        =======\n\n        S_x, S_y: numbers or SymPy expressions\n                  S_x is the section modulus with respect to the x-axis\n                  S_y is the section modulus with respect to the y-axis\n                  A negative sign indicates that the section modulus is\n                  determined for a point below the centroidal axis.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol, Ellipse, Circle, Point2D\n        >>> d = Symbol('d', positive=True)\n        >>> c = Circle((0, 0), d/2)\n        >>> c.section_modulus()\n        (pi*d**3/32, pi*d**3/32)\n        >>> e = Ellipse(Point2D(0, 0), 2, 4)\n        >>> e.section_modulus()\n        (8*pi, 4*pi)\n        >>> e.section_modulus((2, 2))\n        (16*pi, 4*pi)\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Section_modulus\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "semilatus_rectum",
    "full_id": "sympy.geometry.ellipse.Ellipse.semilatus_rectum",
    "type": "property",
    "description": "\n        Calculates the semi-latus rectum of the Ellipse.\n\n        Semi-latus rectum is defined as one half of the chord through a\n        focus parallel to the conic section directrix of a conic section.\n\n        Returns\n        =======\n\n        semilatus_rectum : number\n\n        See Also\n        ========\n\n        apoapsis : Returns greatest distance between focus and contour\n\n        periapsis : The shortest distance between the focus and the contour\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.semilatus_rectum\n        1/3\n\n        References\n        ==========\n\n        .. [1] https://mathworld.wolfram.com/SemilatusRectum.html\n        .. [2] https://en.wikipedia.org/wiki/Ellipse#Semi-latus_rectum\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "tangent_lines",
    "full_id": "sympy.geometry.ellipse.Ellipse.tangent_lines",
    "type": "method",
    "description": "Tangent lines between `p` and the ellipse.\n\n        If `p` is on the ellipse, returns the tangent line through point `p`.\n        Otherwise, returns the tangent line(s) from `p` to the ellipse, or\n        None if no tangent line is possible (e.g., `p` inside ellipse).\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        tangent_lines : list with 1 or 2 Lines\n\n        Raises\n        ======\n\n        NotImplementedError\n            Can only find tangent lines for a point, `p`, on the ellipse.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, sympy.geometry.line.Line\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> e1 = Ellipse(Point(0, 0), 3, 2)\n        >>> e1.tangent_lines(Point(3, 0))\n        [Line2D(Point2D(3, 0), Point2D(3, -12))]\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "vradius",
    "full_id": "sympy.geometry.ellipse.Ellipse.vradius",
    "type": "property",
    "description": "The vertical radius of the ellipse.\n\n        Returns\n        =======\n\n        vradius : number\n\n        See Also\n        ========\n\n        hradius, major, minor\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Ellipse\n        >>> p1 = Point(0, 0)\n        >>> e1 = Ellipse(p1, 3, 1)\n        >>> e1.vradius\n        1\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "circumference",
    "full_id": "sympy.geometry.ellipse.Circle.circumference",
    "type": "property",
    "description": "The circumference of the circle.\n\n        Returns\n        =======\n\n        circumference : number or SymPy expression\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Circle\n        >>> c1 = Circle(Point(3, 4), 6)\n        >>> c1.circumference\n        12*pi\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "equation",
    "full_id": "sympy.geometry.ellipse.Circle.equation",
    "type": "method",
    "description": "The equation of the circle.\n\n        Parameters\n        ==========\n\n        x : str or Symbol, optional\n            Default value is 'x'.\n        y : str or Symbol, optional\n            Default value is 'y'.\n\n        Returns\n        =======\n\n        equation : SymPy expression\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Circle\n        >>> c1 = Circle(Point(0, 0), 5)\n        >>> c1.equation()\n        x**2 + y**2 - 25\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.geometry.ellipse.Circle.intersection",
    "type": "method",
    "description": "The intersection of this circle with another geometrical entity.\n\n        Parameters\n        ==========\n\n        o : GeometryEntity\n\n        Returns\n        =======\n\n        intersection : list of GeometryEntities\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Circle, Line, Ray\n        >>> p1, p2, p3 = Point(0, 0), Point(5, 5), Point(6, 0)\n        >>> p4 = Point(5, 0)\n        >>> c1 = Circle(p1, 5)\n        >>> c1.intersection(p2)\n        []\n        >>> c1.intersection(p4)\n        [Point2D(5, 0)]\n        >>> c1.intersection(Ray(p1, p2))\n        [Point2D(5*sqrt(2)/2, 5*sqrt(2)/2)]\n        >>> c1.intersection(Line(p2, p3))\n        []\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "radius",
    "full_id": "sympy.geometry.ellipse.Circle.radius",
    "type": "property",
    "description": "The radius of the circle.\n\n        Returns\n        =======\n\n        radius : number or SymPy expression\n\n        See Also\n        ========\n\n        Ellipse.major, Ellipse.minor, Ellipse.hradius, Ellipse.vradius\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Circle\n        >>> c1 = Circle(Point(3, 4), 6)\n        >>> c1.radius\n        6\n\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "reflect",
    "full_id": "sympy.geometry.ellipse.Circle.reflect",
    "type": "method",
    "description": "Override GeometryEntity.reflect since the radius\n        is not a GeometryEntity.\n\n        Examples\n        ========\n\n        >>> from sympy import Circle, Line\n        >>> Circle((0, 1), 1).reflect(Line((0, 0), (1, 1)))\n        Circle(Point2D(1, 0), -1)\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "scale",
    "full_id": "sympy.geometry.ellipse.Circle.scale",
    "type": "method",
    "description": "Override GeometryEntity.scale since the radius\n        is not a GeometryEntity.\n\n        Examples\n        ========\n\n        >>> from sympy import Circle\n        >>> Circle((0, 0), 1).scale(2, 2)\n        Circle(Point2D(0, 0), 2)\n        >>> Circle((0, 0), 1).scale(2, 4)\n        Ellipse(Point2D(0, 0), 2, 4)\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "vradius",
    "full_id": "sympy.geometry.ellipse.Circle.vradius",
    "type": "property",
    "description": "\n        This Ellipse property is an alias for the Circle's radius.\n\n        Whereas hradius, major and minor can use Ellipse's conventions,\n        the vradius does not exist for a circle. It is always a positive\n        value in order that the Circle, like Polygons, will have an\n        area that can be positive or negative as determined by the sign\n        of the hradius.\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Circle\n        >>> c1 = Circle(Point(3, 4), 6)\n        >>> c1.vradius\n        6\n        ",
    "section": "Ellipses",
    "url": "https://docs.sympy.org/latest/modules/geometry/ellipses.html"
  },
  {
    "name": "angles",
    "full_id": "sympy.geometry.polygon.Polygon.angles",
    "type": "property",
    "description": "The internal angle at each vertex.\n\n        Returns\n        =======\n\n        angles : dict\n            A dictionary where each key is a vertex and each value is the\n            internal angle at that vertex. The vertices are represented as\n            Points.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, sympy.geometry.line.LinearEntity.angle_between\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon\n        >>> p1, p2, p3, p4 = map(Point, [(0, 0), (1, 0), (5, 1), (0, 1)])\n        >>> poly = Polygon(p1, p2, p3, p4)\n        >>> poly.angles[p1]\n        pi/2\n        >>> poly.angles[p2]\n        acos(-4*sqrt(17)/17)\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "arbitrary_point",
    "full_id": "sympy.geometry.polygon.Polygon.arbitrary_point",
    "type": "method",
    "description": "A parameterized point on the polygon.\n\n        The parameter, varying from 0 to 1, assigns points to the position on\n        the perimeter that is that fraction of the total perimeter. So the\n        point evaluated at t=1/2 would return the point from the first vertex\n        that is 1/2 way around the polygon.\n\n        Parameters\n        ==========\n\n        parameter : str, optional\n            Default value is 't'.\n\n        Returns\n        =======\n\n        arbitrary_point : Point\n\n        Raises\n        ======\n\n        ValueError\n            When `parameter` already appears in the Polygon's definition.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Polygon, Symbol\n        >>> t = Symbol('t', real=True)\n        >>> tri = Polygon((0, 0), (1, 0), (1, 1))\n        >>> p = tri.arbitrary_point('t')\n        >>> perimeter = tri.perimeter\n        >>> s1, s2 = [s.length for s in tri.sides[:2]]\n        >>> p.subs(t, (s1 + s2/2)/perimeter)\n        Point2D(1, 1/2)\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "area",
    "full_id": "sympy.geometry.polygon.Polygon.area",
    "type": "property",
    "description": "\n        The area of the polygon.\n\n        Notes\n        =====\n\n        The area calculation can be positive or negative based on the\n        orientation of the points. If any side of the polygon crosses\n        any other side, there will be areas having opposite signs.\n\n        See Also\n        ========\n\n        sympy.geometry.ellipse.Ellipse.area\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon\n        >>> p1, p2, p3, p4 = map(Point, [(0, 0), (1, 0), (5, 1), (0, 1)])\n        >>> poly = Polygon(p1, p2, p3, p4)\n        >>> poly.area\n        3\n\n        In the Z shaped polygon (with the lower right connecting back\n        to the upper left) the areas cancel out:\n\n        >>> Z = Polygon((0, 1), (1, 1), (0, 0), (1, 0))\n        >>> Z.area\n        0\n\n        In the M shaped polygon, areas do not cancel because no side\n        crosses any other (though there is a point of contact).\n\n        >>> M = Polygon((0, 0), (0, 1), (2, 0), (3, 1), (3, 0))\n        >>> M.area\n        -3/2\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "bisectors",
    "full_id": "sympy.geometry.polygon.Polygon.bisectors",
    "type": "method",
    "description": "Returns angle bisectors of a polygon. If prec is given\n        then approximate the point defining the ray to that precision.\n\n        The distance between the points defining the bisector ray is 1.\n\n        Examples\n        ========\n\n        >>> from sympy import Polygon, Point\n        >>> p = Polygon(Point(0, 0), Point(2, 0), Point(1, 1), Point(0, 3))\n        >>> p.bisectors(2)\n        {Point2D(0, 0): Ray2D(Point2D(0, 0), Point2D(0.71, 0.71)),\n         Point2D(0, 3): Ray2D(Point2D(0, 3), Point2D(0.23, 2.0)),\n         Point2D(1, 1): Ray2D(Point2D(1, 1), Point2D(0.19, 0.42)),\n         Point2D(2, 0): Ray2D(Point2D(2, 0), Point2D(1.1, 0.38))}\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "centroid",
    "full_id": "sympy.geometry.polygon.Polygon.centroid",
    "type": "property",
    "description": "The centroid of the polygon.\n\n        Returns\n        =======\n\n        centroid : Point\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, sympy.geometry.util.centroid\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon\n        >>> p1, p2, p3, p4 = map(Point, [(0, 0), (1, 0), (5, 1), (0, 1)])\n        >>> poly = Polygon(p1, p2, p3, p4)\n        >>> poly.centroid\n        Point2D(31/18, 11/18)\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "cut_section",
    "full_id": "sympy.geometry.polygon.Polygon.cut_section",
    "type": "method",
    "description": "\n        Returns a tuple of two polygon segments that lie above and below\n        the intersecting line respectively.\n\n        Parameters\n        ==========\n\n        line: Line object of geometry module\n            line which cuts the Polygon. The part of the Polygon that lies\n            above and below this line is returned.\n\n        Returns\n        =======\n\n        upper_polygon, lower_polygon: Polygon objects or None\n            upper_polygon is the polygon that lies above the given line.\n            lower_polygon is the polygon that lies below the given line.\n            upper_polygon and lower polygon are ``None`` when no polygon\n            exists above the line or below the line.\n\n        Raises\n        ======\n\n        ValueError: When the line does not intersect the polygon\n\n        Examples\n        ========\n\n        >>> from sympy import Polygon, Line\n        >>> a, b = 20, 10\n        >>> p1, p2, p3, p4 = [(0, b), (0, 0), (a, 0), (a, b)]\n        >>> rectangle = Polygon(p1, p2, p3, p4)\n        >>> t = rectangle.cut_section(Line((0, 5), slope=0))\n        >>> t\n        (Polygon(Point2D(0, 10), Point2D(0, 5), Point2D(20, 5), Point2D(20, 10)),\n        Polygon(Point2D(0, 5), Point2D(0, 0), Point2D(20, 0), Point2D(20, 5)))\n        >>> upper_segment, lower_segment = t\n        >>> upper_segment.area\n        100\n        >>> upper_segment.centroid\n        Point2D(10, 15/2)\n        >>> lower_segment.centroid\n        Point2D(10, 5/2)\n\n        References\n        ==========\n\n        .. [1] https://github.com/sympy/sympy/wiki/A-method-to-return-a-cut-section-of-any-polygon-geometry\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "distance",
    "full_id": "sympy.geometry.polygon.Polygon.distance",
    "type": "method",
    "description": "\n        Returns the shortest distance between self and o.\n\n        If o is a point, then self does not need to be convex.\n        If o is another polygon self and o must be convex.\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon, RegularPolygon\n        >>> p1, p2 = map(Point, [(0, 0), (7, 5)])\n        >>> poly = Polygon(*RegularPolygon(p1, 1, 3).vertices)\n        >>> poly.distance(p2)\n        sqrt(61)\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "encloses_point",
    "full_id": "sympy.geometry.polygon.Polygon.encloses_point",
    "type": "method",
    "description": "\n        Return True if p is enclosed by (is inside of) self.\n\n        Notes\n        =====\n\n        Being on the border of self is considered False.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        encloses_point : True, False or None\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, sympy.geometry.ellipse.Ellipse.encloses_point\n\n        Examples\n        ========\n\n        >>> from sympy import Polygon, Point\n        >>> p = Polygon((0, 0), (4, 0), (4, 4))\n        >>> p.encloses_point(Point(2, 1))\n        True\n        >>> p.encloses_point(Point(2, 2))\n        False\n        >>> p.encloses_point(Point(5, 5))\n        False\n\n        References\n        ==========\n\n        .. [1] https://paulbourke.net/geometry/polygonmesh/#insidepoly\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "first_moment_of_area",
    "full_id": "sympy.geometry.polygon.Polygon.first_moment_of_area",
    "type": "method",
    "description": "\n        Returns the first moment of area of a two-dimensional polygon with\n        respect to a certain point of interest.\n\n        First moment of area is a measure of the distribution of the area\n        of a polygon in relation to an axis. The first moment of area of\n        the entire polygon about its own centroid is always zero. Therefore,\n        here it is calculated for an area, above or below a certain point\n        of interest, that makes up a smaller portion of the polygon. This\n        area is bounded by the point of interest and the extreme end\n        (top or bottom) of the polygon. The first moment for this area is\n        is then determined about the centroidal axis of the initial polygon.\n\n        References\n        ==========\n\n        .. [1] https://skyciv.com/docs/tutorials/section-tutorials/calculating-the-statical-or-first-moment-of-area-of-beam-sections/?cc=BMD\n        .. [2] https://mechanicalc.com/reference/cross-sections\n\n        Parameters\n        ==========\n\n        point: Point, two-tuple of sympifyable objects, or None (default=None)\n            point is the point above or below which the area of interest lies\n            If ``point=None`` then the centroid acts as the point of interest.\n\n        Returns\n        =======\n\n        Q_x, Q_y: number or SymPy expressions\n            Q_x is the first moment of area about the x-axis\n            Q_y is the first moment of area about the y-axis\n            A negative sign indicates that the section modulus is\n            determined for a section below (or left of) the centroidal axis\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon\n        >>> a, b = 50, 10\n        >>> p1, p2, p3, p4 = [(0, b), (0, 0), (a, 0), (a, b)]\n        >>> p = Polygon(p1, p2, p3, p4)\n        >>> p.first_moment_of_area()\n        (625, 3125)\n        >>> p.first_moment_of_area(point=Point(30, 7))\n        (525, 3000)\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.geometry.polygon.Polygon.intersection",
    "type": "method",
    "description": "The intersection of polygon and geometry entity.\n\n        The intersection may be empty and can contain individual Points and\n        complete Line Segments.\n\n        Parameters\n        ==========\n\n        other: GeometryEntity\n\n        Returns\n        =======\n\n        intersection : list\n            The list of Segments and Points\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, sympy.geometry.line.Segment\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon, Line\n        >>> p1, p2, p3, p4 = map(Point, [(0, 0), (1, 0), (5, 1), (0, 1)])\n        >>> poly1 = Polygon(p1, p2, p3, p4)\n        >>> p5, p6, p7 = map(Point, [(3, 2), (1, -1), (0, 2)])\n        >>> poly2 = Polygon(p5, p6, p7)\n        >>> poly1.intersection(poly2)\n        [Point2D(1/3, 1), Point2D(2/3, 0), Point2D(9/5, 1/5), Point2D(7/3, 1)]\n        >>> poly1.intersection(Line(p1, p2))\n        [Segment2D(Point2D(0, 0), Point2D(1, 0))]\n        >>> poly1.intersection(p1)\n        [Point2D(0, 0)]\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "is_convex",
    "full_id": "sympy.geometry.polygon.Polygon.is_convex",
    "type": "method",
    "description": "Is the polygon convex?\n\n        A polygon is convex if all its interior angles are less than 180\n        degrees and there are no intersections between sides.\n\n        Returns\n        =======\n\n        is_convex : boolean\n            True if this polygon is convex, False otherwise.\n\n        See Also\n        ========\n\n        sympy.geometry.util.convex_hull\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon\n        >>> p1, p2, p3, p4 = map(Point, [(0, 0), (1, 0), (5, 1), (0, 1)])\n        >>> poly = Polygon(p1, p2, p3, p4)\n        >>> poly.is_convex()\n        True\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "perimeter",
    "full_id": "sympy.geometry.polygon.Polygon.perimeter",
    "type": "property",
    "description": "The perimeter of the polygon.\n\n        Returns\n        =======\n\n        perimeter : number or Basic instance\n\n        See Also\n        ========\n\n        sympy.geometry.line.Segment.length\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon\n        >>> p1, p2, p3, p4 = map(Point, [(0, 0), (1, 0), (5, 1), (0, 1)])\n        >>> poly = Polygon(p1, p2, p3, p4)\n        >>> poly.perimeter\n        sqrt(17) + 7\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "plot_interval",
    "full_id": "sympy.geometry.polygon.Polygon.plot_interval",
    "type": "method",
    "description": "The plot interval for the default geometric plot of the polygon.\n\n        Parameters\n        ==========\n\n        parameter : str, optional\n            Default value is 't'.\n\n        Returns\n        =======\n\n        plot_interval : list (plot interval)\n            [parameter, lower_bound, upper_bound]\n\n        Examples\n        ========\n\n        >>> from sympy import Polygon\n        >>> p = Polygon((0, 0), (1, 0), (1, 1))\n        >>> p.plot_interval()\n        [t, 0, 1]\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "polar_second_moment_of_area",
    "full_id": "sympy.geometry.polygon.Polygon.polar_second_moment_of_area",
    "type": "method",
    "description": "Returns the polar modulus of a two-dimensional polygon\n\n        It is a constituent of the second moment of area, linked through\n        the perpendicular axis theorem. While the planar second moment of\n        area describes an object's resistance to deflection (bending) when\n        subjected to a force applied to a plane parallel to the central\n        axis, the polar second moment of area describes an object's\n        resistance to deflection when subjected to a moment applied in a\n        plane perpendicular to the object's central axis (i.e. parallel to\n        the cross-section)\n\n        Examples\n        ========\n\n        >>> from sympy import Polygon, symbols\n        >>> a, b = symbols('a, b')\n        >>> rectangle = Polygon((0, 0), (a, 0), (a, b), (0, b))\n        >>> rectangle.polar_second_moment_of_area()\n        a**3*b/12 + a*b**3/12\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Polar_moment_of_inertia\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "second_moment_of_area",
    "full_id": "sympy.geometry.polygon.Polygon.second_moment_of_area",
    "type": "method",
    "description": "Returns the second moment and product moment of area of a two dimensional polygon.\n\n        Parameters\n        ==========\n\n        point : Point, two-tuple of sympifyable objects, or None(default=None)\n            point is the point about which second moment of area is to be found.\n            If \"point=None\" it will be calculated about the axis passing through the\n            centroid of the polygon.\n\n        Returns\n        =======\n\n        I_xx, I_yy, I_xy : number or SymPy expression\n                           I_xx, I_yy are second moment of area of a two dimensional polygon.\n                           I_xy is product moment of area of a two dimensional polygon.\n\n        Examples\n        ========\n\n        >>> from sympy import Polygon, symbols\n        >>> a, b = symbols('a, b')\n        >>> p1, p2, p3, p4, p5 = [(0, 0), (a, 0), (a, b), (0, b), (a/3, b/3)]\n        >>> rectangle = Polygon(p1, p2, p3, p4)\n        >>> rectangle.second_moment_of_area()\n        (a*b**3/12, a**3*b/12, 0)\n        >>> rectangle.second_moment_of_area(p5)\n        (a*b**3/9, a**3*b/9, a**2*b**2/36)\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Second_moment_of_area\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "section_modulus",
    "full_id": "sympy.geometry.polygon.Polygon.section_modulus",
    "type": "method",
    "description": "Returns a tuple with the section modulus of a two-dimensional\n        polygon.\n\n        Section modulus is a geometric property of a polygon defined as the\n        ratio of second moment of area to the distance of the extreme end of\n        the polygon from the centroidal axis.\n\n        Parameters\n        ==========\n\n        point : Point, two-tuple of sympifyable objects, or None(default=None)\n            point is the point at which section modulus is to be found.\n            If \"point=None\" it will be calculated for the point farthest from the\n            centroidal axis of the polygon.\n\n        Returns\n        =======\n\n        S_x, S_y: numbers or SymPy expressions\n                  S_x is the section modulus with respect to the x-axis\n                  S_y is the section modulus with respect to the y-axis\n                  A negative sign indicates that the section modulus is\n                  determined for a point below the centroidal axis\n\n        Examples\n        ========\n\n        >>> from sympy import symbols, Polygon, Point\n        >>> a, b = symbols('a, b', positive=True)\n        >>> rectangle = Polygon((0, 0), (a, 0), (a, b), (0, b))\n        >>> rectangle.section_modulus()\n        (a*b**2/6, a**2*b/6)\n        >>> rectangle.section_modulus(Point(a/4, b/4))\n        (-a*b**2/3, -a**2*b/3)\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Section_modulus\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "sides",
    "full_id": "sympy.geometry.polygon.Polygon.sides",
    "type": "property",
    "description": "The directed line segments that form the sides of the polygon.\n\n        Returns\n        =======\n\n        sides : list of sides\n            Each side is a directed Segment.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, sympy.geometry.line.Segment\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon\n        >>> p1, p2, p3, p4 = map(Point, [(0, 0), (1, 0), (5, 1), (0, 1)])\n        >>> poly = Polygon(p1, p2, p3, p4)\n        >>> poly.sides\n        [Segment2D(Point2D(0, 0), Point2D(1, 0)),\n        Segment2D(Point2D(1, 0), Point2D(5, 1)),\n        Segment2D(Point2D(5, 1), Point2D(0, 1)), Segment2D(Point2D(0, 1), Point2D(0, 0))]\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "vertices",
    "full_id": "sympy.geometry.polygon.Polygon.vertices",
    "type": "property",
    "description": "The vertices of the polygon.\n\n        Returns\n        =======\n\n        vertices : list of Points\n\n        Notes\n        =====\n\n        When iterating over the vertices, it is more efficient to index self\n        rather than to request the vertices and index them. Only use the\n        vertices when you want to process all of them at once. This is even\n        more important with RegularPolygons that calculate each vertex.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Polygon\n        >>> p1, p2, p3, p4 = map(Point, [(0, 0), (1, 0), (5, 1), (0, 1)])\n        >>> poly = Polygon(p1, p2, p3, p4)\n        >>> poly.vertices\n        [Point2D(0, 0), Point2D(1, 0), Point2D(5, 1), Point2D(0, 1)]\n        >>> poly.vertices[0]\n        Point2D(0, 0)\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "angles",
    "full_id": "sympy.geometry.polygon.RegularPolygon.angles",
    "type": "property",
    "description": "\n        Returns a dictionary with keys, the vertices of the Polygon,\n        and values, the interior angle at each vertex.\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point\n        >>> r = RegularPolygon(Point(0, 0), 5, 3)\n        >>> r.angles\n        {Point2D(-5/2, -5*sqrt(3)/2): pi/3,\n         Point2D(-5/2, 5*sqrt(3)/2): pi/3,\n         Point2D(5, 0): pi/3}\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "apothem",
    "full_id": "sympy.geometry.polygon.RegularPolygon.apothem",
    "type": "property",
    "description": "The inradius of the RegularPolygon.\n\n        The apothem/inradius is the radius of the inscribed circle.\n\n        Returns\n        =======\n\n        apothem : number or instance of Basic\n\n        See Also\n        ========\n\n        sympy.geometry.line.Segment.length, sympy.geometry.ellipse.Circle.radius\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy import RegularPolygon, Point\n        >>> radius = Symbol('r')\n        >>> rp = RegularPolygon(Point(0, 0), radius, 4)\n        >>> rp.apothem\n        sqrt(2)*r/2\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "area",
    "full_id": "sympy.geometry.polygon.RegularPolygon.area",
    "type": "property",
    "description": "Returns the area.\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon\n        >>> square = RegularPolygon((0, 0), 1, 4)\n        >>> square.area\n        2\n        >>> _ == square.length**2\n        True\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "args",
    "full_id": "sympy.geometry.polygon.RegularPolygon.args",
    "type": "property",
    "description": "\n        Returns the center point, the radius,\n        the number of sides, and the orientation angle.\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point\n        >>> r = RegularPolygon(Point(0, 0), 5, 3)\n        >>> r.args\n        (Point2D(0, 0), 5, 3, 0)\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "center",
    "full_id": "sympy.geometry.polygon.RegularPolygon.center",
    "type": "property",
    "description": "The center of the RegularPolygon\n\n        This is also the center of the circumscribing circle.\n\n        Returns\n        =======\n\n        center : Point\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, sympy.geometry.ellipse.Ellipse.center\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point\n        >>> rp = RegularPolygon(Point(0, 0), 5, 4)\n        >>> rp.center\n        Point2D(0, 0)\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "circumcenter",
    "full_id": "sympy.geometry.polygon.RegularPolygon.circumcenter",
    "type": "property",
    "description": "\n        Alias for center.\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point\n        >>> rp = RegularPolygon(Point(0, 0), 5, 4)\n        >>> rp.circumcenter\n        Point2D(0, 0)\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "circumcircle",
    "full_id": "sympy.geometry.polygon.RegularPolygon.circumcircle",
    "type": "property",
    "description": "The circumcircle of the RegularPolygon.\n\n        Returns\n        =======\n\n        circumcircle : Circle\n\n        See Also\n        ========\n\n        circumcenter, sympy.geometry.ellipse.Circle\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point\n        >>> rp = RegularPolygon(Point(0, 0), 4, 8)\n        >>> rp.circumcircle\n        Circle(Point2D(0, 0), 4)\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "circumradius",
    "full_id": "sympy.geometry.polygon.RegularPolygon.circumradius",
    "type": "property",
    "description": "\n        Alias for radius.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy import RegularPolygon, Point\n        >>> radius = Symbol('r')\n        >>> rp = RegularPolygon(Point(0, 0), radius, 4)\n        >>> rp.circumradius\n        r\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "encloses_point",
    "full_id": "sympy.geometry.polygon.RegularPolygon.encloses_point",
    "type": "method",
    "description": "\n        Return True if p is enclosed by (is inside of) self.\n\n        Notes\n        =====\n\n        Being on the border of self is considered False.\n\n        The general Polygon.encloses_point method is called only if\n        a point is not within or beyond the incircle or circumcircle,\n        respectively.\n\n        Parameters\n        ==========\n\n        p : Point\n\n        Returns\n        =======\n\n        encloses_point : True, False or None\n\n        See Also\n        ========\n\n        sympy.geometry.ellipse.Ellipse.encloses_point\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, S, Point, Symbol\n        >>> p = RegularPolygon((0, 0), 3, 4)\n        >>> p.encloses_point(Point(0, 0))\n        True\n        >>> r, R = p.inradius, p.circumradius\n        >>> p.encloses_point(Point((r + R)/2, 0))\n        True\n        >>> p.encloses_point(Point(R/2, R/2 + (R - r)/10))\n        False\n        >>> t = Symbol('t', real=True)\n        >>> p.encloses_point(p.arbitrary_point().subs(t, S.Half))\n        False\n        >>> p.encloses_point(Point(5, 5))\n        False\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "exterior_angle",
    "full_id": "sympy.geometry.polygon.RegularPolygon.exterior_angle",
    "type": "property",
    "description": "Measure of the exterior angles.\n\n        Returns\n        =======\n\n        exterior_angle : number\n\n        See Also\n        ========\n\n        sympy.geometry.line.LinearEntity.angle_between\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point\n        >>> rp = RegularPolygon(Point(0, 0), 4, 8)\n        >>> rp.exterior_angle\n        pi/4\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "incircle",
    "full_id": "sympy.geometry.polygon.RegularPolygon.incircle",
    "type": "property",
    "description": "The incircle of the RegularPolygon.\n\n        Returns\n        =======\n\n        incircle : Circle\n\n        See Also\n        ========\n\n        inradius, sympy.geometry.ellipse.Circle\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point\n        >>> rp = RegularPolygon(Point(0, 0), 4, 7)\n        >>> rp.incircle\n        Circle(Point2D(0, 0), 4*cos(pi/7))\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "inradius",
    "full_id": "sympy.geometry.polygon.RegularPolygon.inradius",
    "type": "property",
    "description": "\n        Alias for apothem.\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy import RegularPolygon, Point\n        >>> radius = Symbol('r')\n        >>> rp = RegularPolygon(Point(0, 0), radius, 4)\n        >>> rp.inradius\n        sqrt(2)*r/2\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "interior_angle",
    "full_id": "sympy.geometry.polygon.RegularPolygon.interior_angle",
    "type": "property",
    "description": "Measure of the interior angles.\n\n        Returns\n        =======\n\n        interior_angle : number\n\n        See Also\n        ========\n\n        sympy.geometry.line.LinearEntity.angle_between\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point\n        >>> rp = RegularPolygon(Point(0, 0), 4, 8)\n        >>> rp.interior_angle\n        3*pi/4\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "length",
    "full_id": "sympy.geometry.polygon.RegularPolygon.length",
    "type": "property",
    "description": "Returns the length of the sides.\n\n        The half-length of the side and the apothem form two legs\n        of a right triangle whose hypotenuse is the radius of the\n        regular polygon.\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon\n        >>> from sympy import sqrt\n        >>> s = square_in_unit_circle = RegularPolygon((0, 0), 1, 4)\n        >>> s.length\n        sqrt(2)\n        >>> sqrt((_/2)**2 + s.apothem**2) == s.radius\n        True\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "radius",
    "full_id": "sympy.geometry.polygon.RegularPolygon.radius",
    "type": "property",
    "description": "Radius of the RegularPolygon\n\n        This is also the radius of the circumscribing circle.\n\n        Returns\n        =======\n\n        radius : number or instance of Basic\n\n        See Also\n        ========\n\n        sympy.geometry.line.Segment.length, sympy.geometry.ellipse.Circle.radius\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy import RegularPolygon, Point\n        >>> radius = Symbol('r')\n        >>> rp = RegularPolygon(Point(0, 0), radius, 4)\n        >>> rp.radius\n        r\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "reflect",
    "full_id": "sympy.geometry.polygon.RegularPolygon.reflect",
    "type": "method",
    "description": "Override GeometryEntity.reflect since this is not made of only\n        points.\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Line\n\n        >>> RegularPolygon((0, 0), 1, 4).reflect(Line((0, 1), slope=-2))\n        RegularPolygon(Point2D(4/5, 2/5), -1, 4, atan(4/3))\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "rotate",
    "full_id": "sympy.geometry.polygon.RegularPolygon.rotate",
    "type": "method",
    "description": "Override GeometryEntity.rotate to first rotate the RegularPolygon\n        about its center.\n\n        >>> from sympy import Point, RegularPolygon, pi\n        >>> t = RegularPolygon(Point(1, 0), 1, 3)\n        >>> t.vertices[0] # vertex on x-axis\n        Point2D(2, 0)\n        >>> t.rotate(pi/2).vertices[0] # vertex on y axis now\n        Point2D(0, 2)\n\n        See Also\n        ========\n\n        rotation\n        spin : Rotates a RegularPolygon in place\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "rotation",
    "full_id": "sympy.geometry.polygon.RegularPolygon.rotation",
    "type": "property",
    "description": "CCW angle by which the RegularPolygon is rotated\n\n        Returns\n        =======\n\n        rotation : number or instance of Basic\n\n        Examples\n        ========\n\n        >>> from sympy import pi\n        >>> from sympy.abc import a\n        >>> from sympy import RegularPolygon, Point\n        >>> RegularPolygon(Point(0, 0), 3, 4, pi/4).rotation\n        pi/4\n\n        Numerical rotation angles are made canonical:\n\n        >>> RegularPolygon(Point(0, 0), 3, 4, a).rotation\n        a\n        >>> RegularPolygon(Point(0, 0), 3, 4, pi).rotation\n        0\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "scale",
    "full_id": "sympy.geometry.polygon.RegularPolygon.scale",
    "type": "method",
    "description": "Override GeometryEntity.scale since it is the radius that must be\n        scaled (if x == y) or else a new Polygon must be returned.\n\n        >>> from sympy import RegularPolygon\n\n        Symmetric scaling returns a RegularPolygon:\n\n        >>> RegularPolygon((0, 0), 1, 4).scale(2, 2)\n        RegularPolygon(Point2D(0, 0), 2, 4, 0)\n\n        Asymmetric scaling returns a kite as a Polygon:\n\n        >>> RegularPolygon((0, 0), 1, 4).scale(2, 1)\n        Polygon(Point2D(2, 0), Point2D(0, 1), Point2D(-2, 0), Point2D(0, -1))\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "spin",
    "full_id": "sympy.geometry.polygon.RegularPolygon.spin",
    "type": "method",
    "description": "Increment *in place* the virtual Polygon's rotation by ccw angle.\n\n        See also: rotate method which moves the center.\n\n        >>> from sympy import Polygon, Point, pi\n        >>> r = Polygon(Point(0,0), 1, n=3)\n        >>> r.vertices[0]\n        Point2D(1, 0)\n        >>> r.spin(pi/6)\n        >>> r.vertices[0]\n        Point2D(sqrt(3)/2, 1/2)\n\n        See Also\n        ========\n\n        rotation\n        rotate : Creates a copy of the RegularPolygon rotated about a Point\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "vertices",
    "full_id": "sympy.geometry.polygon.RegularPolygon.vertices",
    "type": "property",
    "description": "The vertices of the RegularPolygon.\n\n        Returns\n        =======\n\n        vertices : list\n            Each vertex is a Point.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import RegularPolygon, Point\n        >>> rp = RegularPolygon(Point(0, 0), 5, 4)\n        >>> rp.vertices\n        [Point2D(5, 0), Point2D(0, 5), Point2D(-5, 0), Point2D(0, -5)]\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "altitudes",
    "full_id": "sympy.geometry.polygon.Triangle.altitudes",
    "type": "property",
    "description": "The altitudes of the triangle.\n\n        An altitude of a triangle is a segment through a vertex,\n        perpendicular to the opposite side, with length being the\n        height of the vertex measured from the line containing the side.\n\n        Returns\n        =======\n\n        altitudes : dict\n            The dictionary consists of keys which are vertices and values\n            which are Segments.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, sympy.geometry.line.Segment.length\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.altitudes[p1]\n        Segment2D(Point2D(0, 0), Point2D(1/2, 1/2))\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "bisectors",
    "full_id": "sympy.geometry.polygon.Triangle.bisectors",
    "type": "method",
    "description": "The angle bisectors of the triangle.\n\n        An angle bisector of a triangle is a straight line through a vertex\n        which cuts the corresponding angle in half.\n\n        Returns\n        =======\n\n        bisectors : dict\n            Each key is a vertex (Point) and each value is the corresponding\n            bisector (Segment).\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point, sympy.geometry.line.Segment\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle, Segment\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> from sympy import sqrt\n        >>> t.bisectors()[p2] == Segment(Point(1, 0), Point(0, sqrt(2) - 1))\n        True\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "circumcenter",
    "full_id": "sympy.geometry.polygon.Triangle.circumcenter",
    "type": "property",
    "description": "The circumcenter of the triangle\n\n        The circumcenter is the center of the circumcircle.\n\n        Returns\n        =======\n\n        circumcenter : Point\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.circumcenter\n        Point2D(1/2, 1/2)\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "circumcircle",
    "full_id": "sympy.geometry.polygon.Triangle.circumcircle",
    "type": "property",
    "description": "The circle which passes through the three vertices of the triangle.\n\n        Returns\n        =======\n\n        circumcircle : Circle\n\n        See Also\n        ========\n\n        sympy.geometry.ellipse.Circle\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.circumcircle\n        Circle(Point2D(1/2, 1/2), sqrt(2)/2)\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "circumradius",
    "full_id": "sympy.geometry.polygon.Triangle.circumradius",
    "type": "property",
    "description": "The radius of the circumcircle of the triangle.\n\n        Returns\n        =======\n\n        circumradius : number of Basic instance\n\n        See Also\n        ========\n\n        sympy.geometry.ellipse.Circle.radius\n\n        Examples\n        ========\n\n        >>> from sympy import Symbol\n        >>> from sympy import Point, Triangle\n        >>> a = Symbol('a')\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, a)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.circumradius\n        sqrt(a**2/4 + 1/4)\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "eulerline",
    "full_id": "sympy.geometry.polygon.Triangle.eulerline",
    "type": "property",
    "description": "The Euler line of the triangle.\n\n        The line which passes through circumcenter, centroid and orthocenter.\n\n        Returns\n        =======\n\n        eulerline : Line (or Point for equilateral triangles in which case all\n                    centers coincide)\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.eulerline\n        Line2D(Point2D(0, 0), Point2D(1/2, 1/2))\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "excenters",
    "full_id": "sympy.geometry.polygon.Triangle.excenters",
    "type": "property",
    "description": "Excenters of the triangle.\n\n        An excenter is the center of a circle that is tangent to a side of the\n        triangle and the extensions of the other two sides.\n\n        Returns\n        =======\n\n        excenters : dict\n\n\n        Examples\n        ========\n\n        The excenters are keyed to the side of the triangle to which their corresponding\n        excircle is tangent: The center is keyed, e.g. the excenter of a circle touching\n        side 0 is:\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(6, 0), Point(0, 2)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.excenters[t.sides[0]]\n        Point2D(12*sqrt(10), 2/3 + sqrt(10)/3)\n\n        See Also\n        ========\n\n        sympy.geometry.polygon.Triangle.exradii\n\n        References\n        ==========\n\n        .. [1] https://mathworld.wolfram.com/Excircles.html\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "exradii",
    "full_id": "sympy.geometry.polygon.Triangle.exradii",
    "type": "property",
    "description": "The radius of excircles of a triangle.\n\n        An excircle of the triangle is a circle lying outside the triangle,\n        tangent to one of its sides and tangent to the extensions of the\n        other two.\n\n        Returns\n        =======\n\n        exradii : dict\n\n        See Also\n        ========\n\n        sympy.geometry.polygon.Triangle.inradius\n\n        Examples\n        ========\n\n        The exradius touches the side of the triangle to which it is keyed, e.g.\n        the exradius touching side 2 is:\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(6, 0), Point(0, 2)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.exradii[t.sides[2]]\n        -2 + sqrt(10)\n\n        References\n        ==========\n\n        .. [1] https://mathworld.wolfram.com/Exradius.html\n        .. [2] https://mathworld.wolfram.com/Excircles.html\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "incenter",
    "full_id": "sympy.geometry.polygon.Triangle.incenter",
    "type": "property",
    "description": "The center of the incircle.\n\n        The incircle is the circle which lies inside the triangle and touches\n        all three sides.\n\n        Returns\n        =======\n\n        incenter : Point\n\n        See Also\n        ========\n\n        incircle, sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.incenter\n        Point2D(1 - sqrt(2)/2, 1 - sqrt(2)/2)\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "incircle",
    "full_id": "sympy.geometry.polygon.Triangle.incircle",
    "type": "property",
    "description": "The incircle of the triangle.\n\n        The incircle is the circle which lies inside the triangle and touches\n        all three sides.\n\n        Returns\n        =======\n\n        incircle : Circle\n\n        See Also\n        ========\n\n        sympy.geometry.ellipse.Circle\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(2, 0), Point(0, 2)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.incircle\n        Circle(Point2D(2 - sqrt(2), 2 - sqrt(2)), 2 - sqrt(2))\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "inradius",
    "full_id": "sympy.geometry.polygon.Triangle.inradius",
    "type": "property",
    "description": "The radius of the incircle.\n\n        Returns\n        =======\n\n        inradius : number of Basic instance\n\n        See Also\n        ========\n\n        incircle, sympy.geometry.ellipse.Circle.radius\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(4, 0), Point(0, 3)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.inradius\n        1\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "is_equilateral",
    "full_id": "sympy.geometry.polygon.Triangle.is_equilateral",
    "type": "method",
    "description": "Are all the sides the same length?\n\n        Returns\n        =======\n\n        is_equilateral : boolean\n\n        See Also\n        ========\n\n        sympy.geometry.entity.GeometryEntity.is_similar, RegularPolygon\n        is_isosceles, is_right, is_scalene\n\n        Examples\n        ========\n\n        >>> from sympy import Triangle, Point\n        >>> t1 = Triangle(Point(0, 0), Point(4, 0), Point(4, 3))\n        >>> t1.is_equilateral()\n        False\n\n        >>> from sympy import sqrt\n        >>> t2 = Triangle(Point(0, 0), Point(10, 0), Point(5, 5*sqrt(3)))\n        >>> t2.is_equilateral()\n        True\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "is_isosceles",
    "full_id": "sympy.geometry.polygon.Triangle.is_isosceles",
    "type": "method",
    "description": "Are two or more of the sides the same length?\n\n        Returns\n        =======\n\n        is_isosceles : boolean\n\n        See Also\n        ========\n\n        is_equilateral, is_right, is_scalene\n\n        Examples\n        ========\n\n        >>> from sympy import Triangle, Point\n        >>> t1 = Triangle(Point(0, 0), Point(4, 0), Point(2, 4))\n        >>> t1.is_isosceles()\n        True\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "is_right",
    "full_id": "sympy.geometry.polygon.Triangle.is_right",
    "type": "method",
    "description": "Is the triangle right-angled.\n\n        Returns\n        =======\n\n        is_right : boolean\n\n        See Also\n        ========\n\n        sympy.geometry.line.LinearEntity.is_perpendicular\n        is_equilateral, is_isosceles, is_scalene\n\n        Examples\n        ========\n\n        >>> from sympy import Triangle, Point\n        >>> t1 = Triangle(Point(0, 0), Point(4, 0), Point(4, 3))\n        >>> t1.is_right()\n        True\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "is_scalene",
    "full_id": "sympy.geometry.polygon.Triangle.is_scalene",
    "type": "method",
    "description": "Are all the sides of the triangle of different lengths?\n\n        Returns\n        =======\n\n        is_scalene : boolean\n\n        See Also\n        ========\n\n        is_equilateral, is_isosceles, is_right\n\n        Examples\n        ========\n\n        >>> from sympy import Triangle, Point\n        >>> t1 = Triangle(Point(0, 0), Point(4, 0), Point(1, 4))\n        >>> t1.is_scalene()\n        True\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "is_similar",
    "full_id": "sympy.geometry.polygon.Triangle.is_similar",
    "type": "method",
    "description": "Is another triangle similar to this one.\n\n        Two triangles are similar if one can be uniformly scaled to the other.\n\n        Parameters\n        ==========\n\n        other: Triangle\n\n        Returns\n        =======\n\n        is_similar : boolean\n\n        See Also\n        ========\n\n        sympy.geometry.entity.GeometryEntity.is_similar\n\n        Examples\n        ========\n\n        >>> from sympy import Triangle, Point\n        >>> t1 = Triangle(Point(0, 0), Point(4, 0), Point(4, 3))\n        >>> t2 = Triangle(Point(0, 0), Point(-4, 0), Point(-4, -3))\n        >>> t1.is_similar(t2)\n        True\n\n        >>> t2 = Triangle(Point(0, 0), Point(-4, 0), Point(-4, -4))\n        >>> t1.is_similar(t2)\n        False\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "medial",
    "full_id": "sympy.geometry.polygon.Triangle.medial",
    "type": "property",
    "description": "The medial triangle of the triangle.\n\n        The triangle which is formed from the midpoints of the three sides.\n\n        Returns\n        =======\n\n        medial : Triangle\n\n        See Also\n        ========\n\n        sympy.geometry.line.Segment.midpoint\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.medial\n        Triangle(Point2D(1/2, 0), Point2D(1/2, 1/2), Point2D(0, 1/2))\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "medians",
    "full_id": "sympy.geometry.polygon.Triangle.medians",
    "type": "property",
    "description": "The medians of the triangle.\n\n        A median of a triangle is a straight line through a vertex and the\n        midpoint of the opposite side, and divides the triangle into two\n        equal areas.\n\n        Returns\n        =======\n\n        medians : dict\n            Each key is a vertex (Point) and each value is the median (Segment)\n            at that point.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point.midpoint, sympy.geometry.line.Segment.midpoint\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.medians[p1]\n        Segment2D(Point2D(0, 0), Point2D(1/2, 1/2))\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "nine_point_circle",
    "full_id": "sympy.geometry.polygon.Triangle.nine_point_circle",
    "type": "property",
    "description": "The nine-point circle of the triangle.\n\n        Nine-point circle is the circumcircle of the medial triangle, which\n        passes through the feet of altitudes and the middle points of segments\n        connecting the vertices and the orthocenter.\n\n        Returns\n        =======\n\n        nine_point_circle : Circle\n\n        See also\n        ========\n\n        sympy.geometry.line.Segment.midpoint\n        sympy.geometry.polygon.Triangle.medial\n        sympy.geometry.polygon.Triangle.orthocenter\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.nine_point_circle\n        Circle(Point2D(1/4, 1/4), sqrt(2)/4)\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "orthocenter",
    "full_id": "sympy.geometry.polygon.Triangle.orthocenter",
    "type": "property",
    "description": "The orthocenter of the triangle.\n\n        The orthocenter is the intersection of the altitudes of a triangle.\n        It may lie inside, outside or on the triangle.\n\n        Returns\n        =======\n\n        orthocenter : Point\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Point, Triangle\n        >>> p1, p2, p3 = Point(0, 0), Point(1, 0), Point(0, 1)\n        >>> t = Triangle(p1, p2, p3)\n        >>> t.orthocenter\n        Point2D(0, 0)\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "vertices",
    "full_id": "sympy.geometry.polygon.Triangle.vertices",
    "type": "property",
    "description": "The triangle's vertices\n\n        Returns\n        =======\n\n        vertices : tuple\n            Each element in the tuple is a Point\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point\n\n        Examples\n        ========\n\n        >>> from sympy import Triangle, Point\n        >>> t = Triangle(Point(0, 0), Point(4, 0), Point(4, 3))\n        >>> t.vertices\n        (Point2D(0, 0), Point2D(4, 0), Point2D(4, 3))\n\n        ",
    "section": "Polygons",
    "url": "https://docs.sympy.org/latest/modules/geometry/polygons.html"
  },
  {
    "name": "angle_between",
    "full_id": "sympy.geometry.plane.Plane.angle_between",
    "type": "method",
    "description": "Angle between the plane and other geometric entity.\n\n        Parameters\n        ==========\n\n        LinearEntity3D, Plane.\n\n        Returns\n        =======\n\n        angle : angle in radians\n\n        Notes\n        =====\n\n        This method accepts only 3D entities as it's parameter, but if you want\n        to calculate the angle between a 2D entity and a plane you should\n        first convert to a 3D entity by projecting onto a desired plane and\n        then proceed to calculate the angle.\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Line3D, Plane\n        >>> a = Plane(Point3D(1, 2, 2), normal_vector=(1, 2, 3))\n        >>> b = Line3D(Point3D(1, 3, 4), Point3D(2, 2, 2))\n        >>> a.angle_between(b)\n        -asin(sqrt(21)/6)\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "arbitrary_point",
    "full_id": "sympy.geometry.plane.Plane.arbitrary_point",
    "type": "method",
    "description": "Returns an arbitrary point on the Plane. If given two\n        parameters, the point ranges over the entire plane. If given 1\n        or no parameters, returns a point with one parameter which,\n        when varying from 0 to 2*pi, moves the point in a circle of\n        radius 1 about p1 of the Plane.\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Ray\n        >>> from sympy.abc import u, v, t, r\n        >>> p = Plane((1, 1, 1), normal_vector=(1, 0, 0))\n        >>> p.arbitrary_point(u, v)\n        Point3D(1, u + 1, v + 1)\n        >>> p.arbitrary_point(t)\n        Point3D(1, cos(t) + 1, sin(t) + 1)\n\n        While arbitrary values of u and v can move the point anywhere in\n        the plane, the single-parameter point can be used to construct a\n        ray whose arbitrary point can be located at angle t and radius\n        r from p.p1:\n\n        >>> Ray(p.p1, _).arbitrary_point(r)\n        Point3D(1, r*cos(t) + 1, r*sin(t) + 1)\n\n        Returns\n        =======\n\n        Point3D\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "are_concurrent",
    "full_id": "sympy.geometry.plane.Plane.are_concurrent",
    "type": "method",
    "description": "Is a sequence of Planes concurrent?\n\n        Two or more Planes are concurrent if their intersections\n        are a common line.\n\n        Parameters\n        ==========\n\n        planes: list\n\n        Returns\n        =======\n\n        Boolean\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Point3D\n        >>> a = Plane(Point3D(5, 0, 0), normal_vector=(1, -1, 1))\n        >>> b = Plane(Point3D(0, -2, 0), normal_vector=(3, 1, 1))\n        >>> c = Plane(Point3D(0, -1, 0), normal_vector=(5, -1, 9))\n        >>> Plane.are_concurrent(a, b)\n        True\n        >>> Plane.are_concurrent(a, b, c)\n        False\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "distance",
    "full_id": "sympy.geometry.plane.Plane.distance",
    "type": "method",
    "description": "Distance between the plane and another geometric entity.\n\n        Parameters\n        ==========\n\n        Point3D, LinearEntity3D, Plane.\n\n        Returns\n        =======\n\n        distance\n\n        Notes\n        =====\n\n        This method accepts only 3D entities as it's parameter, but if you want\n        to calculate the distance between a 2D entity and a plane you should\n        first convert to a 3D entity by projecting onto a desired plane and\n        then proceed to calculate the distance.\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Line3D, Plane\n        >>> a = Plane(Point3D(1, 1, 1), normal_vector=(1, 1, 1))\n        >>> b = Point3D(1, 2, 3)\n        >>> a.distance(b)\n        sqrt(3)\n        >>> c = Line3D(Point3D(2, 3, 1), Point3D(1, 2, 2))\n        >>> a.distance(c)\n        0\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "equals",
    "full_id": "sympy.geometry.plane.Plane.equals",
    "type": "method",
    "description": "\n        Returns True if self and o are the same mathematical entities.\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Point3D\n        >>> a = Plane(Point3D(1, 2, 3), normal_vector=(1, 1, 1))\n        >>> b = Plane(Point3D(1, 2, 3), normal_vector=(2, 2, 2))\n        >>> c = Plane(Point3D(1, 2, 3), normal_vector=(-1, 4, 6))\n        >>> a.equals(a)\n        True\n        >>> a.equals(b)\n        True\n        >>> a.equals(c)\n        False\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "equation",
    "full_id": "sympy.geometry.plane.Plane.equation",
    "type": "method",
    "description": "The equation of the Plane.\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Plane\n        >>> a = Plane(Point3D(1, 1, 2), Point3D(2, 4, 7), Point3D(3, 5, 1))\n        >>> a.equation()\n        -23*x + 11*y - 2*z + 16\n        >>> a = Plane(Point3D(1, 4, 2), normal_vector=(6, 6, 6))\n        >>> a.equation()\n        6*x + 6*y + 6*z - 42\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "intersection",
    "full_id": "sympy.geometry.plane.Plane.intersection",
    "type": "method",
    "description": "The intersection with other geometrical entity.\n\n        Parameters\n        ==========\n\n        Point, Point3D, LinearEntity, LinearEntity3D, Plane\n\n        Returns\n        =======\n\n        List\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Line3D, Plane\n        >>> a = Plane(Point3D(1, 2, 3), normal_vector=(1, 1, 1))\n        >>> b = Point3D(1, 2, 3)\n        >>> a.intersection(b)\n        [Point3D(1, 2, 3)]\n        >>> c = Line3D(Point3D(1, 4, 7), Point3D(2, 2, 2))\n        >>> a.intersection(c)\n        [Point3D(2, 2, 2)]\n        >>> d = Plane(Point3D(6, 0, 0), normal_vector=(2, -5, 3))\n        >>> e = Plane(Point3D(2, 0, 0), normal_vector=(3, 4, -3))\n        >>> d.intersection(e)\n        [Line3D(Point3D(78/23, -24/23, 0), Point3D(147/23, 321/23, 23))]\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "is_coplanar",
    "full_id": "sympy.geometry.plane.Plane.is_coplanar",
    "type": "method",
    "description": "Returns True if `o` is coplanar with self, else False.\n\n        Examples\n        ========\n\n        >>> from sympy import Plane\n        >>> o = (0, 0, 0)\n        >>> p = Plane(o, (1, 1, 1))\n        >>> p2 = Plane(o, (2, 2, 2))\n        >>> p == p2\n        False\n        >>> p.is_coplanar(p2)\n        True\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "is_parallel",
    "full_id": "sympy.geometry.plane.Plane.is_parallel",
    "type": "method",
    "description": "Is the given geometric entity parallel to the plane?\n\n        Parameters\n        ==========\n\n        LinearEntity3D or Plane\n\n        Returns\n        =======\n\n        Boolean\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Point3D\n        >>> a = Plane(Point3D(1,4,6), normal_vector=(2, 4, 6))\n        >>> b = Plane(Point3D(3,1,3), normal_vector=(4, 8, 12))\n        >>> a.is_parallel(b)\n        True\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "is_perpendicular",
    "full_id": "sympy.geometry.plane.Plane.is_perpendicular",
    "type": "method",
    "description": "Is the given geometric entity perpendicualar to the given plane?\n\n        Parameters\n        ==========\n\n        LinearEntity3D or Plane\n\n        Returns\n        =======\n\n        Boolean\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Point3D\n        >>> a = Plane(Point3D(1,4,6), normal_vector=(2, 4, 6))\n        >>> b = Plane(Point3D(2, 2, 2), normal_vector=(-1, 2, -1))\n        >>> a.is_perpendicular(b)\n        True\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "normal_vector",
    "full_id": "sympy.geometry.plane.Plane.normal_vector",
    "type": "property",
    "description": "Normal vector of the given plane.\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Plane\n        >>> a = Plane(Point3D(1, 1, 1), Point3D(2, 3, 4), Point3D(2, 2, 2))\n        >>> a.normal_vector\n        (-1, 2, -1)\n        >>> a = Plane(Point3D(1, 1, 1), normal_vector=(1, 4, 7))\n        >>> a.normal_vector\n        (1, 4, 7)\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "p1",
    "full_id": "sympy.geometry.plane.Plane.p1",
    "type": "property",
    "description": "The only defining point of the plane. Others can be obtained from the\n        arbitrary_point method.\n\n        See Also\n        ========\n\n        sympy.geometry.point.Point3D\n\n        Examples\n        ========\n\n        >>> from sympy import Point3D, Plane\n        >>> a = Plane(Point3D(1, 1, 1), Point3D(2, 3, 4), Point3D(2, 2, 2))\n        >>> a.p1\n        Point3D(1, 1, 1)\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "parallel_plane",
    "full_id": "sympy.geometry.plane.Plane.parallel_plane",
    "type": "method",
    "description": "\n        Plane parallel to the given plane and passing through the point pt.\n\n        Parameters\n        ==========\n\n        pt: Point3D\n\n        Returns\n        =======\n\n        Plane\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Point3D\n        >>> a = Plane(Point3D(1, 4, 6), normal_vector=(2, 4, 6))\n        >>> a.parallel_plane(Point3D(2, 3, 5))\n        Plane(Point3D(2, 3, 5), (2, 4, 6))\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "parameter_value",
    "full_id": "sympy.geometry.plane.Plane.parameter_value",
    "type": "method",
    "description": "Return the parameter(s) corresponding to the given point.\n\n        Examples\n        ========\n\n        >>> from sympy import pi, Plane\n        >>> from sympy.abc import t, u, v\n        >>> p = Plane((2, 0, 0), (0, 0, 1), (0, 1, 0))\n\n        By default, the parameter value returned defines a point\n        that is a distance of 1 from the Plane's p1 value and\n        in line with the given point:\n\n        >>> on_circle = p.arbitrary_point(t).subs(t, pi/4)\n        >>> on_circle.distance(p.p1)\n        1\n        >>> p.parameter_value(on_circle, t)\n        {t: pi/4}\n\n        Moving the point twice as far from p1 does not change\n        the parameter value:\n\n        >>> off_circle = p.p1 + (on_circle - p.p1)*2\n        >>> off_circle.distance(p.p1)\n        2\n        >>> p.parameter_value(off_circle, t)\n        {t: pi/4}\n\n        If the 2-value parameter is desired, supply the two\n        parameter symbols and a replacement dictionary will\n        be returned:\n\n        >>> p.parameter_value(on_circle, u, v)\n        {u: sqrt(10)/10, v: sqrt(10)/30}\n        >>> p.parameter_value(off_circle, u, v)\n        {u: sqrt(10)/5, v: sqrt(10)/15}\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "perpendicular_line",
    "full_id": "sympy.geometry.plane.Plane.perpendicular_line",
    "type": "method",
    "description": "A line perpendicular to the given plane.\n\n        Parameters\n        ==========\n\n        pt: Point3D\n\n        Returns\n        =======\n\n        Line3D\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Point3D\n        >>> a = Plane(Point3D(1,4,6), normal_vector=(2, 4, 6))\n        >>> a.perpendicular_line(Point3D(9, 8, 7))\n        Line3D(Point3D(9, 8, 7), Point3D(11, 12, 13))\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "perpendicular_plane",
    "full_id": "sympy.geometry.plane.Plane.perpendicular_plane",
    "type": "method",
    "description": "\n        Return a perpendicular passing through the given points. If the\n        direction ratio between the points is the same as the Plane's normal\n        vector then, to select from the infinite number of possible planes,\n        a third point will be chosen on the z-axis (or the y-axis\n        if the normal vector is already parallel to the z-axis). If less than\n        two points are given they will be supplied as follows: if no point is\n        given then pt1 will be self.p1; if a second point is not given it will\n        be a point through pt1 on a line parallel to the z-axis (if the normal\n        is not already the z-axis, otherwise on the line parallel to the\n        y-axis).\n\n        Parameters\n        ==========\n\n        pts: 0, 1 or 2 Point3D\n\n        Returns\n        =======\n\n        Plane\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Point3D\n        >>> a, b = Point3D(0, 0, 0), Point3D(0, 1, 0)\n        >>> Z = (0, 0, 1)\n        >>> p = Plane(a, normal_vector=Z)\n        >>> p.perpendicular_plane(a, b)\n        Plane(Point3D(0, 0, 0), (1, 0, 0))\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "projection",
    "full_id": "sympy.geometry.plane.Plane.projection",
    "type": "method",
    "description": "Project the given point onto the plane along the plane normal.\n\n        Parameters\n        ==========\n\n        Point or Point3D\n\n        Returns\n        =======\n\n        Point3D\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Point3D\n        >>> A = Plane(Point3D(1, 1, 2), normal_vector=(1, 1, 1))\n\n        The projection is along the normal vector direction, not the z\n        axis, so (1, 1) does not project to (1, 1, 2) on the plane A:\n\n        >>> b = Point3D(1, 1)\n        >>> A.projection(b)\n        Point3D(5/3, 5/3, 2/3)\n        >>> _ in A\n        True\n\n        But the point (1, 1, 2) projects to (1, 1) on the XY-plane:\n\n        >>> XY = Plane((0, 0, 0), (0, 0, 1))\n        >>> XY.projection((1, 1, 2))\n        Point3D(1, 1, 0)\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "projection_line",
    "full_id": "sympy.geometry.plane.Plane.projection_line",
    "type": "method",
    "description": "Project the given line onto the plane through the normal plane\n        containing the line.\n\n        Parameters\n        ==========\n\n        LinearEntity or LinearEntity3D\n\n        Returns\n        =======\n\n        Point3D, Line3D, Ray3D or Segment3D\n\n        Notes\n        =====\n\n        For the interaction between 2D and 3D lines(segments, rays), you should\n        convert the line to 3D by using this method. For example for finding the\n        intersection between a 2D and a 3D line, convert the 2D line to a 3D line\n        by projecting it on a required plane and then proceed to find the\n        intersection between those lines.\n\n        Examples\n        ========\n\n        >>> from sympy import Plane, Line, Line3D, Point3D\n        >>> a = Plane(Point3D(1, 1, 1), normal_vector=(1, 1, 1))\n        >>> b = Line(Point3D(1, 1), Point3D(2, 2))\n        >>> a.projection_line(b)\n        Line3D(Point3D(4/3, 4/3, 1/3), Point3D(5/3, 5/3, -1/3))\n        >>> c = Line3D(Point3D(1, 1, 1), Point3D(2, 2, 2))\n        >>> a.projection_line(c)\n        Point3D(1, 1, 1)\n\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "random_point",
    "full_id": "sympy.geometry.plane.Plane.random_point",
    "type": "method",
    "description": "Returns a random point on the Plane.\n\n        Returns\n        =======\n\n        Point3D\n\n        Examples\n        ========\n\n        >>> from sympy import Plane\n        >>> p = Plane((1, 0, 0), normal_vector=(0, 1, 0))\n        >>> r = p.random_point(seed=42)  # seed value is optional\n        >>> r.n(3)\n        Point3D(2.29, 0, -1.35)\n\n        The random point can be moved to lie on the circle of radius\n        1 centered on p1:\n\n        >>> c = p.p1 + (r - p.p1).unit\n        >>> c.distance(p.p1).equals(1)\n        True\n        ",
    "section": "Plane",
    "url": "https://docs.sympy.org/latest/modules/geometry/plane.html"
  },
  {
    "name": "is_singular",
    "full_id": "sympy.holonomic.holonomic.DifferentialOperator.is_singular",
    "type": "method",
    "description": "\n        Checks if the differential equation is singular at x0.\n        ",
    "section": "Representation of holonomic functions in SymPy",
    "url": "https://docs.sympy.org/latest/modules/holonomic/represent.html"
  },
  {
    "name": "DifferentialOperators",
    "full_id": "sympy.holonomic.holonomic.DifferentialOperators",
    "type": "function",
    "description": "\n    This function is used to create annihilators using ``Dx``.\n\n    Explanation\n    ===========\n\n    Returns an Algebra of Differential Operators also called Weyl Algebra\n    and the operator for differentiation i.e. the ``Dx`` operator.\n\n    Parameters\n    ==========\n\n    base:\n        Base polynomial ring for the algebra.\n        The base polynomial ring is the ring of polynomials in :math:`x` that\n        will appear as coefficients in the operators.\n    generator:\n        Generator of the algebra which can\n        be either a noncommutative ``Symbol`` or a string. e.g. \"Dx\" or \"D\".\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.abc import x\n    >>> from sympy.holonomic.holonomic import DifferentialOperators\n    >>> R, Dx = DifferentialOperators(ZZ.old_poly_ring(x), 'Dx')\n    >>> R\n    Univariate Differential Operator Algebra in intermediate Dx over the base ring ZZ[x]\n    >>> Dx*x\n    (1) + (x)*Dx\n    ",
    "section": "Representation of holonomic functions in SymPy",
    "url": "https://docs.sympy.org/latest/modules/holonomic/represent.html"
  },
  {
    "name": "from_hyper",
    "full_id": "sympy.holonomic.holonomic.from_hyper",
    "type": "function",
    "description": "\n    Converts a hypergeometric function to holonomic.\n    ``func`` is the Hypergeometric Function and ``x0`` is the point at\n    which initial conditions are required.\n\n    Examples\n    ========\n\n    >>> from sympy.holonomic.holonomic import from_hyper\n    >>> from sympy import symbols, hyper, S\n    >>> x = symbols('x')\n    >>> from_hyper(hyper([], [S(3)/2], x**2/4))\n    HolonomicFunction((-x) + (2)*Dx + (x)*Dx**2, x, 1, [sinh(1), -sinh(1) + cosh(1)])\n    ",
    "section": "Converting hypergeometric functions",
    "url": "https://docs.sympy.org/latest/modules/holonomic/convert.html"
  },
  {
    "name": "from_meijerg",
    "full_id": "sympy.holonomic.holonomic.from_meijerg",
    "type": "function",
    "description": "\n    Converts a Meijer G-function to Holonomic.\n    ``func`` is the G-Function and ``x0`` is the point at\n    which initial conditions are required.\n\n    Examples\n    ========\n\n    >>> from sympy.holonomic.holonomic import from_meijerg\n    >>> from sympy import symbols, meijerg, S\n    >>> x = symbols('x')\n    >>> from_meijerg(meijerg(([], []), ([S(1)/2], [0]), x**2/4))\n    HolonomicFunction((1) + (1)*Dx**2, x, 0, [0, 1/sqrt(pi)])\n    ",
    "section": "Converting Meijer G-functions",
    "url": "https://docs.sympy.org/latest/modules/holonomic/convert.html"
  },
  {
    "name": "expr_to_holonomic",
    "full_id": "sympy.holonomic.holonomic.expr_to_holonomic",
    "type": "function",
    "description": "\n    Converts a function or an expression to a holonomic function.\n\n    Parameters\n    ==========\n\n    func:\n        The expression to be converted.\n    x:\n        variable for the function.\n    x0:\n        point at which initial condition must be computed.\n    y0:\n        One can optionally provide initial condition if the method\n        is not able to do it automatically.\n    lenics:\n        Number of terms in the initial condition. By default it is\n        equal to the order of the annihilator.\n    domain:\n        Ground domain for the polynomials in ``x`` appearing as coefficients\n        in the annihilator.\n    initcond:\n        Set it false if you do not want the initial conditions to be computed.\n\n    Examples\n    ========\n\n    >>> from sympy.holonomic.holonomic import expr_to_holonomic\n    >>> from sympy import sin, exp, symbols\n    >>> x = symbols('x')\n    >>> expr_to_holonomic(sin(x))\n    HolonomicFunction((1) + (1)*Dx**2, x, 0, [0, 1])\n    >>> expr_to_holonomic(exp(x))\n    HolonomicFunction((-1) + (1)*Dx, x, 0, [1])\n\n    See Also\n    ========\n\n    sympy.integrals.meijerint._rewrite1, _convert_poly_rat_alg, _create_table\n    ",
    "section": "Converting symbolic expressions",
    "url": "https://docs.sympy.org/latest/modules/holonomic/convert.html"
  },
  {
    "name": "_create_table",
    "full_id": "sympy.holonomic.holonomic._create_table",
    "type": "function",
    "description": "\n    Creates the look-up table. For a similar implementation\n    see meijerint._create_lookup_table.\n    ",
    "section": "Internal API",
    "url": "https://docs.sympy.org/latest/modules/holonomic/internal.html"
  },
  {
    "name": "_convert_poly_rat_alg",
    "full_id": "sympy.holonomic.holonomic._convert_poly_rat_alg",
    "type": "function",
    "description": "\n    Converts polynomials, rationals and algebraic functions to holonomic.\n    ",
    "section": "Internal API",
    "url": "https://docs.sympy.org/latest/modules/holonomic/internal.html"
  },
  {
    "name": "add_as_roots",
    "full_id": "sympy.liealgebras.root_system.RootSystem.add_as_roots",
    "type": "method",
    "description": "Add two roots together if and only if their sum is also a root\n\n        It takes as input two vectors which should be roots.  It then computes\n        their sum and checks if it is in the list of all possible roots.  If it\n        is, it returns the sum.  Otherwise it returns a string saying that the\n        sum is not a root.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.root_system import RootSystem\n        >>> c = RootSystem(\"A3\")\n        >>> c.add_as_roots([1, 0, -1, 0], [0, 0, 1, -1])\n        [1, 0, 0, -1]\n        >>> c.add_as_roots([1, -1, 0, 0], [0, 0, -1, 1])\n        'The sum of these two roots is not a root'\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "add_simple_roots",
    "full_id": "sympy.liealgebras.root_system.RootSystem.add_simple_roots",
    "type": "method",
    "description": "Add two simple roots together\n\n        The function takes as input two integers, root1 and root2.  It then\n        uses these integers as keys in the dictionary of simple roots, and gets\n        the corresponding simple roots, and then adds them together.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.root_system import RootSystem\n        >>> c = RootSystem(\"A3\")\n        >>> newroot = c.add_simple_roots(1, 2)\n        >>> newroot\n        [1, 0, -1, 0]\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "all_roots",
    "full_id": "sympy.liealgebras.root_system.RootSystem.all_roots",
    "type": "method",
    "description": "Generate all the roots of a given root system\n\n        The result is a dictionary where the keys are integer numbers.  It\n        generates the roots by getting the dictionary of all positive roots\n        from the bases classes, and then taking each root, and multiplying it\n        by -1 and adding it to the dictionary.  In this way all the negative\n        roots are generated.\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "cartan_matrix",
    "full_id": "sympy.liealgebras.root_system.RootSystem.cartan_matrix",
    "type": "method",
    "description": "Cartan matrix of Lie algebra associated with this root system\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.root_system import RootSystem\n        >>> c = RootSystem(\"A3\")\n        >>> c.cartan_matrix()\n        Matrix([\n            [ 2, -1,  0],\n            [-1,  2, -1],\n            [ 0, -1,  2]])\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "dynkin_diagram",
    "full_id": "sympy.liealgebras.root_system.RootSystem.dynkin_diagram",
    "type": "method",
    "description": "Dynkin diagram of the Lie algebra associated with this root system\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.root_system import RootSystem\n        >>> c = RootSystem(\"A3\")\n        >>> print(c.dynkin_diagram())\n        0---0---0\n        1   2   3\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "root_space",
    "full_id": "sympy.liealgebras.root_system.RootSystem.root_space",
    "type": "method",
    "description": "Return the span of the simple roots\n\n        The root space is the vector space spanned by the simple roots, i.e. it\n        is a vector space with a distinguished basis, the simple roots.  This\n        method returns a string that represents the root space as the span of\n        the simple roots, alpha[1],...., alpha[n].\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.root_system import RootSystem\n        >>> c = RootSystem(\"A3\")\n        >>> c.root_space()\n        'alpha[1] + alpha[2] + alpha[3]'\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "simple_roots",
    "full_id": "sympy.liealgebras.root_system.RootSystem.simple_roots",
    "type": "method",
    "description": "Generate the simple roots of the Lie algebra\n\n        The rank of the Lie algebra determines the number of simple roots that\n        it has.  This method obtains the rank of the Lie algebra, and then uses\n        the simple_root method from the Lie algebra classes to generate all the\n        simple roots.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.root_system import RootSystem\n        >>> c = RootSystem(\"A3\")\n        >>> roots = c.simple_roots()\n        >>> roots\n        {1: [1, -1, 0, 0], 2: [0, 1, -1, 0], 3: [0, 0, 1, -1]}\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basic_root",
    "full_id": "sympy.liealgebras.type_a.TypeA.basic_root",
    "type": "method",
    "description": "\n        This is a method just to generate roots\n        with a 1 iin the ith position and a -1\n        in the jth position.\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basis",
    "full_id": "sympy.liealgebras.type_a.TypeA.basis",
    "type": "method",
    "description": "\n        Returns the number of independent generators of A_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "cartan_matrix",
    "full_id": "sympy.liealgebras.type_a.TypeA.cartan_matrix",
    "type": "method",
    "description": "\n        Returns the Cartan matrix for A_n.\n        The Cartan matrix matrix for a Lie algebra is\n        generated by assigning an ordering to the simple\n        roots, (alpha[1], ...., alpha[l]).  Then the ijth\n        entry of the Cartan matrix is (<alpha[i],alpha[j]>).\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType('A4')\n        >>> c.cartan_matrix()\n        Matrix([\n        [ 2, -1,  0,  0],\n        [-1,  2, -1,  0],\n        [ 0, -1,  2, -1],\n        [ 0,  0, -1,  2]])\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "dimension",
    "full_id": "sympy.liealgebras.type_a.TypeA.dimension",
    "type": "method",
    "description": "Dimension of the vector space V underlying the Lie algebra\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"A4\")\n        >>> c.dimension()\n        5\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "highest_root",
    "full_id": "sympy.liealgebras.type_a.TypeA.highest_root",
    "type": "method",
    "description": "\n        Returns the highest weight root for A_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "lie_algebra",
    "full_id": "sympy.liealgebras.type_a.TypeA.lie_algebra",
    "type": "method",
    "description": "\n        Returns the Lie algebra associated with A_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "positive_roots",
    "full_id": "sympy.liealgebras.type_a.TypeA.positive_roots",
    "type": "method",
    "description": "\n        This method generates all the positive roots of\n        A_n.  This is half of all of the roots of A_n;\n        by multiplying all the positive roots by -1 we\n        get the negative roots.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"A3\")\n        >>> c.positive_roots()\n        {1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],\n                5: [0, 1, 0, -1], 6: [0, 0, 1, -1]}\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "roots",
    "full_id": "sympy.liealgebras.type_a.TypeA.roots",
    "type": "method",
    "description": "\n        Returns the total number of roots for A_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "simple_root",
    "full_id": "sympy.liealgebras.type_a.TypeA.simple_root",
    "type": "method",
    "description": "\n        Every lie algebra has a unique root system.\n        Given a root system Q, there is a subset of the\n        roots such that an element of Q is called a\n        simple root if it cannot be written as the sum\n        of two elements in Q.  If we let D denote the\n        set of simple roots, then it is clear that every\n        element of Q can be written as a linear combination\n        of elements of D with all coefficients non-negative.\n\n        In A_n the ith simple root is the root which has a 1\n        in the ith position, a -1 in the (i+1)th position,\n        and zeroes elsewhere.\n\n        This method returns the ith simple root for the A series.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"A4\")\n        >>> c.simple_root(1)\n        [1, -1, 0, 0, 0]\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basis",
    "full_id": "sympy.liealgebras.type_b.TypeB.basis",
    "type": "method",
    "description": "\n        Returns the number of independent generators of B_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "cartan_matrix",
    "full_id": "sympy.liealgebras.type_b.TypeB.cartan_matrix",
    "type": "method",
    "description": "\n        Returns the Cartan matrix for B_n.\n        The Cartan matrix matrix for a Lie algebra is\n        generated by assigning an ordering to the simple\n        roots, (alpha[1], ...., alpha[l]).  Then the ijth\n        entry of the Cartan matrix is (<alpha[i],alpha[j]>).\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType('B4')\n        >>> c.cartan_matrix()\n        Matrix([\n        [ 2, -1,  0,  0],\n        [-1,  2, -1,  0],\n        [ 0, -1,  2, -2],\n        [ 0,  0, -1,  2]])\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "dimension",
    "full_id": "sympy.liealgebras.type_b.TypeB.dimension",
    "type": "method",
    "description": "Dimension of the vector space V underlying the Lie algebra\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"B3\")\n        >>> c.dimension()\n        3\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "lie_algebra",
    "full_id": "sympy.liealgebras.type_b.TypeB.lie_algebra",
    "type": "method",
    "description": "\n        Returns the Lie algebra associated with B_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "positive_roots",
    "full_id": "sympy.liealgebras.type_b.TypeB.positive_roots",
    "type": "method",
    "description": "\n        This method generates all the positive roots of\n        A_n.  This is half of all of the roots of B_n;\n        by multiplying all the positive roots by -1 we\n        get the negative roots.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"A3\")\n        >>> c.positive_roots()\n        {1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],\n                5: [0, 1, 0, -1], 6: [0, 0, 1, -1]}\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "roots",
    "full_id": "sympy.liealgebras.type_b.TypeB.roots",
    "type": "method",
    "description": "\n        Returns the total number of roots for B_n\"\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "simple_root",
    "full_id": "sympy.liealgebras.type_b.TypeB.simple_root",
    "type": "method",
    "description": "\n        Every lie algebra has a unique root system.\n        Given a root system Q, there is a subset of the\n        roots such that an element of Q is called a\n        simple root if it cannot be written as the sum\n        of two elements in Q.  If we let D denote the\n        set of simple roots, then it is clear that every\n        element of Q can be written as a linear combination\n        of elements of D with all coefficients non-negative.\n\n        In B_n the first n-1 simple roots are the same as the\n        roots in A_(n-1) (a 1 in the ith position, a -1 in\n        the (i+1)th position, and zeroes elsewhere).  The n-th\n        simple root is the root with a 1 in the nth position\n        and zeroes elsewhere.\n\n        This method returns the ith simple root for the B series.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"B3\")\n        >>> c.simple_root(2)\n        [0, 1, -1]\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basic_root",
    "full_id": "sympy.liealgebras.type_c.TypeC.basic_root",
    "type": "method",
    "description": "Generate roots with 1 in ith position and a -1 in jth position",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basis",
    "full_id": "sympy.liealgebras.type_c.TypeC.basis",
    "type": "method",
    "description": "\n        Returns the number of independent generators of C_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "cartan_matrix",
    "full_id": "sympy.liealgebras.type_c.TypeC.cartan_matrix",
    "type": "method",
    "description": "The Cartan matrix for C_n\n\n        The Cartan matrix matrix for a Lie algebra is\n        generated by assigning an ordering to the simple\n        roots, (alpha[1], ...., alpha[l]).  Then the ijth\n        entry of the Cartan matrix is (<alpha[i],alpha[j]>).\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType('C4')\n        >>> c.cartan_matrix()\n        Matrix([\n        [ 2, -1,  0,  0],\n        [-1,  2, -1,  0],\n        [ 0, -1,  2, -1],\n        [ 0,  0, -2,  2]])\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "dimension",
    "full_id": "sympy.liealgebras.type_c.TypeC.dimension",
    "type": "method",
    "description": "Dimension of the vector space V underlying the Lie algebra\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"C3\")\n        >>> c.dimension()\n        3\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "lie_algebra",
    "full_id": "sympy.liealgebras.type_c.TypeC.lie_algebra",
    "type": "method",
    "description": "\n        Returns the Lie algebra associated with C_n\"\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "positive_roots",
    "full_id": "sympy.liealgebras.type_c.TypeC.positive_roots",
    "type": "method",
    "description": "Generates all the positive roots of A_n\n\n        This is half of all of the roots of C_n; by multiplying all the\n        positive roots by -1 we get the negative roots.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"A3\")\n        >>> c.positive_roots()\n        {1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],\n                5: [0, 1, 0, -1], 6: [0, 0, 1, -1]}\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "roots",
    "full_id": "sympy.liealgebras.type_c.TypeC.roots",
    "type": "method",
    "description": "\n        Returns the total number of roots for C_n\"\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "simple_root",
    "full_id": "sympy.liealgebras.type_c.TypeC.simple_root",
    "type": "method",
    "description": "The ith simple root for the C series\n\n        Every lie algebra has a unique root system.\n        Given a root system Q, there is a subset of the\n        roots such that an element of Q is called a\n        simple root if it cannot be written as the sum\n        of two elements in Q.  If we let D denote the\n        set of simple roots, then it is clear that every\n        element of Q can be written as a linear combination\n        of elements of D with all coefficients non-negative.\n\n        In C_n, the first n-1 simple roots are the same as\n        the roots in A_(n-1) (a 1 in the ith position, a -1\n        in the (i+1)th position, and zeroes elsewhere).  The\n        nth simple root is the root in which there is a 2 in\n        the nth position and zeroes elsewhere.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"C3\")\n        >>> c.simple_root(2)\n        [0, 1, -1]\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basis",
    "full_id": "sympy.liealgebras.type_d.TypeD.basis",
    "type": "method",
    "description": "\n        Returns the number of independent generators of D_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "cartan_matrix",
    "full_id": "sympy.liealgebras.type_d.TypeD.cartan_matrix",
    "type": "method",
    "description": "\n        Returns the Cartan matrix for D_n.\n        The Cartan matrix matrix for a Lie algebra is\n        generated by assigning an ordering to the simple\n        roots, (alpha[1], ...., alpha[l]).  Then the ijth\n        entry of the Cartan matrix is (<alpha[i],alpha[j]>).\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType('D4')\n        >>> c.cartan_matrix()\n            Matrix([\n            [ 2, -1,  0,  0],\n            [-1,  2, -1, -1],\n            [ 0, -1,  2,  0],\n            [ 0, -1,  0,  2]])\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "dimension",
    "full_id": "sympy.liealgebras.type_d.TypeD.dimension",
    "type": "method",
    "description": "Dmension of the vector space V underlying the Lie algebra\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"D4\")\n        >>> c.dimension()\n        4\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "lie_algebra",
    "full_id": "sympy.liealgebras.type_d.TypeD.lie_algebra",
    "type": "method",
    "description": "\n        Returns the Lie algebra associated with D_n\"\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "positive_roots",
    "full_id": "sympy.liealgebras.type_d.TypeD.positive_roots",
    "type": "method",
    "description": "\n        This method generates all the positive roots of\n        A_n.  This is half of all of the roots of D_n\n        by multiplying all the positive roots by -1 we\n        get the negative roots.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"A3\")\n        >>> c.positive_roots()\n        {1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],\n                5: [0, 1, 0, -1], 6: [0, 0, 1, -1]}\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "roots",
    "full_id": "sympy.liealgebras.type_d.TypeD.roots",
    "type": "method",
    "description": "\n        Returns the total number of roots for D_n\"\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "simple_root",
    "full_id": "sympy.liealgebras.type_d.TypeD.simple_root",
    "type": "method",
    "description": "\n        Every lie algebra has a unique root system.\n        Given a root system Q, there is a subset of the\n        roots such that an element of Q is called a\n        simple root if it cannot be written as the sum\n        of two elements in Q.  If we let D denote the\n        set of simple roots, then it is clear that every\n        element of Q can be written as a linear combination\n        of elements of D with all coefficients non-negative.\n\n        In D_n, the first n-1 simple roots are the same as\n        the roots in A_(n-1) (a 1 in the ith position, a -1\n        in the (i+1)th position, and zeroes elsewhere).\n        The nth simple root is the root in which there 1s in\n        the nth and (n-1)th positions, and zeroes elsewhere.\n\n        This method returns the ith simple root for the D series.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"D4\")\n        >>> c.simple_root(2)\n        [0, 1, -1, 0]\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basic_root",
    "full_id": "sympy.liealgebras.type_e.TypeE.basic_root",
    "type": "method",
    "description": "\n        This is a method just to generate roots\n        with a -1 in the ith position and a 1\n        in the jth position.\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basis",
    "full_id": "sympy.liealgebras.type_e.TypeE.basis",
    "type": "method",
    "description": "\n        Returns the number of independent generators of E_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "cartan_matrix",
    "full_id": "sympy.liealgebras.type_e.TypeE.cartan_matrix",
    "type": "method",
    "description": "\n        Returns the Cartan matrix for G_2\n        The Cartan matrix matrix for a Lie algebra is\n        generated by assigning an ordering to the simple\n        roots, (alpha[1], ...., alpha[l]).  Then the ijth\n        entry of the Cartan matrix is (<alpha[i],alpha[j]>).\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType('A4')\n        >>> c.cartan_matrix()\n        Matrix([\n        [ 2, -1,  0,  0],\n        [-1,  2, -1,  0],\n        [ 0, -1,  2, -1],\n        [ 0,  0, -1,  2]])\n\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "dimension",
    "full_id": "sympy.liealgebras.type_e.TypeE.dimension",
    "type": "method",
    "description": "Dimension of the vector space V underlying the Lie algebra\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"E6\")\n        >>> c.dimension()\n        8\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "positive_roots",
    "full_id": "sympy.liealgebras.type_e.TypeE.positive_roots",
    "type": "method",
    "description": "\n        This method generates all the positive roots of\n        A_n.  This is half of all of the roots of E_n;\n        by multiplying all the positive roots by -1 we\n        get the negative roots.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"A3\")\n        >>> c.positive_roots()\n        {1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],\n                5: [0, 1, 0, -1], 6: [0, 0, 1, -1]}\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "roots",
    "full_id": "sympy.liealgebras.type_e.TypeE.roots",
    "type": "method",
    "description": "\n        Returns the total number of roots of E_n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "simple_root",
    "full_id": "sympy.liealgebras.type_e.TypeE.simple_root",
    "type": "method",
    "description": "\n        Every lie algebra has a unique root system.\n        Given a root system Q, there is a subset of the\n        roots such that an element of Q is called a\n        simple root if it cannot be written as the sum\n        of two elements in Q.  If we let D denote the\n        set of simple roots, then it is clear that every\n        element of Q can be written as a linear combination\n        of elements of D with all coefficients non-negative.\n\n        This method returns the ith simple root for E_n.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"E6\")\n        >>> c.simple_root(2)\n        [1, 1, 0, 0, 0, 0, 0, 0]\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basic_root",
    "full_id": "sympy.liealgebras.type_f.TypeF.basic_root",
    "type": "method",
    "description": "Generate roots with 1 in ith position and -1 in jth position",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basis",
    "full_id": "sympy.liealgebras.type_f.TypeF.basis",
    "type": "method",
    "description": "\n        Returns the number of independent generators of F_4\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "cartan_matrix",
    "full_id": "sympy.liealgebras.type_f.TypeF.cartan_matrix",
    "type": "method",
    "description": "The Cartan matrix for F_4\n\n        The Cartan matrix matrix for a Lie algebra is\n        generated by assigning an ordering to the simple\n        roots, (alpha[1], ...., alpha[l]).  Then the ijth\n        entry of the Cartan matrix is (<alpha[i],alpha[j]>).\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType('A4')\n        >>> c.cartan_matrix()\n        Matrix([\n        [ 2, -1,  0,  0],\n        [-1,  2, -1,  0],\n        [ 0, -1,  2, -1],\n        [ 0,  0, -1,  2]])\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "dimension",
    "full_id": "sympy.liealgebras.type_f.TypeF.dimension",
    "type": "method",
    "description": "Dimension of the vector space V underlying the Lie algebra\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"F4\")\n        >>> c.dimension()\n        4\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "positive_roots",
    "full_id": "sympy.liealgebras.type_f.TypeF.positive_roots",
    "type": "method",
    "description": "Generate all the positive roots of A_n\n\n        This is half of all of the roots of F_4; by multiplying all the\n        positive roots by -1 we get the negative roots.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"A3\")\n        >>> c.positive_roots()\n        {1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],\n                5: [0, 1, 0, -1], 6: [0, 0, 1, -1]}\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "roots",
    "full_id": "sympy.liealgebras.type_f.TypeF.roots",
    "type": "method",
    "description": "\n        Returns the total number of roots for F_4\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "simple_root",
    "full_id": "sympy.liealgebras.type_f.TypeF.simple_root",
    "type": "method",
    "description": "The ith simple root of F_4\n\n        Every lie algebra has a unique root system.\n        Given a root system Q, there is a subset of the\n        roots such that an element of Q is called a\n        simple root if it cannot be written as the sum\n        of two elements in Q.  If we let D denote the\n        set of simple roots, then it is clear that every\n        element of Q can be written as a linear combination\n        of elements of D with all coefficients non-negative.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"F4\")\n        >>> c.simple_root(3)\n        [0, 0, 0, 1]\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "basis",
    "full_id": "sympy.liealgebras.type_g.TypeG.basis",
    "type": "method",
    "description": "\n        Returns the number of independent generators of G_2\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "cartan_matrix",
    "full_id": "sympy.liealgebras.type_g.TypeG.cartan_matrix",
    "type": "method",
    "description": "The Cartan matrix for G_2\n\n        The Cartan matrix matrix for a Lie algebra is\n        generated by assigning an ordering to the simple\n        roots, (alpha[1], ...., alpha[l]).  Then the ijth\n        entry of the Cartan matrix is (<alpha[i],alpha[j]>).\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"G2\")\n        >>> c.cartan_matrix()\n        Matrix([\n            [ 2, -1],\n            [-3,  2]])\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "dimension",
    "full_id": "sympy.liealgebras.type_g.TypeG.dimension",
    "type": "method",
    "description": "Dimension of the vector space V underlying the Lie algebra\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"G2\")\n        >>> c.dimension()\n        3\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "positive_roots",
    "full_id": "sympy.liealgebras.type_g.TypeG.positive_roots",
    "type": "method",
    "description": "Generate all the positive roots of A_n\n\n        This is half of all of the roots of A_n; by multiplying all the\n        positive roots by -1 we get the negative roots.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"A3\")\n        >>> c.positive_roots()\n        {1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],\n                5: [0, 1, 0, -1], 6: [0, 0, 1, -1]}\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "roots",
    "full_id": "sympy.liealgebras.type_g.TypeG.roots",
    "type": "method",
    "description": "\n        Returns the total number of roots of G_2\"\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "simple_root",
    "full_id": "sympy.liealgebras.type_g.TypeG.simple_root",
    "type": "method",
    "description": "The ith simple root of G_2\n\n        Every lie algebra has a unique root system.\n        Given a root system Q, there is a subset of the\n        roots such that an element of Q is called a\n        simple root if it cannot be written as the sum\n        of two elements in Q.  If we let D denote the\n        set of simple roots, then it is clear that every\n        element of Q can be written as a linear combination\n        of elements of D with all coefficients non-negative.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.cartan_type import CartanType\n        >>> c = CartanType(\"G2\")\n        >>> c.simple_root(1)\n        [0, 1, -1]\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "coxeter_diagram",
    "full_id": "sympy.liealgebras.weyl_group.WeylGroup.coxeter_diagram",
    "type": "method",
    "description": "\n        This method returns the Coxeter diagram corresponding to a Weyl group.\n        The Coxeter diagram can be obtained from a Lie algebra's Dynkin diagram\n        by deleting all arrows; the Coxeter diagram is the undirected graph.\n        The vertices of the Coxeter diagram represent the generating reflections\n        of the Weyl group, $s_i$.  An edge is drawn between $s_i$ and $s_j$ if the order\n        $m(i, j)$ of $s_is_j$ is greater than two.  If there is one edge, the order\n        $m(i, j)$ is 3.  If there are two edges, the order $m(i, j)$ is 4, and if there\n        are three edges, the order $m(i, j)$ is 6.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.weyl_group import WeylGroup\n        >>> c = WeylGroup(\"B3\")\n        >>> print(c.coxeter_diagram())\n        0---0===0\n        1   2   3\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "delete_doubles",
    "full_id": "sympy.liealgebras.weyl_group.WeylGroup.delete_doubles",
    "type": "method",
    "description": "\n        This is a helper method for determining the order of an element in the\n        Weyl group of G2.  It takes a Weyl element and if repeated simple reflections\n        in it, it deletes them.\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "element_order",
    "full_id": "sympy.liealgebras.weyl_group.WeylGroup.element_order",
    "type": "method",
    "description": "\n        This method returns the order of a given Weyl group element, which should\n        be specified by the user in the form of products of the generating\n        reflections, i.e. of the form r1*r2 etc.\n\n        For types A-F, this method current works by taking the matrix form of\n        the specified element, and then finding what power of the matrix is the\n        identity.  It then returns this power.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.weyl_group import WeylGroup\n        >>> b = WeylGroup(\"B4\")\n        >>> b.element_order('r1*r4*r2')\n        4\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "generators",
    "full_id": "sympy.liealgebras.weyl_group.WeylGroup.generators",
    "type": "method",
    "description": "\n        This method creates the generating reflections of the Weyl group for\n        a given Lie algebra.  For a Lie algebra of rank n, there are n\n        different generating reflections.  This function returns them as\n        a list.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.weyl_group import WeylGroup\n        >>> c = WeylGroup(\"F4\")\n        >>> c.generators()\n        ['r1', 'r2', 'r3', 'r4']\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "group_name",
    "full_id": "sympy.liealgebras.weyl_group.WeylGroup.group_name",
    "type": "method",
    "description": "\n        This method returns some general information about the Weyl group for\n        a given Lie algebra.  It returns the name of the group and the elements\n        it acts on, if relevant.\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "group_order",
    "full_id": "sympy.liealgebras.weyl_group.WeylGroup.group_order",
    "type": "method",
    "description": "\n        This method returns the order of the Weyl group.\n        For types A, B, C, D, and E the order depends on\n        the rank of the Lie algebra.  For types F and G,\n        the order is fixed.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.weyl_group import WeylGroup\n        >>> c = WeylGroup(\"D4\")\n        >>> c.group_order()\n        192.0\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "matrix_form",
    "full_id": "sympy.liealgebras.weyl_group.WeylGroup.matrix_form",
    "type": "method",
    "description": "\n        This method takes input from the user in the form of products of the\n        generating reflections, and returns the matrix corresponding to the\n        element of the Weyl group.  Since each element of the Weyl group is\n        a reflection of some type, there is a corresponding matrix representation.\n        This method uses the standard representation for all the generating\n        reflections.\n\n        Examples\n        ========\n\n        >>> from sympy.liealgebras.weyl_group import WeylGroup\n        >>> f = WeylGroup(\"F4\")\n        >>> f.matrix_form('r2*r3')\n        Matrix([\n        [1, 0, 0,  0],\n        [0, 1, 0,  0],\n        [0, 0, 0, -1],\n        [0, 0, 1,  0]])\n\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "rank",
    "full_id": "sympy.liealgebras.cartan_type.Standard_Cartan.rank",
    "type": "method",
    "description": "\n        Returns the rank of the Lie algebra\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "series",
    "full_id": "sympy.liealgebras.cartan_type.Standard_Cartan.series",
    "type": "method",
    "description": "\n        Returns the type of the Lie algebra\n        ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "DynkinDiagram",
    "full_id": "sympy.liealgebras.dynkin_diagram.DynkinDiagram",
    "type": "function",
    "description": "Display the Dynkin diagram of a given Lie algebra\n\n    Works by generating the CartanType for the input, t, and then returning the\n    Dynkin diagram method from the individual classes.\n\n    Examples\n    ========\n\n    >>> from sympy.liealgebras.dynkin_diagram import DynkinDiagram\n    >>> print(DynkinDiagram(\"A3\"))\n    0---0---0\n    1   2   3\n\n    >>> print(DynkinDiagram(\"B4\"))\n    0---0---0=>=0\n    1   2   3   4\n\n    ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "CartanMatrix",
    "full_id": "sympy.liealgebras.cartan_matrix.CartanMatrix",
    "type": "function",
    "description": "Access the Cartan matrix of a specific Lie algebra\n\n    Examples\n    ========\n\n    >>> from sympy.liealgebras.cartan_matrix import CartanMatrix\n    >>> CartanMatrix(\"A2\")\n    Matrix([\n    [ 2, -1],\n    [-1,  2]])\n\n    >>> CartanMatrix(['C', 3])\n    Matrix([\n    [ 2, -1,  0],\n    [-1,  2, -1],\n    [ 0, -2,  2]])\n\n    This method works by returning the Cartan matrix\n    which corresponds to Cartan type t.\n    ",
    "section": "Lie Algebra",
    "url": "https://docs.sympy.org/latest/modules/liealgebras/index.html"
  },
  {
    "name": "poly",
    "full_id": "sympy.polys.polytools.poly",
    "type": "function",
    "description": "\n    Efficiently transform an expression into a polynomial.\n\n    Examples\n    ========\n\n    >>> from sympy import poly\n    >>> from sympy.abc import x\n\n    >>> poly(x*(x**2 + x - 1)**2)\n    Poly(x**5 + 2*x**4 - x**3 - 2*x**2 + x, x, domain='ZZ')\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "poly_from_expr",
    "full_id": "sympy.polys.polytools.poly_from_expr",
    "type": "function",
    "description": "Construct a polynomial from an expression.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "parallel_poly_from_expr",
    "full_id": "sympy.polys.polytools.parallel_poly_from_expr",
    "type": "function",
    "description": "Construct polynomials from expressions.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "degree",
    "full_id": "sympy.polys.polytools.degree",
    "type": "function",
    "description": "\n    Return the degree of ``f`` in the given variable.\n\n    The degree of 0 is negative infinity.\n\n    Examples\n    ========\n\n    >>> from sympy import degree\n    >>> from sympy.abc import x, y\n\n    >>> degree(x**2 + y*x + 1, gen=x)\n    2\n    >>> degree(x**2 + y*x + 1, gen=y)\n    1\n    >>> degree(0, x)\n    -oo\n\n    See also\n    ========\n\n    sympy.polys.polytools.Poly.total_degree\n    degree_list\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "degree_list",
    "full_id": "sympy.polys.polytools.degree_list",
    "type": "function",
    "description": "\n    Return a list of degrees of ``f`` in all variables.\n\n    Examples\n    ========\n\n    >>> from sympy import degree_list\n    >>> from sympy.abc import x, y\n\n    >>> degree_list(x**2 + y*x + 1)\n    (2, 1)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "LC",
    "full_id": "sympy.polys.polytools.LC",
    "type": "function",
    "description": "\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import LC\n    >>> from sympy.abc import x, y\n\n    >>> LC(4*x**2 + 2*x*y**2 + x*y + 3*y)\n    4\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "LM",
    "full_id": "sympy.polys.polytools.LM",
    "type": "function",
    "description": "\n    Return the leading monomial of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import LM\n    >>> from sympy.abc import x, y\n\n    >>> LM(4*x**2 + 2*x*y**2 + x*y + 3*y)\n    x**2\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "LT",
    "full_id": "sympy.polys.polytools.LT",
    "type": "function",
    "description": "\n    Return the leading term of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import LT\n    >>> from sympy.abc import x, y\n\n    >>> LT(4*x**2 + 2*x*y**2 + x*y + 3*y)\n    4*x**2\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "pdiv",
    "full_id": "sympy.polys.polytools.pdiv",
    "type": "function",
    "description": "\n    Compute polynomial pseudo-division of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import pdiv\n    >>> from sympy.abc import x\n\n    >>> pdiv(x**2 + 1, 2*x - 4)\n    (2*x + 4, 20)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "prem",
    "full_id": "sympy.polys.polytools.prem",
    "type": "function",
    "description": "\n    Compute polynomial pseudo-remainder of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import prem\n    >>> from sympy.abc import x\n\n    >>> prem(x**2 + 1, 2*x - 4)\n    20\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "pquo",
    "full_id": "sympy.polys.polytools.pquo",
    "type": "function",
    "description": "\n    Compute polynomial pseudo-quotient of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import pquo\n    >>> from sympy.abc import x\n\n    >>> pquo(x**2 + 1, 2*x - 4)\n    2*x + 4\n    >>> pquo(x**2 - 1, 2*x - 1)\n    2*x + 1\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "pexquo",
    "full_id": "sympy.polys.polytools.pexquo",
    "type": "function",
    "description": "\n    Compute polynomial exact pseudo-quotient of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import pexquo\n    >>> from sympy.abc import x\n\n    >>> pexquo(x**2 - 1, 2*x - 2)\n    2*x + 2\n\n    >>> pexquo(x**2 + 1, 2*x - 4)\n    Traceback (most recent call last):\n    ...\n    ExactQuotientFailed: 2*x - 4 does not divide x**2 + 1\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "div",
    "full_id": "sympy.polys.polytools.div",
    "type": "function",
    "description": "\n    Compute polynomial division of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import div, ZZ, QQ\n    >>> from sympy.abc import x\n\n    >>> div(x**2 + 1, 2*x - 4, domain=ZZ)\n    (0, x**2 + 1)\n    >>> div(x**2 + 1, 2*x - 4, domain=QQ)\n    (x/2 + 1, 5)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "rem",
    "full_id": "sympy.polys.polytools.rem",
    "type": "function",
    "description": "\n    Compute polynomial remainder of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import rem, ZZ, QQ\n    >>> from sympy.abc import x\n\n    >>> rem(x**2 + 1, 2*x - 4, domain=ZZ)\n    x**2 + 1\n    >>> rem(x**2 + 1, 2*x - 4, domain=QQ)\n    5\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "quo",
    "full_id": "sympy.polys.polytools.quo",
    "type": "function",
    "description": "\n    Compute polynomial quotient of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import quo\n    >>> from sympy.abc import x\n\n    >>> quo(x**2 + 1, 2*x - 4)\n    x/2 + 1\n    >>> quo(x**2 - 1, x - 1)\n    x + 1\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "exquo",
    "full_id": "sympy.polys.polytools.exquo",
    "type": "function",
    "description": "\n    Compute polynomial exact quotient of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import exquo\n    >>> from sympy.abc import x\n\n    >>> exquo(x**2 - 1, x - 1)\n    x + 1\n\n    >>> exquo(x**2 + 1, 2*x - 4)\n    Traceback (most recent call last):\n    ...\n    ExactQuotientFailed: 2*x - 4 does not divide x**2 + 1\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "half_gcdex",
    "full_id": "sympy.polys.polytools.half_gcdex",
    "type": "function",
    "description": "\n    Half extended Euclidean algorithm of ``f`` and ``g``.\n\n    Returns ``(s, h)`` such that ``h = gcd(f, g)`` and ``s*f = h (mod g)``.\n\n    Examples\n    ========\n\n    >>> from sympy import half_gcdex\n    >>> from sympy.abc import x\n\n    >>> half_gcdex(x**4 - 2*x**3 - 6*x**2 + 12*x + 15, x**3 + x**2 - 4*x - 4)\n    (3/5 - x/5, x + 1)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gcdex",
    "full_id": "sympy.polys.polytools.gcdex",
    "type": "function",
    "description": "\n    Extended Euclidean algorithm of ``f`` and ``g``.\n\n    Returns ``(s, t, h)`` such that ``h = gcd(f, g)`` and ``s*f + t*g = h``.\n\n    Examples\n    ========\n\n    >>> from sympy import gcdex\n    >>> from sympy.abc import x\n\n    >>> gcdex(x**4 - 2*x**3 - 6*x**2 + 12*x + 15, x**3 + x**2 - 4*x - 4)\n    (3/5 - x/5, x**2/5 - 6*x/5 + 2, x + 1)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "invert",
    "full_id": "sympy.polys.polytools.invert",
    "type": "function",
    "description": "\n    Invert ``f`` modulo ``g`` when possible.\n\n    Examples\n    ========\n\n    >>> from sympy import invert, S, mod_inverse\n    >>> from sympy.abc import x\n\n    >>> invert(x**2 - 1, 2*x - 1)\n    -4/3\n\n    >>> invert(x**2 - 1, x - 1)\n    Traceback (most recent call last):\n    ...\n    NotInvertible: zero divisor\n\n    For more efficient inversion of Rationals,\n    use the :obj:`sympy.core.intfunc.mod_inverse` function:\n\n    >>> mod_inverse(3, 5)\n    2\n    >>> (S(2)/5).invert(S(7)/3)\n    5/2\n\n    See Also\n    ========\n    sympy.core.intfunc.mod_inverse\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "subresultants",
    "full_id": "sympy.polys.polytools.subresultants",
    "type": "function",
    "description": "\n    Compute subresultant PRS of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import subresultants\n    >>> from sympy.abc import x\n\n    >>> subresultants(x**2 + 1, x**2 - 1)\n    [x**2 + 1, x**2 - 1, -2]\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "resultant",
    "full_id": "sympy.polys.polytools.resultant",
    "type": "function",
    "description": "\n    Compute resultant of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import resultant\n    >>> from sympy.abc import x\n\n    >>> resultant(x**2 + 1, x**2 - 1)\n    4\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "discriminant",
    "full_id": "sympy.polys.polytools.discriminant",
    "type": "function",
    "description": "\n    Compute discriminant of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import discriminant\n    >>> from sympy.abc import x\n\n    >>> discriminant(x**2 + 2*x + 3)\n    -8\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "terms_gcd",
    "full_id": "sympy.polys.polytools.terms_gcd",
    "type": "function",
    "description": "\n    Remove GCD of terms from ``f``.\n\n    If the ``deep`` flag is True, then the arguments of ``f`` will have\n    terms_gcd applied to them.\n\n    If a fraction is factored out of ``f`` and ``f`` is an Add, then\n    an unevaluated Mul will be returned so that automatic simplification\n    does not redistribute it. The hint ``clear``, when set to False, can be\n    used to prevent such factoring when all coefficients are not fractions.\n\n    Examples\n    ========\n\n    >>> from sympy import terms_gcd, cos\n    >>> from sympy.abc import x, y\n    >>> terms_gcd(x**6*y**2 + x**3*y, x, y)\n    x**3*y*(x**3*y + 1)\n\n    The default action of polys routines is to expand the expression\n    given to them. terms_gcd follows this behavior:\n\n    >>> terms_gcd((3+3*x)*(x+x*y))\n    3*x*(x*y + x + y + 1)\n\n    If this is not desired then the hint ``expand`` can be set to False.\n    In this case the expression will be treated as though it were comprised\n    of one or more terms:\n\n    >>> terms_gcd((3+3*x)*(x+x*y), expand=False)\n    (3*x + 3)*(x*y + x)\n\n    In order to traverse factors of a Mul or the arguments of other\n    functions, the ``deep`` hint can be used:\n\n    >>> terms_gcd((3 + 3*x)*(x + x*y), expand=False, deep=True)\n    3*x*(x + 1)*(y + 1)\n    >>> terms_gcd(cos(x + x*y), deep=True)\n    cos(x*(y + 1))\n\n    Rationals are factored out by default:\n\n    >>> terms_gcd(x + y/2)\n    (2*x + y)/2\n\n    Only the y-term had a coefficient that was a fraction; if one\n    does not want to factor out the 1/2 in cases like this, the\n    flag ``clear`` can be set to False:\n\n    >>> terms_gcd(x + y/2, clear=False)\n    x + y/2\n    >>> terms_gcd(x*y/2 + y**2, clear=False)\n    y*(x/2 + y)\n\n    The ``clear`` flag is ignored if all coefficients are fractions:\n\n    >>> terms_gcd(x/3 + y/2, clear=False)\n    (2*x + 3*y)/6\n\n    See Also\n    ========\n    sympy.core.exprtools.gcd_terms, sympy.core.exprtools.factor_terms\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "cofactors",
    "full_id": "sympy.polys.polytools.cofactors",
    "type": "function",
    "description": "\n    Compute GCD and cofactors of ``f`` and ``g``.\n\n    Returns polynomials ``(h, cff, cfg)`` such that ``h = gcd(f, g)``, and\n    ``cff = quo(f, h)`` and ``cfg = quo(g, h)`` are, so called, cofactors\n    of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import cofactors\n    >>> from sympy.abc import x\n\n    >>> cofactors(x**2 - 1, x**2 - 3*x + 2)\n    (x - 1, x + 1, x - 2)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.polys.polytools.gcd",
    "type": "function",
    "description": "\n    Compute GCD of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import gcd\n    >>> from sympy.abc import x\n\n    >>> gcd(x**2 - 1, x**2 - 3*x + 2)\n    x - 1\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gcd_list",
    "full_id": "sympy.polys.polytools.gcd_list",
    "type": "function",
    "description": "\n    Compute GCD of a list of polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy import gcd_list\n    >>> from sympy.abc import x\n\n    >>> gcd_list([x**3 - 1, x**2 - 1, x**2 - 3*x + 2])\n    x - 1\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.polys.polytools.lcm",
    "type": "function",
    "description": "\n    Compute LCM of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy import lcm\n    >>> from sympy.abc import x\n\n    >>> lcm(x**2 - 1, x**2 - 3*x + 2)\n    x**3 - 2*x**2 - x + 2\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "lcm_list",
    "full_id": "sympy.polys.polytools.lcm_list",
    "type": "function",
    "description": "\n    Compute LCM of a list of polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy import lcm_list\n    >>> from sympy.abc import x\n\n    >>> lcm_list([x**3 - 1, x**2 - 1, x**2 - 3*x + 2])\n    x**5 - x**4 - 2*x**3 - x**2 + x + 2\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "trunc",
    "full_id": "sympy.polys.polytools.trunc",
    "type": "function",
    "description": "\n    Reduce ``f`` modulo a constant ``p``.\n\n    Examples\n    ========\n\n    >>> from sympy import trunc\n    >>> from sympy.abc import x\n\n    >>> trunc(2*x**3 + 3*x**2 + 5*x + 7, 3)\n    -x**3 - x + 1\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "monic",
    "full_id": "sympy.polys.polytools.monic",
    "type": "function",
    "description": "\n    Divide all coefficients of ``f`` by ``LC(f)``.\n\n    Examples\n    ========\n\n    >>> from sympy import monic\n    >>> from sympy.abc import x\n\n    >>> monic(3*x**2 + 4*x + 2)\n    x**2 + 4*x/3 + 2/3\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "content",
    "full_id": "sympy.polys.polytools.content",
    "type": "function",
    "description": "\n    Compute GCD of coefficients of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import content\n    >>> from sympy.abc import x\n\n    >>> content(6*x**2 + 8*x + 12)\n    2\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "primitive",
    "full_id": "sympy.polys.polytools.primitive",
    "type": "function",
    "description": "\n    Compute content and the primitive form of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polytools import primitive\n    >>> from sympy.abc import x\n\n    >>> primitive(6*x**2 + 8*x + 12)\n    (2, 3*x**2 + 4*x + 6)\n\n    >>> eq = (2 + 2*x)*x + 2\n\n    Expansion is performed by default:\n\n    >>> primitive(eq)\n    (2, x**2 + x + 1)\n\n    Set ``expand`` to False to shut this off. Note that the\n    extraction will not be recursive; use the as_content_primitive method\n    for recursive, non-destructive Rational extraction.\n\n    >>> primitive(eq, expand=False)\n    (1, x*(2*x + 2) + 2)\n\n    >>> eq.as_content_primitive()\n    (2, x*(x + 1) + 1)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "compose",
    "full_id": "sympy.polys.polytools.compose",
    "type": "function",
    "description": "\n    Compute functional composition ``f(g)``.\n\n    Examples\n    ========\n\n    >>> from sympy import compose\n    >>> from sympy.abc import x\n\n    >>> compose(x**2 + x, x - 1)\n    x**2 - x\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "decompose",
    "full_id": "sympy.polys.polytools.decompose",
    "type": "function",
    "description": "\n    Compute functional decomposition of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import decompose\n    >>> from sympy.abc import x\n\n    >>> decompose(x**4 + 2*x**3 - x - 1)\n    [x**2 - x - 1, x**2 + x]\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sturm",
    "full_id": "sympy.polys.polytools.sturm",
    "type": "function",
    "description": "\n    Compute Sturm sequence of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import sturm\n    >>> from sympy.abc import x\n\n    >>> sturm(x**3 - 2*x**2 + x - 3)\n    [x**3 - 2*x**2 + x - 3, 3*x**2 - 4*x + 1, 2*x/9 + 25/9, -2079/4]\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gff_list",
    "full_id": "sympy.polys.polytools.gff_list",
    "type": "function",
    "description": "\n    Compute a list of greatest factorial factors of ``f``.\n\n    Note that the input to ff() and rf() should be Poly instances to use the\n    definitions here.\n\n    Examples\n    ========\n\n    >>> from sympy import gff_list, ff, Poly\n    >>> from sympy.abc import x\n\n    >>> f = Poly(x**5 + 2*x**4 - x**3 - 2*x**2, x)\n\n    >>> gff_list(f)\n    [(Poly(x, x, domain='ZZ'), 1), (Poly(x + 2, x, domain='ZZ'), 4)]\n\n    >>> (ff(Poly(x), 1)*ff(Poly(x + 2), 4)) == f\n    True\n\n    >>> f = Poly(x**12 + 6*x**11 - 11*x**10 - 56*x**9 + 220*x**8 + 208*x**7 -         1401*x**6 + 1090*x**5 + 2715*x**4 - 6720*x**3 - 1092*x**2 + 5040*x, x)\n\n    >>> gff_list(f)\n    [(Poly(x**3 + 7, x, domain='ZZ'), 2), (Poly(x**2 + 5*x, x, domain='ZZ'), 3)]\n\n    >>> ff(Poly(x**3 + 7, x), 2)*ff(Poly(x**2 + 5*x, x), 3) == f\n    True\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gff",
    "full_id": "sympy.polys.polytools.gff",
    "type": "function",
    "description": "Compute greatest factorial factorization of ``f``.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sqf_norm",
    "full_id": "sympy.polys.polytools.sqf_norm",
    "type": "function",
    "description": "\n    Compute square-free norm of ``f``.\n\n    Returns ``s``, ``f``, ``r``, such that ``g(x) = f(x-sa)`` and\n    ``r(x) = Norm(g(x))`` is a square-free polynomial over ``K``,\n    where ``a`` is the algebraic extension of the ground domain.\n\n    Examples\n    ========\n\n    >>> from sympy import sqf_norm, sqrt\n    >>> from sympy.abc import x\n\n    >>> sqf_norm(x**2 + 1, extension=[sqrt(3)])\n    ([1], x**2 - 2*sqrt(3)*x + 4, x**4 - 4*x**2 + 16)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sqf_part",
    "full_id": "sympy.polys.polytools.sqf_part",
    "type": "function",
    "description": "\n    Compute square-free part of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import sqf_part\n    >>> from sympy.abc import x\n\n    >>> sqf_part(x**3 - 3*x - 2)\n    x**2 - x - 2\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sqf_list",
    "full_id": "sympy.polys.polytools.sqf_list",
    "type": "function",
    "description": "\n    Compute a list of square-free factors of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import sqf_list\n    >>> from sympy.abc import x\n\n    >>> sqf_list(2*x**5 + 16*x**4 + 50*x**3 + 76*x**2 + 56*x + 16)\n    (2, [(x + 1, 2), (x + 2, 3)])\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sqf",
    "full_id": "sympy.polys.polytools.sqf",
    "type": "function",
    "description": "\n    Compute square-free factorization of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import sqf\n    >>> from sympy.abc import x\n\n    >>> sqf(2*x**5 + 16*x**4 + 50*x**3 + 76*x**2 + 56*x + 16)\n    2*(x + 1)**2*(x + 2)**3\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "factor_list",
    "full_id": "sympy.polys.polytools.factor_list",
    "type": "function",
    "description": "\n    Compute a list of irreducible factors of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import factor_list\n    >>> from sympy.abc import x, y\n\n    >>> factor_list(2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y)\n    (2, [(x + y, 1), (x**2 + 1, 2)])\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "factor",
    "full_id": "sympy.polys.polytools.factor",
    "type": "function",
    "description": "\n    Compute the factorization of expression, ``f``, into irreducibles. (To\n    factor an integer into primes, use ``factorint``.)\n\n    There two modes implemented: symbolic and formal. If ``f`` is not an\n    instance of :class:`Poly` and generators are not specified, then the\n    former mode is used. Otherwise, the formal mode is used.\n\n    In symbolic mode, :func:`factor` will traverse the expression tree and\n    factor its components without any prior expansion, unless an instance\n    of :class:`~.Add` is encountered (in this case formal factorization is\n    used). This way :func:`factor` can handle large or symbolic exponents.\n\n    By default, the factorization is computed over the rationals. To factor\n    over other domain, e.g. an algebraic or finite field, use appropriate\n    options: ``extension``, ``modulus`` or ``domain``.\n\n    Examples\n    ========\n\n    >>> from sympy import factor, sqrt, exp\n    >>> from sympy.abc import x, y\n\n    >>> factor(2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y)\n    2*(x + y)*(x**2 + 1)**2\n\n    >>> factor(x**2 + 1)\n    x**2 + 1\n    >>> factor(x**2 + 1, modulus=2)\n    (x + 1)**2\n    >>> factor(x**2 + 1, gaussian=True)\n    (x - I)*(x + I)\n\n    >>> factor(x**2 - 2, extension=sqrt(2))\n    (x - sqrt(2))*(x + sqrt(2))\n\n    >>> factor((x**2 - 1)/(x**2 + 4*x + 4))\n    (x - 1)*(x + 1)/(x + 2)**2\n    >>> factor((x**2 + 4*x + 4)**10000000*(x**2 + 1))\n    (x + 2)**20000000*(x**2 + 1)\n\n    By default, factor deals with an expression as a whole:\n\n    >>> eq = 2**(x**2 + 2*x + 1)\n    >>> factor(eq)\n    2**(x**2 + 2*x + 1)\n\n    If the ``deep`` flag is True then subexpressions will\n    be factored:\n\n    >>> factor(eq, deep=True)\n    2**((x + 1)**2)\n\n    If the ``fraction`` flag is False then rational expressions\n    will not be combined. By default it is True.\n\n    >>> factor(5*x + 3*exp(2 - 7*x), deep=True)\n    (5*x*exp(7*x) + 3*exp(2))*exp(-7*x)\n    >>> factor(5*x + 3*exp(2 - 7*x), deep=True, fraction=False)\n    5*x + 3*exp(2)*exp(-7*x)\n\n    See Also\n    ========\n    sympy.ntheory.factor_.factorint\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "intervals",
    "full_id": "sympy.polys.polytools.intervals",
    "type": "function",
    "description": "\n    Compute isolating intervals for roots of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import intervals\n    >>> from sympy.abc import x\n\n    >>> intervals(x**2 - 3)\n    [((-2, -1), 1), ((1, 2), 1)]\n    >>> intervals(x**2 - 3, eps=1e-2)\n    [((-26/15, -19/11), 1), ((19/11, 26/15), 1)]\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "refine_root",
    "full_id": "sympy.polys.polytools.refine_root",
    "type": "function",
    "description": "\n    Refine an isolating interval of a root to the given precision.\n\n    Examples\n    ========\n\n    >>> from sympy import refine_root\n    >>> from sympy.abc import x\n\n    >>> refine_root(x**2 - 3, 1, 2, eps=1e-2)\n    (19/11, 26/15)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "count_roots",
    "full_id": "sympy.polys.polytools.count_roots",
    "type": "function",
    "description": "\n    Return the number of roots of ``f`` in ``[inf, sup]`` interval.\n\n    If one of ``inf`` or ``sup`` is complex, it will return the number of roots\n    in the complex rectangle with corners at ``inf`` and ``sup``.\n\n    Examples\n    ========\n\n    >>> from sympy import count_roots, I\n    >>> from sympy.abc import x\n\n    >>> count_roots(x**4 - 4, -3, 3)\n    2\n    >>> count_roots(x**4 - 4, 0, 1 + 3*I)\n    1\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "all_roots",
    "full_id": "sympy.polys.polytools.all_roots",
    "type": "function",
    "description": "\n    Returns the real and complex roots of ``f`` with multiplicities.\n\n    Explanation\n    ===========\n\n    Finds all real and complex roots of a univariate polynomial with rational\n    coefficients of any degree exactly. The roots are represented in the form\n    given by :func:`~.rootof`. This is equivalent to using :func:`~.rootof` to\n    find each of the indexed roots.\n\n    Examples\n    ========\n\n    >>> from sympy import all_roots\n    >>> from sympy.abc import x, y\n\n    >>> print(all_roots(x**3 + 1))\n    [-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2]\n\n    Simple radical formulae are used in some cases but the cubic and quartic\n    formulae are avoided. Instead most non-rational roots will be represented\n    as :class:`~.ComplexRootOf`:\n\n    >>> print(all_roots(x**3 + x + 1))\n    [CRootOf(x**3 + x + 1, 0), CRootOf(x**3 + x + 1, 1), CRootOf(x**3 + x + 1, 2)]\n\n    All roots of any polynomial with rational coefficients of any degree can be\n    represented using :py:class:`~.ComplexRootOf`. The use of\n    :py:class:`~.ComplexRootOf` bypasses limitations on the availability of\n    radical formulae for quintic and higher degree polynomials _[1]:\n\n    >>> p = x**5 - x - 1\n    >>> for r in all_roots(p): print(r)\n    CRootOf(x**5 - x - 1, 0)\n    CRootOf(x**5 - x - 1, 1)\n    CRootOf(x**5 - x - 1, 2)\n    CRootOf(x**5 - x - 1, 3)\n    CRootOf(x**5 - x - 1, 4)\n    >>> [r.evalf(3) for r in all_roots(p)]\n    [1.17, -0.765 - 0.352*I, -0.765 + 0.352*I, 0.181 - 1.08*I, 0.181 + 1.08*I]\n\n    Irrational algebraic or transcendental coefficients cannot currently be\n    handled by :func:`all_roots` (or :func:`~.rootof` more generally):\n\n    >>> from sympy import sqrt, expand\n    >>> p = expand((x - sqrt(2))*(x - sqrt(3)))\n    >>> print(p)\n    x**2 - sqrt(3)*x - sqrt(2)*x + sqrt(6)\n    >>> all_roots(p)\n    Traceback (most recent call last):\n    ...\n    NotImplementedError: sorted roots not supported over EX\n\n    In the case of algebraic or transcendental coefficients\n    :func:`~.ground_roots` might be able to find some roots by factorisation:\n\n    >>> from sympy import ground_roots\n    >>> ground_roots(p, x, extension=True)\n    {sqrt(2): 1, sqrt(3): 1}\n\n    If the coefficients are numeric then :func:`~.nroots` can be used to find\n    all roots approximately:\n\n    >>> from sympy import nroots\n    >>> nroots(p, 5)\n    [1.4142, 1.732]\n\n    If the coefficients are symbolic then :func:`sympy.polys.polyroots.roots`\n    or :func:`~.ground_roots` should be used instead:\n\n    >>> from sympy import roots, ground_roots\n    >>> p = x**2 - 3*x*y + 2*y**2\n    >>> roots(p, x)\n    {y: 1, 2*y: 1}\n    >>> ground_roots(p, x)\n    {y: 1, 2*y: 1}\n\n    Parameters\n    ==========\n\n    f : :class:`~.Expr` or :class:`~.Poly`\n        A univariate polynomial with rational (or ``Float``) coefficients.\n    multiple : ``bool`` (default ``True``).\n        Whether to return a ``list`` of roots or a list of root/multiplicity\n        pairs.\n    radicals : ``bool`` (default ``True``)\n        Use simple radical formulae rather than :py:class:`~.ComplexRootOf` for\n        some irrational roots.\n\n    Returns\n    =======\n\n    A list of :class:`~.Expr` (usually :class:`~.ComplexRootOf`) representing\n    the roots is returned with each root repeated according to its multiplicity\n    as a root of ``f``. The roots are always uniquely ordered with real roots\n    coming before complex roots. The real roots are in increasing order.\n    Complex roots are ordered by increasing real part and then increasing\n    imaginary part.\n\n    If ``multiple=False`` is passed then a list of root/multiplicity pairs is\n    returned instead.\n\n    If ``radicals=False`` is passed then all roots will be represented as\n    either rational numbers or :class:`~.ComplexRootOf`.\n\n    See also\n    ========\n\n    Poly.all_roots:\n        The underlying :class:`Poly` method used by :func:`~.all_roots`.\n    rootof:\n        Compute a single numbered root of a univariate polynomial.\n    real_roots:\n        Compute all the real roots using :func:`~.rootof`.\n    ground_roots:\n        Compute some roots in the ground domain by factorisation.\n    nroots:\n        Compute all roots using approximate numerical techniques.\n    sympy.polys.polyroots.roots:\n        Compute symbolic expressions for roots using radical formulae.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "real_roots",
    "full_id": "sympy.polys.polytools.real_roots",
    "type": "function",
    "description": "\n    Returns the real roots of ``f`` with multiplicities.\n\n    Explanation\n    ===========\n\n    Finds all real roots of a univariate polynomial with rational coefficients\n    of any degree exactly. The roots are represented in the form given by\n    :func:`~.rootof`. This is equivalent to using :func:`~.rootof` or\n    :func:`~.all_roots` and filtering out only the real roots. However if only\n    the real roots are needed then :func:`real_roots` is more efficient than\n    :func:`~.all_roots` because it computes only the real roots and avoids\n    costly complex root isolation routines.\n\n    Examples\n    ========\n\n    >>> from sympy import real_roots\n    >>> from sympy.abc import x, y\n\n    >>> real_roots(2*x**3 - 7*x**2 + 4*x + 4)\n    [-1/2, 2, 2]\n    >>> real_roots(2*x**3 - 7*x**2 + 4*x + 4, multiple=False)\n    [(-1/2, 1), (2, 2)]\n\n    Real roots of any polynomial with rational coefficients of any degree can\n    be represented using :py:class:`~.ComplexRootOf`:\n\n    >>> p = x**9 + 2*x + 2\n    >>> print(real_roots(p))\n    [CRootOf(x**9 + 2*x + 2, 0)]\n    >>> [r.evalf(3) for r in real_roots(p)]\n    [-0.865]\n\n    All rational roots will be returned as rational numbers. Roots of some\n    simple factors will be expressed using radical or other formulae (unless\n    ``radicals=False`` is passed). All other roots will be expressed as\n    :class:`~.ComplexRootOf`.\n\n    >>> p = (x + 7)*(x**2 - 2)*(x**3 + x + 1)\n    >>> print(real_roots(p))\n    [-7, -sqrt(2), CRootOf(x**3 + x + 1, 0), sqrt(2)]\n    >>> print(real_roots(p, radicals=False))\n    [-7, CRootOf(x**2 - 2, 0), CRootOf(x**3 + x + 1, 0), CRootOf(x**2 - 2, 1)]\n\n    All returned root expressions will numerically evaluate to real numbers\n    with no imaginary part. This is in contrast to the expressions generated by\n    the cubic or quartic formulae as used by :func:`~.roots` which suffer from\n    casus irreducibilis [1]_:\n\n    >>> from sympy import roots\n    >>> p = 2*x**3 - 9*x**2 - 6*x + 3\n    >>> [r.evalf(5) for r in roots(p, multiple=True)]\n    [5.0365 - 0.e-11*I, 0.33984 + 0.e-13*I, -0.87636 + 0.e-10*I]\n    >>> [r.evalf(5) for r in real_roots(p, x)]\n    [-0.87636, 0.33984, 5.0365]\n    >>> [r.is_real for r in roots(p, multiple=True)]\n    [None, None, None]\n    >>> [r.is_real for r in real_roots(p)]\n    [True, True, True]\n\n    Using :func:`real_roots` is equivalent to using :func:`~.all_roots` (or\n    :func:`~.rootof`) and filtering out only the real roots:\n\n    >>> from sympy import all_roots\n    >>> r = [r for r in all_roots(p) if r.is_real]\n    >>> real_roots(p) == r\n    True\n\n    If only the real roots are wanted then using :func:`real_roots` is faster\n    than using :func:`~.all_roots`. Using :func:`real_roots` avoids complex root\n    isolation which can be a lot slower than real root isolation especially for\n    polynomials of high degree which typically have many more complex roots\n    than real roots.\n\n    Irrational algebraic or transcendental coefficients cannot be handled by\n    :func:`real_roots` (or :func:`~.rootof` more generally):\n\n    >>> from sympy import sqrt, expand\n    >>> p = expand((x - sqrt(2))*(x - sqrt(3)))\n    >>> print(p)\n    x**2 - sqrt(3)*x - sqrt(2)*x + sqrt(6)\n    >>> real_roots(p)\n    Traceback (most recent call last):\n    ...\n    NotImplementedError: sorted roots not supported over EX\n\n    In the case of algebraic or transcendental coefficients\n    :func:`~.ground_roots` might be able to find some roots by factorisation:\n\n    >>> from sympy import ground_roots\n    >>> ground_roots(p, x, extension=True)\n    {sqrt(2): 1, sqrt(3): 1}\n\n    If the coefficients are numeric then :func:`~.nroots` can be used to find\n    all roots approximately:\n\n    >>> from sympy import nroots\n    >>> nroots(p, 5)\n    [1.4142, 1.732]\n\n    If the coefficients are symbolic then :func:`sympy.polys.polyroots.roots`\n    or :func:`~.ground_roots` should be used instead.\n\n    >>> from sympy import roots, ground_roots\n    >>> p = x**2 - 3*x*y + 2*y**2\n    >>> roots(p, x)\n    {y: 1, 2*y: 1}\n    >>> ground_roots(p, x)\n    {y: 1, 2*y: 1}\n\n    Parameters\n    ==========\n\n    f : :class:`~.Expr` or :class:`~.Poly`\n        A univariate polynomial with rational (or ``Float``) coefficients.\n    multiple : ``bool`` (default ``True``).\n        Whether to return a ``list`` of roots or a list of root/multiplicity\n        pairs.\n    radicals : ``bool`` (default ``True``)\n        Use simple radical formulae rather than :py:class:`~.ComplexRootOf` for\n        some irrational roots.\n\n    Returns\n    =======\n\n    A list of :class:`~.Expr` (usually :class:`~.ComplexRootOf`) representing\n    the real roots is returned. The roots are arranged in increasing order and\n    are repeated according to their multiplicities as roots of ``f``.\n\n    If ``multiple=False`` is passed then a list of root/multiplicity pairs is\n    returned instead.\n\n    If ``radicals=False`` is passed then all roots will be represented as\n    either rational numbers or :class:`~.ComplexRootOf`.\n\n    See also\n    ========\n\n    Poly.real_roots:\n        The underlying :class:`Poly` method used by :func:`real_roots`.\n    rootof:\n        Compute a single numbered root of a univariate polynomial.\n    all_roots:\n        Compute all real and non-real roots using :func:`~.rootof`.\n    ground_roots:\n        Compute some roots in the ground domain by factorisation.\n    nroots:\n        Compute all roots using approximate numerical techniques.\n    sympy.polys.polyroots.roots:\n        Compute symbolic expressions for roots using radical formulae.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Casus_irreducibilis\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "nroots",
    "full_id": "sympy.polys.polytools.nroots",
    "type": "function",
    "description": "\n    Compute numerical approximations of roots of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import nroots\n    >>> from sympy.abc import x\n\n    >>> nroots(x**2 - 3, n=15)\n    [-1.73205080756888, 1.73205080756888]\n    >>> nroots(x**2 - 3, n=30)\n    [-1.73205080756887729352744634151, 1.73205080756887729352744634151]\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "ground_roots",
    "full_id": "sympy.polys.polytools.ground_roots",
    "type": "function",
    "description": "\n    Compute roots of ``f`` by factorization in the ground domain.\n\n    Examples\n    ========\n\n    >>> from sympy import ground_roots\n    >>> from sympy.abc import x\n\n    >>> ground_roots(x**6 - 4*x**4 + 4*x**3 - x**2)\n    {0: 2, 1: 2}\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "nth_power_roots_poly",
    "full_id": "sympy.polys.polytools.nth_power_roots_poly",
    "type": "function",
    "description": "\n    Construct a polynomial with n-th powers of roots of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import nth_power_roots_poly, factor, roots\n    >>> from sympy.abc import x\n\n    >>> f = x**4 - x**2 + 1\n    >>> g = factor(nth_power_roots_poly(f, 2))\n\n    >>> g\n    (x**2 - x + 1)**2\n\n    >>> R_f = [ (r**2).expand() for r in roots(f) ]\n    >>> R_g = roots(g).keys()\n\n    >>> set(R_f) == set(R_g)\n    True\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "cancel",
    "full_id": "sympy.polys.polytools.cancel",
    "type": "function",
    "description": "\n    Cancel common factors in a rational function ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy import cancel, sqrt, Symbol, together\n    >>> from sympy.abc import x\n    >>> A = Symbol('A', commutative=False)\n\n    >>> cancel((2*x**2 - 2)/(x**2 - 2*x + 1))\n    (2*x + 2)/(x - 1)\n    >>> cancel((sqrt(3) + sqrt(15)*A)/(sqrt(2) + sqrt(10)*A))\n    sqrt(6)/2\n\n    Note: due to automatic distribution of Rationals, a sum divided by an integer\n    will appear as a sum. To recover a rational form use `together` on the result:\n\n    >>> cancel(x/2 + 1)\n    x/2 + 1\n    >>> together(_)\n    (x + 2)/2\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "reduced",
    "full_id": "sympy.polys.polytools.reduced",
    "type": "function",
    "description": "\n    Reduces a polynomial ``f`` modulo a set of polynomials ``G``.\n\n    Given a polynomial ``f`` and a set of polynomials ``G = (g_1, ..., g_n)``,\n    computes a set of quotients ``q = (q_1, ..., q_n)`` and the remainder ``r``\n    such that ``f = q_1*g_1 + ... + q_n*g_n + r``, where ``r`` vanishes or ``r``\n    is a completely reduced polynomial with respect to ``G``.\n\n    Examples\n    ========\n\n    >>> from sympy import reduced\n    >>> from sympy.abc import x, y\n\n    >>> reduced(2*x**4 + y**2 - x**2 + y**3, [x**3 - x, y**3 - y])\n    ([2*x, 1], x**2 + y**2 + y)\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "groebner",
    "full_id": "sympy.polys.polytools.groebner",
    "type": "function",
    "description": "\n    Computes the reduced Groebner basis for a set of polynomials.\n\n    Use the ``order`` argument to set the monomial ordering that will be\n    used to compute the basis. Allowed orders are ``lex``, ``grlex`` and\n    ``grevlex``. If no order is specified, it defaults to ``lex``.\n\n    For more information on Groebner bases, see the references and the docstring\n    of :func:`~.solve_poly_system`.\n\n    Examples\n    ========\n\n    Example taken from [1].\n\n    >>> from sympy import groebner\n    >>> from sympy.abc import x, y\n\n    >>> F = [x*y - 2*y, 2*y**2 - x**2]\n\n    >>> groebner(F, x, y, order='lex')\n    GroebnerBasis([x**2 - 2*y**2, x*y - 2*y, y**3 - 2*y], x, y,\n                  domain='ZZ', order='lex')\n    >>> groebner(F, x, y, order='grlex')\n    GroebnerBasis([y**3 - 2*y, x**2 - 2*y**2, x*y - 2*y], x, y,\n                  domain='ZZ', order='grlex')\n    >>> groebner(F, x, y, order='grevlex')\n    GroebnerBasis([y**3 - 2*y, x**2 - 2*y**2, x*y - 2*y], x, y,\n                  domain='ZZ', order='grevlex')\n\n    By default, an improved implementation of the Buchberger algorithm is\n    used. Optionally, an implementation of the F5B algorithm can be used. The\n    algorithm can be set using the ``method`` flag or with the\n    :func:`sympy.polys.polyconfig.setup` function.\n\n    >>> F = [x**2 - x - 1, (2*x - 1) * y - (x**10 - (1 - x)**10)]\n\n    >>> groebner(F, x, y, method='buchberger')\n    GroebnerBasis([x**2 - x - 1, y - 55], x, y, domain='ZZ', order='lex')\n    >>> groebner(F, x, y, method='f5b')\n    GroebnerBasis([x**2 - x - 1, y - 55], x, y, domain='ZZ', order='lex')\n\n    References\n    ==========\n\n    1. [Buchberger01]_\n    2. [Cox97]_\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_zero_dimensional",
    "full_id": "sympy.polys.polytools.is_zero_dimensional",
    "type": "function",
    "description": "\n    Checks if the ideal generated by a Groebner basis is zero-dimensional.\n\n    The algorithm checks if the set of monomials not divisible by the\n    leading monomial of any element of ``F`` is bounded.\n\n    References\n    ==========\n\n    David A. Cox, John B. Little, Donal O'Shea. Ideals, Varieties and\n    Algorithms, 3rd edition, p. 230\n\n    ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "EC",
    "full_id": "sympy.polys.polytools.Poly.EC",
    "type": "method",
    "description": "\n        Returns the last non-zero coefficient of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**3 + 2*x**2 + 3*x, x).EC()\n        3\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "EM",
    "full_id": "sympy.polys.polytools.Poly.EM",
    "type": "method",
    "description": "\n        Returns the last non-zero monomial of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(4*x**2 + 2*x*y**2 + x*y + 3*y, x, y).EM()\n        x**0*y**1\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "ET",
    "full_id": "sympy.polys.polytools.Poly.ET",
    "type": "method",
    "description": "\n        Returns the last non-zero term of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(4*x**2 + 2*x*y**2 + x*y + 3*y, x, y).ET()\n        (x**0*y**1, 3)\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "LC",
    "full_id": "sympy.polys.polytools.Poly.LC",
    "type": "method",
    "description": "\n        Returns the leading coefficient of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(4*x**3 + 2*x**2 + 3*x, x).LC()\n        4\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "LM",
    "full_id": "sympy.polys.polytools.Poly.LM",
    "type": "method",
    "description": "\n        Returns the leading monomial of ``f``.\n\n        The Leading monomial signifies the monomial having\n        the highest power of the principal generator in the\n        expression f.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(4*x**2 + 2*x*y**2 + x*y + 3*y, x, y).LM()\n        x**2*y**0\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "LT",
    "full_id": "sympy.polys.polytools.Poly.LT",
    "type": "method",
    "description": "\n        Returns the leading term of ``f``.\n\n        The Leading term signifies the term having\n        the highest power of the principal generator in the\n        expression f along with its coefficient.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(4*x**2 + 2*x*y**2 + x*y + 3*y, x, y).LT()\n        (x**2*y**0, 4)\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "TC",
    "full_id": "sympy.polys.polytools.Poly.TC",
    "type": "method",
    "description": "\n        Returns the trailing coefficient of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**3 + 2*x**2 + 3*x, x).TC()\n        0\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "abs",
    "full_id": "sympy.polys.polytools.Poly.abs",
    "type": "method",
    "description": "\n        Make all coefficients in ``f`` positive.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 1, x).abs()\n        Poly(x**2 + 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.polytools.Poly.add",
    "type": "method",
    "description": "\n        Add two polynomials ``f`` and ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).add(Poly(x - 2, x))\n        Poly(x**2 + x - 1, x, domain='ZZ')\n\n        >>> Poly(x**2 + 1, x) + Poly(x - 2, x)\n        Poly(x**2 + x - 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "add_ground",
    "full_id": "sympy.polys.polytools.Poly.add_ground",
    "type": "method",
    "description": "\n        Add an element of the ground domain to ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x + 1).add_ground(2)\n        Poly(x + 3, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "all_coeffs",
    "full_id": "sympy.polys.polytools.Poly.all_coeffs",
    "type": "method",
    "description": "\n        Returns all coefficients from a univariate polynomial ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**3 + 2*x - 1, x).all_coeffs()\n        [1, 0, 2, -1]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "all_monoms",
    "full_id": "sympy.polys.polytools.Poly.all_monoms",
    "type": "method",
    "description": "\n        Returns all monomials from a univariate polynomial ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**3 + 2*x - 1, x).all_monoms()\n        [(3,), (2,), (1,), (0,)]\n\n        See Also\n        ========\n        all_terms\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "all_roots",
    "full_id": "sympy.polys.polytools.Poly.all_roots",
    "type": "method",
    "description": "\n        Return a list of real and complex roots with multiplicities.\n\n        See :func:`all_roots` for more explanation.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(2*x**3 - 7*x**2 + 4*x + 4).all_roots()\n        [-1/2, 2, 2]\n        >>> Poly(x**3 + x + 1).all_roots()\n        [CRootOf(x**3 + x + 1, 0),\n         CRootOf(x**3 + x + 1, 1),\n         CRootOf(x**3 + x + 1, 2)]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "all_terms",
    "full_id": "sympy.polys.polytools.Poly.all_terms",
    "type": "method",
    "description": "\n        Returns all terms from a univariate polynomial ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**3 + 2*x - 1, x).all_terms()\n        [((3,), 1), ((2,), 0), ((1,), 2), ((0,), -1)]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "as_dict",
    "full_id": "sympy.polys.polytools.Poly.as_dict",
    "type": "method",
    "description": "\n        Switch to a ``dict`` representation.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + 2*x*y**2 - y, x, y).as_dict()\n        {(0, 1): -1, (1, 2): 2, (2, 0): 1}\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "as_expr",
    "full_id": "sympy.polys.polytools.Poly.as_expr",
    "type": "method",
    "description": "\n        Convert a Poly instance to an Expr instance.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> f = Poly(x**2 + 2*x*y**2 - y, x, y)\n\n        >>> f.as_expr()\n        x**2 + 2*x*y**2 - y\n        >>> f.as_expr({x: 5})\n        10*y**2 - y + 25\n        >>> f.as_expr(5, 6)\n        379\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "as_list",
    "full_id": "sympy.polys.polytools.Poly.as_list",
    "type": "method",
    "description": "Switch to a ``list`` representation.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "as_poly",
    "full_id": "sympy.polys.polytools.Poly.as_poly",
    "type": "method",
    "description": "Converts ``self`` to a polynomial or returns ``None``.\n\n        >>> from sympy import sin\n        >>> from sympy.abc import x, y\n\n        >>> print((x**2 + x*y).as_poly())\n        Poly(x**2 + x*y, x, y, domain='ZZ')\n\n        >>> print((x**2 + x*y).as_poly(x, y))\n        Poly(x**2 + x*y, x, y, domain='ZZ')\n\n        >>> print((x**2 + sin(y)).as_poly(x, y))\n        None\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "cancel",
    "full_id": "sympy.polys.polytools.Poly.cancel",
    "type": "method",
    "description": "\n        Cancel common factors in a rational function ``f/g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(2*x**2 - 2, x).cancel(Poly(x**2 - 2*x + 1, x))\n        (1, Poly(2*x + 2, x, domain='ZZ'), Poly(x - 1, x, domain='ZZ'))\n\n        >>> Poly(2*x**2 - 2, x).cancel(Poly(x**2 - 2*x + 1, x), include=True)\n        (Poly(2*x + 2, x, domain='ZZ'), Poly(x - 1, x, domain='ZZ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "clear_denoms",
    "full_id": "sympy.polys.polytools.Poly.clear_denoms",
    "type": "method",
    "description": "\n        Clear denominators, but keep the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, S, QQ\n        >>> from sympy.abc import x\n\n        >>> f = Poly(x/2 + S(1)/3, x, domain=QQ)\n\n        >>> f.clear_denoms()\n        (6, Poly(3*x + 2, x, domain='QQ'))\n        >>> f.clear_denoms(convert=True)\n        (6, Poly(3*x + 2, x, domain='ZZ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "coeff_monomial",
    "full_id": "sympy.polys.polytools.Poly.coeff_monomial",
    "type": "method",
    "description": "\n        Returns the coefficient of ``monom`` in ``f`` if there, else None.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, exp\n        >>> from sympy.abc import x, y\n\n        >>> p = Poly(24*x*y*exp(8) + 23*x, x, y)\n\n        >>> p.coeff_monomial(x)\n        23\n        >>> p.coeff_monomial(y)\n        0\n        >>> p.coeff_monomial(x*y)\n        24*exp(8)\n\n        Note that ``Expr.coeff()`` behaves differently, collecting terms\n        if possible; the Poly must be converted to an Expr to use that\n        method, however:\n\n        >>> p.as_expr().coeff(x)\n        24*y*exp(8) + 23\n        >>> p.as_expr().coeff(y)\n        24*x*exp(8)\n        >>> p.as_expr().coeff(x*y)\n        24*exp(8)\n\n        See Also\n        ========\n        nth: more efficient query using exponents of the monomial's generators\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "coeffs",
    "full_id": "sympy.polys.polytools.Poly.coeffs",
    "type": "method",
    "description": "\n        Returns all non-zero coefficients from ``f`` in lex order.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**3 + 2*x + 3, x).coeffs()\n        [1, 2, 3]\n\n        See Also\n        ========\n        all_coeffs\n        coeff_monomial\n        nth\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "cofactors",
    "full_id": "sympy.polys.polytools.Poly.cofactors",
    "type": "method",
    "description": "\n        Returns the GCD of ``f`` and ``g`` and their cofactors.\n\n        Returns polynomials ``(h, cff, cfg)`` such that ``h = gcd(f, g)``, and\n        ``cff = quo(f, h)`` and ``cfg = quo(g, h)`` are, so called, cofactors\n        of ``f`` and ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 1, x).cofactors(Poly(x**2 - 3*x + 2, x))\n        (Poly(x - 1, x, domain='ZZ'),\n         Poly(x + 1, x, domain='ZZ'),\n         Poly(x - 2, x, domain='ZZ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "compose",
    "full_id": "sympy.polys.polytools.Poly.compose",
    "type": "method",
    "description": "\n        Computes the functional composition of ``f`` and ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + x, x).compose(Poly(x - 1, x))\n        Poly(x**2 - x, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "content",
    "full_id": "sympy.polys.polytools.Poly.content",
    "type": "method",
    "description": "\n        Returns the GCD of polynomial coefficients.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(6*x**2 + 8*x + 12, x).content()\n        2\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "count_roots",
    "full_id": "sympy.polys.polytools.Poly.count_roots",
    "type": "method",
    "description": "\n        Return the number of roots of ``f`` in ``[inf, sup]`` interval.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, I\n        >>> from sympy.abc import x\n\n        >>> Poly(x**4 - 4, x).count_roots(-3, 3)\n        2\n        >>> Poly(x**4 - 4, x).count_roots(0, 1 + 3*I)\n        1\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "decompose",
    "full_id": "sympy.polys.polytools.Poly.decompose",
    "type": "method",
    "description": "\n        Computes a functional decomposition of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**4 + 2*x**3 - x - 1, x, domain='ZZ').decompose()\n        [Poly(x**2 - x - 1, x, domain='ZZ'), Poly(x**2 + x, x, domain='ZZ')]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "deflate",
    "full_id": "sympy.polys.polytools.Poly.deflate",
    "type": "method",
    "description": "\n        Reduce degree of ``f`` by mapping ``x_i**m`` to ``y_i``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**6*y**2 + x**3 + 1, x, y).deflate()\n        ((3, 2), Poly(x**2*y + x + 1, x, y, domain='ZZ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "degree",
    "full_id": "sympy.polys.polytools.Poly.degree",
    "type": "method",
    "description": "\n        Returns degree of ``f`` in ``x_j``.\n\n        The degree of 0 is negative infinity.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + y*x + 1, x, y).degree()\n        2\n        >>> Poly(x**2 + y*x + y, x, y).degree(y)\n        1\n        >>> Poly(0, x).degree()\n        -oo\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "degree_list",
    "full_id": "sympy.polys.polytools.Poly.degree_list",
    "type": "method",
    "description": "\n        Returns a list of degrees of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + y*x + 1, x, y).degree_list()\n        (2, 1)\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "diff",
    "full_id": "sympy.polys.polytools.Poly.diff",
    "type": "method",
    "description": "\n        Computes partial derivative of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + 2*x + 1, x).diff()\n        Poly(2*x + 2, x, domain='ZZ')\n\n        >>> Poly(x*y**2 + x, x, y).diff((0, 0), (1, 1))\n        Poly(2*x*y, x, y, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "discriminant",
    "full_id": "sympy.polys.polytools.Poly.discriminant",
    "type": "method",
    "description": "\n        Computes the discriminant of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 2*x + 3, x).discriminant()\n        -8\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "dispersion",
    "full_id": "sympy.polys.polytools.Poly.dispersion",
    "type": "method",
    "description": "Compute the *dispersion* of polynomials.\n\n        For two polynomials `f(x)` and `g(x)` with `\\deg f > 0`\n        and `\\deg g > 0` the dispersion `\\operatorname{dis}(f, g)` is defined as:\n\n        .. math::\n            \\operatorname{dis}(f, g)\n            & := \\max\\{ J(f,g) \\cup \\{0\\} \\} \\\\\n            &  = \\max\\{ \\{a \\in \\mathbb{N} | \\gcd(f(x), g(x+a)) \\neq 1\\} \\cup \\{0\\} \\}\n\n        and for a single polynomial `\\operatorname{dis}(f) := \\operatorname{dis}(f, f)`.\n\n        Examples\n        ========\n\n        >>> from sympy import poly\n        >>> from sympy.polys.dispersion import dispersion, dispersionset\n        >>> from sympy.abc import x\n\n        Dispersion set and dispersion of a simple polynomial:\n\n        >>> fp = poly((x - 3)*(x + 3), x)\n        >>> sorted(dispersionset(fp))\n        [0, 6]\n        >>> dispersion(fp)\n        6\n\n        Note that the definition of the dispersion is not symmetric:\n\n        >>> fp = poly(x**4 - 3*x**2 + 1, x)\n        >>> gp = fp.shift(-3)\n        >>> sorted(dispersionset(fp, gp))\n        [2, 3, 4]\n        >>> dispersion(fp, gp)\n        4\n        >>> sorted(dispersionset(gp, fp))\n        []\n        >>> dispersion(gp, fp)\n        -oo\n\n        Computing the dispersion also works over field extensions:\n\n        >>> from sympy import sqrt\n        >>> fp = poly(x**2 + sqrt(5)*x - 1, x, domain='QQ<sqrt(5)>')\n        >>> gp = poly(x**2 + (2 + sqrt(5))*x + sqrt(5), x, domain='QQ<sqrt(5)>')\n        >>> sorted(dispersionset(fp, gp))\n        [2]\n        >>> sorted(dispersionset(gp, fp))\n        [1, 4]\n\n        We can even perform the computations for polynomials\n        having symbolic coefficients:\n\n        >>> from sympy.abc import a\n        >>> fp = poly(4*x**4 + (4*a + 8)*x**3 + (a**2 + 6*a + 4)*x**2 + (a**2 + 2*a)*x, x)\n        >>> sorted(dispersionset(fp))\n        [0, 1]\n\n        See Also\n        ========\n\n        dispersionset\n\n        References\n        ==========\n\n        1. [ManWright94]_\n        2. [Koepf98]_\n        3. [Abramov71]_\n        4. [Man93]_\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "dispersionset",
    "full_id": "sympy.polys.polytools.Poly.dispersionset",
    "type": "method",
    "description": "Compute the *dispersion set* of two polynomials.\n\n        For two polynomials `f(x)` and `g(x)` with `\\deg f > 0`\n        and `\\deg g > 0` the dispersion set `\\operatorname{J}(f, g)` is defined as:\n\n        .. math::\n            \\operatorname{J}(f, g)\n            & := \\{a \\in \\mathbb{N}_0 | \\gcd(f(x), g(x+a)) \\neq 1\\} \\\\\n            &  = \\{a \\in \\mathbb{N}_0 | \\deg \\gcd(f(x), g(x+a)) \\geq 1\\}\n\n        For a single polynomial one defines `\\operatorname{J}(f) := \\operatorname{J}(f, f)`.\n\n        Examples\n        ========\n\n        >>> from sympy import poly\n        >>> from sympy.polys.dispersion import dispersion, dispersionset\n        >>> from sympy.abc import x\n\n        Dispersion set and dispersion of a simple polynomial:\n\n        >>> fp = poly((x - 3)*(x + 3), x)\n        >>> sorted(dispersionset(fp))\n        [0, 6]\n        >>> dispersion(fp)\n        6\n\n        Note that the definition of the dispersion is not symmetric:\n\n        >>> fp = poly(x**4 - 3*x**2 + 1, x)\n        >>> gp = fp.shift(-3)\n        >>> sorted(dispersionset(fp, gp))\n        [2, 3, 4]\n        >>> dispersion(fp, gp)\n        4\n        >>> sorted(dispersionset(gp, fp))\n        []\n        >>> dispersion(gp, fp)\n        -oo\n\n        Computing the dispersion also works over field extensions:\n\n        >>> from sympy import sqrt\n        >>> fp = poly(x**2 + sqrt(5)*x - 1, x, domain='QQ<sqrt(5)>')\n        >>> gp = poly(x**2 + (2 + sqrt(5))*x + sqrt(5), x, domain='QQ<sqrt(5)>')\n        >>> sorted(dispersionset(fp, gp))\n        [2]\n        >>> sorted(dispersionset(gp, fp))\n        [1, 4]\n\n        We can even perform the computations for polynomials\n        having symbolic coefficients:\n\n        >>> from sympy.abc import a\n        >>> fp = poly(4*x**4 + (4*a + 8)*x**3 + (a**2 + 6*a + 4)*x**2 + (a**2 + 2*a)*x, x)\n        >>> sorted(dispersionset(fp))\n        [0, 1]\n\n        See Also\n        ========\n\n        dispersion\n\n        References\n        ==========\n\n        1. [ManWright94]_\n        2. [Koepf98]_\n        3. [Abramov71]_\n        4. [Man93]_\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "div",
    "full_id": "sympy.polys.polytools.Poly.div",
    "type": "method",
    "description": "\n        Polynomial division with remainder of ``f`` by ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).div(Poly(2*x - 4, x))\n        (Poly(1/2*x + 1, x, domain='QQ'), Poly(5, x, domain='QQ'))\n\n        >>> Poly(x**2 + 1, x).div(Poly(2*x - 4, x), auto=False)\n        (Poly(0, x, domain='ZZ'), Poly(x**2 + 1, x, domain='ZZ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "domain",
    "full_id": "sympy.polys.polytools.Poly.domain",
    "type": "property",
    "description": "Get the ground domain of a :py:class:`~.Poly`\n\n        Returns\n        =======\n\n        :py:class:`~.Domain`:\n            Ground domain of the :py:class:`~.Poly`.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, Symbol\n        >>> x = Symbol('x')\n        >>> p = Poly(x**2 + x)\n        >>> p\n        Poly(x**2 + x, x, domain='ZZ')\n        >>> p.domain\n        ZZ\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "eject",
    "full_id": "sympy.polys.polytools.Poly.eject",
    "type": "method",
    "description": "\n        Eject selected generators into the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> f = Poly(x**2*y + x*y**3 + x*y + 1, x, y)\n\n        >>> f.eject(x)\n        Poly(x*y**3 + (x**2 + x)*y + 1, y, domain='ZZ[x]')\n        >>> f.eject(y)\n        Poly(y*x**2 + (y**3 + y)*x + 1, x, domain='ZZ[y]')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.polys.polytools.Poly.eval",
    "type": "method",
    "description": "\n        Evaluate ``f`` at ``a`` in the given variable.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y, z\n\n        >>> Poly(x**2 + 2*x + 3, x).eval(2)\n        11\n\n        >>> Poly(2*x*y + 3*x + y + 2, x, y).eval(x, 2)\n        Poly(5*y + 8, y, domain='ZZ')\n\n        >>> f = Poly(2*x*y + 3*x + y + 2*z, x, y, z)\n\n        >>> f.eval({x: 2})\n        Poly(5*y + 2*z + 6, y, z, domain='ZZ')\n        >>> f.eval({x: 2, y: 5})\n        Poly(2*z + 31, z, domain='ZZ')\n        >>> f.eval({x: 2, y: 5, z: 7})\n        45\n\n        >>> f.eval((2, 5))\n        Poly(2*z + 31, z, domain='ZZ')\n        >>> f(2, 5)\n        Poly(2*z + 31, z, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "exclude",
    "full_id": "sympy.polys.polytools.Poly.exclude",
    "type": "method",
    "description": "\n        Remove unnecessary generators from ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import a, b, c, d, x\n\n        >>> Poly(a + x, a, b, c, d, x).exclude()\n        Poly(a + x, a, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "exquo",
    "full_id": "sympy.polys.polytools.Poly.exquo",
    "type": "method",
    "description": "\n        Computes polynomial exact quotient of ``f`` by ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 1, x).exquo(Poly(x - 1, x))\n        Poly(x + 1, x, domain='ZZ')\n\n        >>> Poly(x**2 + 1, x).exquo(Poly(2*x - 4, x))\n        Traceback (most recent call last):\n        ...\n        ExactQuotientFailed: 2*x - 4 does not divide x**2 + 1\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "exquo_ground",
    "full_id": "sympy.polys.polytools.Poly.exquo_ground",
    "type": "method",
    "description": "\n        Exact quotient of ``f`` by a an element of the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(2*x + 4).exquo_ground(2)\n        Poly(x + 2, x, domain='ZZ')\n\n        >>> Poly(2*x + 3).exquo_ground(2)\n        Traceback (most recent call last):\n        ...\n        ExactQuotientFailed: 2 does not divide 3 in ZZ\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "factor_list",
    "full_id": "sympy.polys.polytools.Poly.factor_list",
    "type": "method",
    "description": "\n        Returns a list of irreducible factors of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> f = 2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y\n\n        >>> Poly(f).factor_list()\n        (2, [(Poly(x + y, x, y, domain='ZZ'), 1),\n             (Poly(x**2 + 1, x, y, domain='ZZ'), 2)])\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "factor_list_include",
    "full_id": "sympy.polys.polytools.Poly.factor_list_include",
    "type": "method",
    "description": "\n        Returns a list of irreducible factors of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> f = 2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y\n\n        >>> Poly(f).factor_list_include()\n        [(Poly(2*x + 2*y, x, y, domain='ZZ'), 1),\n         (Poly(x**2 + 1, x, y, domain='ZZ'), 2)]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.polys.polytools.Poly.free_symbols",
    "type": "property",
    "description": "\n        Free symbols of a polynomial expression.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y, z\n\n        >>> Poly(x**2 + 1).free_symbols\n        {x}\n        >>> Poly(x**2 + y).free_symbols\n        {x, y}\n        >>> Poly(x**2 + y, x).free_symbols\n        {x, y}\n        >>> Poly(x**2 + y, x, z).free_symbols\n        {x, y}\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "free_symbols_in_domain",
    "full_id": "sympy.polys.polytools.Poly.free_symbols_in_domain",
    "type": "property",
    "description": "\n        Free symbols of the domain of ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + 1).free_symbols_in_domain\n        set()\n        >>> Poly(x**2 + y).free_symbols_in_domain\n        set()\n        >>> Poly(x**2 + y, x).free_symbols_in_domain\n        {y}\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "from_dict",
    "full_id": "sympy.polys.polytools.Poly.from_dict",
    "type": "method",
    "description": "Construct a polynomial from a ``dict``.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "from_list",
    "full_id": "sympy.polys.polytools.Poly.from_list",
    "type": "method",
    "description": "Construct a polynomial from a ``list``.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "from_poly",
    "full_id": "sympy.polys.polytools.Poly.from_poly",
    "type": "method",
    "description": "Construct a polynomial from a polynomial.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "galois_group",
    "full_id": "sympy.polys.polytools.Poly.galois_group",
    "type": "method",
    "description": "\n        Compute the Galois group of this polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n        >>> f = Poly(x**4 - 2)\n        >>> G, _ = f.galois_group(by_name=True)\n        >>> print(G)\n        S4TransitiveSubgroups.D4\n\n        See Also\n        ========\n\n        sympy.polys.numberfields.galoisgroups.galois_group\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.polys.polytools.Poly.gcd",
    "type": "method",
    "description": "\n        Returns the polynomial GCD of ``f`` and ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 1, x).gcd(Poly(x**2 - 3*x + 2, x))\n        Poly(x - 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gcdex",
    "full_id": "sympy.polys.polytools.Poly.gcdex",
    "type": "method",
    "description": "\n        Extended Euclidean algorithm of ``f`` and ``g``.\n\n        Returns ``(s, t, h)`` such that ``h = gcd(f, g)`` and ``s*f + t*g = h``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f = x**4 - 2*x**3 - 6*x**2 + 12*x + 15\n        >>> g = x**3 + x**2 - 4*x - 4\n\n        >>> Poly(f).gcdex(Poly(g))\n        (Poly(-1/5*x + 3/5, x, domain='QQ'),\n         Poly(1/5*x**2 - 6/5*x + 2, x, domain='QQ'),\n         Poly(x + 1, x, domain='QQ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gen",
    "full_id": "sympy.polys.polytools.Poly.gen",
    "type": "property",
    "description": "\n        Return the principal generator.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).gen\n        x\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "get_domain",
    "full_id": "sympy.polys.polytools.Poly.get_domain",
    "type": "method",
    "description": "Get the ground domain of ``f``.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "get_modulus",
    "full_id": "sympy.polys.polytools.Poly.get_modulus",
    "type": "method",
    "description": "\n        Get the modulus of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, modulus=2).get_modulus()\n        2\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gff_list",
    "full_id": "sympy.polys.polytools.Poly.gff_list",
    "type": "method",
    "description": "\n        Computes greatest factorial factorization of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f = x**5 + 2*x**4 - x**3 - 2*x**2\n\n        >>> Poly(f).gff_list()\n        [(Poly(x, x, domain='ZZ'), 1), (Poly(x + 2, x, domain='ZZ'), 4)]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "ground_roots",
    "full_id": "sympy.polys.polytools.Poly.ground_roots",
    "type": "method",
    "description": "\n        Compute roots of ``f`` by factorization in the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**6 - 4*x**4 + 4*x**3 - x**2).ground_roots()\n        {0: 2, 1: 2}\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "half_gcdex",
    "full_id": "sympy.polys.polytools.Poly.half_gcdex",
    "type": "method",
    "description": "\n        Half extended Euclidean algorithm of ``f`` and ``g``.\n\n        Returns ``(s, h)`` such that ``h = gcd(f, g)`` and ``s*f = h (mod g)``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f = x**4 - 2*x**3 - 6*x**2 + 12*x + 15\n        >>> g = x**3 + x**2 - 4*x - 4\n\n        >>> Poly(f).half_gcdex(Poly(g))\n        (Poly(-1/5*x + 3/5, x, domain='QQ'), Poly(x + 1, x, domain='QQ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "has_only_gens",
    "full_id": "sympy.polys.polytools.Poly.has_only_gens",
    "type": "method",
    "description": "\n        Return ``True`` if ``Poly(f, *gens)`` retains ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y, z\n\n        >>> Poly(x*y + 1, x, y, z).has_only_gens(x, y)\n        True\n        >>> Poly(x*y + z, x, y, z).has_only_gens(x, y)\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "homogeneous_order",
    "full_id": "sympy.polys.polytools.Poly.homogeneous_order",
    "type": "method",
    "description": "\n        Returns the homogeneous order of ``f``.\n\n        A homogeneous polynomial is a polynomial whose all monomials with\n        non-zero coefficients have the same total degree. This degree is\n        the homogeneous order of ``f``. If you only want to check if a\n        polynomial is homogeneous, then use :func:`Poly.is_homogeneous`.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> f = Poly(x**5 + 2*x**3*y**2 + 9*x*y**4)\n        >>> f.homogeneous_order()\n        5\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "homogenize",
    "full_id": "sympy.polys.polytools.Poly.homogenize",
    "type": "method",
    "description": "\n        Returns the homogeneous polynomial of ``f``.\n\n        A homogeneous polynomial is a polynomial whose all monomials with\n        non-zero coefficients have the same total degree. If you only\n        want to check if a polynomial is homogeneous, then use\n        :func:`Poly.is_homogeneous`. If you want not only to check if a\n        polynomial is homogeneous but also compute its homogeneous order,\n        then use :func:`Poly.homogeneous_order`.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y, z\n\n        >>> f = Poly(x**5 + 2*x**2*y**2 + 9*x*y**3)\n        >>> f.homogenize(z)\n        Poly(x**5 + 2*x**2*y**2*z + 9*x*y**3*z, x, y, z, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "inject",
    "full_id": "sympy.polys.polytools.Poly.inject",
    "type": "method",
    "description": "\n        Inject ground domain generators into ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> f = Poly(x**2*y + x*y**3 + x*y + 1, x)\n\n        >>> f.inject()\n        Poly(x**2*y + x*y**3 + x*y + 1, x, y, domain='ZZ')\n        >>> f.inject(front=True)\n        Poly(y**3*x + y*x**2 + y*x + 1, y, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "integrate",
    "full_id": "sympy.polys.polytools.Poly.integrate",
    "type": "method",
    "description": "\n        Computes indefinite integral of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + 2*x + 1, x).integrate()\n        Poly(1/3*x**3 + x**2 + x, x, domain='QQ')\n\n        >>> Poly(x*y**2 + x, x, y).integrate((0, 1), (1, 0))\n        Poly(1/2*x**2*y**2 + 1/2*x**2, x, y, domain='QQ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "intervals",
    "full_id": "sympy.polys.polytools.Poly.intervals",
    "type": "method",
    "description": "\n        Compute isolating intervals for roots of ``f``.\n\n        For real roots the Vincent-Akritas-Strzebonski (VAS) continued fractions method is used.\n\n        References\n        ==========\n        .. [#] Alkiviadis G. Akritas and Adam W. Strzebonski: A Comparative Study of Two Real Root\n            Isolation Methods . Nonlinear Analysis: Modelling and Control, Vol. 10, No. 4, 297-304, 2005.\n        .. [#] Alkiviadis G. Akritas, Adam W. Strzebonski and Panagiotis S. Vigklas: Improving the\n            Performance of the Continued Fractions Method Using new Bounds of Positive Roots. Nonlinear\n            Analysis: Modelling and Control, Vol. 13, No. 3, 265-279, 2008.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 3, x).intervals()\n        [((-2, -1), 1), ((1, 2), 1)]\n        >>> Poly(x**2 - 3, x).intervals(eps=1e-2)\n        [((-26/15, -19/11), 1), ((19/11, 26/15), 1)]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "invert",
    "full_id": "sympy.polys.polytools.Poly.invert",
    "type": "method",
    "description": "\n        Invert ``f`` modulo ``g`` when possible.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 1, x).invert(Poly(2*x - 1, x))\n        Poly(-4/3, x, domain='QQ')\n\n        >>> Poly(x**2 - 1, x).invert(Poly(x - 1, x))\n        Traceback (most recent call last):\n        ...\n        NotInvertible: zero divisor\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_cyclotomic",
    "full_id": "sympy.polys.polytools.Poly.is_cyclotomic",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is a cyclotomic polnomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f = x**16 + x**14 - x**10 + x**8 - x**6 + x**2 + 1\n\n        >>> Poly(f).is_cyclotomic\n        False\n\n        >>> g = x**16 + x**14 - x**10 - x**8 - x**6 + x**2 + 1\n\n        >>> Poly(g).is_cyclotomic\n        True\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_ground",
    "full_id": "sympy.polys.polytools.Poly.is_ground",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is an element of the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x, x).is_ground\n        False\n        >>> Poly(2, x).is_ground\n        True\n        >>> Poly(y, x).is_ground\n        True\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_homogeneous",
    "full_id": "sympy.polys.polytools.Poly.is_homogeneous",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is a homogeneous polynomial.\n\n        A homogeneous polynomial is a polynomial whose all monomials with\n        non-zero coefficients have the same total degree. If you want not\n        only to check if a polynomial is homogeneous but also compute its\n        homogeneous order, then use :func:`Poly.homogeneous_order`.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + x*y, x, y).is_homogeneous\n        True\n        >>> Poly(x**3 + x*y, x, y).is_homogeneous\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_irreducible",
    "full_id": "sympy.polys.polytools.Poly.is_irreducible",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` has no factors over its domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + x + 1, x, modulus=2).is_irreducible\n        True\n        >>> Poly(x**2 + 1, x, modulus=2).is_irreducible\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_linear",
    "full_id": "sympy.polys.polytools.Poly.is_linear",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is linear in all its variables.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x + y + 2, x, y).is_linear\n        True\n        >>> Poly(x*y + 2, x, y).is_linear\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_monic",
    "full_id": "sympy.polys.polytools.Poly.is_monic",
    "type": "property",
    "description": "\n        Returns ``True`` if the leading coefficient of ``f`` is one.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x + 2, x).is_monic\n        True\n        >>> Poly(2*x + 2, x).is_monic\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_monomial",
    "full_id": "sympy.polys.polytools.Poly.is_monomial",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is zero or has only one term.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(3*x**2, x).is_monomial\n        True\n        >>> Poly(3*x**2 + 1, x).is_monomial\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_multivariate",
    "full_id": "sympy.polys.polytools.Poly.is_multivariate",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is a multivariate polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + x + 1, x).is_multivariate\n        False\n        >>> Poly(x*y**2 + x*y + 1, x, y).is_multivariate\n        True\n        >>> Poly(x*y**2 + x*y + 1, x).is_multivariate\n        False\n        >>> Poly(x**2 + x + 1, x, y).is_multivariate\n        True\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_one",
    "full_id": "sympy.polys.polytools.Poly.is_one",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is a unit polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(0, x).is_one\n        False\n        >>> Poly(1, x).is_one\n        True\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_primitive",
    "full_id": "sympy.polys.polytools.Poly.is_primitive",
    "type": "property",
    "description": "\n        Returns ``True`` if GCD of the coefficients of ``f`` is one.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(2*x**2 + 6*x + 12, x).is_primitive\n        False\n        >>> Poly(x**2 + 3*x + 6, x).is_primitive\n        True\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_quadratic",
    "full_id": "sympy.polys.polytools.Poly.is_quadratic",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is quadratic in all its variables.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x*y + 2, x, y).is_quadratic\n        True\n        >>> Poly(x*y**2 + 2, x, y).is_quadratic\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_sqf",
    "full_id": "sympy.polys.polytools.Poly.is_sqf",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is a square-free polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 2*x + 1, x).is_sqf\n        False\n        >>> Poly(x**2 - 1, x).is_sqf\n        True\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_univariate",
    "full_id": "sympy.polys.polytools.Poly.is_univariate",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is a univariate polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + x + 1, x).is_univariate\n        True\n        >>> Poly(x*y**2 + x*y + 1, x, y).is_univariate\n        False\n        >>> Poly(x*y**2 + x*y + 1, x).is_univariate\n        True\n        >>> Poly(x**2 + x + 1, x, y).is_univariate\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.polytools.Poly.is_zero",
    "type": "property",
    "description": "\n        Returns ``True`` if ``f`` is a zero polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(0, x).is_zero\n        True\n        >>> Poly(1, x).is_zero\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "l1_norm",
    "full_id": "sympy.polys.polytools.Poly.l1_norm",
    "type": "method",
    "description": "\n        Returns l1 norm of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(-x**2 + 2*x - 3, x).l1_norm()\n        6\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.polys.polytools.Poly.lcm",
    "type": "method",
    "description": "\n        Returns polynomial LCM of ``f`` and ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 1, x).lcm(Poly(x**2 - 3*x + 2, x))\n        Poly(x**3 - 2*x**2 - x + 2, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "length",
    "full_id": "sympy.polys.polytools.Poly.length",
    "type": "method",
    "description": "\n        Returns the number of non-zero terms in ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 2*x - 1).length()\n        3\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "lift",
    "full_id": "sympy.polys.polytools.Poly.lift",
    "type": "method",
    "description": "\n        Convert algebraic coefficients to rationals.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, I\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + I*x + 1, x, extension=I).lift()\n        Poly(x**4 + 3*x**2 + 1, x, domain='QQ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "ltrim",
    "full_id": "sympy.polys.polytools.Poly.ltrim",
    "type": "method",
    "description": "\n        Remove dummy generators from ``f`` that are to the left of\n        specified ``gen`` in the generators as ordered. When ``gen``\n        is an integer, it refers to the generator located at that\n        position within the tuple of generators of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y, z\n\n        >>> Poly(y**2 + y*z**2, x, y, z).ltrim(y)\n        Poly(y**2 + y*z**2, y, z, domain='ZZ')\n        >>> Poly(z, x, y, z).ltrim(-1)\n        Poly(z, z, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "make_monic_over_integers_by_scaling_roots",
    "full_id": "sympy.polys.polytools.Poly.make_monic_over_integers_by_scaling_roots",
    "type": "method",
    "description": "\n        Turn any univariate polynomial over :ref:`QQ` or :ref:`ZZ` into a monic\n        polynomial over :ref:`ZZ`, by scaling the roots as necessary.\n\n        Explanation\n        ===========\n\n        This operation can be performed whether or not *f* is irreducible; when\n        it is, this can be understood as determining an algebraic integer\n        generating the same field as a root of *f*.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, S\n        >>> from sympy.abc import x\n        >>> f = Poly(x**2/2 + S(1)/4 * x + S(1)/8, x, domain='QQ')\n        >>> f.make_monic_over_integers_by_scaling_roots()\n        (Poly(x**2 + 2*x + 4, x, domain='ZZ'), 4)\n\n        Returns\n        =======\n\n        Pair ``(g, c)``\n            g is the polynomial\n\n            c is the integer by which the roots had to be scaled\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "match",
    "full_id": "sympy.polys.polytools.Poly.match",
    "type": "method",
    "description": "Match expression from Poly. See Basic.match()",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "max_norm",
    "full_id": "sympy.polys.polytools.Poly.max_norm",
    "type": "method",
    "description": "\n        Returns maximum norm of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(-x**2 + 2*x - 3, x).max_norm()\n        3\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "monic",
    "full_id": "sympy.polys.polytools.Poly.monic",
    "type": "method",
    "description": "\n        Divides all coefficients by ``LC(f)``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, ZZ\n        >>> from sympy.abc import x\n\n        >>> Poly(3*x**2 + 6*x + 9, x, domain=ZZ).monic()\n        Poly(x**2 + 2*x + 3, x, domain='QQ')\n\n        >>> Poly(3*x**2 + 4*x + 2, x, domain=ZZ).monic()\n        Poly(x**2 + 4/3*x + 2/3, x, domain='QQ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "monoms",
    "full_id": "sympy.polys.polytools.Poly.monoms",
    "type": "method",
    "description": "\n        Returns all non-zero monomials from ``f`` in lex order.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + 2*x*y**2 + x*y + 3*y, x, y).monoms()\n        [(2, 0), (1, 2), (1, 1), (0, 1)]\n\n        See Also\n        ========\n        all_monoms\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.polys.polytools.Poly.mul",
    "type": "method",
    "description": "\n        Multiply two polynomials ``f`` and ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).mul(Poly(x - 2, x))\n        Poly(x**3 - 2*x**2 + x - 2, x, domain='ZZ')\n\n        >>> Poly(x**2 + 1, x)*Poly(x - 2, x)\n        Poly(x**3 - 2*x**2 + x - 2, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "mul_ground",
    "full_id": "sympy.polys.polytools.Poly.mul_ground",
    "type": "method",
    "description": "\n        Multiply ``f`` by a an element of the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x + 1).mul_ground(2)\n        Poly(2*x + 2, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "neg",
    "full_id": "sympy.polys.polytools.Poly.neg",
    "type": "method",
    "description": "\n        Negate all coefficients in ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 1, x).neg()\n        Poly(-x**2 + 1, x, domain='ZZ')\n\n        >>> -Poly(x**2 - 1, x)\n        Poly(-x**2 + 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "new",
    "full_id": "sympy.polys.polytools.Poly.new",
    "type": "method",
    "description": "Construct :class:`Poly` instance from raw representation.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "norm",
    "full_id": "sympy.polys.polytools.Poly.norm",
    "type": "method",
    "description": "\n        Computes the product, ``Norm(f)``, of the conjugates of\n        a polynomial ``f`` defined over a number field ``K``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, sqrt\n        >>> from sympy.abc import x\n\n        >>> a, b = sqrt(2), sqrt(3)\n\n        A polynomial over a quadratic extension.\n        Two conjugates x - a and x + a.\n\n        >>> f = Poly(x - a, x, extension=a)\n        >>> f.norm()\n        Poly(x**2 - 2, x, domain='QQ')\n\n        A polynomial over a quartic extension.\n        Four conjugates x - a, x - a, x + a and x + a.\n\n        >>> f = Poly(x - a, x, extension=(a, b))\n        >>> f.norm()\n        Poly(x**4 - 4*x**2 + 4, x, domain='QQ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "nroots",
    "full_id": "sympy.polys.polytools.Poly.nroots",
    "type": "method",
    "description": "\n        Compute numerical approximations of roots of ``f``.\n\n        Parameters\n        ==========\n\n        n ... the number of digits to calculate\n        maxsteps ... the maximum number of iterations to do\n\n        If the accuracy `n` cannot be reached in `maxsteps`, it will raise an\n        exception. You need to rerun with higher maxsteps.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 3).nroots(n=15)\n        [-1.73205080756888, 1.73205080756888]\n        >>> Poly(x**2 - 3).nroots(n=30)\n        [-1.73205080756887729352744634151, 1.73205080756887729352744634151]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "nth",
    "full_id": "sympy.polys.polytools.Poly.nth",
    "type": "method",
    "description": "\n        Returns the ``n``-th coefficient of ``f`` where ``N`` are the\n        exponents of the generators in the term of interest.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, sqrt\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**3 + 2*x**2 + 3*x, x).nth(2)\n        2\n        >>> Poly(x**3 + 2*x*y**2 + y**2, x, y).nth(1, 2)\n        2\n        >>> Poly(4*sqrt(x)*y)\n        Poly(4*y*(sqrt(x)), y, sqrt(x), domain='ZZ')\n        >>> _.nth(1, 1)\n        4\n\n        See Also\n        ========\n        coeff_monomial\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "nth_power_roots_poly",
    "full_id": "sympy.polys.polytools.Poly.nth_power_roots_poly",
    "type": "method",
    "description": "\n        Construct a polynomial with n-th powers of roots of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f = Poly(x**4 - x**2 + 1)\n\n        >>> f.nth_power_roots_poly(2)\n        Poly(x**4 - 2*x**3 + 3*x**2 - 2*x + 1, x, domain='ZZ')\n        >>> f.nth_power_roots_poly(3)\n        Poly(x**4 + 2*x**2 + 1, x, domain='ZZ')\n        >>> f.nth_power_roots_poly(4)\n        Poly(x**4 + 2*x**3 + 3*x**2 + 2*x + 1, x, domain='ZZ')\n        >>> f.nth_power_roots_poly(12)\n        Poly(x**4 - 4*x**3 + 6*x**2 - 4*x + 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "one",
    "full_id": "sympy.polys.polytools.Poly.one",
    "type": "property",
    "description": "Return one polynomial with ``self``'s properties.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "pdiv",
    "full_id": "sympy.polys.polytools.Poly.pdiv",
    "type": "method",
    "description": "\n        Polynomial pseudo-division of ``f`` by ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).pdiv(Poly(2*x - 4, x))\n        (Poly(2*x + 4, x, domain='ZZ'), Poly(20, x, domain='ZZ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "per",
    "full_id": "sympy.polys.polytools.Poly.per",
    "type": "method",
    "description": "\n        Create a Poly out of the given representation.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, ZZ\n        >>> from sympy.abc import x, y\n\n        >>> from sympy.polys.polyclasses import DMP\n\n        >>> a = Poly(x**2 + 1)\n\n        >>> a.per(DMP([ZZ(1), ZZ(1)], ZZ), gens=[y])\n        Poly(y + 1, y, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "pexquo",
    "full_id": "sympy.polys.polytools.Poly.pexquo",
    "type": "method",
    "description": "\n        Polynomial exact pseudo-quotient of ``f`` by ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 1, x).pexquo(Poly(2*x - 2, x))\n        Poly(2*x + 2, x, domain='ZZ')\n\n        >>> Poly(x**2 + 1, x).pexquo(Poly(2*x - 4, x))\n        Traceback (most recent call last):\n        ...\n        ExactQuotientFailed: 2*x - 4 does not divide x**2 + 1\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "pow",
    "full_id": "sympy.polys.polytools.Poly.pow",
    "type": "method",
    "description": "\n        Raise ``f`` to a non-negative power ``n``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x - 2, x).pow(3)\n        Poly(x**3 - 6*x**2 + 12*x - 8, x, domain='ZZ')\n\n        >>> Poly(x - 2, x)**3\n        Poly(x**3 - 6*x**2 + 12*x - 8, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "pquo",
    "full_id": "sympy.polys.polytools.Poly.pquo",
    "type": "method",
    "description": "\n        Polynomial pseudo-quotient of ``f`` by ``g``.\n\n        See the Caveat note in the function prem(f, g).\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).pquo(Poly(2*x - 4, x))\n        Poly(2*x + 4, x, domain='ZZ')\n\n        >>> Poly(x**2 - 1, x).pquo(Poly(2*x - 2, x))\n        Poly(2*x + 2, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "prem",
    "full_id": "sympy.polys.polytools.Poly.prem",
    "type": "method",
    "description": "\n        Polynomial pseudo-remainder of ``f`` by ``g``.\n\n        Caveat: The function prem(f, g, x) can be safely used to compute\n          in Z[x] _only_ subresultant polynomial remainder sequences (prs's).\n\n          To safely compute Euclidean and Sturmian prs's in Z[x]\n          employ anyone of the corresponding functions found in\n          the module sympy.polys.subresultants_qq_zz. The functions\n          in the module with suffix _pg compute prs's in Z[x] employing\n          rem(f, g, x), whereas the functions with suffix _amv\n          compute prs's in Z[x] employing rem_z(f, g, x).\n\n          The function rem_z(f, g, x) differs from prem(f, g, x) in that\n          to compute the remainder polynomials in Z[x] it premultiplies\n          the divident times the absolute value of the leading coefficient\n          of the divisor raised to the power degree(f, x) - degree(g, x) + 1.\n\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).prem(Poly(2*x - 4, x))\n        Poly(20, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "primitive",
    "full_id": "sympy.polys.polytools.Poly.primitive",
    "type": "method",
    "description": "\n        Returns the content and a primitive form of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(2*x**2 + 8*x + 12, x).primitive()\n        (2, Poly(x**2 + 4*x + 6, x, domain='ZZ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "quo",
    "full_id": "sympy.polys.polytools.Poly.quo",
    "type": "method",
    "description": "\n        Computes polynomial quotient of ``f`` by ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).quo(Poly(2*x - 4, x))\n        Poly(1/2*x + 1, x, domain='QQ')\n\n        >>> Poly(x**2 - 1, x).quo(Poly(x - 1, x))\n        Poly(x + 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "quo_ground",
    "full_id": "sympy.polys.polytools.Poly.quo_ground",
    "type": "method",
    "description": "\n        Quotient of ``f`` by a an element of the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(2*x + 4).quo_ground(2)\n        Poly(x + 2, x, domain='ZZ')\n\n        >>> Poly(2*x + 3).quo_ground(2)\n        Poly(x + 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "rat_clear_denoms",
    "full_id": "sympy.polys.polytools.Poly.rat_clear_denoms",
    "type": "method",
    "description": "\n        Clear denominators in a rational function ``f/g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> f = Poly(x**2/y + 1, x)\n        >>> g = Poly(x**3 + y, x)\n\n        >>> p, q = f.rat_clear_denoms(g)\n\n        >>> p\n        Poly(x**2 + y, x, domain='ZZ[y]')\n        >>> q\n        Poly(y*x**3 + y**2, x, domain='ZZ[y]')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "real_roots",
    "full_id": "sympy.polys.polytools.Poly.real_roots",
    "type": "method",
    "description": "\n        Return a list of real roots with multiplicities.\n\n        See :func:`real_roots` for more explanation.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(2*x**3 - 7*x**2 + 4*x + 4).real_roots()\n        [-1/2, 2, 2]\n        >>> Poly(x**3 + x + 1).real_roots()\n        [CRootOf(x**3 + x + 1, 0)]\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "refine_root",
    "full_id": "sympy.polys.polytools.Poly.refine_root",
    "type": "method",
    "description": "\n        Refine an isolating interval of a root to the given precision.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 3, x).refine_root(1, 2, eps=1e-2)\n        (19/11, 26/15)\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "rem",
    "full_id": "sympy.polys.polytools.Poly.rem",
    "type": "method",
    "description": "\n        Computes the polynomial remainder of ``f`` by ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).rem(Poly(2*x - 4, x))\n        Poly(5, x, domain='ZZ')\n\n        >>> Poly(x**2 + 1, x).rem(Poly(2*x - 4, x), auto=False)\n        Poly(x**2 + 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "reorder",
    "full_id": "sympy.polys.polytools.Poly.reorder",
    "type": "method",
    "description": "\n        Efficiently apply new order of generators.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + x*y**2, x, y).reorder(y, x)\n        Poly(y**2*x + x**2, y, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "replace",
    "full_id": "sympy.polys.polytools.Poly.replace",
    "type": "method",
    "description": "\n        Replace ``x`` with ``y`` in generators list.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + 1, x).replace(x, y)\n        Poly(y**2 + 1, y, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "resultant",
    "full_id": "sympy.polys.polytools.Poly.resultant",
    "type": "method",
    "description": "\n        Computes the resultant of ``f`` and ``g`` via PRS.\n\n        If includePRS=True, it includes the subresultant PRS in the result.\n        Because the PRS is used to calculate the resultant, this is more\n        efficient than calling :func:`subresultants` separately.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f = Poly(x**2 + 1, x)\n\n        >>> f.resultant(Poly(x**2 - 1, x))\n        4\n        >>> f.resultant(Poly(x**2 - 1, x), includePRS=True)\n        (4, [Poly(x**2 + 1, x, domain='ZZ'), Poly(x**2 - 1, x, domain='ZZ'),\n             Poly(-2, x, domain='ZZ')])\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "retract",
    "full_id": "sympy.polys.polytools.Poly.retract",
    "type": "method",
    "description": "\n        Recalculate the ground domain of a polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f = Poly(x**2 + 1, x, domain='QQ[y]')\n        >>> f\n        Poly(x**2 + 1, x, domain='QQ[y]')\n\n        >>> f.retract()\n        Poly(x**2 + 1, x, domain='ZZ')\n        >>> f.retract(field=True)\n        Poly(x**2 + 1, x, domain='QQ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "revert",
    "full_id": "sympy.polys.polytools.Poly.revert",
    "type": "method",
    "description": "\n        Compute ``f**(-1)`` mod ``x**n``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(1, x).revert(2)\n        Poly(1, x, domain='ZZ')\n\n        >>> Poly(1 + x, x).revert(1)\n        Poly(1, x, domain='ZZ')\n\n        >>> Poly(x**2 - 2, x).revert(2)\n        Traceback (most recent call last):\n        ...\n        NotReversible: only units are reversible in a ring\n\n        >>> Poly(1/x, x).revert(1)\n        Traceback (most recent call last):\n        ...\n        PolynomialError: 1/x contains an element of the generators set\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "root",
    "full_id": "sympy.polys.polytools.Poly.root",
    "type": "method",
    "description": "\n        Get an indexed root of a polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f = Poly(2*x**3 - 7*x**2 + 4*x + 4)\n\n        >>> f.root(0)\n        -1/2\n        >>> f.root(1)\n        2\n        >>> f.root(2)\n        2\n        >>> f.root(3)\n        Traceback (most recent call last):\n        ...\n        IndexError: root index out of [-3, 2] range, got 3\n\n        >>> Poly(x**5 + x + 1).root(0)\n        CRootOf(x**3 - x**2 + 1, 0)\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "same_root",
    "full_id": "sympy.polys.polytools.Poly.same_root",
    "type": "method",
    "description": "\n        Decide whether two roots of this polynomial are equal.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, cyclotomic_poly, exp, I, pi\n        >>> f = Poly(cyclotomic_poly(5))\n        >>> r0 = exp(2*I*pi/5)\n        >>> indices = [i for i, r in enumerate(f.all_roots()) if f.same_root(r, r0)]\n        >>> print(indices)\n        [3]\n\n        Raises\n        ======\n\n        DomainError\n            If the domain of the polynomial is not :ref:`ZZ`, :ref:`QQ`,\n            :ref:`RR`, or :ref:`CC`.\n        MultivariatePolynomialError\n            If the polynomial is not univariate.\n        PolynomialError\n            If the polynomial is of degree < 2.\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "set_domain",
    "full_id": "sympy.polys.polytools.Poly.set_domain",
    "type": "method",
    "description": "Set the ground domain of ``f``.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "set_modulus",
    "full_id": "sympy.polys.polytools.Poly.set_modulus",
    "type": "method",
    "description": "\n        Set the modulus of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(5*x**2 + 2*x - 1, x).set_modulus(2)\n        Poly(x**2 + 1, x, modulus=2)\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "shift",
    "full_id": "sympy.polys.polytools.Poly.shift",
    "type": "method",
    "description": "\n        Efficiently compute Taylor shift ``f(x + a)``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 2*x + 1, x).shift(2)\n        Poly(x**2 + 2*x + 1, x, domain='ZZ')\n\n        See Also\n        ========\n\n        shift_list: Analogous method for multivariate polynomials.\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "shift_list",
    "full_id": "sympy.polys.polytools.Poly.shift_list",
    "type": "method",
    "description": "\n        Efficiently compute Taylor shift ``f(X + A)``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x*y, [x,y]).shift_list([1, 2]) == Poly((x+1)*(y+2), [x,y])\n        True\n\n        See Also\n        ========\n\n        shift: Analogous method for univariate polynomials.\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "slice",
    "full_id": "sympy.polys.polytools.Poly.slice",
    "type": "method",
    "description": "Take a continuous subsequence of terms of ``f``.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sqf_list",
    "full_id": "sympy.polys.polytools.Poly.sqf_list",
    "type": "method",
    "description": "\n        Returns a list of square-free factors of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f = 2*x**5 + 16*x**4 + 50*x**3 + 76*x**2 + 56*x + 16\n\n        >>> Poly(f).sqf_list()\n        (2, [(Poly(x + 1, x, domain='ZZ'), 2),\n             (Poly(x + 2, x, domain='ZZ'), 3)])\n\n        >>> Poly(f).sqf_list(all=True)\n        (2, [(Poly(1, x, domain='ZZ'), 1),\n             (Poly(x + 1, x, domain='ZZ'), 2),\n             (Poly(x + 2, x, domain='ZZ'), 3)])\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sqf_list_include",
    "full_id": "sympy.polys.polytools.Poly.sqf_list_include",
    "type": "method",
    "description": "\n        Returns a list of square-free factors of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, expand\n        >>> from sympy.abc import x\n\n        >>> f = expand(2*(x + 1)**3*x**4)\n        >>> f\n        2*x**7 + 6*x**6 + 6*x**5 + 2*x**4\n\n        >>> Poly(f).sqf_list_include()\n        [(Poly(2, x, domain='ZZ'), 1),\n         (Poly(x + 1, x, domain='ZZ'), 3),\n         (Poly(x, x, domain='ZZ'), 4)]\n\n        >>> Poly(f).sqf_list_include(all=True)\n        [(Poly(2, x, domain='ZZ'), 1),\n         (Poly(1, x, domain='ZZ'), 2),\n         (Poly(x + 1, x, domain='ZZ'), 3),\n         (Poly(x, x, domain='ZZ'), 4)]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sqf_norm",
    "full_id": "sympy.polys.polytools.Poly.sqf_norm",
    "type": "method",
    "description": "\n        Computes square-free norm of ``f``.\n\n        Returns ``s``, ``f``, ``r``, such that ``g(x) = f(x-sa)`` and\n        ``r(x) = Norm(g(x))`` is a square-free polynomial over ``K``,\n        where ``a`` is the algebraic extension of the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, sqrt\n        >>> from sympy.abc import x\n\n        >>> s, f, r = Poly(x**2 + 1, x, extension=[sqrt(3)]).sqf_norm()\n\n        >>> s\n        [1]\n        >>> f\n        Poly(x**2 - 2*sqrt(3)*x + 4, x, domain='QQ<sqrt(3)>')\n        >>> r\n        Poly(x**4 - 4*x**2 + 16, x, domain='QQ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sqf_part",
    "full_id": "sympy.polys.polytools.Poly.sqf_part",
    "type": "method",
    "description": "\n        Computes square-free part of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**3 - 3*x - 2, x).sqf_part()\n        Poly(x**2 - x - 2, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sqr",
    "full_id": "sympy.polys.polytools.Poly.sqr",
    "type": "method",
    "description": "\n        Square a polynomial ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x - 2, x).sqr()\n        Poly(x**2 - 4*x + 4, x, domain='ZZ')\n\n        >>> Poly(x - 2, x)**2\n        Poly(x**2 - 4*x + 4, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sturm",
    "full_id": "sympy.polys.polytools.Poly.sturm",
    "type": "method",
    "description": "\n        Computes the Sturm sequence of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**3 - 2*x**2 + x - 3, x).sturm()\n        [Poly(x**3 - 2*x**2 + x - 3, x, domain='QQ'),\n         Poly(3*x**2 - 4*x + 1, x, domain='QQ'),\n         Poly(2/9*x + 25/9, x, domain='QQ'),\n         Poly(-2079/4, x, domain='QQ')]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sub",
    "full_id": "sympy.polys.polytools.Poly.sub",
    "type": "method",
    "description": "\n        Subtract two polynomials ``f`` and ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).sub(Poly(x - 2, x))\n        Poly(x**2 - x + 3, x, domain='ZZ')\n\n        >>> Poly(x**2 + 1, x) - Poly(x - 2, x)\n        Poly(x**2 - x + 3, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "sub_ground",
    "full_id": "sympy.polys.polytools.Poly.sub_ground",
    "type": "method",
    "description": "\n        Subtract an element of the ground domain from ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x + 1).sub_ground(2)\n        Poly(x - 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "subresultants",
    "full_id": "sympy.polys.polytools.Poly.subresultants",
    "type": "method",
    "description": "\n        Computes the subresultant PRS of ``f`` and ``g``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x).subresultants(Poly(x**2 - 1, x))\n        [Poly(x**2 + 1, x, domain='ZZ'),\n         Poly(x**2 - 1, x, domain='ZZ'),\n         Poly(-2, x, domain='ZZ')]\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "terms",
    "full_id": "sympy.polys.polytools.Poly.terms",
    "type": "method",
    "description": "\n        Returns all non-zero terms from ``f`` in lex order.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + 2*x*y**2 + x*y + 3*y, x, y).terms()\n        [((2, 0), 1), ((1, 2), 2), ((1, 1), 1), ((0, 1), 3)]\n\n        See Also\n        ========\n        all_terms\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "terms_gcd",
    "full_id": "sympy.polys.polytools.Poly.terms_gcd",
    "type": "method",
    "description": "\n        Remove GCD of terms from the polynomial ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**6*y**2 + x**3*y, x, y).terms_gcd()\n        ((3, 1), Poly(x**3*y + 1, x, y, domain='ZZ'))\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "termwise",
    "full_id": "sympy.polys.polytools.Poly.termwise",
    "type": "method",
    "description": "\n        Apply a function to all terms of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> def func(k, coeff):\n        ...     k = k[0]\n        ...     return coeff//10**(2-k)\n\n        >>> Poly(x**2 + 20*x + 400).termwise(func)\n        Poly(x**2 + 2*x + 4, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "to_exact",
    "full_id": "sympy.polys.polytools.Poly.to_exact",
    "type": "method",
    "description": "\n        Make the ground domain exact.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, RR\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1.0, x, domain=RR).to_exact()\n        Poly(x**2 + 1, x, domain='QQ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "to_field",
    "full_id": "sympy.polys.polytools.Poly.to_field",
    "type": "method",
    "description": "\n        Make the ground domain a field.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, ZZ\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, x, domain=ZZ).to_field()\n        Poly(x**2 + 1, x, domain='QQ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "to_ring",
    "full_id": "sympy.polys.polytools.Poly.to_ring",
    "type": "method",
    "description": "\n        Make the ground domain a ring.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, QQ\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 + 1, domain=QQ).to_ring()\n        Poly(x**2 + 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "total_degree",
    "full_id": "sympy.polys.polytools.Poly.total_degree",
    "type": "method",
    "description": "\n        Returns the total degree of ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x, y\n\n        >>> Poly(x**2 + y*x + 1, x, y).total_degree()\n        2\n        >>> Poly(x + y**5, x, y).total_degree()\n        5\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "transform",
    "full_id": "sympy.polys.polytools.Poly.transform",
    "type": "method",
    "description": "\n        Efficiently evaluate the functional transformation ``q**n * f(p/q)``.\n\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(x**2 - 2*x + 1, x).transform(Poly(x + 1, x), Poly(x - 1, x))\n        Poly(4, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "trunc",
    "full_id": "sympy.polys.polytools.Poly.trunc",
    "type": "method",
    "description": "\n        Reduce ``f`` modulo a constant ``p``.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> Poly(2*x**3 + 3*x**2 + 5*x + 7, x).trunc(3)\n        Poly(-x**3 - x + 1, x, domain='ZZ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "unify",
    "full_id": "sympy.polys.polytools.Poly.unify",
    "type": "method",
    "description": "\n        Make ``f`` and ``g`` belong to the same domain.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly\n        >>> from sympy.abc import x\n\n        >>> f, g = Poly(x/2 + 1), Poly(2*x + 1)\n\n        >>> f\n        Poly(1/2*x + 1, x, domain='QQ')\n        >>> g\n        Poly(2*x + 1, x, domain='ZZ')\n\n        >>> F, G = f.unify(g)\n\n        >>> F\n        Poly(1/2*x + 1, x, domain='QQ')\n        >>> G\n        Poly(2*x + 1, x, domain='QQ')\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "unit",
    "full_id": "sympy.polys.polytools.Poly.unit",
    "type": "property",
    "description": "Return unit polynomial with ``self``'s properties.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "zero",
    "full_id": "sympy.polys.polytools.Poly.zero",
    "type": "property",
    "description": "Return zero polynomial with ``self``'s properties.",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "free_symbols",
    "full_id": "sympy.polys.polytools.PurePoly.free_symbols",
    "type": "property",
    "description": "\n        Free symbols of a polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy import PurePoly\n        >>> from sympy.abc import x, y\n\n        >>> PurePoly(x**2 + 1).free_symbols\n        set()\n        >>> PurePoly(x**2 + y).free_symbols\n        set()\n        >>> PurePoly(x**2 + y, x).free_symbols\n        {y}\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.polys.polytools.GroebnerBasis.contains",
    "type": "method",
    "description": "\n        Check if ``poly`` belongs the ideal generated by ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy import groebner\n        >>> from sympy.abc import x, y\n\n        >>> f = 2*x**3 + y**3 + 3*y\n        >>> G = groebner([x**2 + y**2 - 1, x*y - 2])\n\n        >>> G.contains(f)\n        True\n        >>> G.contains(f + 1)\n        False\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "fglm",
    "full_id": "sympy.polys.polytools.GroebnerBasis.fglm",
    "type": "method",
    "description": "\n        Convert a Groebner basis from one ordering to another.\n\n        The FGLM algorithm converts reduced Groebner bases of zero-dimensional\n        ideals from one ordering to another. This method is often used when it\n        is infeasible to compute a Groebner basis with respect to a particular\n        ordering directly.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import groebner\n\n        >>> F = [x**2 - 3*y - x + 1, y**2 - 2*x + y - 1]\n        >>> G = groebner(F, x, y, order='grlex')\n\n        >>> list(G.fglm('lex'))\n        [2*x - y**2 - y + 1, y**4 + 2*y**3 - 3*y**2 - 16*y + 7]\n        >>> list(groebner(F, x, y, order='lex'))\n        [2*x - y**2 - y + 1, y**4 + 2*y**3 - 3*y**2 - 16*y + 7]\n\n        References\n        ==========\n\n        .. [1] J.C. Faugere, P. Gianni, D. Lazard, T. Mora (1994). Efficient\n               Computation of Zero-dimensional Groebner Bases by Change of\n               Ordering\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "is_zero_dimensional",
    "full_id": "sympy.polys.polytools.GroebnerBasis.is_zero_dimensional",
    "type": "property",
    "description": "\n        Checks if the ideal generated by a Groebner basis is zero-dimensional.\n\n        The algorithm checks if the set of monomials not divisible by the\n        leading monomial of any element of ``F`` is bounded.\n\n        References\n        ==========\n\n        David A. Cox, John B. Little, Donal O'Shea. Ideals, Varieties and\n        Algorithms, 3rd edition, p. 230\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "reduce",
    "full_id": "sympy.polys.polytools.GroebnerBasis.reduce",
    "type": "method",
    "description": "\n        Reduces a polynomial modulo a Groebner basis.\n\n        Given a polynomial ``f`` and a set of polynomials ``G = (g_1, ..., g_n)``,\n        computes a set of quotients ``q = (q_1, ..., q_n)`` and the remainder ``r``\n        such that ``f = q_1*f_1 + ... + q_n*f_n + r``, where ``r`` vanishes or ``r``\n        is a completely reduced polynomial with respect to ``G``.\n\n        Examples\n        ========\n\n        >>> from sympy import groebner, expand\n        >>> from sympy.abc import x, y\n\n        >>> f = 2*x**4 - x**2 + y**3 + y**2\n        >>> G = groebner([x**3 - x, y**3 - y])\n\n        >>> G.reduce(f)\n        ([2*x, 1], x**2 + y**2 + y)\n        >>> Q, r = _\n\n        >>> expand(sum(q*g for q, g in zip(Q, G)) + r)\n        2*x**4 - x**2 + y**3 + y**2\n        >>> _ == f\n        True\n\n        ",
    "section": "Basic polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "symmetrize",
    "full_id": "sympy.polys.polyfuncs.symmetrize",
    "type": "function",
    "description": "\n    Rewrite a polynomial in terms of elementary symmetric polynomials.\n\n    A symmetric polynomial is a multivariate polynomial that remains invariant\n    under any variable permutation, i.e., if `f = f(x_1, x_2, \\dots, x_n)`,\n    then `f = f(x_{i_1}, x_{i_2}, \\dots, x_{i_n})`, where\n    `(i_1, i_2, \\dots, i_n)` is a permutation of `(1, 2, \\dots, n)` (an\n    element of the group `S_n`).\n\n    Returns a tuple of symmetric polynomials ``(f1, f2, ..., fn)`` such that\n    ``f = f1 + f2 + ... + fn``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polyfuncs import symmetrize\n    >>> from sympy.abc import x, y\n\n    >>> symmetrize(x**2 + y**2)\n    (-2*x*y + (x + y)**2, 0)\n\n    >>> symmetrize(x**2 + y**2, formal=True)\n    (s1**2 - 2*s2, 0, [(s1, x + y), (s2, x*y)])\n\n    >>> symmetrize(x**2 - y**2)\n    (-2*x*y + (x + y)**2, -2*y**2)\n\n    >>> symmetrize(x**2 - y**2, formal=True)\n    (s1**2 - 2*s2, -2*y**2, [(s1, x + y), (s2, x*y)])\n\n    ",
    "section": "Extra polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "horner",
    "full_id": "sympy.polys.polyfuncs.horner",
    "type": "function",
    "description": "\n    Rewrite a polynomial in Horner form.\n\n    Among other applications, evaluation of a polynomial at a point is optimal\n    when it is applied using the Horner scheme ([1]).\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polyfuncs import horner\n    >>> from sympy.abc import x, y, a, b, c, d, e\n\n    >>> horner(9*x**4 + 8*x**3 + 7*x**2 + 6*x + 5)\n    x*(x*(x*(9*x + 8) + 7) + 6) + 5\n\n    >>> horner(a*x**4 + b*x**3 + c*x**2 + d*x + e)\n    e + x*(d + x*(c + x*(a*x + b)))\n\n    >>> f = 4*x**2*y**2 + 2*x**2*y + 2*x*y**2 + x*y\n\n    >>> horner(f, wrt=x)\n    x*(x*y*(4*y + 2) + y*(2*y + 1))\n\n    >>> horner(f, wrt=y)\n    y*(x*y*(4*x + 2) + x*(2*x + 1))\n\n    References\n    ==========\n    [1] - https://en.wikipedia.org/wiki/Horner_scheme\n\n    ",
    "section": "Extra polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "interpolate",
    "full_id": "sympy.polys.polyfuncs.interpolate",
    "type": "function",
    "description": "\n    Construct an interpolating polynomial for the data points\n    evaluated at point x (which can be symbolic or numeric).\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polyfuncs import interpolate\n    >>> from sympy.abc import a, b, x\n\n    A list is interpreted as though it were paired with a range starting\n    from 1:\n\n    >>> interpolate([1, 4, 9, 16], x)\n    x**2\n\n    This can be made explicit by giving a list of coordinates:\n\n    >>> interpolate([(1, 1), (2, 4), (3, 9)], x)\n    x**2\n\n    The (x, y) coordinates can also be given as keys and values of a\n    dictionary (and the points need not be equispaced):\n\n    >>> interpolate([(-1, 2), (1, 2), (2, 5)], x)\n    x**2 + 1\n    >>> interpolate({-1: 2, 1: 2, 2: 5}, x)\n    x**2 + 1\n\n    If the interpolation is going to be used only once then the\n    value of interest can be passed instead of passing a symbol:\n\n    >>> interpolate([1, 4, 9], 5)\n    25\n\n    Symbolic coordinates are also supported:\n\n    >>> [(i,interpolate((a, b), i)) for i in range(1, 4)]\n    [(1, a), (2, b), (3, -a + 2*b)]\n    ",
    "section": "Extra polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "viete",
    "full_id": "sympy.polys.polyfuncs.viete",
    "type": "function",
    "description": "\n    Generate Viete's formulas for ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.polyfuncs import viete\n    >>> from sympy import symbols\n\n    >>> x, a, b, c, r1, r2 = symbols('x,a:c,r1:3')\n\n    >>> viete(a*x**2 + b*x + c, [r1, r2], x)\n    [(r1 + r2, -b/a), (r1*r2, c/a)]\n\n    ",
    "section": "Extra polynomial manipulation functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "construct_domain",
    "full_id": "sympy.polys.constructor.construct_domain",
    "type": "function",
    "description": "Construct a minimal domain for a list of expressions.\n\n    Explanation\n    ===========\n\n    Given a list of normal SymPy expressions (of type :py:class:`~.Expr`)\n    ``construct_domain`` will find a minimal :py:class:`~.Domain` that can\n    represent those expressions. The expressions will be converted to elements\n    of the domain and both the domain and the domain elements are returned.\n\n    Parameters\n    ==========\n\n    obj: list or dict\n        The expressions to build a domain for.\n\n    **args: keyword arguments\n        Options that affect the choice of domain.\n\n    Returns\n    =======\n\n    (K, elements): Domain and list of domain elements\n        The domain K that can represent the expressions and the list or dict\n        of domain elements representing the same expressions as elements of K.\n\n    Examples\n    ========\n\n    Given a list of :py:class:`~.Integer` ``construct_domain`` will return the\n    domain :ref:`ZZ` and a list of integers as elements of :ref:`ZZ`.\n\n    >>> from sympy import construct_domain, S\n    >>> expressions = [S(2), S(3), S(4)]\n    >>> K, elements = construct_domain(expressions)\n    >>> K\n    ZZ\n    >>> elements\n    [2, 3, 4]\n    >>> type(elements[0])  # doctest: +SKIP\n    <class 'int'>\n    >>> type(expressions[0])\n    <class 'sympy.core.numbers.Integer'>\n\n    If there are any :py:class:`~.Rational` then :ref:`QQ` is returned\n    instead.\n\n    >>> construct_domain([S(1)/2, S(3)/4])\n    (QQ, [1/2, 3/4])\n\n    If there are symbols then a polynomial ring :ref:`K[x]` is returned.\n\n    >>> from sympy import symbols\n    >>> x, y = symbols('x, y')\n    >>> construct_domain([2*x + 1, S(3)/4])\n    (QQ[x], [2*x + 1, 3/4])\n    >>> construct_domain([2*x + 1, y])\n    (ZZ[x,y], [2*x + 1, y])\n\n    If any symbols appear with negative powers then a rational function field\n    :ref:`K(x)` will be returned.\n\n    >>> construct_domain([y/x, x/(1 - y)])\n    (ZZ(x,y), [y/x, -x/(y - 1)])\n\n    Irrational algebraic numbers will result in the :ref:`EX` domain by\n    default. The keyword argument ``extension=True`` leads to the construction\n    of an algebraic number field :ref:`QQ(a)`.\n\n    >>> from sympy import sqrt\n    >>> construct_domain([sqrt(2)])\n    (EX, [EX(sqrt(2))])\n    >>> construct_domain([sqrt(2)], extension=True)  # doctest: +SKIP\n    (QQ<sqrt(2)>, [ANP([1, 0], [1, 0, -2], QQ)])\n\n    See also\n    ========\n\n    Domain\n    Expr\n    ",
    "section": "Domain constructors",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "as_expr",
    "full_id": "sympy.polys.monomials.Monomial.as_expr",
    "type": "method",
    "description": "Convert a monomial instance to a SymPy expression.",
    "section": "Monomials encoded as tuples",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.polys.monomials.Monomial.gcd",
    "type": "method",
    "description": "Greatest common divisor of monomials.",
    "section": "Monomials encoded as tuples",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.polys.monomials.Monomial.lcm",
    "type": "method",
    "description": "Least common multiple of monomials.",
    "section": "Monomials encoded as tuples",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "itermonomials",
    "full_id": "sympy.polys.monomials.itermonomials",
    "type": "function",
    "description": "\n    ``max_degrees`` and ``min_degrees`` are either both integers or both lists.\n    Unless otherwise specified, ``min_degrees`` is either ``0`` or\n    ``[0, ..., 0]``.\n\n    A generator of all monomials ``monom`` is returned, such that\n    either\n    ``min_degree <= total_degree(monom) <= max_degree``,\n    or\n    ``min_degrees[i] <= degree_list(monom)[i] <= max_degrees[i]``,\n    for all ``i``.\n\n    Case I. ``max_degrees`` and ``min_degrees`` are both integers\n    =============================================================\n\n    Given a set of variables $V$ and a min_degree $N$ and a max_degree $M$\n    generate a set of monomials of degree less than or equal to $N$ and greater\n    than or equal to $M$. The total number of monomials in commutative\n    variables is huge and is given by the following formula if $M = 0$:\n\n        .. math::\n            \\frac{(\\#V + N)!}{\\#V! N!}\n\n    For example if we would like to generate a dense polynomial of\n    a total degree $N = 50$ and $M = 0$, which is the worst case, in 5\n    variables, assuming that exponents and all of coefficients are 32-bit long\n    and stored in an array we would need almost 80 GiB of memory! Fortunately\n    most polynomials, that we will encounter, are sparse.\n\n    Consider monomials in commutative variables $x$ and $y$\n    and non-commutative variables $a$ and $b$::\n\n        >>> from sympy import symbols\n        >>> from sympy.polys.monomials import itermonomials\n        >>> from sympy.polys.orderings import monomial_key\n        >>> from sympy.abc import x, y\n\n        >>> sorted(itermonomials([x, y], 2), key=monomial_key('grlex', [y, x]))\n        [1, x, y, x**2, x*y, y**2]\n\n        >>> sorted(itermonomials([x, y], 3), key=monomial_key('grlex', [y, x]))\n        [1, x, y, x**2, x*y, y**2, x**3, x**2*y, x*y**2, y**3]\n\n        >>> a, b = symbols('a, b', commutative=False)\n        >>> set(itermonomials([a, b, x], 2))\n        {1, a, a**2, b, b**2, x, x**2, a*b, b*a, x*a, x*b}\n\n        >>> sorted(itermonomials([x, y], 2, 1), key=monomial_key('grlex', [y, x]))\n        [x, y, x**2, x*y, y**2]\n\n    Case II. ``max_degrees`` and ``min_degrees`` are both lists\n    ===========================================================\n\n    If ``max_degrees = [d_1, ..., d_n]`` and\n    ``min_degrees = [e_1, ..., e_n]``, the number of monomials generated\n    is:\n\n    .. math::\n        (d_1 - e_1 + 1) (d_2 - e_2 + 1) \\cdots (d_n - e_n + 1)\n\n    Let us generate all monomials ``monom`` in variables $x$ and $y$\n    such that ``[1, 2][i] <= degree_list(monom)[i] <= [2, 4][i]``,\n    ``i = 0, 1`` ::\n\n        >>> from sympy import symbols\n        >>> from sympy.polys.monomials import itermonomials\n        >>> from sympy.polys.orderings import monomial_key\n        >>> from sympy.abc import x, y\n\n        >>> sorted(itermonomials([x, y], [2, 4], [1, 2]), reverse=True, key=monomial_key('lex', [x, y]))\n        [x**2*y**4, x**2*y**3, x**2*y**2, x*y**4, x*y**3, x*y**2]\n    ",
    "section": "Monomials encoded as tuples",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "monomial_count",
    "full_id": "sympy.polys.monomials.monomial_count",
    "type": "function",
    "description": "\n    Computes the number of monomials.\n\n    The number of monomials is given by the following formula:\n\n    .. math::\n\n        \\frac{(\\#V + N)!}{\\#V! N!}\n\n    where `N` is a total degree and `V` is a set of variables.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.monomials import itermonomials, monomial_count\n    >>> from sympy.polys.orderings import monomial_key\n    >>> from sympy.abc import x, y\n\n    >>> monomial_count(2, 2)\n    6\n\n    >>> M = list(itermonomials([x, y], 2))\n\n    >>> sorted(M, key=monomial_key('grlex', [y, x]))\n    [1, x, y, x**2, x*y, y**2]\n    >>> len(M)\n    6\n\n    ",
    "section": "Monomials encoded as tuples",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "rootof",
    "full_id": "sympy.polys.rootoftools.rootof",
    "type": "function",
    "description": "An indexed root of a univariate polynomial.\n\n    Returns either a :obj:`ComplexRootOf` object or an explicit\n    expression involving radicals.\n\n    Parameters\n    ==========\n\n    f : Expr\n        Univariate polynomial.\n    x : Symbol, optional\n        Generator for ``f``.\n    index : int or Integer\n    radicals : bool\n               Return a radical expression if possible.\n    expand : bool\n             Expand ``f``.\n    ",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_all_roots",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._all_roots",
    "type": "method",
    "description": "Get real and complex roots of a composite polynomial.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_complexes_index",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._complexes_index",
    "type": "method",
    "description": "\n        Map initial complex root index to an index in a factor where\n        the root belongs.\n        ",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_complexes_sorted",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._complexes_sorted",
    "type": "method",
    "description": "Make complex isolating intervals disjoint and sort roots.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_count_roots",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._count_roots",
    "type": "method",
    "description": "Count the number of real or complex roots with multiplicities.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_ensure_complexes_init",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._ensure_complexes_init",
    "type": "method",
    "description": "Ensure that our poly has entries in the complexes cache.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_ensure_reals_init",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._ensure_reals_init",
    "type": "method",
    "description": "Ensure that our poly has entries in the reals cache.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_eval_evalf",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._eval_evalf",
    "type": "method",
    "description": "Evaluate this complex root to the given precision.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_eval_is_imaginary",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._eval_is_imaginary",
    "type": "method",
    "description": "Return ``True`` if the root is imaginary.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_eval_is_real",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._eval_is_real",
    "type": "method",
    "description": "Return ``True`` if the root is real.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_get_complexes",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._get_complexes",
    "type": "method",
    "description": "Compute complex root isolating intervals for a list of factors.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_get_complexes_sqf",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._get_complexes_sqf",
    "type": "method",
    "description": "Get complex root isolating intervals for a square-free factor.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_get_interval",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._get_interval",
    "type": "method",
    "description": "Internal function for retrieving isolation interval from cache.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_get_reals",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._get_reals",
    "type": "method",
    "description": "Compute real root isolating intervals for a list of factors.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_get_reals_sqf",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._get_reals_sqf",
    "type": "method",
    "description": "Get real root isolating intervals for a square-free factor.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_get_roots",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._get_roots",
    "type": "method",
    "description": "Return postprocessed roots of specified kind.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_indexed_root",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._indexed_root",
    "type": "method",
    "description": "Get a root of a composite polynomial by index.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_new",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._new",
    "type": "method",
    "description": "Construct new ``CRootOf`` object from raw data.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_postprocess_root",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._postprocess_root",
    "type": "method",
    "description": "Return the root if it is trivial or a ``CRootOf`` object.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_preprocess_roots",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._preprocess_roots",
    "type": "method",
    "description": "Take heroic measures to make ``poly`` compatible with ``CRootOf``.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_real_roots",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._real_roots",
    "type": "method",
    "description": "Get real roots of a composite polynomial.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_reals_index",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._reals_index",
    "type": "method",
    "description": "\n        Map initial real root index to an index in a factor where\n        the root belongs.\n        ",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_reals_sorted",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._reals_sorted",
    "type": "method",
    "description": "Make real isolating intervals disjoint and sort roots.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_refine_complexes",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._refine_complexes",
    "type": "method",
    "description": "return complexes such that no bounding rectangles of non-conjugate\n        roots would intersect. In addition, assure that neither ay nor by is\n        0 to guarantee that non-real roots are distinct from real roots in\n        terms of the y-bounds.\n        ",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_reset",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._reset",
    "type": "method",
    "description": "\n        Reset all intervals\n        ",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_roots_trivial",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._roots_trivial",
    "type": "method",
    "description": "Compute roots in linear, quadratic and binomial cases.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "_set_interval",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf._set_interval",
    "type": "method",
    "description": "Internal function for updating isolation interval in cache.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "all_roots",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf.all_roots",
    "type": "method",
    "description": "Get real and complex roots of a polynomial.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "clear_cache",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf.clear_cache",
    "type": "method",
    "description": "Reset cache for reals and complexes.\n\n        The intervals used to approximate a root instance are updated\n        as needed. When a request is made to see the intervals, the\n        most current values are shown. `clear_cache` will reset all\n        CRootOf instances back to their original state.\n\n        See Also\n        ========\n\n        _reset\n        ",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "eval_approx",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf.eval_approx",
    "type": "method",
    "description": "Evaluate this complex root to the given precision.\n\n        This uses secant method and root bounds are used to both\n        generate an initial guess and to check that the root\n        returned is valid. If ever the method converges outside the\n        root bounds, the bounds will be made smaller and updated.\n        ",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "eval_rational",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf.eval_rational",
    "type": "method",
    "description": "\n        Return a Rational approximation of ``self`` that has real\n        and imaginary component approximations that are within ``dx``\n        and ``dy`` of the true values, respectively. Alternatively,\n        ``n`` digits of precision can be specified.\n\n        The interval is refined with bisection and is sure to\n        converge. The root bounds are updated when the refinement\n        is complete so recalculation at the same or lesser precision\n        will not have to repeat the refinement and should be much\n        faster.\n\n        The following example first obtains Rational approximation to\n        1e-8 accuracy for all roots of the 4-th order Legendre\n        polynomial. Since the roots are all less than 1, this will\n        ensure the decimal representation of the approximation will be\n        correct (including rounding) to 6 digits:\n\n        >>> from sympy import legendre_poly, Symbol\n        >>> x = Symbol(\"x\")\n        >>> p = legendre_poly(4, x, polys=True)\n        >>> r = p.real_roots()[-1]\n        >>> r.eval_rational(10**-8).n(6)\n        0.861136\n\n        It is not necessary to a two-step calculation, however: the\n        decimal representation can be computed directly:\n\n        >>> r.evalf(17)\n        0.86113631159405258\n\n        ",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "real_roots",
    "full_id": "sympy.polys.rootoftools.ComplexRootOf.real_roots",
    "type": "method",
    "description": "Get real roots of a polynomial.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "new",
    "full_id": "sympy.polys.rootoftools.RootSum.new",
    "type": "method",
    "description": "Construct new ``RootSum`` instance.",
    "section": "Formal manipulation of roots of polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "roots",
    "full_id": "sympy.polys.polyroots.roots",
    "type": "function",
    "description": "\n    Computes symbolic roots of a univariate polynomial.\n\n    Given a univariate polynomial f with symbolic coefficients (or\n    a list of the polynomial's coefficients), returns a dictionary\n    with its roots and their multiplicities.\n\n    Only roots expressible via radicals will be returned.  To get\n    a complete set of roots use RootOf class or numerical methods\n    instead. By default cubic and quartic formulas are used in\n    the algorithm. To disable them because of unreadable output\n    set ``cubics=False`` or ``quartics=False`` respectively. If cubic\n    roots are real but are expressed in terms of complex numbers\n    (casus irreducibilis [1]) the ``trig`` flag can be set to True to\n    have the solutions returned in terms of cosine and inverse cosine\n    functions.\n\n    To get roots from a specific domain set the ``filter`` flag with\n    one of the following specifiers: Z, Q, R, I, C. By default all\n    roots are returned (this is equivalent to setting ``filter='C'``).\n\n    By default a dictionary is returned giving a compact result in\n    case of multiple roots.  However to get a list containing all\n    those roots set the ``multiple`` flag to True; the list will\n    have identical roots appearing next to each other in the result.\n    (For a given Poly, the all_roots method will give the roots in\n    sorted numerical order.)\n\n    If the ``strict`` flag is True, ``UnsolvableFactorError`` will be\n    raised if the roots found are known to be incomplete (because\n    some roots are not expressible in radicals).\n\n    Examples\n    ========\n\n    >>> from sympy import Poly, roots, degree\n    >>> from sympy.abc import x, y\n\n    >>> roots(x**2 - 1, x)\n    {-1: 1, 1: 1}\n\n    >>> p = Poly(x**2-1, x)\n    >>> roots(p)\n    {-1: 1, 1: 1}\n\n    >>> p = Poly(x**2-y, x, y)\n\n    >>> roots(Poly(p, x))\n    {-sqrt(y): 1, sqrt(y): 1}\n\n    >>> roots(x**2 - y, x)\n    {-sqrt(y): 1, sqrt(y): 1}\n\n    >>> roots([1, 0, -1])\n    {-1: 1, 1: 1}\n\n    ``roots`` will only return roots expressible in radicals. If\n    the given polynomial has some or all of its roots inexpressible in\n    radicals, the result of ``roots`` will be incomplete or empty\n    respectively.\n\n    Example where result is incomplete:\n\n    >>> roots((x-1)*(x**5-x+1), x)\n    {1: 1}\n\n    In this case, the polynomial has an unsolvable quintic factor\n    whose roots cannot be expressed by radicals. The polynomial has a\n    rational root (due to the factor `(x-1)`), which is returned since\n    ``roots`` always finds all rational roots.\n\n    Example where result is empty:\n\n    >>> roots(x**7-3*x**2+1, x)\n    {}\n\n    Here, the polynomial has no roots expressible in radicals, so\n    ``roots`` returns an empty dictionary.\n\n    The result produced by ``roots`` is complete if and only if the\n    sum of the multiplicity of each root is equal to the degree of\n    the polynomial. If strict=True, UnsolvableFactorError will be\n    raised if the result is incomplete.\n\n    The result can be be checked for completeness as follows:\n\n    >>> f = x**3-2*x**2+1\n    >>> sum(roots(f, x).values()) == degree(f, x)\n    True\n    >>> f = (x-1)*(x**5-x+1)\n    >>> sum(roots(f, x).values()) == degree(f, x)\n    False\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Cubic_equation#Trigonometric_and_hyperbolic_solutions\n\n    ",
    "section": "Symbolic root-finding algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "swinnerton_dyer_poly",
    "full_id": "sympy.polys.specialpolys.swinnerton_dyer_poly",
    "type": "function",
    "description": "Generates n-th Swinnerton-Dyer polynomial in `x`.\n\n    Parameters\n    ----------\n    n : int\n        `n` decides the order of polynomial\n    x : optional\n    polys : bool, optional\n        ``polys=True`` returns an expression, otherwise\n        (default) returns an expression.\n    ",
    "section": "Special polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "interpolating_poly",
    "full_id": "sympy.polys.specialpolys.interpolating_poly",
    "type": "function",
    "description": "Construct Lagrange interpolating polynomial for ``n``\n    data points. If a sequence of values are given for ``X`` and ``Y``\n    then the first ``n`` values will be used.\n    ",
    "section": "Special polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "cyclotomic_poly",
    "full_id": "sympy.polys.specialpolys.cyclotomic_poly",
    "type": "function",
    "description": "Generates cyclotomic polynomial of order `n` in `x`.\n\n    Parameters\n    ----------\n    n : int\n        `n` decides the order of polynomial\n    x : optional\n    polys : bool, optional\n        ``polys=True`` returns an expression, otherwise\n        (default) returns an expression.\n    ",
    "section": "Special polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "symmetric_poly",
    "full_id": "sympy.polys.specialpolys.symmetric_poly",
    "type": "function",
    "description": "\n    Generates symmetric polynomial of order `n`.\n\n    Parameters\n    ==========\n\n    polys: bool, optional (default: False)\n        Returns a Poly object when ``polys=True``, otherwise\n        (default) returns an expression.\n    ",
    "section": "Special polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "random_poly",
    "full_id": "sympy.polys.specialpolys.random_poly",
    "type": "function",
    "description": "Generates a polynomial of degree ``n`` with coefficients in\n    ``[inf, sup]``.\n\n    Parameters\n    ----------\n    x\n        `x` is the independent term of polynomial\n    n : int\n        `n` decides the order of polynomial\n    inf\n        Lower limit of range in which coefficients lie\n    sup\n        Upper limit of range in which coefficients lie\n    domain : optional\n         Decides what ring the coefficients are supposed\n         to belong. Default is set to Integers.\n    polys : bool, optional\n        ``polys=True`` returns an expression, otherwise\n        (default) returns an expression.\n    ",
    "section": "Special polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "chebyshevt_poly",
    "full_id": "sympy.polys.orthopolys.chebyshevt_poly",
    "type": "function",
    "description": "Generates the Chebyshev polynomial of the first kind `T_n(x)`.\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n    ",
    "section": "Orthogonal polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "chebyshevu_poly",
    "full_id": "sympy.polys.orthopolys.chebyshevu_poly",
    "type": "function",
    "description": "Generates the Chebyshev polynomial of the second kind `U_n(x)`.\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n    ",
    "section": "Orthogonal polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "gegenbauer_poly",
    "full_id": "sympy.polys.orthopolys.gegenbauer_poly",
    "type": "function",
    "description": "Generates the Gegenbauer polynomial `C_n^{(a)}(x)`.\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    a\n        Decides minimal domain for the list of coefficients.\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n    ",
    "section": "Orthogonal polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "hermite_poly",
    "full_id": "sympy.polys.orthopolys.hermite_poly",
    "type": "function",
    "description": "Generates the Hermite polynomial `H_n(x)`.\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n    ",
    "section": "Orthogonal polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "hermite_prob_poly",
    "full_id": "sympy.polys.orthopolys.hermite_prob_poly",
    "type": "function",
    "description": "Generates the probabilist's Hermite polynomial `He_n(x)`.\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n    ",
    "section": "Orthogonal polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "jacobi_poly",
    "full_id": "sympy.polys.orthopolys.jacobi_poly",
    "type": "function",
    "description": "Generates the Jacobi polynomial `P_n^{(a,b)}(x)`.\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    a\n        Lower limit of minimal domain for the list of coefficients.\n    b\n        Upper limit of minimal domain for the list of coefficients.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n    ",
    "section": "Orthogonal polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "legendre_poly",
    "full_id": "sympy.polys.orthopolys.legendre_poly",
    "type": "function",
    "description": "Generates the Legendre polynomial `P_n(x)`.\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n    ",
    "section": "Orthogonal polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "laguerre_poly",
    "full_id": "sympy.polys.orthopolys.laguerre_poly",
    "type": "function",
    "description": "Generates the Laguerre polynomial `L_n^{(\\alpha)}(x)`.\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    alpha : optional\n        Decides minimal domain for the list of coefficients.\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n    ",
    "section": "Orthogonal polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "spherical_bessel_fn",
    "full_id": "sympy.polys.orthopolys.spherical_bessel_fn",
    "type": "function",
    "description": "\n    Coefficients for the spherical Bessel functions.\n\n    These are only needed in the jn() function.\n\n    The coefficients are calculated from:\n\n    fn(0, z) = 1/z\n    fn(1, z) = 1/z**2\n    fn(n-1, z) + fn(n+1, z) == (2*n+1)/z * fn(n, z)\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.orthopolys import spherical_bessel_fn as fn\n    >>> from sympy import Symbol\n    >>> z = Symbol(\"z\")\n    >>> fn(1, z)\n    z**(-2)\n    >>> fn(2, z)\n    -1/z + 3/z**3\n    >>> fn(3, z)\n    -6/z**2 + 15/z**4\n    >>> fn(4, z)\n    1/z - 45/z**3 + 105/z**5\n\n    ",
    "section": "Orthogonal polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "bernoulli_poly",
    "full_id": "sympy.polys.appellseqs.bernoulli_poly",
    "type": "function",
    "description": "Generates the Bernoulli polynomial `\\operatorname{B}_n(x)`.\n\n    `\\operatorname{B}_n(x)` is the unique polynomial satisfying\n\n    .. math :: \\int_{x}^{x+1} \\operatorname{B}_n(t) \\,dt = x^n.\n\n    Based on this, we have for nonnegative integer `s` and integer\n    `a` and `b`\n\n    .. math :: \\sum_{k=a}^{b} k^s = \\frac{\\operatorname{B}_{s+1}(b+1) -\n            \\operatorname{B}_{s+1}(a)}{s+1}\n\n    which is related to Jakob Bernoulli's original motivation for introducing\n    the Bernoulli numbers, the values of these polynomials at `x = 1`.\n\n    Examples\n    ========\n\n    >>> from sympy import summation\n    >>> from sympy.abc import x\n    >>> from sympy.polys import bernoulli_poly\n    >>> bernoulli_poly(5, x)\n    x**5 - 5*x**4/2 + 5*x**3/3 - x/6\n\n    >>> def psum(p, a, b):\n    ...     return (bernoulli_poly(p+1,b+1) - bernoulli_poly(p+1,a)) / (p+1)\n    >>> psum(4, -6, 27)\n    3144337\n    >>> summation(x**4, (x, -6, 27))\n    3144337\n\n    >>> psum(1, 1, x).factor()\n    x*(x + 1)/2\n    >>> psum(2, 1, x).factor()\n    x*(x + 1)*(2*x + 1)/6\n    >>> psum(3, 1, x).factor()\n    x**2*(x + 1)**2/4\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n\n    See Also\n    ========\n\n    sympy.functions.combinatorial.numbers.bernoulli\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Bernoulli_polynomials\n    ",
    "section": "Appell sequences",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "bernoulli_c_poly",
    "full_id": "sympy.polys.appellseqs.bernoulli_c_poly",
    "type": "function",
    "description": "Generates the central Bernoulli polynomial `\\operatorname{B}_n^c(x)`.\n\n    These are scaled and shifted versions of the plain Bernoulli polynomials,\n    done in such a way that `\\operatorname{B}_n^c(x)` is an even or odd function\n    for even or odd `n` respectively:\n\n    .. math :: \\operatorname{B}_n^c(x) = 2^n \\operatorname{B}_n\n            \\left(\\frac{x+1}{2}\\right)\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n    ",
    "section": "Appell sequences",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "genocchi_poly",
    "full_id": "sympy.polys.appellseqs.genocchi_poly",
    "type": "function",
    "description": "Generates the Genocchi polynomial `\\operatorname{G}_n(x)`.\n\n    `\\operatorname{G}_n(x)` is twice the difference between the plain and\n    central Bernoulli polynomials, so has degree `n-1`:\n\n    .. math :: \\operatorname{G}_n(x) = 2 (\\operatorname{B}_n(x) -\n            \\operatorname{B}_n^c(x))\n\n    The factor of 2 in the definition endows `\\operatorname{G}_n(x)` with\n    integer coefficients.\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial plus one.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n\n    See Also\n    ========\n\n    sympy.functions.combinatorial.numbers.genocchi\n    ",
    "section": "Appell sequences",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "euler_poly",
    "full_id": "sympy.polys.appellseqs.euler_poly",
    "type": "function",
    "description": "Generates the Euler polynomial `\\operatorname{E}_n(x)`.\n\n    These are scaled and reindexed versions of the Genocchi polynomials:\n\n    .. math :: \\operatorname{E}_n(x) = -\\frac{\\operatorname{G}_{n+1}(x)}{n+1}\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n\n    See Also\n    ========\n\n    sympy.functions.combinatorial.numbers.euler\n    ",
    "section": "Appell sequences",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "andre_poly",
    "full_id": "sympy.polys.appellseqs.andre_poly",
    "type": "function",
    "description": "Generates the Andre polynomial `\\mathcal{A}_n(x)`.\n\n    This is the Appell sequence where the constant coefficients form the sequence\n    of Euler numbers ``euler(n)``. As such they have integer coefficients\n    and parities matching the parity of `n`.\n\n    Luschny calls these the *Swiss-knife polynomials* because their values\n    at 0 and 1 can be simply transformed into both the Bernoulli and Euler\n    numbers. Here they are called the Andre polynomials because\n    `|\\mathcal{A}_n(n\\bmod 2)|` for `n \\ge 0` generates what Luschny calls\n    the *Andre numbers*, A000111 in the OEIS.\n\n    Examples\n    ========\n\n    >>> from sympy import bernoulli, euler, genocchi\n    >>> from sympy.abc import x\n    >>> from sympy.polys import andre_poly\n    >>> andre_poly(9, x)\n    x**9 - 36*x**7 + 630*x**5 - 5124*x**3 + 12465*x\n\n    >>> [andre_poly(n, 0) for n in range(11)]\n    [1, 0, -1, 0, 5, 0, -61, 0, 1385, 0, -50521]\n    >>> [euler(n) for n in range(11)]\n    [1, 0, -1, 0, 5, 0, -61, 0, 1385, 0, -50521]\n    >>> [andre_poly(n-1, 1) * n / (4**n - 2**n) for n in range(1, 11)]\n    [1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66]\n    >>> [bernoulli(n) for n in range(1, 11)]\n    [1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66]\n    >>> [-andre_poly(n-1, -1) * n / (-2)**(n-1) for n in range(1, 11)]\n    [-1, -1, 0, 1, 0, -3, 0, 17, 0, -155]\n    >>> [genocchi(n) for n in range(1, 11)]\n    [-1, -1, 0, 1, 0, -3, 0, 17, 0, -155]\n\n    >>> [abs(andre_poly(n, n%2)) for n in range(11)]\n    [1, 1, 1, 2, 5, 16, 61, 272, 1385, 7936, 50521]\n\n    Parameters\n    ==========\n\n    n : int\n        Degree of the polynomial.\n    x : optional\n    polys : bool, optional\n        If True, return a Poly, otherwise (default) return an expression.\n\n    See Also\n    ========\n\n    sympy.functions.combinatorial.numbers.andre\n\n    References\n    ==========\n\n    .. [1] Peter Luschny, \"An introduction to the Bernoulli function\",\n           https://arxiv.org/abs/2009.06743\n    ",
    "section": "Appell sequences",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "together",
    "full_id": "sympy.polys.rationaltools.together",
    "type": "function",
    "description": "\n    Denest and combine rational expressions using symbolic methods.\n\n    This function takes an expression or a container of expressions\n    and puts it (them) together by denesting and combining rational\n    subexpressions. No heroic measures are taken to minimize degree\n    of the resulting numerator and denominator. To obtain completely\n    reduced expression use :func:`~.cancel`. However, :func:`~.together`\n    can preserve as much as possible of the structure of the input\n    expression in the output (no expansion is performed).\n\n    A wide variety of objects can be put together including lists,\n    tuples, sets, relational objects, integrals and others. It is\n    also possible to transform interior of function applications,\n    by setting ``deep`` flag to ``True``.\n\n    By definition, :func:`~.together` is a complement to :func:`~.apart`,\n    so ``apart(together(expr))`` should return expr unchanged. Note\n    however, that :func:`~.together` uses only symbolic methods, so\n    it might be necessary to use :func:`~.cancel` to perform algebraic\n    simplification and minimize degree of the numerator and denominator.\n\n    Examples\n    ========\n\n    >>> from sympy import together, exp\n    >>> from sympy.abc import x, y, z\n\n    >>> together(1/x + 1/y)\n    (x + y)/(x*y)\n    >>> together(1/x + 1/y + 1/z)\n    (x*y + x*z + y*z)/(x*y*z)\n\n    >>> together(1/(x*y) + 1/y**2)\n    (x + y)/(x*y**2)\n\n    >>> together(1/(1 + 1/x) + 1/(1 + 1/y))\n    (x*(y + 1) + y*(x + 1))/((x + 1)*(y + 1))\n\n    >>> together(exp(1/x + 1/y))\n    exp(1/y + 1/x)\n    >>> together(exp(1/x + 1/y), deep=True)\n    exp((x + y)/(x*y))\n\n    >>> together(1/exp(x) + 1/(x*exp(x)))\n    (x + 1)*exp(-x)/x\n\n    >>> together(1/exp(2*x) + 1/(x*exp(3*x)))\n    (x*exp(x) + 1)*exp(-3*x)/x\n\n    ",
    "section": "Manipulation of rational functions",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "apart",
    "full_id": "sympy.polys.partfrac.apart",
    "type": "function",
    "description": "\n    Compute partial fraction decomposition of a rational function.\n\n    Given a rational function ``f``, computes the partial fraction\n    decomposition of ``f``. Two algorithms are available: One is based on the\n    undertermined coefficients method, the other is Bronstein's full partial\n    fraction decomposition algorithm.\n\n    The undetermined coefficients method (selected by ``full=False``) uses\n    polynomial factorization (and therefore accepts the same options as\n    factor) for the denominator. Per default it works over the rational\n    numbers, therefore decomposition of denominators with non-rational roots\n    (e.g. irrational, complex roots) is not supported by default (see options\n    of factor).\n\n    Bronstein's algorithm can be selected by using ``full=True`` and allows a\n    decomposition of denominators with non-rational roots. A human-readable\n    result can be obtained via ``doit()`` (see examples below).\n\n    Examples\n    ========\n\n    >>> from sympy.polys.partfrac import apart\n    >>> from sympy.abc import x, y\n\n    By default, using the undetermined coefficients method:\n\n    >>> apart(y/(x + 2)/(x + 1), x)\n    -y/(x + 2) + y/(x + 1)\n\n    The undetermined coefficients method does not provide a result when the\n    denominators roots are not rational:\n\n    >>> apart(y/(x**2 + x + 1), x)\n    y/(x**2 + x + 1)\n\n    You can choose Bronstein's algorithm by setting ``full=True``:\n\n    >>> apart(y/(x**2 + x + 1), x, full=True)\n    RootSum(_w**2 + _w + 1, Lambda(_a, (-2*_a*y/3 - y/3)/(-_a + x)))\n\n    Calling ``doit()`` yields a human-readable result:\n\n    >>> apart(y/(x**2 + x + 1), x, full=True).doit()\n    (-y/3 - 2*y*(-1/2 - sqrt(3)*I/2)/3)/(x + 1/2 + sqrt(3)*I/2) + (-y/3 -\n        2*y*(-1/2 + sqrt(3)*I/2)/3)/(x + 1/2 - sqrt(3)*I/2)\n\n\n    See Also\n    ========\n\n    apart_list, assemble_partfrac_list\n    ",
    "section": "Partial fraction decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "apart_list",
    "full_id": "sympy.polys.partfrac.apart_list",
    "type": "function",
    "description": "\n    Compute partial fraction decomposition of a rational function\n    and return the result in structured form.\n\n    Given a rational function ``f`` compute the partial fraction decomposition\n    of ``f``. Only Bronstein's full partial fraction decomposition algorithm\n    is supported by this method. The return value is highly structured and\n    perfectly suited for further algorithmic treatment rather than being\n    human-readable. The function returns a tuple holding three elements:\n\n    * The first item is the common coefficient, free of the variable `x` used\n      for decomposition. (It is an element of the base field `K`.)\n\n    * The second item is the polynomial part of the decomposition. This can be\n      the zero polynomial. (It is an element of `K[x]`.)\n\n    * The third part itself is a list of quadruples. Each quadruple\n      has the following elements in this order:\n\n      - The (not necessarily irreducible) polynomial `D` whose roots `w_i` appear\n        in the linear denominator of a bunch of related fraction terms. (This item\n        can also be a list of explicit roots. However, at the moment ``apart_list``\n        never returns a result this way, but the related ``assemble_partfrac_list``\n        function accepts this format as input.)\n\n      - The numerator of the fraction, written as a function of the root `w`\n\n      - The linear denominator of the fraction *excluding its power exponent*,\n        written as a function of the root `w`.\n\n      - The power to which the denominator has to be raised.\n\n    On can always rebuild a plain expression by using the function ``assemble_partfrac_list``.\n\n    Examples\n    ========\n\n    A first example:\n\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\n    >>> from sympy.abc import x, t\n\n    >>> f = (2*x**3 - 2*x) / (x**2 - 2*x + 1)\n    >>> pfd = apart_list(f)\n    >>> pfd\n    (1,\n    Poly(2*x + 4, x, domain='ZZ'),\n    [(Poly(_w - 1, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    2*x + 4 + 4/(x - 1)\n\n    Second example:\n\n    >>> f = (-2*x - 2*x**2) / (3*x**2 - 6*x)\n    >>> pfd = apart_list(f)\n    >>> pfd\n    (-1,\n    Poly(2/3, x, domain='QQ'),\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 2), Lambda(_a, -_a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    -2/3 - 2/(x - 2)\n\n    Another example, showing symbolic parameters:\n\n    >>> pfd = apart_list(t/(x**2 + x + t), x)\n    >>> pfd\n    (1,\n    Poly(0, x, domain='ZZ[t]'),\n    [(Poly(_w**2 + _w + t, _w, domain='ZZ[t]'),\n    Lambda(_a, -2*_a*t/(4*t - 1) - t/(4*t - 1)),\n    Lambda(_a, -_a + x),\n    1)])\n\n    >>> assemble_partfrac_list(pfd)\n    RootSum(_w**2 + _w + t, Lambda(_a, (-2*_a*t/(4*t - 1) - t/(4*t - 1))/(-_a + x)))\n\n    This example is taken from Bronstein's original paper:\n\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\n    >>> pfd = apart_list(f)\n    >>> pfd\n    (1,\n    Poly(0, x, domain='ZZ'),\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\n    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\n    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\n\n    See also\n    ========\n\n    apart, assemble_partfrac_list\n\n    References\n    ==========\n\n    .. [1] [Bronstein93]_\n\n    ",
    "section": "Partial fraction decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "assemble_partfrac_list",
    "full_id": "sympy.polys.partfrac.assemble_partfrac_list",
    "type": "function",
    "description": "Reassemble a full partial fraction decomposition\n    from a structured result obtained by the function ``apart_list``.\n\n    Examples\n    ========\n\n    This example is taken from Bronstein's original paper:\n\n    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\n    >>> from sympy.abc import x\n\n    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\n    >>> pfd = apart_list(f)\n    >>> pfd\n    (1,\n    Poly(0, x, domain='ZZ'),\n    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\n    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\n    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\n\n    If we happen to know some roots we can provide them easily inside the structure:\n\n    >>> pfd = apart_list(2/(x**2-2))\n    >>> pfd\n    (1,\n    Poly(0, x, domain='ZZ'),\n    [(Poly(_w**2 - 2, _w, domain='ZZ'),\n    Lambda(_a, _a/2),\n    Lambda(_a, -_a + x),\n    1)])\n\n    >>> pfda = assemble_partfrac_list(pfd)\n    >>> pfda\n    RootSum(_w**2 - 2, Lambda(_a, _a/(-_a + x)))/2\n\n    >>> pfda.doit()\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\n\n    >>> from sympy import Dummy, Poly, Lambda, sqrt\n    >>> a = Dummy(\"a\")\n    >>> pfd = (1, Poly(0, x, domain='ZZ'), [([sqrt(2),-sqrt(2)], Lambda(a, a/2), Lambda(a, -a + x), 1)])\n\n    >>> assemble_partfrac_list(pfd)\n    -sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2)))\n\n    See Also\n    ========\n\n    apart, apart_list\n    ",
    "section": "Partial fraction decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "dispersionset",
    "full_id": "sympy.polys.dispersion.dispersionset",
    "type": "function",
    "description": "Compute the *dispersion set* of two polynomials.\n\n    For two polynomials `f(x)` and `g(x)` with `\\deg f > 0`\n    and `\\deg g > 0` the dispersion set `\\operatorname{J}(f, g)` is defined as:\n\n    .. math::\n        \\operatorname{J}(f, g)\n        & := \\{a \\in \\mathbb{N}_0 | \\gcd(f(x), g(x+a)) \\neq 1\\} \\\\\n        &  = \\{a \\in \\mathbb{N}_0 | \\deg \\gcd(f(x), g(x+a)) \\geq 1\\}\n\n    For a single polynomial one defines `\\operatorname{J}(f) := \\operatorname{J}(f, f)`.\n\n    Examples\n    ========\n\n    >>> from sympy import poly\n    >>> from sympy.polys.dispersion import dispersion, dispersionset\n    >>> from sympy.abc import x\n\n    Dispersion set and dispersion of a simple polynomial:\n\n    >>> fp = poly((x - 3)*(x + 3), x)\n    >>> sorted(dispersionset(fp))\n    [0, 6]\n    >>> dispersion(fp)\n    6\n\n    Note that the definition of the dispersion is not symmetric:\n\n    >>> fp = poly(x**4 - 3*x**2 + 1, x)\n    >>> gp = fp.shift(-3)\n    >>> sorted(dispersionset(fp, gp))\n    [2, 3, 4]\n    >>> dispersion(fp, gp)\n    4\n    >>> sorted(dispersionset(gp, fp))\n    []\n    >>> dispersion(gp, fp)\n    -oo\n\n    Computing the dispersion also works over field extensions:\n\n    >>> from sympy import sqrt\n    >>> fp = poly(x**2 + sqrt(5)*x - 1, x, domain='QQ<sqrt(5)>')\n    >>> gp = poly(x**2 + (2 + sqrt(5))*x + sqrt(5), x, domain='QQ<sqrt(5)>')\n    >>> sorted(dispersionset(fp, gp))\n    [2]\n    >>> sorted(dispersionset(gp, fp))\n    [1, 4]\n\n    We can even perform the computations for polynomials\n    having symbolic coefficients:\n\n    >>> from sympy.abc import a\n    >>> fp = poly(4*x**4 + (4*a + 8)*x**3 + (a**2 + 6*a + 4)*x**2 + (a**2 + 2*a)*x, x)\n    >>> sorted(dispersionset(fp))\n    [0, 1]\n\n    See Also\n    ========\n\n    dispersion\n\n    References\n    ==========\n\n    .. [1] [ManWright94]_\n    .. [2] [Koepf98]_\n    .. [3] [Abramov71]_\n    .. [4] [Man93]_\n    ",
    "section": "Dispersion of Polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "dispersion",
    "full_id": "sympy.polys.dispersion.dispersion",
    "type": "function",
    "description": "Compute the *dispersion* of polynomials.\n\n    For two polynomials `f(x)` and `g(x)` with `\\deg f > 0`\n    and `\\deg g > 0` the dispersion `\\operatorname{dis}(f, g)` is defined as:\n\n    .. math::\n        \\operatorname{dis}(f, g)\n        & := \\max\\{ J(f,g) \\cup \\{0\\} \\} \\\\\n        &  = \\max\\{ \\{a \\in \\mathbb{N} | \\gcd(f(x), g(x+a)) \\neq 1\\} \\cup \\{0\\} \\}\n\n    and for a single polynomial `\\operatorname{dis}(f) := \\operatorname{dis}(f, f)`.\n    Note that we make the definition `\\max\\{\\} := -\\infty`.\n\n    Examples\n    ========\n\n    >>> from sympy import poly\n    >>> from sympy.polys.dispersion import dispersion, dispersionset\n    >>> from sympy.abc import x\n\n    Dispersion set and dispersion of a simple polynomial:\n\n    >>> fp = poly((x - 3)*(x + 3), x)\n    >>> sorted(dispersionset(fp))\n    [0, 6]\n    >>> dispersion(fp)\n    6\n\n    Note that the definition of the dispersion is not symmetric:\n\n    >>> fp = poly(x**4 - 3*x**2 + 1, x)\n    >>> gp = fp.shift(-3)\n    >>> sorted(dispersionset(fp, gp))\n    [2, 3, 4]\n    >>> dispersion(fp, gp)\n    4\n    >>> sorted(dispersionset(gp, fp))\n    []\n    >>> dispersion(gp, fp)\n    -oo\n\n    The maximum of an empty set is defined to be `-\\infty`\n    as seen in this example.\n\n    Computing the dispersion also works over field extensions:\n\n    >>> from sympy import sqrt\n    >>> fp = poly(x**2 + sqrt(5)*x - 1, x, domain='QQ<sqrt(5)>')\n    >>> gp = poly(x**2 + (2 + sqrt(5))*x + sqrt(5), x, domain='QQ<sqrt(5)>')\n    >>> sorted(dispersionset(fp, gp))\n    [2]\n    >>> sorted(dispersionset(gp, fp))\n    [1, 4]\n\n    We can even perform the computations for polynomials\n    having symbolic coefficients:\n\n    >>> from sympy.abc import a\n    >>> fp = poly(4*x**4 + (4*a + 8)*x**3 + (a**2 + 6*a + 4)*x**2 + (a**2 + 2*a)*x, x)\n    >>> sorted(dispersionset(fp))\n    [0, 1]\n\n    See Also\n    ========\n\n    dispersionset\n\n    References\n    ==========\n\n    .. [1] [ManWright94]_\n    .. [2] [Koepf98]_\n    .. [3] [Abramov71]_\n    .. [4] [Man93]_\n    ",
    "section": "Dispersion of Polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/reference.html"
  },
  {
    "name": "free_module",
    "full_id": "sympy.polys.domains.ring.Ring.free_module",
    "type": "method",
    "description": "\n        Generate a free module of rank ``rank`` over self.\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).free_module(2)\n        QQ[x]**2\n        ",
    "section": "Base Rings",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "ideal",
    "full_id": "sympy.polys.domains.ring.Ring.ideal",
    "type": "method",
    "description": "\n        Generate an ideal of ``self``.\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).ideal(x**2)\n        <x**2>\n        ",
    "section": "Base Rings",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "quotient_ring",
    "full_id": "sympy.polys.domains.ring.Ring.quotient_ring",
    "type": "method",
    "description": "\n        Form a quotient ring of ``self``.\n\n        Here ``e`` can be an ideal or an iterable.\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).quotient_ring(QQ.old_poly_ring(x).ideal(x**2))\n        QQ[x]/<x**2>\n        >>> QQ.old_poly_ring(x).quotient_ring([x**2])\n        QQ[x]/<x**2>\n\n        The division operator has been overloaded for this:\n\n        >>> QQ.old_poly_ring(x)/[x**2]\n        QQ[x]/<x**2>\n        ",
    "section": "Base Rings",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "PolynomialRing",
    "full_id": "sympy.polys.domains.polynomialring.PolynomialRing",
    "type": "function",
    "description": "A class for representing multivariate polynomial rings.",
    "section": "Base Rings",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.polys.agca.modules.Module.contains",
    "type": "method",
    "description": "Return True if ``elem`` is an element of this module.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "convert",
    "full_id": "sympy.polys.agca.modules.Module.convert",
    "type": "method",
    "description": "\n        Convert ``elem`` into internal representation of this module.\n\n        If ``M`` is not None, it should be a module containing it.\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "identity_hom",
    "full_id": "sympy.polys.agca.modules.Module.identity_hom",
    "type": "method",
    "description": "Return the identity homomorphism on ``self``.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_submodule",
    "full_id": "sympy.polys.agca.modules.Module.is_submodule",
    "type": "method",
    "description": "Returns True if ``other`` is a submodule of ``self``.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.agca.modules.Module.is_zero",
    "type": "method",
    "description": "Returns True if ``self`` is a zero module.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "multiply_ideal",
    "full_id": "sympy.polys.agca.modules.Module.multiply_ideal",
    "type": "method",
    "description": "\n        Multiply ``self`` by the ideal ``other``.\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "quotient_module",
    "full_id": "sympy.polys.agca.modules.Module.quotient_module",
    "type": "method",
    "description": "Generate a quotient module.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "submodule",
    "full_id": "sympy.polys.agca.modules.Module.submodule",
    "type": "method",
    "description": "Generate a submodule.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "subset",
    "full_id": "sympy.polys.agca.modules.Module.subset",
    "type": "method",
    "description": "\n        Returns True if ``other`` is is a subset of ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> F.subset([(1, x), (x, 2)])\n        True\n        >>> F.subset([(1/x, x), (x, 2)])\n        False\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "basis",
    "full_id": "sympy.polys.agca.modules.FreeModule.basis",
    "type": "method",
    "description": "\n        Return a set of basis elements.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).free_module(3).basis()\n        ([1, 0, 0], [0, 1, 0], [0, 0, 1])\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "convert",
    "full_id": "sympy.polys.agca.modules.FreeModule.convert",
    "type": "method",
    "description": "\n        Convert ``elem`` into the internal representation.\n\n        This method is called implicitly whenever computations involve elements\n        not in the internal representation.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> F.convert([1, 0])\n        [1, 0]\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "identity_hom",
    "full_id": "sympy.polys.agca.modules.FreeModule.identity_hom",
    "type": "method",
    "description": "\n        Return the identity homomorphism on ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).free_module(2).identity_hom()\n        Matrix([\n        [1, 0], : QQ[x]**2 -> QQ[x]**2\n        [0, 1]])\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_submodule",
    "full_id": "sympy.polys.agca.modules.FreeModule.is_submodule",
    "type": "method",
    "description": "\n        Returns True if ``other`` is a submodule of ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> M = F.submodule([2, x])\n        >>> F.is_submodule(F)\n        True\n        >>> F.is_submodule(M)\n        True\n        >>> M.is_submodule(F)\n        False\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.agca.modules.FreeModule.is_zero",
    "type": "method",
    "description": "\n        Returns True if ``self`` is a zero module.\n\n        (If, as this implementation assumes, the coefficient ring is not the\n        zero ring, then this is equivalent to the rank being zero.)\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).free_module(0).is_zero()\n        True\n        >>> QQ.old_poly_ring(x).free_module(1).is_zero()\n        False\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "multiply_ideal",
    "full_id": "sympy.polys.agca.modules.FreeModule.multiply_ideal",
    "type": "method",
    "description": "\n        Multiply ``self`` by the ideal ``other``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> I = QQ.old_poly_ring(x).ideal(x)\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> F.multiply_ideal(I)\n        <[x, 0], [0, x]>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "quotient_module",
    "full_id": "sympy.polys.agca.modules.FreeModule.quotient_module",
    "type": "method",
    "description": "\n        Return a quotient module.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> M = QQ.old_poly_ring(x).free_module(2)\n        >>> M.quotient_module(M.submodule([1, x], [x, 2]))\n        QQ[x]**2/<[1, x], [x, 2]>\n\n        Or more conicisely, using the overloaded division operator:\n\n        >>> QQ.old_poly_ring(x).free_module(2) / [[1, x], [x, 2]]\n        QQ[x]**2/<[1, x], [x, 2]>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "convert",
    "full_id": "sympy.polys.agca.modules.SubModule.convert",
    "type": "method",
    "description": "\n        Convert ``elem`` into the internal represantition.\n\n        Mostly called implicitly.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> M = QQ.old_poly_ring(x).free_module(2).submodule([1, x])\n        >>> M.convert([2, 2*x])\n        [2, 2*x]\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "identity_hom",
    "full_id": "sympy.polys.agca.modules.SubModule.identity_hom",
    "type": "method",
    "description": "\n        Return the identity homomorphism on ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).free_module(2).submodule([x, x]).identity_hom()\n        Matrix([\n        [1, 0], : <[x, x]> -> <[x, x]>\n        [0, 1]])\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "in_terms_of_generators",
    "full_id": "sympy.polys.agca.modules.SubModule.in_terms_of_generators",
    "type": "method",
    "description": "\n        Express element ``e`` of ``self`` in terms of the generators.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> M = F.submodule([1, 0], [1, 1])\n        >>> M.in_terms_of_generators([x, x**2])  # doctest: +SKIP\n        [DMP_Python([-1, 1, 0], QQ), DMP_Python([1, 0, 0], QQ)]\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "inclusion_hom",
    "full_id": "sympy.polys.agca.modules.SubModule.inclusion_hom",
    "type": "method",
    "description": "\n        Return a homomorphism representing the inclusion map of ``self``.\n\n        That is, the natural map from ``self`` to ``self.container``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).free_module(2).submodule([x, x]).inclusion_hom()\n        Matrix([\n        [1, 0], : <[x, x]> -> QQ[x]**2\n        [0, 1]])\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "intersect",
    "full_id": "sympy.polys.agca.modules.SubModule.intersect",
    "type": "method",
    "description": "\n        Returns the intersection of ``self`` with submodule ``other``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x, y).free_module(2)\n        >>> F.submodule([x, x]).intersect(F.submodule([y, y]))\n        <[x*y, x*y]>\n\n        Some implementation allow further options to be passed. Currently, to\n        only one implemented is ``relations=True``, in which case the function\n        will return a triple ``(res, rela, relb)``, where ``res`` is the\n        intersection module, and ``rela`` and ``relb`` are lists of coefficient\n        vectors, expressing the generators of ``res`` in terms of the\n        generators of ``self`` (``rela``) and ``other`` (``relb``).\n\n        >>> F.submodule([x, x]).intersect(F.submodule([y, y]), relations=True)\n        (<[x*y, x*y]>, [(DMP_Python([[1, 0]], QQ),)], [(DMP_Python([[1], []], QQ),)])\n\n        The above result says: the intersection module is generated by the\n        single element `(-xy, -xy) = -y (x, x) = -x (y, y)`, where\n        `(x, x)` and `(y, y)` respectively are the unique generators of\n        the two modules being intersected.\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_full_module",
    "full_id": "sympy.polys.agca.modules.SubModule.is_full_module",
    "type": "method",
    "description": "\n        Return True if ``self`` is the entire free module.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> F.submodule([x, 1]).is_full_module()\n        False\n        >>> F.submodule([1, 1], [1, 2]).is_full_module()\n        True\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_submodule",
    "full_id": "sympy.polys.agca.modules.SubModule.is_submodule",
    "type": "method",
    "description": "\n        Returns True if ``other`` is a submodule of ``self``.\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> M = F.submodule([2, x])\n        >>> N = M.submodule([2*x, x**2])\n        >>> M.is_submodule(M)\n        True\n        >>> M.is_submodule(N)\n        True\n        >>> N.is_submodule(M)\n        False\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.agca.modules.SubModule.is_zero",
    "type": "method",
    "description": "\n        Return True if ``self`` is a zero module.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> F.submodule([x, 1]).is_zero()\n        False\n        >>> F.submodule([0, 0]).is_zero()\n        True\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "module_quotient",
    "full_id": "sympy.polys.agca.modules.SubModule.module_quotient",
    "type": "method",
    "description": "\n        Returns the module quotient of ``self`` by submodule ``other``.\n\n        That is, if ``self`` is the module `M` and ``other`` is `N`, then\n        return the ideal `\\{f \\in R | fN \\subset M\\}`.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x, y\n        >>> F = QQ.old_poly_ring(x, y).free_module(2)\n        >>> S = F.submodule([x*y, x*y])\n        >>> T = F.submodule([x, x])\n        >>> S.module_quotient(T)\n        <y>\n\n        Some implementations allow further options to be passed. Currently, the\n        only one implemented is ``relations=True``, which may only be passed\n        if ``other`` is principal. In this case the function\n        will return a pair ``(res, rel)`` where ``res`` is the ideal, and\n        ``rel`` is a list of coefficient vectors, expressing the generators of\n        the ideal, multiplied by the generator of ``other`` in terms of\n        generators of ``self``.\n\n        >>> S.module_quotient(T, relations=True)\n        (<y>, [[DMP_Python([[1]], QQ)]])\n\n        This means that the quotient ideal is generated by the single element\n        `y`, and that `y (x, x) = 1 (xy, xy)`, `(x, x)` and `(xy, xy)` being\n        the generators of `T` and `S`, respectively.\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "multiply_ideal",
    "full_id": "sympy.polys.agca.modules.SubModule.multiply_ideal",
    "type": "method",
    "description": "\n        Multiply ``self`` by the ideal ``I``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> I = QQ.old_poly_ring(x).ideal(x**2)\n        >>> M = QQ.old_poly_ring(x).free_module(2).submodule([1, 1])\n        >>> I*M\n        <[x**2, x**2]>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "quotient_module",
    "full_id": "sympy.polys.agca.modules.SubModule.quotient_module",
    "type": "method",
    "description": "\n        Return a quotient module.\n\n        This is the same as taking a submodule of a quotient of the containing\n        module.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> S1 = F.submodule([x, 1])\n        >>> S2 = F.submodule([x**2, x])\n        >>> S1.quotient_module(S2)\n        <[x, 1] + <[x**2, x]>>\n\n        Or more coincisely, using the overloaded division operator:\n\n        >>> F.submodule([x, 1]) / [(x**2, x)]\n        <[x, 1] + <[x**2, x]>>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "reduce_element",
    "full_id": "sympy.polys.agca.modules.SubModule.reduce_element",
    "type": "method",
    "description": "\n        Reduce the element ``x`` of our ring modulo the ideal ``self``.\n\n        Here \"reduce\" has no specific meaning, it could return a unique normal\n        form, simplify the expression a bit, or just do nothing.\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "submodule",
    "full_id": "sympy.polys.agca.modules.SubModule.submodule",
    "type": "method",
    "description": "\n        Generate a submodule.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> M = QQ.old_poly_ring(x).free_module(2).submodule([x, 1])\n        >>> M.submodule([x**2, x])\n        <[x**2, x]>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "syzygy_module",
    "full_id": "sympy.polys.agca.modules.SubModule.syzygy_module",
    "type": "method",
    "description": "\n        Compute the syzygy module of the generators of ``self``.\n\n        Suppose `M` is generated by `f_1, \\ldots, f_n` over the ring\n        `R`. Consider the homomorphism `\\phi: R^n \\to M`, given by\n        sending `(r_1, \\ldots, r_n) \\to r_1 f_1 + \\cdots + r_n f_n`.\n        The syzygy module is defined to be the kernel of `\\phi`.\n\n        Examples\n        ========\n\n        The syzygy module is zero iff the generators generate freely a free\n        submodule:\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).free_module(2).submodule([1, 0], [1, 1]).syzygy_module().is_zero()\n        True\n\n        A slightly more interesting example:\n\n        >>> M = QQ.old_poly_ring(x, y).free_module(2).submodule([x, 2*x], [y, 2*y])\n        >>> S = QQ.old_poly_ring(x, y).free_module(2).submodule([y, -x])\n        >>> M.syzygy_module() == S\n        True\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "union",
    "full_id": "sympy.polys.agca.modules.SubModule.union",
    "type": "method",
    "description": "\n        Returns the module generated by the union of ``self`` and ``other``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(1)\n        >>> M = F.submodule([x**2 + x]) # <x(x+1)>\n        >>> N = F.submodule([x**2 - 1]) # <(x-1)(x+1)>\n        >>> M.union(N) == F.submodule([x+1])\n        True\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "contains",
    "full_id": "sympy.polys.agca.ideals.Ideal.contains",
    "type": "method",
    "description": "\n        Return True if ``elem`` is an element of this ideal.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).ideal(x+1, x-1).contains(3)\n        True\n        >>> QQ.old_poly_ring(x).ideal(x**2, x**3).contains(x)\n        False\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "depth",
    "full_id": "sympy.polys.agca.ideals.Ideal.depth",
    "type": "method",
    "description": "Compute the depth of ``self``.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "height",
    "full_id": "sympy.polys.agca.ideals.Ideal.height",
    "type": "method",
    "description": "Compute the height of ``self``.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "intersect",
    "full_id": "sympy.polys.agca.ideals.Ideal.intersect",
    "type": "method",
    "description": "\n        Compute the intersection of self with ideal J.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import QQ\n        >>> R = QQ.old_poly_ring(x, y)\n        >>> R.ideal(x).intersect(R.ideal(y))\n        <x*y>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_maximal",
    "full_id": "sympy.polys.agca.ideals.Ideal.is_maximal",
    "type": "method",
    "description": "Return True if ``self`` is a maximal ideal.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_primary",
    "full_id": "sympy.polys.agca.ideals.Ideal.is_primary",
    "type": "method",
    "description": "Return True if ``self`` is a primary ideal.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_prime",
    "full_id": "sympy.polys.agca.ideals.Ideal.is_prime",
    "type": "method",
    "description": "Return True if ``self`` is a prime ideal.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_principal",
    "full_id": "sympy.polys.agca.ideals.Ideal.is_principal",
    "type": "method",
    "description": "Return True if ``self`` is a principal ideal.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_radical",
    "full_id": "sympy.polys.agca.ideals.Ideal.is_radical",
    "type": "method",
    "description": "Return True if ``self`` is a radical ideal.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_whole_ring",
    "full_id": "sympy.polys.agca.ideals.Ideal.is_whole_ring",
    "type": "method",
    "description": "Return True if ``self`` is the whole ring.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.agca.ideals.Ideal.is_zero",
    "type": "method",
    "description": "Return True if ``self`` is the zero ideal.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "product",
    "full_id": "sympy.polys.agca.ideals.Ideal.product",
    "type": "method",
    "description": "\n        Compute the ideal product of ``self`` and ``J``.\n\n        That is, compute the ideal generated by products `xy`, for `x` an element\n        of ``self`` and `y \\in J`.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x, y).ideal(x).product(QQ.old_poly_ring(x, y).ideal(y))\n        <x*y>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "quotient",
    "full_id": "sympy.polys.agca.ideals.Ideal.quotient",
    "type": "method",
    "description": "\n        Compute the ideal quotient of ``self`` by ``J``.\n\n        That is, if ``self`` is the ideal `I`, compute the set\n        `I : J = \\{x \\in R | xJ \\subset I \\}`.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x, y\n        >>> from sympy import QQ\n        >>> R = QQ.old_poly_ring(x, y)\n        >>> R.ideal(x*y).quotient(R.ideal(x))\n        <y>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "radical",
    "full_id": "sympy.polys.agca.ideals.Ideal.radical",
    "type": "method",
    "description": "Compute the radical of ``self``.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "reduce_element",
    "full_id": "sympy.polys.agca.ideals.Ideal.reduce_element",
    "type": "method",
    "description": "\n        Reduce the element ``x`` of our ring modulo the ideal ``self``.\n\n        Here \"reduce\" has no specific meaning: it could return a unique normal\n        form, simplify the expression a bit, or just do nothing.\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "saturate",
    "full_id": "sympy.polys.agca.ideals.Ideal.saturate",
    "type": "method",
    "description": "\n        Compute the ideal saturation of ``self`` by ``J``.\n\n        That is, if ``self`` is the ideal `I`, compute the set\n        `I : J^\\infty = \\{x \\in R | xJ^n \\subset I \\text{ for some } n\\}`.\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "subset",
    "full_id": "sympy.polys.agca.ideals.Ideal.subset",
    "type": "method",
    "description": "\n        Returns True if ``other`` is is a subset of ``self``.\n\n        Here ``other`` may be an ideal.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> I = QQ.old_poly_ring(x).ideal(x+1)\n        >>> I.subset([x**2 - 1, x**2 + 2*x + 1])\n        True\n        >>> I.subset([x**2 + 1, x + 1])\n        False\n        >>> I.subset(QQ.old_poly_ring(x).ideal(x**2 - 1))\n        True\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "union",
    "full_id": "sympy.polys.agca.ideals.Ideal.union",
    "type": "method",
    "description": "\n        Compute the ideal generated by the union of ``self`` and ``J``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> QQ.old_poly_ring(x).ideal(x**2 - 1).union(QQ.old_poly_ring(x).ideal((x+1)**2)) == QQ.old_poly_ring(x).ideal(x+1)\n        True\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "convert",
    "full_id": "sympy.polys.agca.modules.QuotientModule.convert",
    "type": "method",
    "description": "\n        Convert ``elem`` into the internal representation.\n\n        This method is called implicitly whenever computations involve elements\n        not in the internal representation.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2) / [(1, 2), (1, x)]\n        >>> F.convert([1, 0])\n        [1, 0] + <[1, 2], [1, x]>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "identity_hom",
    "full_id": "sympy.polys.agca.modules.QuotientModule.identity_hom",
    "type": "method",
    "description": "\n        Return the identity homomorphism on ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> M = QQ.old_poly_ring(x).free_module(2) / [(1, 2), (1, x)]\n        >>> M.identity_hom()\n        Matrix([\n        [1, 0], : QQ[x]**2/<[1, 2], [1, x]> -> QQ[x]**2/<[1, 2], [1, x]>\n        [0, 1]])\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_submodule",
    "full_id": "sympy.polys.agca.modules.QuotientModule.is_submodule",
    "type": "method",
    "description": "\n        Return True if ``other`` is a submodule of ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> Q = QQ.old_poly_ring(x).free_module(2) / [(x, x)]\n        >>> S = Q.submodule([1, 0])\n        >>> Q.is_submodule(S)\n        True\n        >>> S.is_submodule(Q)\n        False\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.agca.modules.QuotientModule.is_zero",
    "type": "method",
    "description": "\n        Return True if ``self`` is a zero module.\n\n        This happens if and only if the base module is the same as the\n        submodule being killed.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> (F/[(1, 0)]).is_zero()\n        False\n        >>> (F/[(1, 0), (0, 1)]).is_zero()\n        True\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "quotient_hom",
    "full_id": "sympy.polys.agca.modules.QuotientModule.quotient_hom",
    "type": "method",
    "description": "\n        Return the quotient homomorphism to ``self``.\n\n        That is, return a homomorphism representing the natural map from\n        ``self.base`` to ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> M = QQ.old_poly_ring(x).free_module(2) / [(1, 2), (1, x)]\n        >>> M.quotient_hom()\n        Matrix([\n        [1, 0], : QQ[x]**2 -> QQ[x]**2/<[1, 2], [1, x]>\n        [0, 1]])\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "submodule",
    "full_id": "sympy.polys.agca.modules.QuotientModule.submodule",
    "type": "method",
    "description": "\n        Generate a submodule.\n\n        This is the same as taking a quotient of a submodule of the base\n        module.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> Q = QQ.old_poly_ring(x).free_module(2) / [(x, x)]\n        >>> Q.submodule([x, 0])\n        <[x, 0] + <[x, x]>>\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "eq",
    "full_id": "sympy.polys.agca.modules.QuotientModuleElement.eq",
    "type": "method",
    "description": "Equality comparison.",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "quotient_hom",
    "full_id": "sympy.polys.agca.modules.SubQuotientModule.quotient_hom",
    "type": "method",
    "description": "\n        Return the quotient homomorphism to self.\n\n        That is, return the natural map from ``self.base`` to ``self``.\n\n        Examples\n        ========\n\n        >>> from sympy.abc import x\n        >>> from sympy import QQ\n        >>> M = (QQ.old_poly_ring(x).free_module(2) / [(1, x)]).submodule([1, 0])\n        >>> M.quotient_hom()\n        Matrix([\n        [1, 0], : <[1, 0], [1, x]> -> <[1, 0] + <[1, x]>, [1, x] + <[1, x]>>\n        [0, 1]])\n        ",
    "section": "Modules, Ideals and their Elementary Properties",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "homomorphism",
    "full_id": "sympy.polys.agca.homomorphisms.homomorphism",
    "type": "function",
    "description": "\n    Create a homomorphism object.\n\n    This function tries to build a homomorphism from ``domain`` to ``codomain``\n    via the matrix ``matrix``.\n\n    Examples\n    ========\n\n    >>> from sympy import QQ\n    >>> from sympy.abc import x\n    >>> from sympy.polys.agca import homomorphism\n\n    >>> R = QQ.old_poly_ring(x)\n    >>> T = R.free_module(2)\n\n    If ``domain`` is a free module generated by `e_1, \\ldots, e_n`, then\n    ``matrix`` should be an n-element iterable `(b_1, \\ldots, b_n)` where\n    the `b_i` are elements of ``codomain``. The constructed homomorphism is the\n    unique homomorphism sending `e_i` to `b_i`.\n\n    >>> F = R.free_module(2)\n    >>> h = homomorphism(F, T, [[1, x], [x**2, 0]])\n    >>> h\n    Matrix([\n    [1, x**2], : QQ[x]**2 -> QQ[x]**2\n    [x,    0]])\n    >>> h([1, 0])\n    [1, x]\n    >>> h([0, 1])\n    [x**2, 0]\n    >>> h([1, 1])\n    [x**2 + 1, x]\n\n    If ``domain`` is a submodule of a free module, them ``matrix`` determines\n    a homomoprhism from the containing free module to ``codomain``, and the\n    homomorphism returned is obtained by restriction to ``domain``.\n\n    >>> S = F.submodule([1, 0], [0, x])\n    >>> homomorphism(S, T, [[1, x], [x**2, 0]])\n    Matrix([\n    [1, x**2], : <[1, 0], [0, x]> -> QQ[x]**2\n    [x,    0]])\n\n    If ``domain`` is a (sub)quotient `N/K`, then ``matrix`` determines a\n    homomorphism from `N` to ``codomain``. If the kernel contains `K`, this\n    homomorphism descends to ``domain`` and is returned; otherwise an exception\n    is raised.\n\n    >>> homomorphism(S/[(1, 0)], T, [0, [x**2, 0]])\n    Matrix([\n    [0, x**2], : <[1, 0] + <[1, 0]>, [0, x] + <[1, 0]>, [1, 0] + <[1, 0]>> -> QQ[x]**2\n    [0,    0]])\n    >>> homomorphism(S/[(0, x)], T, [0, [x**2, 0]])\n    Traceback (most recent call last):\n    ...\n    ValueError: kernel <[1, 0], [0, 0]> must contain sm, got <[0,x]>\n\n    ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "image",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.image",
    "type": "method",
    "description": "\n        Compute the image of ``self``.\n\n        That is, if ``self`` is the homomorphism `\\phi: M \\to N`, then compute\n        `im(\\phi) = \\{\\phi(x) | x \\in M \\}`.  This is a submodule of `N`.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> homomorphism(F, F, [[1, 0], [x, 0]]).image() == F.submodule([1, 0])\n        True\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_injective",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.is_injective",
    "type": "method",
    "description": "\n        Return True if ``self`` is injective.\n\n        That is, check if the elements of the domain are mapped to the same\n        codomain element.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> h = homomorphism(F, F, [[1, 0], [x, 0]])\n        >>> h.is_injective()\n        False\n        >>> h.quotient_domain(h.kernel()).is_injective()\n        True\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_isomorphism",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.is_isomorphism",
    "type": "method",
    "description": "\n        Return True if ``self`` is an isomorphism.\n\n        That is, check if every element of the codomain has precisely one\n        preimage. Equivalently, ``self`` is both injective and surjective.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> h = homomorphism(F, F, [[1, 0], [x, 0]])\n        >>> h = h.restrict_codomain(h.image())\n        >>> h.is_isomorphism()\n        False\n        >>> h.quotient_domain(h.kernel()).is_isomorphism()\n        True\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_surjective",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.is_surjective",
    "type": "method",
    "description": "\n        Return True if ``self`` is surjective.\n\n        That is, check if every element of the codomain has at least one\n        preimage.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> h = homomorphism(F, F, [[1, 0], [x, 0]])\n        >>> h.is_surjective()\n        False\n        >>> h.restrict_codomain(h.image()).is_surjective()\n        True\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.is_zero",
    "type": "method",
    "description": "\n        Return True if ``self`` is a zero morphism.\n\n        That is, check if every element of the domain is mapped to zero\n        under self.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> h = homomorphism(F, F, [[1, 0], [x, 0]])\n        >>> h.is_zero()\n        False\n        >>> h.restrict_domain(F.submodule()).is_zero()\n        True\n        >>> h.quotient_codomain(h.image()).is_zero()\n        True\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "kernel",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.kernel",
    "type": "method",
    "description": "\n        Compute the kernel of ``self``.\n\n        That is, if ``self`` is the homomorphism `\\phi: M \\to N`, then compute\n        `ker(\\phi) = \\{x \\in M | \\phi(x) = 0\\}`.  This is a submodule of `M`.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> homomorphism(F, F, [[1, 0], [x, 0]]).kernel()\n        <[x, -1]>\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "quotient_codomain",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.quotient_codomain",
    "type": "method",
    "description": "\n        Return ``self`` with codomain replaced by ``codomain/sm``.\n\n        Here ``sm`` must be a submodule of ``self.codomain``.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> h = homomorphism(F, F, [[1, 0], [x, 0]])\n        >>> h\n        Matrix([\n        [1, x], : QQ[x]**2 -> QQ[x]**2\n        [0, 0]])\n        >>> h.quotient_codomain(F.submodule([1, 1]))\n        Matrix([\n        [1, x], : QQ[x]**2 -> QQ[x]**2/<[1, 1]>\n        [0, 0]])\n\n        This is the same as composing with the quotient map on the left:\n\n        >>> (F/[(1, 1)]).quotient_hom() * h\n        Matrix([\n        [1, x], : QQ[x]**2 -> QQ[x]**2/<[1, 1]>\n        [0, 0]])\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "quotient_domain",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.quotient_domain",
    "type": "method",
    "description": "\n        Return ``self`` with domain replaced by ``domain/sm``.\n\n        Here ``sm`` must be a submodule of ``self.kernel()``.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> h = homomorphism(F, F, [[1, 0], [x, 0]])\n        >>> h\n        Matrix([\n        [1, x], : QQ[x]**2 -> QQ[x]**2\n        [0, 0]])\n        >>> h.quotient_domain(F.submodule([-x, 1]))\n        Matrix([\n        [1, x], : QQ[x]**2/<[-x, 1]> -> QQ[x]**2\n        [0, 0]])\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "restrict_codomain",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.restrict_codomain",
    "type": "method",
    "description": "\n        Return ``self``, with codomain restricted to to ``sm``.\n\n        Here ``sm`` has to be a submodule of ``self.codomain`` containing the\n        image.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> h = homomorphism(F, F, [[1, 0], [x, 0]])\n        >>> h\n        Matrix([\n        [1, x], : QQ[x]**2 -> QQ[x]**2\n        [0, 0]])\n        >>> h.restrict_codomain(F.submodule([1, 0]))\n        Matrix([\n        [1, x], : QQ[x]**2 -> <[1, 0]>\n        [0, 0]])\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "restrict_domain",
    "full_id": "sympy.polys.agca.homomorphisms.ModuleHomomorphism.restrict_domain",
    "type": "method",
    "description": "\n        Return ``self``, with the domain restricted to ``sm``.\n\n        Here ``sm`` has to be a submodule of ``self.domain``.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.agca import homomorphism\n\n        >>> F = QQ.old_poly_ring(x).free_module(2)\n        >>> h = homomorphism(F, F, [[1, 0], [x, 0]])\n        >>> h\n        Matrix([\n        [1, x], : QQ[x]**2 -> QQ[x]**2\n        [0, 0]])\n        >>> h.restrict_domain(F.submodule([1, 0]))\n        Matrix([\n        [1, x], : <[1, 0]> -> QQ[x]**2\n        [0, 0]])\n\n        This is the same as just composing on the right with the submodule\n        inclusion:\n\n        >>> h * F.submodule([1, 0]).inclusion_hom()\n        Matrix([\n        [1, x], : <[1, 0]> -> QQ[x]**2\n        [0, 0]])\n        ",
    "section": "Module Homomorphisms and Syzygies",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "inverse",
    "full_id": "sympy.polys.agca.extensions.ExtensionElement.inverse",
    "type": "method",
    "description": "Multiplicative inverse.\n\n        Raises\n        ======\n\n        NotInvertible\n            If the element is a zero divisor.\n\n        ",
    "section": "Finite Extensions",
    "url": "https://docs.sympy.org/latest/modules/polys/agca.html"
  },
  {
    "name": "abs",
    "full_id": "sympy.polys.domains.domain.Domain.abs",
    "type": "method",
    "description": "Absolute value of ``a``, implies ``__abs__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.domains.domain.Domain.add",
    "type": "method",
    "description": "Sum of ``a`` and ``b``, implies ``__add__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "alg_field_from_poly",
    "full_id": "sympy.polys.domains.domain.Domain.alg_field_from_poly",
    "type": "method",
    "description": "\n        Convenience method to construct an algebraic extension on a root of a\n        polynomial, chosen by root index.\n\n        Parameters\n        ==========\n\n        poly : :py:class:`~.Poly`\n            The polynomial whose root generates the extension.\n        alias : str, optional (default=None)\n            Symbol name for the generator of the extension.\n            E.g. \"alpha\" or \"theta\".\n        root_index : int, optional (default=-1)\n            Specifies which root of the polynomial is desired. The ordering is\n            as defined by the :py:class:`~.ComplexRootOf` class. The default of\n            ``-1`` selects the most natural choice in the common cases of\n            quadratic and cyclotomic fields (the square root on the positive\n            real or imaginary axis, resp. $\\mathrm{e}^{2\\pi i/n}$).\n\n        Examples\n        ========\n\n        >>> from sympy import QQ, Poly\n        >>> from sympy.abc import x\n        >>> f = Poly(x**2 - 2)\n        >>> K = QQ.alg_field_from_poly(f)\n        >>> K.ext.minpoly == f\n        True\n        >>> g = Poly(8*x**3 - 6*x - 1)\n        >>> L = QQ.alg_field_from_poly(g, \"alpha\")\n        >>> L.ext.minpoly == g\n        True\n        >>> L.to_sympy(L([1, 1, 1]))\n        alpha**2 + alpha + 1\n\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "algebraic_field",
    "full_id": "sympy.polys.domains.domain.Domain.algebraic_field",
    "type": "method",
    "description": "Returns an algebraic field, i.e. `K(\\alpha, \\ldots)`.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "almosteq",
    "full_id": "sympy.polys.domains.domain.Domain.almosteq",
    "type": "method",
    "description": "Check if ``a`` and ``b`` are almost equal.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "characteristic",
    "full_id": "sympy.polys.domains.domain.Domain.characteristic",
    "type": "method",
    "description": "Return the characteristic of this domain.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "cofactors",
    "full_id": "sympy.polys.domains.domain.Domain.cofactors",
    "type": "method",
    "description": "Returns GCD and cofactors of ``a`` and ``b``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "convert",
    "full_id": "sympy.polys.domains.domain.Domain.convert",
    "type": "method",
    "description": "Convert ``element`` to ``self.dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "convert_from",
    "full_id": "sympy.polys.domains.domain.Domain.convert_from",
    "type": "method",
    "description": "Convert ``element`` to ``self.dtype`` given the base domain.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "cyclotomic_field",
    "full_id": "sympy.polys.domains.domain.Domain.cyclotomic_field",
    "type": "method",
    "description": "\n        Convenience method to construct a cyclotomic field.\n\n        Parameters\n        ==========\n\n        n : int\n            Construct the nth cyclotomic field.\n        ss : boolean, optional (default=False)\n            If True, append *n* as a subscript on the alias string.\n        alias : str, optional (default=\"zeta\")\n            Symbol name for the generator.\n        gen : :py:class:`~.Symbol`, optional (default=None)\n            Desired variable for the cyclotomic polynomial that defines the\n            field. If ``None``, a dummy variable will be used.\n        root_index : int, optional (default=-1)\n            Specifies which root of the polynomial is desired. The ordering is\n            as defined by the :py:class:`~.ComplexRootOf` class. The default of\n            ``-1`` selects the root $\\mathrm{e}^{2\\pi i/n}$.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ, latex\n        >>> K = QQ.cyclotomic_field(5)\n        >>> K.to_sympy(K([-1, 1]))\n        1 - zeta\n        >>> L = QQ.cyclotomic_field(7, True)\n        >>> a = L.to_sympy(L([-1, 1]))\n        >>> print(a)\n        1 - zeta7\n        >>> print(latex(a))\n        1 - \\zeta_{7}\n\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "denom",
    "full_id": "sympy.polys.domains.domain.Domain.denom",
    "type": "method",
    "description": "Returns denominator of ``a``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "div",
    "full_id": "sympy.polys.domains.domain.Domain.div",
    "type": "method",
    "description": "Quotient and remainder for *a* and *b*. Analogue of ``divmod(a, b)``\n\n        Explanation\n        ===========\n\n        This is essentially the same as ``divmod(a, b)`` except that is more\n        consistent when working over some :py:class:`~.Field` domains such as\n        :ref:`QQ`. When working over an arbitrary :py:class:`~.Domain` the\n        :py:meth:`~.Domain.div` method should be used instead of ``divmod``.\n\n        The key invariant is that if ``q, r = K.div(a, b)`` then\n        ``a == b*q + r``.\n\n        The result of ``K.div(a, b)`` is the same as the tuple\n        ``(K.quo(a, b), K.rem(a, b))`` except that if both quotient and\n        remainder are needed then it is more efficient to use\n        :py:meth:`~.Domain.div`.\n\n        Examples\n        ========\n\n        We can use ``K.div`` instead of ``divmod`` for floor division and\n        remainder.\n\n        >>> from sympy import ZZ, QQ\n        >>> ZZ.div(ZZ(5), ZZ(2))\n        (2, 1)\n\n        If ``K`` is a :py:class:`~.Field` then the division is always exact\n        with a remainder of :py:attr:`~.Domain.zero`.\n\n        >>> QQ.div(QQ(5), QQ(2))\n        (5/2, 0)\n\n        Parameters\n        ==========\n\n        a: domain element\n            The dividend\n        b: domain element\n            The divisor\n\n        Returns\n        =======\n\n        (q, r): tuple of domain elements\n            The quotient and remainder\n\n        Raises\n        ======\n\n        ZeroDivisionError: when the divisor is zero.\n\n        See also\n        ========\n\n        quo: Analogue of ``a // b``\n        rem: Analogue of ``a % b``\n        exquo: Analogue of ``a / b``\n\n        Notes\n        =====\n\n        If ``gmpy`` is installed then the ``gmpy.mpq`` type will be used as\n        the :py:attr:`~.Domain.dtype` for :ref:`QQ`. The ``gmpy.mpq`` type\n        defines ``divmod`` in a way that is undesirable so\n        :py:meth:`~.Domain.div` should be used instead of ``divmod``.\n\n        >>> a = QQ(1)\n        >>> b = QQ(3, 2)\n        >>> a               # doctest: +SKIP\n        mpq(1,1)\n        >>> b               # doctest: +SKIP\n        mpq(3,2)\n        >>> divmod(a, b)    # doctest: +SKIP\n        (mpz(0), mpq(1,1))\n        >>> QQ.div(a, b)    # doctest: +SKIP\n        (mpq(2,3), mpq(0,1))\n\n        Using ``//`` or ``%`` with :ref:`QQ` will lead to incorrect results so\n        :py:meth:`~.Domain.div` should be used instead.\n\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "drop",
    "full_id": "sympy.polys.domains.domain.Domain.drop",
    "type": "method",
    "description": "Drop generators from this domain.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "evalf",
    "full_id": "sympy.polys.domains.domain.Domain.evalf",
    "type": "method",
    "description": "Returns numerical approximation of ``a``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exquo",
    "full_id": "sympy.polys.domains.domain.Domain.exquo",
    "type": "method",
    "description": "Exact quotient of *a* and *b*. Analogue of ``a / b``.\n\n        Explanation\n        ===========\n\n        This is essentially the same as ``a / b`` except that an error will be\n        raised if the division is inexact (if there is any remainder) and the\n        result will always be a domain element. When working in a\n        :py:class:`~.Domain` that is not a :py:class:`~.Field` (e.g. :ref:`ZZ`\n        or :ref:`K[x]`) ``exquo`` should be used instead of ``/``.\n\n        The key invariant is that if ``q = K.exquo(a, b)`` (and ``exquo`` does\n        not raise an exception) then ``a == b*q``.\n\n        Examples\n        ========\n\n        We can use ``K.exquo`` instead of ``/`` for exact division.\n\n        >>> from sympy import ZZ\n        >>> ZZ.exquo(ZZ(4), ZZ(2))\n        2\n        >>> ZZ.exquo(ZZ(5), ZZ(2))\n        Traceback (most recent call last):\n            ...\n        ExactQuotientFailed: 2 does not divide 5 in ZZ\n\n        Over a :py:class:`~.Field` such as :ref:`QQ`, division (with nonzero\n        divisor) is always exact so in that case ``/`` can be used instead of\n        :py:meth:`~.Domain.exquo`.\n\n        >>> from sympy import QQ\n        >>> QQ.exquo(QQ(5), QQ(2))\n        5/2\n        >>> QQ(5) / QQ(2)\n        5/2\n\n        Parameters\n        ==========\n\n        a: domain element\n            The dividend\n        b: domain element\n            The divisor\n\n        Returns\n        =======\n\n        q: domain element\n            The exact quotient\n\n        Raises\n        ======\n\n        ExactQuotientFailed: if exact division is not possible.\n        ZeroDivisionError: when the divisor is zero.\n\n        See also\n        ========\n\n        quo: Analogue of ``a // b``\n        rem: Analogue of ``a % b``\n        div: Analogue of ``divmod(a, b)``\n\n        Notes\n        =====\n\n        Since the default :py:attr:`~.Domain.dtype` for :ref:`ZZ` is ``int``\n        (or ``mpz``) division as ``a / b`` should not be used as it would give\n        a ``float`` which is not a domain element.\n\n        >>> ZZ(4) / ZZ(2) # doctest: +SKIP\n        2.0\n        >>> ZZ(5) / ZZ(2) # doctest: +SKIP\n        2.5\n\n        On the other hand with `SYMPY_GROUND_TYPES=flint` elements of :ref:`ZZ`\n        are ``flint.fmpz`` and division would raise an exception:\n\n        >>> ZZ(4) / ZZ(2) # doctest: +SKIP\n        Traceback (most recent call last):\n        ...\n        TypeError: unsupported operand type(s) for /: 'fmpz' and 'fmpz'\n\n        Using ``/`` with :ref:`ZZ` will lead to incorrect results so\n        :py:meth:`~.Domain.exquo` should be used instead.\n\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exsqrt",
    "full_id": "sympy.polys.domains.domain.Domain.exsqrt",
    "type": "method",
    "description": "Principal square root of a within the domain if ``a`` is square.\n\n        Explanation\n        ===========\n        The implementation of this method should return an element ``b`` in the\n        domain such that ``b * b == a``, or ``None`` if there is no such ``b``.\n        For inexact domains like :ref:`RR` and :ref:`CC`, a tiny difference in\n        this equality can be tolerated. The choice of a \"principal\" square root\n        should follow a consistent rule whenever possible.\n\n        See also\n        ========\n        sqrt, is_square\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "frac_field",
    "full_id": "sympy.polys.domains.domain.Domain.frac_field",
    "type": "method",
    "description": "Returns a fraction field, i.e. `K(X)`.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_AlgebraicField",
    "full_id": "sympy.polys.domains.domain.Domain.from_AlgebraicField",
    "type": "method",
    "description": "Convert an algebraic number to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ComplexField",
    "full_id": "sympy.polys.domains.domain.Domain.from_ComplexField",
    "type": "method",
    "description": "Convert a complex element to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ExpressionDomain",
    "full_id": "sympy.polys.domains.domain.Domain.from_ExpressionDomain",
    "type": "method",
    "description": "Convert a ``EX`` object to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_FF",
    "full_id": "sympy.polys.domains.domain.Domain.from_FF",
    "type": "method",
    "description": "Convert ``ModularInteger(int)`` to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_FF_gmpy",
    "full_id": "sympy.polys.domains.domain.Domain.from_FF_gmpy",
    "type": "method",
    "description": "Convert ``ModularInteger(mpz)`` to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_FractionField",
    "full_id": "sympy.polys.domains.domain.Domain.from_FractionField",
    "type": "method",
    "description": "Convert a rational function to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GlobalPolynomialRing",
    "full_id": "sympy.polys.domains.domain.Domain.from_GlobalPolynomialRing",
    "type": "method",
    "description": "Convert a polynomial to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_MonogenicFiniteExtension",
    "full_id": "sympy.polys.domains.domain.Domain.from_MonogenicFiniteExtension",
    "type": "method",
    "description": "Convert an ``ExtensionElement`` to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ_gmpy",
    "full_id": "sympy.polys.domains.domain.Domain.from_QQ_gmpy",
    "type": "method",
    "description": "Convert a GMPY ``mpq`` object to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ_python",
    "full_id": "sympy.polys.domains.domain.Domain.from_QQ_python",
    "type": "method",
    "description": "Convert a Python ``Fraction`` object to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_RealField",
    "full_id": "sympy.polys.domains.domain.Domain.from_RealField",
    "type": "method",
    "description": "Convert a real element object to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ_gmpy",
    "full_id": "sympy.polys.domains.domain.Domain.from_ZZ_gmpy",
    "type": "method",
    "description": "Convert a GMPY ``mpz`` object to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ_python",
    "full_id": "sympy.polys.domains.domain.Domain.from_ZZ_python",
    "type": "method",
    "description": "Convert a Python ``int`` object to ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_sympy",
    "full_id": "sympy.polys.domains.domain.Domain.from_sympy",
    "type": "method",
    "description": "Convert a SymPy expression to an element of this domain.\n\n        Explanation\n        ===========\n\n        See :py:meth:`~.Domain.to_sympy` for explanation and examples.\n\n        Parameters\n        ==========\n\n        expr: Expr\n            A normal SymPy expression of type :py:class:`~.Expr`.\n\n        Returns\n        =======\n\n        a: domain element\n            An element of this :py:class:`~.Domain`.\n\n        See also\n        ========\n\n        to_sympy\n        convert_from\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.polys.domains.domain.Domain.gcd",
    "type": "method",
    "description": "Returns GCD of ``a`` and ``b``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcdex",
    "full_id": "sympy.polys.domains.domain.Domain.gcdex",
    "type": "method",
    "description": "Extended GCD of ``a`` and ``b``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "get_exact",
    "full_id": "sympy.polys.domains.domain.Domain.get_exact",
    "type": "method",
    "description": "Returns an exact domain associated with ``self``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "get_field",
    "full_id": "sympy.polys.domains.domain.Domain.get_field",
    "type": "method",
    "description": "Returns a field associated with ``self``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "get_ring",
    "full_id": "sympy.polys.domains.domain.Domain.get_ring",
    "type": "method",
    "description": "Returns a ring associated with ``self``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "half_gcdex",
    "full_id": "sympy.polys.domains.domain.Domain.half_gcdex",
    "type": "method",
    "description": "Half extended GCD of ``a`` and ``b``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "inject",
    "full_id": "sympy.polys.domains.domain.Domain.inject",
    "type": "method",
    "description": "Inject generators into this domain.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "invert",
    "full_id": "sympy.polys.domains.domain.Domain.invert",
    "type": "method",
    "description": "Returns inversion of ``a mod b``, implies something.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_negative",
    "full_id": "sympy.polys.domains.domain.Domain.is_negative",
    "type": "method",
    "description": "Returns True if ``a`` is negative.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_nonnegative",
    "full_id": "sympy.polys.domains.domain.Domain.is_nonnegative",
    "type": "method",
    "description": "Returns True if ``a`` is non-negative.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_nonpositive",
    "full_id": "sympy.polys.domains.domain.Domain.is_nonpositive",
    "type": "method",
    "description": "Returns True if ``a`` is non-positive.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_one",
    "full_id": "sympy.polys.domains.domain.Domain.is_one",
    "type": "method",
    "description": "Returns True if ``a`` is one.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_positive",
    "full_id": "sympy.polys.domains.domain.Domain.is_positive",
    "type": "method",
    "description": "Returns True if ``a`` is positive.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_square",
    "full_id": "sympy.polys.domains.domain.Domain.is_square",
    "type": "method",
    "description": "Returns whether ``a`` is a square in the domain.\n\n        Explanation\n        ===========\n        Returns ``True`` if there is an element ``b`` in the domain such that\n        ``b * b == a``, otherwise returns ``False``. For inexact domains like\n        :ref:`RR` and :ref:`CC`, a tiny difference in this equality can be\n        tolerated.\n\n        See also\n        ========\n        exsqrt\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.domains.domain.Domain.is_zero",
    "type": "method",
    "description": "Returns True if ``a`` is zero.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.polys.domains.domain.Domain.lcm",
    "type": "method",
    "description": "Returns LCM of ``a`` and ``b``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "log",
    "full_id": "sympy.polys.domains.domain.Domain.log",
    "type": "method",
    "description": "Returns b-base logarithm of ``a``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "map",
    "full_id": "sympy.polys.domains.domain.Domain.map",
    "type": "method",
    "description": "Rersively apply ``self`` to all elements of ``seq``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.polys.domains.domain.Domain.mul",
    "type": "method",
    "description": "Product of ``a`` and ``b``, implies ``__mul__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "neg",
    "full_id": "sympy.polys.domains.domain.Domain.neg",
    "type": "method",
    "description": "Returns ``a`` negated, implies ``__neg__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "numer",
    "full_id": "sympy.polys.domains.domain.Domain.numer",
    "type": "method",
    "description": "Returns numerator of ``a``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "of_type",
    "full_id": "sympy.polys.domains.domain.Domain.of_type",
    "type": "method",
    "description": "Check if ``a`` is of type ``dtype``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "old_poly_ring",
    "full_id": "sympy.polys.domains.domain.Domain.old_poly_ring",
    "type": "method",
    "description": "Returns a polynomial ring, i.e. `K[X]`.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "pos",
    "full_id": "sympy.polys.domains.domain.Domain.pos",
    "type": "method",
    "description": "Returns ``a`` positive, implies ``__pos__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "pow",
    "full_id": "sympy.polys.domains.domain.Domain.pow",
    "type": "method",
    "description": "Raise ``a`` to power ``b``, implies ``__pow__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "quo",
    "full_id": "sympy.polys.domains.domain.Domain.quo",
    "type": "method",
    "description": "Quotient of *a* and *b*. Analogue of ``a // b``.\n\n        ``K.quo(a, b)`` is equivalent to ``K.div(a, b)[0]``. See\n        :py:meth:`~.Domain.div` for more explanation.\n\n        See also\n        ========\n\n        rem: Analogue of ``a % b``\n        div: Analogue of ``divmod(a, b)``\n        exquo: Analogue of ``a / b``\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "rem",
    "full_id": "sympy.polys.domains.domain.Domain.rem",
    "type": "method",
    "description": "Modulo division of *a* and *b*. Analogue of ``a % b``.\n\n        ``K.rem(a, b)`` is equivalent to ``K.div(a, b)[1]``. See\n        :py:meth:`~.Domain.div` for more explanation.\n\n        See also\n        ========\n\n        quo: Analogue of ``a // b``\n        div: Analogue of ``divmod(a, b)``\n        exquo: Analogue of ``a / b``\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "revert",
    "full_id": "sympy.polys.domains.domain.Domain.revert",
    "type": "method",
    "description": "Returns ``a**(-1)`` if possible.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sqrt",
    "full_id": "sympy.polys.domains.domain.Domain.sqrt",
    "type": "method",
    "description": "Returns a (possibly inexact) square root of ``a``.\n\n        Explanation\n        ===========\n        There is no universal definition of \"inexact square root\" for all\n        domains. It is not recommended to implement this method for domains\n        other then :ref:`ZZ`.\n\n        See also\n        ========\n        exsqrt\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sub",
    "full_id": "sympy.polys.domains.domain.Domain.sub",
    "type": "method",
    "description": "Difference of ``a`` and ``b``, implies ``__sub__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_sympy",
    "full_id": "sympy.polys.domains.domain.Domain.to_sympy",
    "type": "method",
    "description": "Convert domain element *a* to a SymPy expression (Expr).\n\n        Explanation\n        ===========\n\n        Convert a :py:class:`~.Domain` element *a* to :py:class:`~.Expr`. Most\n        public SymPy functions work with objects of type :py:class:`~.Expr`.\n        The elements of a :py:class:`~.Domain` have a different internal\n        representation. It is not possible to mix domain elements with\n        :py:class:`~.Expr` so each domain has :py:meth:`~.Domain.to_sympy` and\n        :py:meth:`~.Domain.from_sympy` methods to convert its domain elements\n        to and from :py:class:`~.Expr`.\n\n        Parameters\n        ==========\n\n        a: domain element\n            An element of this :py:class:`~.Domain`.\n\n        Returns\n        =======\n\n        expr: Expr\n            A normal SymPy expression of type :py:class:`~.Expr`.\n\n        Examples\n        ========\n\n        Construct an element of the :ref:`QQ` domain and then convert it to\n        :py:class:`~.Expr`.\n\n        >>> from sympy import QQ, Expr\n        >>> q_domain = QQ(2)\n        >>> q_domain\n        2\n        >>> q_expr = QQ.to_sympy(q_domain)\n        >>> q_expr\n        2\n\n        Although the printed forms look similar these objects are not of the\n        same type.\n\n        >>> isinstance(q_domain, Expr)\n        False\n        >>> isinstance(q_expr, Expr)\n        True\n\n        Construct an element of :ref:`K[x]` and convert to\n        :py:class:`~.Expr`.\n\n        >>> from sympy import Symbol\n        >>> x = Symbol('x')\n        >>> K = QQ[x]\n        >>> x_domain = K.gens[0]  # generator x as a domain element\n        >>> p_domain = x_domain**2/3 + 1\n        >>> p_domain\n        1/3*x**2 + 1\n        >>> p_expr = K.to_sympy(p_domain)\n        >>> p_expr\n        x**2/3 + 1\n\n        The :py:meth:`~.Domain.from_sympy` method is used for the opposite\n        conversion from a normal SymPy expression to a domain element.\n\n        >>> p_domain == p_expr\n        False\n        >>> K.from_sympy(p_expr) == p_domain\n        True\n        >>> K.to_sympy(p_domain) == p_expr\n        True\n        >>> K.from_sympy(K.to_sympy(p_domain)) == p_domain\n        True\n        >>> K.to_sympy(K.from_sympy(p_expr)) == p_expr\n        True\n\n        The :py:meth:`~.Domain.from_sympy` method makes it easier to construct\n        domain elements interactively.\n\n        >>> from sympy import Symbol\n        >>> x = Symbol('x')\n        >>> K = QQ[x]\n        >>> K.from_sympy(x**2/3 + 1)\n        1/3*x**2 + 1\n\n        See also\n        ========\n\n        from_sympy\n        convert_from\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "tp",
    "full_id": "sympy.polys.domains.domain.Domain.tp",
    "type": "property",
    "description": "Alias for :py:attr:`~.Domain.dtype`",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "unify",
    "full_id": "sympy.polys.domains.domain.Domain.unify",
    "type": "method",
    "description": "\n        Construct a minimal domain that contains elements of ``K0`` and ``K1``.\n\n        Known domains (from smallest to largest):\n\n        - ``GF(p)``\n        - ``ZZ``\n        - ``QQ``\n        - ``RR(prec, tol)``\n        - ``CC(prec, tol)``\n        - ``ALG(a, b, c)``\n        - ``K[x, y, z]``\n        - ``K(x, y, z)``\n        - ``EX``\n\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "unify_composite",
    "full_id": "sympy.polys.domains.domain.Domain.unify_composite",
    "type": "method",
    "description": "Unify two domains where at least one is composite.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "parent",
    "full_id": "sympy.polys.domains.domainelement.DomainElement.parent",
    "type": "method",
    "description": "Get the domain associated with ``self``\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ, symbols\n        >>> x, y = symbols('x, y')\n        >>> K = ZZ[x,y]\n        >>> p = K(x)**2 + K(y)**2\n        >>> p\n        x**2 + y**2\n        >>> p.parent()\n        ZZ[x,y]\n\n        Notes\n        =====\n\n        This is used by :py:meth:`~.Domain.convert` to identify the domain\n        associated with a domain element.\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "div",
    "full_id": "sympy.polys.domains.field.Field.div",
    "type": "method",
    "description": "Division of ``a`` and ``b``, implies ``__truediv__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exquo",
    "full_id": "sympy.polys.domains.field.Field.exquo",
    "type": "method",
    "description": "Exact quotient of ``a`` and ``b``, implies ``__truediv__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.polys.domains.field.Field.gcd",
    "type": "method",
    "description": "\n        Returns GCD of ``a`` and ``b``.\n\n        This definition of GCD over fields allows to clear denominators\n        in `primitive()`.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.domains import QQ\n        >>> from sympy import S, gcd, primitive\n        >>> from sympy.abc import x\n\n        >>> QQ.gcd(QQ(2, 3), QQ(4, 9))\n        2/9\n        >>> gcd(S(2)/3, S(4)/9)\n        2/9\n        >>> primitive(2*x/3 + S(4)/9)\n        (2/9, 3*x + 2)\n\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_unit",
    "full_id": "sympy.polys.domains.field.Field.is_unit",
    "type": "method",
    "description": "Return true if ``a`` is a invertible",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.polys.domains.field.Field.lcm",
    "type": "method",
    "description": "\n        Returns LCM of ``a`` and ``b``.\n\n        >>> from sympy.polys.domains import QQ\n        >>> from sympy import S, lcm\n\n        >>> QQ.lcm(QQ(2, 3), QQ(4, 9))\n        4/3\n        >>> lcm(S(2)/3, S(4)/9)\n        4/3\n\n        ",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "quo",
    "full_id": "sympy.polys.domains.field.Field.quo",
    "type": "method",
    "description": "Quotient of ``a`` and ``b``, implies ``__truediv__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "rem",
    "full_id": "sympy.polys.domains.field.Field.rem",
    "type": "method",
    "description": "Remainder of ``a`` and ``b``, implies nothing.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "denom",
    "full_id": "sympy.polys.domains.ring.Ring.denom",
    "type": "method",
    "description": "Returns denominator of `a`.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "div",
    "full_id": "sympy.polys.domains.ring.Ring.div",
    "type": "method",
    "description": "Division of ``a`` and ``b``, implies ``__divmod__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exquo",
    "full_id": "sympy.polys.domains.ring.Ring.exquo",
    "type": "method",
    "description": "Exact quotient of ``a`` and ``b``, implies ``__floordiv__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "invert",
    "full_id": "sympy.polys.domains.ring.Ring.invert",
    "type": "method",
    "description": "Returns inversion of ``a mod b``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "quo",
    "full_id": "sympy.polys.domains.ring.Ring.quo",
    "type": "method",
    "description": "Quotient of ``a`` and ``b``, implies ``__floordiv__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "rem",
    "full_id": "sympy.polys.domains.ring.Ring.rem",
    "type": "method",
    "description": "Remainder of ``a`` and ``b``, implies ``__mod__``.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "get_exact",
    "full_id": "sympy.polys.domains.compositedomain.CompositeDomain.get_exact",
    "type": "method",
    "description": "Returns an exact version of this domain.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_Exact",
    "full_id": "sympy.polys.domains.compositedomain.CompositeDomain.is_Exact",
    "type": "property",
    "description": "Returns ``True`` if this domain is exact.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "set_domain",
    "full_id": "sympy.polys.domains.compositedomain.CompositeDomain.set_domain",
    "type": "method",
    "description": "Set the ground domain of this domain.",
    "section": "Abstract Domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exsqrt",
    "full_id": "sympy.polys.domains.FiniteField.exsqrt",
    "type": "method",
    "description": "Square root modulo p of ``a`` if it is a quadratic residue.\n\n        Explanation\n        ===========\n        Always returns the square root that is no larger than ``p // 2``.\n        ",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ",
    "full_id": "sympy.polys.domains.FiniteField.from_QQ",
    "type": "method",
    "description": "Convert Python's ``Fraction`` to ``dtype``.",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ_gmpy",
    "full_id": "sympy.polys.domains.FiniteField.from_QQ_gmpy",
    "type": "method",
    "description": "Convert GMPY's ``mpq`` to ``dtype``.",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_RealField",
    "full_id": "sympy.polys.domains.FiniteField.from_RealField",
    "type": "method",
    "description": "Convert mpmath's ``mpf`` to ``dtype``.",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ",
    "full_id": "sympy.polys.domains.FiniteField.from_ZZ",
    "type": "method",
    "description": "Convert Python's ``int`` to ``dtype``.",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ_gmpy",
    "full_id": "sympy.polys.domains.FiniteField.from_ZZ_gmpy",
    "type": "method",
    "description": "Convert GMPY's ``mpz`` to ``dtype``.",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_sympy",
    "full_id": "sympy.polys.domains.FiniteField.from_sympy",
    "type": "method",
    "description": "Convert SymPy's Integer to SymPy's ``Integer``.",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_square",
    "full_id": "sympy.polys.domains.FiniteField.is_square",
    "type": "method",
    "description": "Returns True if ``a`` is a quadratic residue modulo p.",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_int",
    "full_id": "sympy.polys.domains.FiniteField.to_int",
    "type": "method",
    "description": "Convert ``val`` to a Python ``int`` object.",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_sympy",
    "full_id": "sympy.polys.domains.FiniteField.to_sympy",
    "type": "method",
    "description": "Convert ``a`` to a SymPy object.",
    "section": "GF(p)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "algebraic_field",
    "full_id": "sympy.polys.domains.IntegerRing.algebraic_field",
    "type": "method",
    "description": "Returns an algebraic field, i.e. `\\mathbb{Q}(\\alpha, \\ldots)`.\n\n        Parameters\n        ==========\n\n        *extension : One or more :py:class:`~.Expr`.\n            Generators of the extension. These should be expressions that are\n            algebraic over `\\mathbb{Q}`.\n\n        alias : str, :py:class:`~.Symbol`, None, optional (default=None)\n            If provided, this will be used as the alias symbol for the\n            primitive element of the returned :py:class:`~.AlgebraicField`.\n\n        Returns\n        =======\n\n        :py:class:`~.AlgebraicField`\n            A :py:class:`~.Domain` representing the algebraic field extension.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ, sqrt\n        >>> ZZ.algebraic_field(sqrt(2))\n        QQ<sqrt(2)>\n        ",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exsqrt",
    "full_id": "sympy.polys.domains.IntegerRing.exsqrt",
    "type": "method",
    "description": "Non-negative square root of ``a`` if ``a`` is a square.\n\n        See also\n        ========\n        is_square\n        ",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "factorial",
    "full_id": "sympy.polys.domains.IntegerRing.factorial",
    "type": "method",
    "description": "Compute factorial of ``a``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_AlgebraicField",
    "full_id": "sympy.polys.domains.IntegerRing.from_AlgebraicField",
    "type": "method",
    "description": "Convert a :py:class:`~.ANP` object to :ref:`ZZ`.\n\n        See :py:meth:`~.Domain.convert`.\n        ",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_EX",
    "full_id": "sympy.polys.domains.IntegerRing.from_EX",
    "type": "method",
    "description": "Convert ``Expression`` to GMPY's ``mpz``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_FF",
    "full_id": "sympy.polys.domains.IntegerRing.from_FF",
    "type": "method",
    "description": "Convert ``ModularInteger(int)`` to GMPY's ``mpz``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_FF_gmpy",
    "full_id": "sympy.polys.domains.IntegerRing.from_FF_gmpy",
    "type": "method",
    "description": "Convert ``ModularInteger(mpz)`` to GMPY's ``mpz``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ",
    "full_id": "sympy.polys.domains.IntegerRing.from_QQ",
    "type": "method",
    "description": "Convert Python's ``Fraction`` to GMPY's ``mpz``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ_gmpy",
    "full_id": "sympy.polys.domains.IntegerRing.from_QQ_gmpy",
    "type": "method",
    "description": "Convert GMPY ``mpq`` to GMPY's ``mpz``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_RealField",
    "full_id": "sympy.polys.domains.IntegerRing.from_RealField",
    "type": "method",
    "description": "Convert mpmath's ``mpf`` to GMPY's ``mpz``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ",
    "full_id": "sympy.polys.domains.IntegerRing.from_ZZ",
    "type": "method",
    "description": "Convert Python's ``int`` to GMPY's ``mpz``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ_gmpy",
    "full_id": "sympy.polys.domains.IntegerRing.from_ZZ_gmpy",
    "type": "method",
    "description": "Convert GMPY's ``mpz`` to GMPY's ``mpz``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_sympy",
    "full_id": "sympy.polys.domains.IntegerRing.from_sympy",
    "type": "method",
    "description": "Convert SymPy's Integer to ``dtype``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.polys.domains.IntegerRing.gcd",
    "type": "method",
    "description": "Compute GCD of ``a`` and ``b``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcdex",
    "full_id": "sympy.polys.domains.IntegerRing.gcdex",
    "type": "method",
    "description": "Compute extended GCD of ``a`` and ``b``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "get_field",
    "full_id": "sympy.polys.domains.IntegerRing.get_field",
    "type": "method",
    "description": "Return the associated field of fractions :ref:`QQ`\n\n        Returns\n        =======\n\n        :ref:`QQ`:\n            The associated field of fractions :ref:`QQ`, a\n            :py:class:`~.Domain` representing the rational numbers\n            `\\mathbb{Q}`.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> ZZ.get_field()\n        QQ\n        ",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_square",
    "full_id": "sympy.polys.domains.IntegerRing.is_square",
    "type": "method",
    "description": "Return ``True`` if ``a`` is a square.\n\n        Explanation\n        ===========\n        An integer is a square if and only if there exists an integer\n        ``b`` such that ``b * b == a``.\n        ",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.polys.domains.IntegerRing.lcm",
    "type": "method",
    "description": "Compute LCM of ``a`` and ``b``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "log",
    "full_id": "sympy.polys.domains.IntegerRing.log",
    "type": "method",
    "description": "Logarithm of *a* to the base *b*.\n\n        Parameters\n        ==========\n\n        a: number\n        b: number\n\n        Returns\n        =======\n\n        $\\\\lfloor\\log(a, b)\\\\rfloor$:\n            Floor of the logarithm of *a* to the base *b*\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> ZZ.log(ZZ(8), ZZ(2))\n        3\n        >>> ZZ.log(ZZ(9), ZZ(2))\n        3\n\n        Notes\n        =====\n\n        This function uses ``math.log`` which is based on ``float`` so it will\n        fail for large integer arguments.\n        ",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sqrt",
    "full_id": "sympy.polys.domains.IntegerRing.sqrt",
    "type": "method",
    "description": "Compute square root of ``a``.",
    "section": "ZZ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "algebraic_field",
    "full_id": "sympy.polys.domains.RationalField.algebraic_field",
    "type": "method",
    "description": "Returns an algebraic field, i.e. `\\mathbb{Q}(\\alpha, \\ldots)`.\n\n        Parameters\n        ==========\n\n        *extension : One or more :py:class:`~.Expr`\n            Generators of the extension. These should be expressions that are\n            algebraic over `\\mathbb{Q}`.\n\n        alias : str, :py:class:`~.Symbol`, None, optional (default=None)\n            If provided, this will be used as the alias symbol for the\n            primitive element of the returned :py:class:`~.AlgebraicField`.\n\n        Returns\n        =======\n\n        :py:class:`~.AlgebraicField`\n            A :py:class:`~.Domain` representing the algebraic field extension.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ, sqrt\n        >>> QQ.algebraic_field(sqrt(2))\n        QQ<sqrt(2)>\n        ",
    "section": "QQ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_AlgebraicField",
    "full_id": "sympy.polys.domains.RationalField.from_AlgebraicField",
    "type": "method",
    "description": "Convert a :py:class:`~.ANP` object to :ref:`QQ`.\n\n        See :py:meth:`~.Domain.convert`\n        ",
    "section": "QQ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianRationalField",
    "full_id": "sympy.polys.domains.RationalField.from_GaussianRationalField",
    "type": "method",
    "description": "Convert a ``GaussianElement`` object to ``dtype``.",
    "section": "QQ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_RealField",
    "full_id": "sympy.polys.domains.RationalField.from_RealField",
    "type": "method",
    "description": "Convert a mpmath ``mpf`` object to ``dtype``.",
    "section": "QQ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "get_ring",
    "full_id": "sympy.polys.domains.RationalField.get_ring",
    "type": "method",
    "description": "Returns ring associated with ``self``.",
    "section": "QQ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_square",
    "full_id": "sympy.polys.domains.RationalField.is_square",
    "type": "method",
    "description": "Return ``True`` if ``a`` is a square.\n\n        Explanation\n        ===========\n        A rational number is a square if and only if there exists\n        a rational number ``b`` such that ``b * b == a``.\n        ",
    "section": "QQ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "factorial",
    "full_id": "sympy.polys.domains.GMPYRationalField.factorial",
    "type": "method",
    "description": "Returns factorial of ``a``.",
    "section": "QQ",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_AlgebraicField",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianDomain.from_AlgebraicField",
    "type": "method",
    "description": "Convert an element from ZZ<I> or QQ<I> to ``self.dtype``.",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianDomain.from_QQ",
    "type": "method",
    "description": "Convert a GMPY mpq to ``self.dtype``.",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ_python",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianDomain.from_QQ_python",
    "type": "method",
    "description": "Convert a QQ_python element to ``self.dtype``.",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianDomain.from_ZZ",
    "type": "method",
    "description": "Convert a ZZ_python element to ``self.dtype``.",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ_gmpy",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianDomain.from_ZZ_gmpy",
    "type": "method",
    "description": "Convert a GMPY mpz to ``self.dtype``.",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_sympy",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianDomain.from_sympy",
    "type": "method",
    "description": "Convert a SymPy object to ``self.dtype``.",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_negative",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianDomain.is_negative",
    "type": "method",
    "description": "Returns ``False`` for any ``GaussianElement``.",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "new",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianElement.new",
    "type": "method",
    "description": "Create a new GaussianElement of the same domain.",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "parent",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianElement.parent",
    "type": "method",
    "description": "The domain that this is an element of (ZZ_I or QQ_I)",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "quadrant",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianElement.quadrant",
    "type": "method",
    "description": "Return quadrant index 0-3.\n\n        0 is included in quadrant 0.\n        ",
    "section": "Gaussian domains",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianIntegerRing",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianIntegerRing.from_GaussianIntegerRing",
    "type": "method",
    "description": "Convert a ZZ_I element to ZZ_I.",
    "section": "ZZ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianRationalField",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianIntegerRing.from_GaussianRationalField",
    "type": "method",
    "description": "Convert a QQ_I element to ZZ_I.",
    "section": "ZZ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianIntegerRing.gcd",
    "type": "method",
    "description": "Greatest common divisor of a and b over ZZ_I.",
    "section": "ZZ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianIntegerRing.lcm",
    "type": "method",
    "description": "Least common multiple of a and b over ZZ_I.",
    "section": "ZZ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "normalize",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianIntegerRing.normalize",
    "type": "method",
    "description": "Return first quadrant element associated with ``d``.\n\n        Also multiply the other arguments by the same power of i.\n        ",
    "section": "ZZ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "as_AlgebraicField",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianRationalField.as_AlgebraicField",
    "type": "method",
    "description": "Get equivalent domain as an ``AlgebraicField``.",
    "section": "QQ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "denom",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianRationalField.denom",
    "type": "method",
    "description": "Get the denominator of ``a``.",
    "section": "QQ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ComplexField",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianRationalField.from_ComplexField",
    "type": "method",
    "description": "Convert a ComplexField element to QQ_I.",
    "section": "QQ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianIntegerRing",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianRationalField.from_GaussianIntegerRing",
    "type": "method",
    "description": "Convert a ZZ_I element to QQ_I.",
    "section": "QQ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianRationalField",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianRationalField.from_GaussianRationalField",
    "type": "method",
    "description": "Convert a QQ_I element to QQ_I.",
    "section": "QQ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "numer",
    "full_id": "sympy.polys.domains.gaussiandomains.GaussianRationalField.numer",
    "type": "method",
    "description": "Get the numerator of ``a``.",
    "section": "QQ_I",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "algebraic_field",
    "full_id": "sympy.polys.domains.AlgebraicField.algebraic_field",
    "type": "method",
    "description": "Returns an algebraic field, i.e. `\\mathbb{Q}(\\alpha, \\ldots)`.",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "discriminant",
    "full_id": "sympy.polys.domains.AlgebraicField.discriminant",
    "type": "method",
    "description": "Get the discriminant of the field.",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_AlgebraicField",
    "full_id": "sympy.polys.domains.AlgebraicField.from_AlgebraicField",
    "type": "method",
    "description": "Convert AlgebraicField element 'a' to another AlgebraicField",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianIntegerRing",
    "full_id": "sympy.polys.domains.AlgebraicField.from_GaussianIntegerRing",
    "type": "method",
    "description": "Convert a GaussianInteger element 'a' to ``dtype``.",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianRationalField",
    "full_id": "sympy.polys.domains.AlgebraicField.from_GaussianRationalField",
    "type": "method",
    "description": "Convert a GaussianRational element 'a' to ``dtype``.",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_sympy",
    "full_id": "sympy.polys.domains.AlgebraicField.from_sympy",
    "type": "method",
    "description": "Convert SymPy's expression to ``dtype``.",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "galois_group",
    "full_id": "sympy.polys.domains.AlgebraicField.galois_group",
    "type": "method",
    "description": "\n        Compute the Galois group of the Galois closure of this field.\n\n        Examples\n        ========\n\n        If the field is Galois, the order of the group will equal the degree\n        of the field:\n\n        >>> from sympy import QQ\n        >>> from sympy.abc import x\n        >>> k = QQ.alg_field_from_poly(x**4 + 1)\n        >>> G, _ = k.galois_group()\n        >>> G.order()\n        4\n\n        If the field is not Galois, then its Galois closure is a proper\n        extension, and the order of the Galois group will be greater than the\n        degree of the field:\n\n        >>> k = QQ.alg_field_from_poly(x**4 - 2)\n        >>> G, _ = k.galois_group()\n        >>> G.order()\n        8\n\n        See Also\n        ========\n\n        sympy.polys.numberfields.galoisgroups.galois_group\n\n        ",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "integral_basis",
    "full_id": "sympy.polys.domains.AlgebraicField.integral_basis",
    "type": "method",
    "description": "\n        Get an integral basis for the field.\n\n        Parameters\n        ==========\n\n        fmt : str, None, optional (default=None)\n            If ``None``, return a list of :py:class:`~.ANP` instances.\n            If ``\"sympy\"``, convert each element of the list to an\n            :py:class:`~.Expr`, using ``self.to_sympy()``.\n            If ``\"alg\"``, convert each element of the list to an\n            :py:class:`~.AlgebraicNumber`, using ``self.to_alg_num()``.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ, AlgebraicNumber, sqrt\n        >>> alpha = AlgebraicNumber(sqrt(5), alias='alpha')\n        >>> k = QQ.algebraic_field(alpha)\n        >>> B0 = k.integral_basis()\n        >>> B1 = k.integral_basis(fmt='sympy')\n        >>> B2 = k.integral_basis(fmt='alg')\n        >>> print(B0[1])  # doctest: +SKIP\n        ANP([mpq(1,2), mpq(1,2)], [mpq(1,1), mpq(0,1), mpq(-5,1)], QQ)\n        >>> print(B1[1])\n        1/2 + alpha/2\n        >>> print(B2[1])\n        alpha/2 + 1/2\n\n        In the last two cases we get legible expressions, which print somewhat\n        differently because of the different types involved:\n\n        >>> print(type(B1[1]))\n        <class 'sympy.core.add.Add'>\n        >>> print(type(B2[1]))\n        <class 'sympy.core.numbers.AlgebraicNumber'>\n\n        See Also\n        ========\n\n        to_sympy\n        to_alg_num\n        maximal_order\n        ",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "maximal_order",
    "full_id": "sympy.polys.domains.AlgebraicField.maximal_order",
    "type": "method",
    "description": "\n        Compute the maximal order, or ring of integers, of the field.\n\n        Returns\n        =======\n\n        :py:class:`~sympy.polys.numberfields.modules.Submodule`.\n\n        See Also\n        ========\n\n        integral_basis\n\n        ",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "primes_above",
    "full_id": "sympy.polys.domains.AlgebraicField.primes_above",
    "type": "method",
    "description": "Compute the prime ideals lying above a given rational prime *p*.",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_alg_num",
    "full_id": "sympy.polys.domains.AlgebraicField.to_alg_num",
    "type": "method",
    "description": "Convert ``a`` of ``dtype`` to an :py:class:`~.AlgebraicNumber`.",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_sympy",
    "full_id": "sympy.polys.domains.AlgebraicField.to_sympy",
    "type": "method",
    "description": "Convert ``a`` of ``dtype`` to a SymPy object.",
    "section": "QQ<a>",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exsqrt",
    "full_id": "sympy.polys.domains.RealField.exsqrt",
    "type": "method",
    "description": "Non-negative square root for ``a >= 0`` and ``None`` otherwise.\n\n        Explanation\n        ===========\n        The square root may be slightly inaccurate due to floating point\n        rounding error.\n        ",
    "section": "RR",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_sympy",
    "full_id": "sympy.polys.domains.RealField.from_sympy",
    "type": "method",
    "description": "Convert SymPy's number to ``dtype``.",
    "section": "RR",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_square",
    "full_id": "sympy.polys.domains.RealField.is_square",
    "type": "method",
    "description": "Returns ``True`` if ``a >= 0`` and ``False`` otherwise.",
    "section": "RR",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_rational",
    "full_id": "sympy.polys.domains.RealField.to_rational",
    "type": "method",
    "description": "Convert a real number to rational number.",
    "section": "RR",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_sympy",
    "full_id": "sympy.polys.domains.RealField.to_sympy",
    "type": "method",
    "description": "Convert ``element`` to SymPy number.",
    "section": "RR",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exsqrt",
    "full_id": "sympy.polys.domains.ComplexField.exsqrt",
    "type": "method",
    "description": "Returns the principal complex square root of ``a``.\n\n        Explanation\n        ===========\n        The argument of the principal square root is always within\n        $(-\\frac{\\pi}{2}, \\frac{\\pi}{2}]$. The square root may be\n        slightly inaccurate due to floating point rounding error.\n        ",
    "section": "CC",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_negative",
    "full_id": "sympy.polys.domains.ComplexField.is_negative",
    "type": "method",
    "description": "Returns ``False`` for any ``ComplexElement``.",
    "section": "CC",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_square",
    "full_id": "sympy.polys.domains.ComplexField.is_square",
    "type": "method",
    "description": "Returns ``True``. Every complex number has a complex square root.",
    "section": "CC",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "factorial",
    "full_id": "sympy.polys.domains.PolynomialRing.factorial",
    "type": "method",
    "description": "Returns factorial of `a`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ComplexField",
    "full_id": "sympy.polys.domains.PolynomialRing.from_ComplexField",
    "type": "method",
    "description": "Convert a mpmath `mpf` object to `dtype`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianIntegerRing",
    "full_id": "sympy.polys.domains.PolynomialRing.from_GaussianIntegerRing",
    "type": "method",
    "description": "Convert a `GaussianInteger` object to `dtype`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianRationalField",
    "full_id": "sympy.polys.domains.PolynomialRing.from_GaussianRationalField",
    "type": "method",
    "description": "Convert a `GaussianRational` object to `dtype`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GlobalPolynomialRing",
    "full_id": "sympy.polys.domains.PolynomialRing.from_GlobalPolynomialRing",
    "type": "method",
    "description": "Convert from old poly ring to ``dtype``.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ",
    "full_id": "sympy.polys.domains.PolynomialRing.from_QQ",
    "type": "method",
    "description": "Convert a Python `Fraction` object to `dtype`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_QQ_gmpy",
    "full_id": "sympy.polys.domains.PolynomialRing.from_QQ_gmpy",
    "type": "method",
    "description": "Convert a GMPY `mpq` object to `dtype`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ",
    "full_id": "sympy.polys.domains.PolynomialRing.from_ZZ",
    "type": "method",
    "description": "Convert a Python `int` object to `dtype`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_ZZ_gmpy",
    "full_id": "sympy.polys.domains.PolynomialRing.from_ZZ_gmpy",
    "type": "method",
    "description": "Convert a GMPY `mpz` object to `dtype`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_sympy",
    "full_id": "sympy.polys.domains.PolynomialRing.from_sympy",
    "type": "method",
    "description": "Convert SymPy's expression to `dtype`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.polys.domains.PolynomialRing.gcd",
    "type": "method",
    "description": "Returns GCD of `a` and `b`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcdex",
    "full_id": "sympy.polys.domains.PolynomialRing.gcdex",
    "type": "method",
    "description": "Extended GCD of `a` and `b`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "get_field",
    "full_id": "sympy.polys.domains.PolynomialRing.get_field",
    "type": "method",
    "description": "Returns a field associated with `self`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_negative",
    "full_id": "sympy.polys.domains.PolynomialRing.is_negative",
    "type": "method",
    "description": "Returns True if `LC(a)` is negative.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_nonnegative",
    "full_id": "sympy.polys.domains.PolynomialRing.is_nonnegative",
    "type": "method",
    "description": "Returns True if `LC(a)` is non-negative.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_nonpositive",
    "full_id": "sympy.polys.domains.PolynomialRing.is_nonpositive",
    "type": "method",
    "description": "Returns True if `LC(a)` is non-positive.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_positive",
    "full_id": "sympy.polys.domains.PolynomialRing.is_positive",
    "type": "method",
    "description": "Returns True if `LC(a)` is positive.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_unit",
    "full_id": "sympy.polys.domains.PolynomialRing.is_unit",
    "type": "method",
    "description": "Returns ``True`` if ``a`` is a unit of ``self``",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.polys.domains.PolynomialRing.lcm",
    "type": "method",
    "description": "Returns LCM of `a` and `b`.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_sympy",
    "full_id": "sympy.polys.domains.PolynomialRing.to_sympy",
    "type": "method",
    "description": "Convert `a` to a SymPy object.",
    "section": "K[x]",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianIntegerRing",
    "full_id": "sympy.polys.domains.FractionField.from_GaussianIntegerRing",
    "type": "method",
    "description": "Convert a ``GaussianInteger`` object to ``dtype``.",
    "section": "K(x)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_GaussianRationalField",
    "full_id": "sympy.polys.domains.FractionField.from_GaussianRationalField",
    "type": "method",
    "description": "Convert a ``GaussianRational`` object to ``dtype``.",
    "section": "K(x)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_negative",
    "full_id": "sympy.polys.domains.FractionField.is_negative",
    "type": "method",
    "description": "Returns True if ``LC(a)`` is negative.",
    "section": "K(x)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_nonnegative",
    "full_id": "sympy.polys.domains.FractionField.is_nonnegative",
    "type": "method",
    "description": "Returns True if ``LC(a)`` is non-negative.",
    "section": "K(x)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_nonpositive",
    "full_id": "sympy.polys.domains.FractionField.is_nonpositive",
    "type": "method",
    "description": "Returns True if ``LC(a)`` is non-positive.",
    "section": "K(x)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_positive",
    "full_id": "sympy.polys.domains.FractionField.is_positive",
    "type": "method",
    "description": "Returns True if ``LC(a)`` is positive.",
    "section": "K(x)",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "ring",
    "full_id": "sympy.polys.rings.ring",
    "type": "function",
    "description": "Construct a polynomial ring returning ``(ring, x_1, ..., x_n)``.\n\n    Parameters\n    ==========\n\n    symbols : str\n        Symbol/Expr or sequence of str, Symbol/Expr (non-empty)\n    domain : :class:`~.Domain` or coercible\n    order : :class:`~.MonomialOrder` or coercible, optional, defaults to ``lex``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.orderings import lex\n\n    >>> R, x, y, z = ring(\"x,y,z\", ZZ, lex)\n    >>> R\n    Polynomial ring in x, y, z over ZZ with lex order\n    >>> x + y + z\n    x + y + z\n    >>> type(_)\n    <class 'sympy.polys.rings.PolyElement'>\n\n    ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "xring",
    "full_id": "sympy.polys.rings.xring",
    "type": "function",
    "description": "Construct a polynomial ring returning ``(ring, (x_1, ..., x_n))``.\n\n    Parameters\n    ==========\n\n    symbols : str\n        Symbol/Expr or sequence of str, Symbol/Expr (non-empty)\n    domain : :class:`~.Domain` or coercible\n    order : :class:`~.MonomialOrder` or coercible, optional, defaults to ``lex``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.rings import xring\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.orderings import lex\n\n    >>> R, (x, y, z) = xring(\"x,y,z\", ZZ, lex)\n    >>> R\n    Polynomial ring in x, y, z over ZZ with lex order\n    >>> x + y + z\n    x + y + z\n    >>> type(_)\n    <class 'sympy.polys.rings.PolyElement'>\n\n    ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "vring",
    "full_id": "sympy.polys.rings.vring",
    "type": "function",
    "description": "Construct a polynomial ring and inject ``x_1, ..., x_n`` into the global namespace.\n\n    Parameters\n    ==========\n\n    symbols : str\n        Symbol/Expr or sequence of str, Symbol/Expr (non-empty)\n    domain : :class:`~.Domain` or coercible\n    order : :class:`~.MonomialOrder` or coercible, optional, defaults to ``lex``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.rings import vring\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.orderings import lex\n\n    >>> vring(\"x,y,z\", ZZ, lex)\n    Polynomial ring in x, y, z over ZZ with lex order\n    >>> x + y + z # noqa:\n    x + y + z\n    >>> type(_)\n    <class 'sympy.polys.rings.PolyElement'>\n\n    ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sring",
    "full_id": "sympy.polys.rings.sring",
    "type": "function",
    "description": "Construct a ring deriving generators and domain from options and input expressions.\n\n    Parameters\n    ==========\n\n    exprs : :class:`~.Expr` or sequence of :class:`~.Expr` (sympifiable)\n    symbols : sequence of :class:`~.Symbol`/:class:`~.Expr`\n    options : keyword arguments understood by :class:`~.Options`\n\n    Examples\n    ========\n\n    >>> from sympy import sring, symbols\n\n    >>> x, y, z = symbols(\"x,y,z\")\n    >>> R, f = sring(x + 2*y + 3*z)\n    >>> R\n    Polynomial ring in x, y, z over ZZ with lex order\n    >>> f\n    x + 2*y + 3*z\n    >>> type(_)\n    <class 'sympy.polys.rings.PolyElement'>\n\n    ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.rings.PolyRing.add",
    "type": "method",
    "description": "\n        Add a sequence of polynomials or containers of polynomials.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> R, x = ring(\"x\", ZZ)\n        >>> R.add([ x**2 + 2*i + 3 for i in range(4) ])\n        4*x**2 + 24\n        >>> _.factor_list()\n        (4, [(x**2 + 6, 1)])\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "add_gens",
    "full_id": "sympy.polys.rings.PolyRing.add_gens",
    "type": "method",
    "description": "Add the elements of ``symbols`` as generators to ``self``",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "compose",
    "full_id": "sympy.polys.rings.PolyRing.compose",
    "type": "method",
    "description": "Add the generators of ``other`` to ``self``",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "drop",
    "full_id": "sympy.polys.rings.PolyRing.drop",
    "type": "method",
    "description": "Remove specified generators from this ring.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "drop_to_ground",
    "full_id": "sympy.polys.rings.PolyRing.drop_to_ground",
    "type": "method",
    "description": "\n        Remove specified generators from the ring and inject them into\n        its domain.\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "index",
    "full_id": "sympy.polys.rings.PolyRing.index",
    "type": "method",
    "description": "Compute index of ``gen`` in ``self.gens``.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "monomial_basis",
    "full_id": "sympy.polys.rings.PolyRing.monomial_basis",
    "type": "method",
    "description": "Return the ith-basis element.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.polys.rings.PolyRing.mul",
    "type": "method",
    "description": "\n        Multiply a sequence of polynomials or containers of polynomials.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> R, x = ring(\"x\", ZZ)\n        >>> R.mul([ x**2 + 2*i + 3 for i in range(4) ])\n        x**8 + 24*x**6 + 206*x**4 + 744*x**2 + 945\n        >>> _.factor_list()\n        (1, [(x**2 + 3, 1), (x**2 + 5, 1), (x**2 + 7, 1), (x**2 + 9, 1)])\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "symmetric_poly",
    "full_id": "sympy.polys.rings.PolyRing.symmetric_poly",
    "type": "method",
    "description": "\n        Return the elementary symmetric polynomial of degree *n* over\n        this ring's generators.\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "almosteq",
    "full_id": "sympy.polys.rings.PolyElement.almosteq",
    "type": "method",
    "description": "Approximate equality test for polynomials.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "cancel",
    "full_id": "sympy.polys.rings.PolyElement.cancel",
    "type": "method",
    "description": "\n        Cancel common factors in a rational function ``f/g``.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x,y = ring(\"x,y\", ZZ)\n\n        >>> (2*x**2 - 2).cancel(x**2 - 2*x + 1)\n        (2*x + 2, x - 1)\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "coeff",
    "full_id": "sympy.polys.rings.PolyElement.coeff",
    "type": "method",
    "description": "\n        Returns the coefficient that stands next to the given monomial.\n\n        Parameters\n        ==========\n\n        element : PolyElement (with ``is_monomial = True``) or 1\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> _, x, y, z = ring(\"x,y,z\", ZZ)\n        >>> f = 3*x**2*y - x*y*z + 7*z**3 + 23\n\n        >>> f.coeff(x**2*y)\n        3\n        >>> f.coeff(x*y)\n        0\n        >>> f.coeff(1)\n        23\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "coeff_wrt",
    "full_id": "sympy.polys.rings.PolyElement.coeff_wrt",
    "type": "method",
    "description": "\n        Coefficient of ``self`` with respect to ``x**deg``.\n\n        Treating ``self`` as a univariate polynomial in ``x`` this finds the\n        coefficient of ``x**deg`` as a polynomial in the other generators.\n\n        Parameters\n        ==========\n\n        x : generator or generator index\n            The generator or generator index to compute the expression for.\n        deg : int\n            The degree of the monomial to compute the expression for.\n\n        Returns\n        =======\n\n        :py:class:`~.PolyElement`\n            The coefficient of ``x**deg`` as a polynomial in the same ring.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x, y, z = ring(\"x, y, z\", ZZ)\n\n        >>> p = 2*x**4 + 3*y**4 + 10*z**2 + 10*x*z**2\n        >>> deg = 2\n        >>> p.coeff_wrt(2, deg) # Using the generator index\n        10*x + 10\n        >>> p.coeff_wrt(z, deg) # Using the generator\n        10*x + 10\n        >>> p.coeff(z**2) # shows the difference between coeff and coeff_wrt\n        10\n\n        See Also\n        ========\n\n        coeff, coeffs\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "coeffs",
    "full_id": "sympy.polys.rings.PolyElement.coeffs",
    "type": "method",
    "description": "Ordered list of polynomial coefficients.\n\n        Parameters\n        ==========\n\n        order : :class:`~.MonomialOrder` or coercible, optional\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n        >>> from sympy.polys.orderings import lex, grlex\n\n        >>> _, x, y = ring(\"x, y\", ZZ, lex)\n        >>> f = x*y**7 + 2*x**2*y**3\n\n        >>> f.coeffs()\n        [2, 1]\n        >>> f.coeffs(grlex)\n        [1, 2]\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "const",
    "full_id": "sympy.polys.rings.PolyElement.const",
    "type": "method",
    "description": "Returns the constant coefficient.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "content",
    "full_id": "sympy.polys.rings.PolyElement.content",
    "type": "method",
    "description": "Returns GCD of polynomial's coefficients.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "copy",
    "full_id": "sympy.polys.rings.PolyElement.copy",
    "type": "method",
    "description": "Return a copy of polynomial self.\n\n        Polynomials are mutable; if one is interested in preserving\n        a polynomial, and one plans to use inplace operations, one\n        can copy the polynomial. This method makes a shallow copy.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.domains import ZZ\n        >>> from sympy.polys.rings import ring\n\n        >>> R, x, y = ring('x, y', ZZ)\n        >>> p = (x + y)**2\n        >>> p1 = p.copy()\n        >>> p2 = p\n        >>> p[R.zero_monom] = 3\n        >>> p\n        x**2 + 2*x*y + y**2 + 3\n        >>> p1\n        x**2 + 2*x*y + y**2\n        >>> p2\n        x**2 + 2*x*y + y**2 + 3\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "degree",
    "full_id": "sympy.polys.rings.PolyElement.degree",
    "type": "method",
    "description": "\n        The leading degree in ``x`` or the main variable.\n\n        Note that the degree of 0 is negative infinity (``float('-inf')``)\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "degrees",
    "full_id": "sympy.polys.rings.PolyElement.degrees",
    "type": "method",
    "description": "\n        A tuple containing leading degrees in all variables.\n\n        Note that the degree of 0 is negative infinity (``float('-inf')``)\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "diff",
    "full_id": "sympy.polys.rings.PolyElement.diff",
    "type": "method",
    "description": "Computes partial derivative in ``x``.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> _, x, y = ring(\"x,y\", ZZ)\n        >>> p = x + x**2*y**3\n        >>> p.diff(x)\n        2*x*y**3 + 1\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "div",
    "full_id": "sympy.polys.rings.PolyElement.div",
    "type": "method",
    "description": "Division algorithm, see [CLO] p64.\n\n        fv array of polynomials\n           return qv, r such that\n           self = sum(fv[i]*qv[i]) + r\n\n        All polynomials are required not to be Laurent polynomials.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> _, x, y = ring('x, y', ZZ)\n        >>> f = x**3\n        >>> f0 = x - y**2\n        >>> f1 = x - y\n        >>> qv, r = f.div((f0, f1))\n        >>> qv[0]\n        x**2 + x*y**2 + y**4\n        >>> qv[1]\n        0\n        >>> r\n        y**6\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "imul_num",
    "full_id": "sympy.polys.rings.PolyElement.imul_num",
    "type": "method",
    "description": "multiply inplace the polynomial p by an element in the\n        coefficient ring, provided p is not one of the generators;\n        else multiply not inplace\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> _, x, y = ring('x, y', ZZ)\n        >>> p = x + y**2\n        >>> p1 = p.imul_num(3)\n        >>> p1\n        3*x + 3*y**2\n        >>> p1 is p\n        True\n        >>> p = x\n        >>> p1 = p.imul_num(3)\n        >>> p1\n        3*x\n        >>> p1 is p\n        False\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "itercoeffs",
    "full_id": "sympy.polys.rings.PolyElement.itercoeffs",
    "type": "method",
    "description": "Iterator over coefficients of a polynomial.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "itermonoms",
    "full_id": "sympy.polys.rings.PolyElement.itermonoms",
    "type": "method",
    "description": "Iterator over monomials of a polynomial.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "iterterms",
    "full_id": "sympy.polys.rings.PolyElement.iterterms",
    "type": "method",
    "description": "Iterator over terms of a polynomial.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "leading_expv",
    "full_id": "sympy.polys.rings.PolyElement.leading_expv",
    "type": "method",
    "description": "Leading monomial tuple according to the monomial ordering.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> _, x, y, z = ring('x, y, z', ZZ)\n        >>> p = x**4 + x**3*y + x**2*z**2 + z**7\n        >>> p.leading_expv()\n        (4, 0, 0)\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "leading_monom",
    "full_id": "sympy.polys.rings.PolyElement.leading_monom",
    "type": "method",
    "description": "\n        Leading monomial as a polynomial element.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> _, x, y = ring('x, y', ZZ)\n        >>> (3*x*y + y**2).leading_monom()\n        x*y\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "leading_term",
    "full_id": "sympy.polys.rings.PolyElement.leading_term",
    "type": "method",
    "description": "Leading term as a polynomial element.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> _, x, y = ring('x, y', ZZ)\n        >>> (3*x*y + y**2).leading_term()\n        3*x*y\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "listcoeffs",
    "full_id": "sympy.polys.rings.PolyElement.listcoeffs",
    "type": "method",
    "description": "Unordered list of polynomial coefficients.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "listmonoms",
    "full_id": "sympy.polys.rings.PolyElement.listmonoms",
    "type": "method",
    "description": "Unordered list of polynomial monomials.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "listterms",
    "full_id": "sympy.polys.rings.PolyElement.listterms",
    "type": "method",
    "description": "Unordered list of polynomial terms.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "monic",
    "full_id": "sympy.polys.rings.PolyElement.monic",
    "type": "method",
    "description": "Divides all coefficients by the leading coefficient.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "monoms",
    "full_id": "sympy.polys.rings.PolyElement.monoms",
    "type": "method",
    "description": "Ordered list of polynomial monomials.\n\n        Parameters\n        ==========\n\n        order : :class:`~.MonomialOrder` or coercible, optional\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n        >>> from sympy.polys.orderings import lex, grlex\n\n        >>> _, x, y = ring(\"x, y\", ZZ, lex)\n        >>> f = x*y**7 + 2*x**2*y**3\n\n        >>> f.monoms()\n        [(2, 3), (1, 7)]\n        >>> f.monoms(grlex)\n        [(1, 7), (2, 3)]\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "pdiv",
    "full_id": "sympy.polys.rings.PolyElement.pdiv",
    "type": "method",
    "description": "\n        Computes the pseudo-division of the polynomial ``self`` with respect to ``g``.\n\n        The pseudo-division algorithm is used to find the pseudo-quotient ``q``\n        and pseudo-remainder ``r`` such that ``m*f = g*q + r``, where ``m``\n        represents the multiplier and ``f`` is the dividend polynomial.\n\n        The pseudo-quotient ``q`` and pseudo-remainder ``r`` are polynomials in\n        the variable ``x``, with the degree of ``r`` with respect to ``x``\n        being strictly less than the degree of ``g`` with respect to ``x``.\n\n        The multiplier ``m`` is defined as\n        ``LC(g, x) ^ (deg(f, x) - deg(g, x) + 1)``,\n        where ``LC(g, x)`` represents the leading coefficient of ``g``.\n\n        It is important to note that in the context of the ``prem`` method,\n        multivariate polynomials in a ring, such as ``R[x,y,z]``, are treated\n        as univariate polynomials with coefficients that are polynomials,\n        such as ``R[x,y][z]``. When dividing ``f`` by ``g`` with respect to the\n        variable ``z``, the pseudo-quotient ``q`` and pseudo-remainder ``r``\n        satisfy ``m*f = g*q + r``, where ``deg(r, z) < deg(g, z)``\n        and ``m = LC(g, z)^(deg(f, z) - deg(g, z) + 1)``.\n\n        In this function, the pseudo-remainder ``r`` can be obtained using the\n        ``prem`` method, the pseudo-quotient ``q`` can\n        be obtained using the ``pquo`` method, and\n        the function ``pdiv`` itself returns a tuple ``(q, r)``.\n\n\n        Parameters\n        ==========\n\n        g : :py:class:`~.PolyElement`\n            The polynomial to divide ``self`` by.\n        x : generator or generator index, optional\n            The main variable of the polynomials and default is first generator.\n\n        Returns\n        =======\n\n        :py:class:`~.PolyElement`\n            The pseudo-division polynomial (tuple of ``q`` and ``r``).\n\n        Raises\n        ======\n\n        ZeroDivisionError : If ``g`` is the zero polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x, y = ring(\"x, y\", ZZ)\n\n        >>> f = x**2 + x*y\n        >>> g = 2*x + 2\n        >>> f.pdiv(g) # first generator is chosen by default if it is not given\n        (2*x + 2*y - 2, -4*y + 4)\n        >>> f.div(g) # shows the difference between pdiv and div\n        (0, x**2 + x*y)\n        >>> f.pdiv(g, y) # generator is given\n        (2*x**3 + 2*x**2*y + 6*x**2 + 2*x*y + 8*x + 4, 0)\n        >>> f.pdiv(g, 1) # generator index is given\n        (2*x**3 + 2*x**2*y + 6*x**2 + 2*x*y + 8*x + 4, 0)\n\n        See Also\n        ========\n\n        prem\n            Computes only the pseudo-remainder more efficiently than\n            `f.pdiv(g)[1]`.\n        pquo\n            Returns only the pseudo-quotient.\n        pexquo\n            Returns only an exact pseudo-quotient having no remainder.\n        div\n            Returns quotient and remainder of f and g polynomials.\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "pexquo",
    "full_id": "sympy.polys.rings.PolyElement.pexquo",
    "type": "method",
    "description": "\n        Polynomial exact pseudo-quotient in multivariate polynomial ring.\n\n        Examples\n        ========\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x,y = ring(\"x,y\", ZZ)\n\n        >>> f = x**2 + x*y\n        >>> g = 2*x + 2*y\n        >>> h = 2*x + 2\n        >>> f.pexquo(g)\n        2*x\n        >>> f.exquo(g) # shows the differnce between pexquo and exquo\n        Traceback (most recent call last):\n        ...\n        ExactQuotientFailed: 2*x + 2*y does not divide x**2 + x*y\n        >>> f.pexquo(h)\n        Traceback (most recent call last):\n        ...\n        ExactQuotientFailed: 2*x + 2 does not divide x**2 + x*y\n\n        See Also\n        ========\n\n        prem, pdiv, pquo, sympy.polys.domains.ring.Ring.exquo\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "pquo",
    "full_id": "sympy.polys.rings.PolyElement.pquo",
    "type": "method",
    "description": "\n        Polynomial pseudo-quotient in multivariate polynomial ring.\n\n        Examples\n        ========\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x,y = ring(\"x,y\", ZZ)\n\n        >>> f = x**2 + x*y\n        >>> g = 2*x + 2*y\n        >>> h = 2*x + 2\n        >>> f.pquo(g)\n        2*x\n        >>> f.quo(g) # shows the difference between pquo and quo\n        0\n        >>> f.pquo(h)\n        2*x + 2*y - 2\n        >>> f.quo(h) # shows the difference between pquo and quo\n        0\n\n        See Also\n        ========\n\n        prem, pdiv, pexquo, sympy.polys.domains.ring.Ring.quo\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "prem",
    "full_id": "sympy.polys.rings.PolyElement.prem",
    "type": "method",
    "description": "\n        Pseudo-remainder of the polynomial ``self`` with respect to ``g``.\n\n        The pseudo-quotient ``q`` and pseudo-remainder ``r`` with respect to\n        ``z`` when dividing ``f`` by ``g`` satisfy ``m*f = g*q + r``,\n        where ``deg(r,z) < deg(g,z)`` and\n        ``m = LC(g,z)**(deg(f,z) - deg(g,z)+1)``.\n\n        See :meth:`pdiv` for explanation of pseudo-division.\n\n\n        Parameters\n        ==========\n\n        g : :py:class:`~.PolyElement`\n            The polynomial to divide ``self`` by.\n        x : generator or generator index, optional\n            The main variable of the polynomials and default is first generator.\n\n        Returns\n        =======\n\n        :py:class:`~.PolyElement`\n            The pseudo-remainder polynomial.\n\n        Raises\n        ======\n\n        ZeroDivisionError : If ``g`` is the zero polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x, y = ring(\"x, y\", ZZ)\n\n        >>> f = x**2 + x*y\n        >>> g = 2*x + 2\n        >>> f.prem(g) # first generator is chosen by default if it is not given\n        -4*y + 4\n        >>> f.rem(g) # shows the differnce between prem and rem\n        x**2 + x*y\n        >>> f.prem(g, y) # generator is given\n        0\n        >>> f.prem(g, 1) # generator index is given\n        0\n\n        See Also\n        ========\n\n        pdiv, pquo, pexquo, sympy.polys.domains.ring.Ring.rem\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "primitive",
    "full_id": "sympy.polys.rings.PolyElement.primitive",
    "type": "method",
    "description": "Returns content and a primitive polynomial.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "square",
    "full_id": "sympy.polys.rings.PolyElement.square",
    "type": "method",
    "description": "square of a polynomial\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n\n        >>> _, x, y = ring('x, y', ZZ)\n        >>> p = x + y**2\n        >>> p.square()\n        x**2 + 2*x*y**2 + y**4\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "strip_zero",
    "full_id": "sympy.polys.rings.PolyElement.strip_zero",
    "type": "method",
    "description": "Eliminate monomials with zero coefficient.",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "subresultants",
    "full_id": "sympy.polys.rings.PolyElement.subresultants",
    "type": "method",
    "description": "\n        Computes the subresultant PRS of two polynomials ``self`` and ``g``.\n\n        Parameters\n        ==========\n\n        g : :py:class:`~.PolyElement`\n            The second polynomial.\n        x : generator or generator index\n            The variable with respect to which the subresultant sequence is computed.\n\n        Returns\n        =======\n\n        R : list\n            Returns a list polynomials representing the subresultant PRS.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x, y = ring(\"x, y\", ZZ)\n\n        >>> f = x**2*y + x*y\n        >>> g = x + y\n        >>> f.subresultants(g) # first generator is chosen by default if not given\n        [x**2*y + x*y, x + y, y**3 - y**2]\n        >>> f.subresultants(g, 0) # generator index is given\n        [x**2*y + x*y, x + y, y**3 - y**2]\n        >>> f.subresultants(g, y) # generator is given\n        [x**2*y + x*y, x + y, x**3 + x**2]\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "symmetrize",
    "full_id": "sympy.polys.rings.PolyElement.symmetrize",
    "type": "method",
    "description": "\n        Rewrite *self* in terms of elementary symmetric polynomials.\n\n        Explanation\n        ===========\n\n        If this :py:class:`~.PolyElement` belongs to a ring of $n$ variables,\n        we can try to write it as a function of the elementary symmetric\n        polynomials on $n$ variables. We compute a symmetric part, and a\n        remainder for any part we were not able to symmetrize.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n        >>> R, x, y = ring(\"x,y\", ZZ)\n\n        >>> f = x**2 + y**2\n        >>> f.symmetrize()\n        (x**2 - 2*y, 0, [(x, x + y), (y, x*y)])\n\n        >>> f = x**2 - y**2\n        >>> f.symmetrize()\n        (x**2 - 2*y, -2*y**2, [(x, x + y), (y, x*y)])\n\n        Returns\n        =======\n\n        Triple ``(p, r, m)``\n            ``p`` is a :py:class:`~.PolyElement` that represents our attempt\n            to express *self* as a function of elementary symmetric\n            polynomials. Each variable in ``p`` stands for one of the\n            elementary symmetric polynomials. The correspondence is given\n            by ``m``.\n\n            ``r`` is the remainder.\n\n            ``m`` is a list of pairs, giving the mapping from variables in\n            ``p`` to elementary symmetric polynomials.\n\n            The triple satisfies the equation ``p.compose(m) + r == self``.\n            If the remainder ``r`` is zero, *self* is symmetric. If it is\n            nonzero, we were not able to represent *self* as symmetric.\n\n        See Also\n        ========\n\n        sympy.polys.polyfuncs.symmetrize\n\n        References\n        ==========\n\n        .. [1] Lauer, E. Algorithms for symmetrical polynomials, Proc. 1976\n            ACM Symp. on Symbolic and Algebraic Computing, NY 242-247.\n            https://dl.acm.org/doi/pdf/10.1145/800205.806342\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "tail_degree",
    "full_id": "sympy.polys.rings.PolyElement.tail_degree",
    "type": "method",
    "description": "\n        The tail degree in ``x`` or the main variable.\n\n        Note that the degree of 0 is negative infinity (``float('-inf')``)\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "tail_degrees",
    "full_id": "sympy.polys.rings.PolyElement.tail_degrees",
    "type": "method",
    "description": "\n        A tuple containing tail degrees in all variables.\n\n        Note that the degree of 0 is negative infinity (``float('-inf')``)\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "terms",
    "full_id": "sympy.polys.rings.PolyElement.terms",
    "type": "method",
    "description": "Ordered list of polynomial terms.\n\n        Parameters\n        ==========\n\n        order : :class:`~.MonomialOrder` or coercible, optional\n\n        Examples\n        ========\n\n        >>> from sympy.polys.rings import ring\n        >>> from sympy.polys.domains import ZZ\n        >>> from sympy.polys.orderings import lex, grlex\n\n        >>> _, x, y = ring(\"x, y\", ZZ, lex)\n        >>> f = x*y**7 + 2*x**2*y**3\n\n        >>> f.terms()\n        [((2, 3), 2), ((1, 7), 1)]\n        >>> f.terms(grlex)\n        [((1, 7), 1), ((2, 3), 2)]\n\n        ",
    "section": "Sparse polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "field",
    "full_id": "sympy.polys.fields.field",
    "type": "function",
    "description": "Construct new rational function field returning (field, x1, ..., xn).",
    "section": "Sparse rational functions",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "xfield",
    "full_id": "sympy.polys.fields.xfield",
    "type": "function",
    "description": "Construct new rational function field returning (field, (x1, ..., xn)).",
    "section": "Sparse rational functions",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "vfield",
    "full_id": "sympy.polys.fields.vfield",
    "type": "function",
    "description": "Construct new rational function field and inject generators into global namespace.",
    "section": "Sparse rational functions",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sfield",
    "full_id": "sympy.polys.fields.sfield",
    "type": "function",
    "description": "Construct a field deriving generators and domain\n    from options and input expressions.\n\n    Parameters\n    ==========\n\n    exprs   : py:class:`~.Expr` or sequence of :py:class:`~.Expr` (sympifiable)\n\n    symbols : sequence of :py:class:`~.Symbol`/:py:class:`~.Expr`\n\n    options : keyword arguments understood by :py:class:`~.Options`\n\n    Examples\n    ========\n\n    >>> from sympy import exp, log, symbols, sfield\n\n    >>> x = symbols(\"x\")\n    >>> K, f = sfield((x*log(x) + 4*x**2)*exp(1/x + log(x)/3)/x**2)\n    >>> K\n    Rational function field in x, exp(1/x), log(x), x**(1/3) over ZZ with lex order\n    >>> f\n    (4*x**2*(exp(1/x)) + x*(exp(1/x))*(log(x)))/((x**(1/3))**5)\n    ",
    "section": "Sparse rational functions",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "diff",
    "full_id": "sympy.polys.fields.FracElement.diff",
    "type": "method",
    "description": "Computes partial derivative in ``x``.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.fields import field\n        >>> from sympy.polys.domains import ZZ\n\n        >>> _, x, y, z = field(\"x,y,z\", ZZ)\n        >>> ((x**2 + y)/(z + 1)).diff(x)\n        2*x/(z + 1)\n\n        ",
    "section": "Sparse rational functions",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "LC",
    "full_id": "sympy.polys.polyclasses.DMP.LC",
    "type": "method",
    "description": "Returns the leading coefficient of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "TC",
    "full_id": "sympy.polys.polyclasses.DMP.TC",
    "type": "method",
    "description": "Returns the trailing coefficient of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "abs",
    "full_id": "sympy.polys.polyclasses.DMP.abs",
    "type": "method",
    "description": "Make all coefficients in ``f`` positive.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.polyclasses.DMP.add",
    "type": "method",
    "description": "Add two multivariate polynomials ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "add_ground",
    "full_id": "sympy.polys.polyclasses.DMP.add_ground",
    "type": "method",
    "description": "Add an element of the ground domain to ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "all_coeffs",
    "full_id": "sympy.polys.polyclasses.DMP.all_coeffs",
    "type": "method",
    "description": "Returns all coefficients from ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "all_monoms",
    "full_id": "sympy.polys.polyclasses.DMP.all_monoms",
    "type": "method",
    "description": "Returns all monomials from ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "all_terms",
    "full_id": "sympy.polys.polyclasses.DMP.all_terms",
    "type": "method",
    "description": "Returns all terms from a ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "cancel",
    "full_id": "sympy.polys.polyclasses.DMP.cancel",
    "type": "method",
    "description": "Cancel common factors in a rational function ``f/g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "cauchy_lower_bound",
    "full_id": "sympy.polys.polyclasses.DMP.cauchy_lower_bound",
    "type": "method",
    "description": "Computes the Cauchy lower bound on the nonzero roots of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "cauchy_upper_bound",
    "full_id": "sympy.polys.polyclasses.DMP.cauchy_upper_bound",
    "type": "method",
    "description": "Computes the Cauchy upper bound on the roots of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "clear_denoms",
    "full_id": "sympy.polys.polyclasses.DMP.clear_denoms",
    "type": "method",
    "description": "Clear denominators, but keep the ground domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "coeffs",
    "full_id": "sympy.polys.polyclasses.DMP.coeffs",
    "type": "method",
    "description": "Returns all non-zero coefficients from ``f`` in lex order.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "cofactors",
    "full_id": "sympy.polys.polyclasses.DMP.cofactors",
    "type": "method",
    "description": "Returns GCD of ``f`` and ``g`` and their cofactors.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "compose",
    "full_id": "sympy.polys.polyclasses.DMP.compose",
    "type": "method",
    "description": "Computes functional composition of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "content",
    "full_id": "sympy.polys.polyclasses.DMP.content",
    "type": "method",
    "description": "Returns GCD of polynomial coefficients.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "convert",
    "full_id": "sympy.polys.polyclasses.DMP.convert",
    "type": "method",
    "description": "Convert ``f`` to a ``DMP`` over the new domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "count_complex_roots",
    "full_id": "sympy.polys.polyclasses.DMP.count_complex_roots",
    "type": "method",
    "description": "Return the number of complex roots of ``f`` in ``[inf, sup]``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "count_real_roots",
    "full_id": "sympy.polys.polyclasses.DMP.count_real_roots",
    "type": "method",
    "description": "Return the number of real roots of ``f`` in ``[inf, sup]``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "decompose",
    "full_id": "sympy.polys.polyclasses.DMP.decompose",
    "type": "method",
    "description": "Computes functional decomposition of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "deflate",
    "full_id": "sympy.polys.polyclasses.DMP.deflate",
    "type": "method",
    "description": "Reduce degree of `f` by mapping `x_i^m` to `y_i`.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "degree",
    "full_id": "sympy.polys.polyclasses.DMP.degree",
    "type": "method",
    "description": "Returns the leading degree of ``f`` in ``x_j``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "degree_list",
    "full_id": "sympy.polys.polyclasses.DMP.degree_list",
    "type": "method",
    "description": "Returns a list of degrees of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "diff",
    "full_id": "sympy.polys.polyclasses.DMP.diff",
    "type": "method",
    "description": "Computes the ``m``-th order derivative of ``f`` in ``x_j``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "discriminant",
    "full_id": "sympy.polys.polyclasses.DMP.discriminant",
    "type": "method",
    "description": "Computes discriminant of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "div",
    "full_id": "sympy.polys.polyclasses.DMP.div",
    "type": "method",
    "description": "Polynomial division with remainder of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "eject",
    "full_id": "sympy.polys.polyclasses.DMP.eject",
    "type": "method",
    "description": "Eject selected generators into the ground domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "eval",
    "full_id": "sympy.polys.polyclasses.DMP.eval",
    "type": "method",
    "description": "Evaluates ``f`` at the given point ``a`` in ``x_j``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exclude",
    "full_id": "sympy.polys.polyclasses.DMP.exclude",
    "type": "method",
    "description": "\n        Remove useless generators from ``f``.\n\n        Returns the removed generators and the new excluded ``f``.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.polyclasses import DMP\n        >>> from sympy.polys.domains import ZZ\n\n        >>> DMP([[[ZZ(1)]], [[ZZ(1)], [ZZ(2)]]], ZZ).exclude()\n        ([2], DMP_Python([[1], [1, 2]], ZZ))\n\n        ",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exquo",
    "full_id": "sympy.polys.polyclasses.DMP.exquo",
    "type": "method",
    "description": "Computes polynomial exact quotient of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exquo_ground",
    "full_id": "sympy.polys.polyclasses.DMP.exquo_ground",
    "type": "method",
    "description": "Exact quotient of ``f`` by a an element of the ground domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "factor_list",
    "full_id": "sympy.polys.polyclasses.DMP.factor_list",
    "type": "method",
    "description": "Returns a list of irreducible factors of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_list",
    "full_id": "sympy.polys.polyclasses.DMP.from_list",
    "type": "method",
    "description": "Create an instance of ``cls`` given a list of native coefficients.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "from_sympy_list",
    "full_id": "sympy.polys.polyclasses.DMP.from_sympy_list",
    "type": "method",
    "description": "Create an instance of ``cls`` given a list of SymPy coefficients.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcd",
    "full_id": "sympy.polys.polyclasses.DMP.gcd",
    "type": "method",
    "description": "Returns polynomial GCD of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gcdex",
    "full_id": "sympy.polys.polyclasses.DMP.gcdex",
    "type": "method",
    "description": "Extended Euclidean algorithm, if univariate.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "gff_list",
    "full_id": "sympy.polys.polyclasses.DMP.gff_list",
    "type": "method",
    "description": "Computes greatest factorial factorization of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "ground_new",
    "full_id": "sympy.polys.polyclasses.DMP.ground_new",
    "type": "method",
    "description": "Construct a new ground instance of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "half_gcdex",
    "full_id": "sympy.polys.polyclasses.DMP.half_gcdex",
    "type": "method",
    "description": "Half extended Euclidean algorithm, if univariate.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "homogeneous_order",
    "full_id": "sympy.polys.polyclasses.DMP.homogeneous_order",
    "type": "method",
    "description": "Returns the homogeneous order of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "homogenize",
    "full_id": "sympy.polys.polyclasses.DMP.homogenize",
    "type": "method",
    "description": "Return homogeneous polynomial of ``f``",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "inject",
    "full_id": "sympy.polys.polyclasses.DMP.inject",
    "type": "method",
    "description": "Inject ground domain generators into ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "integrate",
    "full_id": "sympy.polys.polyclasses.DMP.integrate",
    "type": "method",
    "description": "Computes the ``m``-th order indefinite integral of ``f`` in ``x_j``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "intervals",
    "full_id": "sympy.polys.polyclasses.DMP.intervals",
    "type": "method",
    "description": "Compute isolating intervals for roots of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "invert",
    "full_id": "sympy.polys.polyclasses.DMP.invert",
    "type": "method",
    "description": "Invert ``f`` modulo ``g``, if possible.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_cyclotomic",
    "full_id": "sympy.polys.polyclasses.DMP.is_cyclotomic",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is a cyclotomic polynomial.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_ground",
    "full_id": "sympy.polys.polyclasses.DMP.is_ground",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is an element of the ground domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_homogeneous",
    "full_id": "sympy.polys.polyclasses.DMP.is_homogeneous",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is a homogeneous polynomial.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_irreducible",
    "full_id": "sympy.polys.polyclasses.DMP.is_irreducible",
    "type": "property",
    "description": "Returns ``True`` if ``f`` has no factors over its domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_linear",
    "full_id": "sympy.polys.polyclasses.DMP.is_linear",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is linear in all its variables.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_monic",
    "full_id": "sympy.polys.polyclasses.DMP.is_monic",
    "type": "property",
    "description": "Returns ``True`` if the leading coefficient of ``f`` is one.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_monomial",
    "full_id": "sympy.polys.polyclasses.DMP.is_monomial",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is zero or has only one term.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_one",
    "full_id": "sympy.polys.polyclasses.DMP.is_one",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is a unit polynomial.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_primitive",
    "full_id": "sympy.polys.polyclasses.DMP.is_primitive",
    "type": "property",
    "description": "Returns ``True`` if the GCD of the coefficients of ``f`` is one.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_quadratic",
    "full_id": "sympy.polys.polyclasses.DMP.is_quadratic",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is quadratic in all its variables.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_sqf",
    "full_id": "sympy.polys.polyclasses.DMP.is_sqf",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is a square-free polynomial.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.polyclasses.DMP.is_zero",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is a zero polynomial.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "l1_norm",
    "full_id": "sympy.polys.polyclasses.DMP.l1_norm",
    "type": "method",
    "description": "Returns l1 norm of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "l2_norm_squared",
    "full_id": "sympy.polys.polyclasses.DMP.l2_norm_squared",
    "type": "method",
    "description": "Return squared l2 norm of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "lcm",
    "full_id": "sympy.polys.polyclasses.DMP.lcm",
    "type": "method",
    "description": "Returns polynomial LCM of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "lift",
    "full_id": "sympy.polys.polyclasses.DMP.lift",
    "type": "method",
    "description": "Convert algebraic coefficients to rationals.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "max_norm",
    "full_id": "sympy.polys.polyclasses.DMP.max_norm",
    "type": "method",
    "description": "Returns maximum norm of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "mignotte_sep_bound_squared",
    "full_id": "sympy.polys.polyclasses.DMP.mignotte_sep_bound_squared",
    "type": "method",
    "description": "Computes the squared Mignotte bound on root separations of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "monic",
    "full_id": "sympy.polys.polyclasses.DMP.monic",
    "type": "method",
    "description": "Divides all coefficients by ``LC(f)``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "monoms",
    "full_id": "sympy.polys.polyclasses.DMP.monoms",
    "type": "method",
    "description": "Returns all non-zero monomials from ``f`` in lex order.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.polys.polyclasses.DMP.mul",
    "type": "method",
    "description": "Multiply two multivariate polynomials ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "mul_ground",
    "full_id": "sympy.polys.polyclasses.DMP.mul_ground",
    "type": "method",
    "description": "Multiply ``f`` by a an element of the ground domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "neg",
    "full_id": "sympy.polys.polyclasses.DMP.neg",
    "type": "method",
    "description": "Negate all coefficients in ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "norm",
    "full_id": "sympy.polys.polyclasses.DMP.norm",
    "type": "method",
    "description": "Computes ``Norm(f)``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "nth",
    "full_id": "sympy.polys.polyclasses.DMP.nth",
    "type": "method",
    "description": "Returns the ``n``-th coefficient of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "pdiv",
    "full_id": "sympy.polys.polyclasses.DMP.pdiv",
    "type": "method",
    "description": "Polynomial pseudo-division of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "permute",
    "full_id": "sympy.polys.polyclasses.DMP.permute",
    "type": "method",
    "description": "\n        Returns a polynomial in `K[x_{P(1)}, ..., x_{P(n)}]`.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.polyclasses import DMP\n        >>> from sympy.polys.domains import ZZ\n\n        >>> DMP([[[ZZ(2)], [ZZ(1), ZZ(0)]], [[]]], ZZ).permute([1, 0, 2])\n        DMP_Python([[[2], []], [[1, 0], []]], ZZ)\n\n        >>> DMP([[[ZZ(2)], [ZZ(1), ZZ(0)]], [[]]], ZZ).permute([1, 2, 0])\n        DMP_Python([[[1], []], [[2, 0], []]], ZZ)\n\n        ",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "pexquo",
    "full_id": "sympy.polys.polyclasses.DMP.pexquo",
    "type": "method",
    "description": "Polynomial exact pseudo-quotient of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "pow",
    "full_id": "sympy.polys.polyclasses.DMP.pow",
    "type": "method",
    "description": "Raise ``f`` to a non-negative power ``n``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "pquo",
    "full_id": "sympy.polys.polyclasses.DMP.pquo",
    "type": "method",
    "description": "Polynomial pseudo-quotient of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "prem",
    "full_id": "sympy.polys.polyclasses.DMP.prem",
    "type": "method",
    "description": "Polynomial pseudo-remainder of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "primitive",
    "full_id": "sympy.polys.polyclasses.DMP.primitive",
    "type": "method",
    "description": "Returns content and a primitive form of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "quo",
    "full_id": "sympy.polys.polyclasses.DMP.quo",
    "type": "method",
    "description": "Computes polynomial quotient of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "quo_ground",
    "full_id": "sympy.polys.polyclasses.DMP.quo_ground",
    "type": "method",
    "description": "Quotient of ``f`` by a an element of the ground domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "refine_root",
    "full_id": "sympy.polys.polyclasses.DMP.refine_root",
    "type": "method",
    "description": "\n        Refine an isolating interval to the given precision.\n\n        ``eps`` should be a rational number.\n\n        ",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "rem",
    "full_id": "sympy.polys.polyclasses.DMP.rem",
    "type": "method",
    "description": "Computes polynomial remainder of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "rep",
    "full_id": "sympy.polys.polyclasses.DMP.rep",
    "type": "property",
    "description": "Get the representation of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "resultant",
    "full_id": "sympy.polys.polyclasses.DMP.resultant",
    "type": "method",
    "description": "Computes resultant of ``f`` and ``g`` via PRS.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "revert",
    "full_id": "sympy.polys.polyclasses.DMP.revert",
    "type": "method",
    "description": "Compute ``f**(-1)`` mod ``x**n``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "shift",
    "full_id": "sympy.polys.polyclasses.DMP.shift",
    "type": "method",
    "description": "Efficiently compute Taylor shift ``f(x + a)``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "shift_list",
    "full_id": "sympy.polys.polyclasses.DMP.shift_list",
    "type": "method",
    "description": "Efficiently compute Taylor shift ``f(X + A)``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sqf_list",
    "full_id": "sympy.polys.polyclasses.DMP.sqf_list",
    "type": "method",
    "description": "Returns a list of square-free factors of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sqf_norm",
    "full_id": "sympy.polys.polyclasses.DMP.sqf_norm",
    "type": "method",
    "description": "Computes square-free norm of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sqf_part",
    "full_id": "sympy.polys.polyclasses.DMP.sqf_part",
    "type": "method",
    "description": "Computes square-free part of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sqr",
    "full_id": "sympy.polys.polyclasses.DMP.sqr",
    "type": "method",
    "description": "Square a multivariate polynomial ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sturm",
    "full_id": "sympy.polys.polyclasses.DMP.sturm",
    "type": "method",
    "description": "Computes the Sturm sequence of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sub",
    "full_id": "sympy.polys.polyclasses.DMP.sub",
    "type": "method",
    "description": "Subtract two multivariate polynomials ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sub_ground",
    "full_id": "sympy.polys.polyclasses.DMP.sub_ground",
    "type": "method",
    "description": "Subtract an element of the ground domain from ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "subresultants",
    "full_id": "sympy.polys.polyclasses.DMP.subresultants",
    "type": "method",
    "description": "Computes subresultant PRS sequence of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "terms",
    "full_id": "sympy.polys.polyclasses.DMP.terms",
    "type": "method",
    "description": "Returns all non-zero terms from ``f`` in lex order.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "terms_gcd",
    "full_id": "sympy.polys.polyclasses.DMP.terms_gcd",
    "type": "method",
    "description": "Remove GCD of terms from the polynomial ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_best",
    "full_id": "sympy.polys.polyclasses.DMP.to_best",
    "type": "method",
    "description": "Convert to DUP_Flint if possible.\n\n        This method should be used when the domain or level is changed and it\n        potentially becomes possible to convert from DMP_Python to DUP_Flint.\n        ",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_dict",
    "full_id": "sympy.polys.polyclasses.DMP.to_dict",
    "type": "method",
    "description": "Convert ``f`` to a dict representation with native coefficients.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_exact",
    "full_id": "sympy.polys.polyclasses.DMP.to_exact",
    "type": "method",
    "description": "Make the ground domain exact.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_field",
    "full_id": "sympy.polys.polyclasses.DMP.to_field",
    "type": "method",
    "description": "Make the ground domain a field.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_list",
    "full_id": "sympy.polys.polyclasses.DMP.to_list",
    "type": "method",
    "description": "Convert ``f`` to a list representation with native coefficients.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_ring",
    "full_id": "sympy.polys.polyclasses.DMP.to_ring",
    "type": "method",
    "description": "Make the ground domain a ring.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_sympy_dict",
    "full_id": "sympy.polys.polyclasses.DMP.to_sympy_dict",
    "type": "method",
    "description": "Convert ``f`` to a dict representation with SymPy coefficients.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_sympy_list",
    "full_id": "sympy.polys.polyclasses.DMP.to_sympy_list",
    "type": "method",
    "description": "Convert ``f`` to a list representation with SymPy coefficients.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "to_tuple",
    "full_id": "sympy.polys.polyclasses.DMP.to_tuple",
    "type": "method",
    "description": "\n        Convert ``f`` to a tuple representation with native coefficients.\n\n        This is needed for hashing.\n        ",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "total_degree",
    "full_id": "sympy.polys.polyclasses.DMP.total_degree",
    "type": "method",
    "description": "Returns the total degree of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "transform",
    "full_id": "sympy.polys.polyclasses.DMP.transform",
    "type": "method",
    "description": "Evaluate functional transformation ``q**n * f(p/q)``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "trunc",
    "full_id": "sympy.polys.polyclasses.DMP.trunc",
    "type": "method",
    "description": "Reduce ``f`` modulo a constant ``p``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "unify_DMP",
    "full_id": "sympy.polys.polyclasses.DMP.unify_DMP",
    "type": "method",
    "description": "Unify and return ``DMP`` instances of ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.polyclasses.DMF.add",
    "type": "method",
    "description": "Add two multivariate fractions ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "cancel",
    "full_id": "sympy.polys.polyclasses.DMF.cancel",
    "type": "method",
    "description": "Remove common factors from ``f.num`` and ``f.den``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "denom",
    "full_id": "sympy.polys.polyclasses.DMF.denom",
    "type": "method",
    "description": "Returns the denominator of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "exquo",
    "full_id": "sympy.polys.polyclasses.DMF.exquo",
    "type": "method",
    "description": "Computes quotient of fractions ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "frac_unify",
    "full_id": "sympy.polys.polyclasses.DMF.frac_unify",
    "type": "method",
    "description": "Unify representations of two multivariate fractions.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "half_per",
    "full_id": "sympy.polys.polyclasses.DMF.half_per",
    "type": "method",
    "description": "Create a DMP out of the given representation.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "invert",
    "full_id": "sympy.polys.polyclasses.DMF.invert",
    "type": "method",
    "description": "Computes inverse of a fraction ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_one",
    "full_id": "sympy.polys.polyclasses.DMF.is_one",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is a unit fraction.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.polyclasses.DMF.is_zero",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is a zero fraction.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.polys.polyclasses.DMF.mul",
    "type": "method",
    "description": "Multiply two multivariate fractions ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "numer",
    "full_id": "sympy.polys.polyclasses.DMF.numer",
    "type": "method",
    "description": "Returns the numerator of ``f``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "per",
    "full_id": "sympy.polys.polyclasses.DMF.per",
    "type": "method",
    "description": "Create a DMF out of the given representation.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "poly_unify",
    "full_id": "sympy.polys.polyclasses.DMF.poly_unify",
    "type": "method",
    "description": "Unify a multivariate fraction and a polynomial.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "sub",
    "full_id": "sympy.polys.polyclasses.DMF.sub",
    "type": "method",
    "description": "Subtract two multivariate fractions ``f`` and ``g``.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "convert",
    "full_id": "sympy.polys.polyclasses.ANP.convert",
    "type": "method",
    "description": "Convert ``f`` to a ``ANP`` over a new domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_one",
    "full_id": "sympy.polys.polyclasses.ANP.is_one",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is a unit algebraic number.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "is_zero",
    "full_id": "sympy.polys.polyclasses.ANP.is_zero",
    "type": "property",
    "description": "Returns ``True`` if ``f`` is a zero algebraic number.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "mod_to_list",
    "full_id": "sympy.polys.polyclasses.ANP.mod_to_list",
    "type": "method",
    "description": "Return ``f.mod`` as a list with native coefficients.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "mul_ground",
    "full_id": "sympy.polys.polyclasses.ANP.mul_ground",
    "type": "method",
    "description": "Multiply ``f`` by an element of the ground domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "quo_ground",
    "full_id": "sympy.polys.polyclasses.ANP.quo_ground",
    "type": "method",
    "description": "Quotient of ``f`` by an element of the ground domain.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "unify",
    "full_id": "sympy.polys.polyclasses.ANP.unify",
    "type": "method",
    "description": "Unify representations of two algebraic numbers.",
    "section": "Dense polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/domainsref.html"
  },
  {
    "name": "dmp_LC",
    "full_id": "sympy.polys.densebasic.dmp_LC",
    "type": "function",
    "description": "\n    Return leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import poly_LC\n\n    >>> poly_LC([], ZZ)\n    0\n    >>> poly_LC([ZZ(1), ZZ(2), ZZ(3)], ZZ)\n    1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_TC",
    "full_id": "sympy.polys.densebasic.dmp_TC",
    "type": "function",
    "description": "\n    Return trailing coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import poly_TC\n\n    >>> poly_TC([], ZZ)\n    0\n    >>> poly_TC([ZZ(1), ZZ(2), ZZ(3)], ZZ)\n    3\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground_LC",
    "full_id": "sympy.polys.densebasic.dmp_ground_LC",
    "type": "function",
    "description": "\n    Return the ground leading coefficient.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground_LC\n\n    >>> f = ZZ.map([[[1], [2, 3]]])\n\n    >>> dmp_ground_LC(f, 2, ZZ)\n    1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground_TC",
    "full_id": "sympy.polys.densebasic.dmp_ground_TC",
    "type": "function",
    "description": "\n    Return the ground trailing coefficient.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground_TC\n\n    >>> f = ZZ.map([[[1], [2, 3]]])\n\n    >>> dmp_ground_TC(f, 2, ZZ)\n    3\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_true_LT",
    "full_id": "sympy.polys.densebasic.dmp_true_LT",
    "type": "function",
    "description": "\n    Return the leading term ``c * x_1**n_1 ... x_k**n_k``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_true_LT\n\n    >>> f = ZZ.map([[4], [2, 0], [3, 0, 0]])\n\n    >>> dmp_true_LT(f, 1, ZZ)\n    ((2, 0), 4)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_degree",
    "full_id": "sympy.polys.densebasic.dmp_degree",
    "type": "function",
    "description": "\n    Return the leading degree of ``f`` in ``x_0`` in ``K[X]``.\n\n    Note that the degree of 0 is negative infinity (``float('-inf')``).\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_degree\n\n    >>> dmp_degree([[[]]], 2)\n    -inf\n\n    >>> f = ZZ.map([[2], [1, 2, 3]])\n\n    >>> dmp_degree(f, 1)\n    1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_degree_in",
    "full_id": "sympy.polys.densebasic.dmp_degree_in",
    "type": "function",
    "description": "\n    Return the leading degree of ``f`` in ``x_j`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_degree_in\n\n    >>> f = ZZ.map([[2], [1, 2, 3]])\n\n    >>> dmp_degree_in(f, 0, 1)\n    1\n    >>> dmp_degree_in(f, 1, 1)\n    2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_degree_list",
    "full_id": "sympy.polys.densebasic.dmp_degree_list",
    "type": "function",
    "description": "\n    Return a list of degrees of ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_degree_list\n\n    >>> f = ZZ.map([[1], [1, 2, 3]])\n\n    >>> dmp_degree_list(f, 1)\n    (1, 2)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_strip",
    "full_id": "sympy.polys.densebasic.dmp_strip",
    "type": "function",
    "description": "\n    Remove leading zeros from ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_strip\n\n    >>> dmp_strip([[], [0, 1, 2], [1]], 1)\n    [[0, 1, 2], [1]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_validate",
    "full_id": "sympy.polys.densebasic.dmp_validate",
    "type": "function",
    "description": "\n    Return the number of levels in ``f`` and recursively strip it.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_validate\n\n    >>> dmp_validate([[], [0, 1, 2], [1]])\n    ([[1, 2], [1]], 1)\n\n    >>> dmp_validate([[1], 1])\n    Traceback (most recent call last):\n    ...\n    ValueError: invalid data structure for a multivariate polynomial\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_reverse",
    "full_id": "sympy.polys.densebasic.dup_reverse",
    "type": "function",
    "description": "\n    Compute ``x**n * f(1/x)``, i.e.: reverse ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_reverse\n\n    >>> f = ZZ.map([1, 2, 3, 0])\n\n    >>> dup_reverse(f)\n    [3, 2, 1]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_copy",
    "full_id": "sympy.polys.densebasic.dmp_copy",
    "type": "function",
    "description": "\n    Create a new copy of a polynomial ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_copy\n\n    >>> f = ZZ.map([[1], [1, 2]])\n\n    >>> dmp_copy(f, 1)\n    [[1], [1, 2]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_to_tuple",
    "full_id": "sympy.polys.densebasic.dmp_to_tuple",
    "type": "function",
    "description": "\n    Convert `f` into a nested tuple of tuples.\n\n    This is needed for hashing.  This is similar to dmp_copy().\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_to_tuple\n\n    >>> f = ZZ.map([[1], [1, 2]])\n\n    >>> dmp_to_tuple(f, 1)\n    ((1,), (1, 2))\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_normal",
    "full_id": "sympy.polys.densebasic.dmp_normal",
    "type": "function",
    "description": "\n    Normalize a multivariate polynomial in the given domain.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_normal\n\n    >>> dmp_normal([[], [0, 1, 2]], 1, ZZ)\n    [[1, 2]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_convert",
    "full_id": "sympy.polys.densebasic.dmp_convert",
    "type": "function",
    "description": "\n    Convert the ground domain of ``f`` from ``K0`` to ``K1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_convert\n\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> dmp_convert([[R(1)], [R(2)]], 1, R.to_domain(), ZZ)\n    [[1], [2]]\n    >>> dmp_convert([[ZZ(1)], [ZZ(2)]], 1, ZZ, R.to_domain())\n    [[1], [2]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_from_sympy",
    "full_id": "sympy.polys.densebasic.dmp_from_sympy",
    "type": "function",
    "description": "\n    Convert the ground domain of ``f`` from SymPy to ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy import S\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_from_sympy\n\n    >>> dmp_from_sympy([[S(1)], [S(2)]], 1, ZZ) == [[ZZ(1)], [ZZ(2)]]\n    True\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_nth",
    "full_id": "sympy.polys.densebasic.dmp_nth",
    "type": "function",
    "description": "\n    Return the ``n``-th coefficient of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_nth\n\n    >>> f = ZZ.map([[1], [2], [3]])\n\n    >>> dmp_nth(f, 0, 1, ZZ)\n    [3]\n    >>> dmp_nth(f, 4, 1, ZZ)\n    []\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground_nth",
    "full_id": "sympy.polys.densebasic.dmp_ground_nth",
    "type": "function",
    "description": "\n    Return the ground ``n``-th coefficient of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_ground_nth\n\n    >>> f = ZZ.map([[1], [2, 3]])\n\n    >>> dmp_ground_nth(f, (0, 1), 1, ZZ)\n    2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zero_p",
    "full_id": "sympy.polys.densebasic.dmp_zero_p",
    "type": "function",
    "description": "\n    Return ``True`` if ``f`` is zero in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero_p\n\n    >>> dmp_zero_p([[[[[]]]]], 4)\n    True\n    >>> dmp_zero_p([[[[[1]]]]], 4)\n    False\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zero",
    "full_id": "sympy.polys.densebasic.dmp_zero",
    "type": "function",
    "description": "\n    Return a multivariate zero.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_zero\n\n    >>> dmp_zero(4)\n    [[[[[]]]]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_one_p",
    "full_id": "sympy.polys.densebasic.dmp_one_p",
    "type": "function",
    "description": "\n    Return ``True`` if ``f`` is one in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_one_p\n\n    >>> dmp_one_p([[[ZZ(1)]]], 2, ZZ)\n    True\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_one",
    "full_id": "sympy.polys.densebasic.dmp_one",
    "type": "function",
    "description": "\n    Return a multivariate one over ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_one\n\n    >>> dmp_one(2, ZZ)\n    [[[1]]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground_p",
    "full_id": "sympy.polys.densebasic.dmp_ground_p",
    "type": "function",
    "description": "\n    Return True if ``f`` is constant in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_ground_p\n\n    >>> dmp_ground_p([[[3]]], 3, 2)\n    True\n    >>> dmp_ground_p([[[4]]], None, 2)\n    True\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground",
    "full_id": "sympy.polys.densebasic.dmp_ground",
    "type": "function",
    "description": "\n    Return a multivariate constant.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_ground\n\n    >>> dmp_ground(3, 5)\n    [[[[[[3]]]]]]\n    >>> dmp_ground(1, -1)\n    1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zeros",
    "full_id": "sympy.polys.densebasic.dmp_zeros",
    "type": "function",
    "description": "\n    Return a list of multivariate zeros.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_zeros\n\n    >>> dmp_zeros(3, 2, ZZ)\n    [[[[]]], [[[]]], [[[]]]]\n    >>> dmp_zeros(3, -1, ZZ)\n    [0, 0, 0]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_grounds",
    "full_id": "sympy.polys.densebasic.dmp_grounds",
    "type": "function",
    "description": "\n    Return a list of multivariate constants.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_grounds\n\n    >>> dmp_grounds(ZZ(4), 3, 2)\n    [[[[4]]], [[[4]]], [[[4]]]]\n    >>> dmp_grounds(ZZ(4), 3, -1)\n    [4, 4, 4]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_negative_p",
    "full_id": "sympy.polys.densebasic.dmp_negative_p",
    "type": "function",
    "description": "\n    Return ``True`` if ``LC(f)`` is negative.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_negative_p\n\n    >>> dmp_negative_p([[ZZ(1)], [-ZZ(1)]], 1, ZZ)\n    False\n    >>> dmp_negative_p([[-ZZ(1)], [ZZ(1)]], 1, ZZ)\n    True\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_positive_p",
    "full_id": "sympy.polys.densebasic.dmp_positive_p",
    "type": "function",
    "description": "\n    Return ``True`` if ``LC(f)`` is positive.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_positive_p\n\n    >>> dmp_positive_p([[ZZ(1)], [-ZZ(1)]], 1, ZZ)\n    True\n    >>> dmp_positive_p([[-ZZ(1)], [ZZ(1)]], 1, ZZ)\n    False\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_from_dict",
    "full_id": "sympy.polys.densebasic.dmp_from_dict",
    "type": "function",
    "description": "\n    Create a ``K[X]`` polynomial from a ``dict``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_from_dict\n\n    >>> dmp_from_dict({(0, 0): ZZ(3), (0, 1): ZZ(2), (2, 1): ZZ(1)}, 1, ZZ)\n    [[1, 0], [], [2, 3]]\n    >>> dmp_from_dict({}, 0, ZZ)\n    []\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_to_dict",
    "full_id": "sympy.polys.densebasic.dmp_to_dict",
    "type": "function",
    "description": "\n    Convert a ``K[X]`` polynomial to a ``dict````.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.densebasic import dmp_to_dict\n\n    >>> dmp_to_dict([[1, 0], [], [2, 3]], 1)\n    {(0, 0): 3, (0, 1): 2, (2, 1): 1}\n    >>> dmp_to_dict([], 0)\n    {}\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_swap",
    "full_id": "sympy.polys.densebasic.dmp_swap",
    "type": "function",
    "description": "\n    Transform ``K[..x_i..x_j..]`` to ``K[..x_j..x_i..]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_swap\n\n    >>> f = ZZ.map([[[2], [1, 0]], []])\n\n    >>> dmp_swap(f, 0, 1, 2, ZZ)\n    [[[2], []], [[1, 0], []]]\n    >>> dmp_swap(f, 1, 2, 2, ZZ)\n    [[[1], [2, 0]], [[]]]\n    >>> dmp_swap(f, 0, 2, 2, ZZ)\n    [[[1, 0]], [[2, 0], []]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_permute",
    "full_id": "sympy.polys.densebasic.dmp_permute",
    "type": "function",
    "description": "\n    Return a polynomial in ``K[x_{P(1)},..,x_{P(n)}]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_permute\n\n    >>> f = ZZ.map([[[2], [1, 0]], []])\n\n    >>> dmp_permute(f, [1, 0, 2], 2, ZZ)\n    [[[2], []], [[1, 0], []]]\n    >>> dmp_permute(f, [1, 2, 0], 2, ZZ)\n    [[[1], []], [[2, 0], []]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_nest",
    "full_id": "sympy.polys.densebasic.dmp_nest",
    "type": "function",
    "description": "\n    Return a multivariate value nested ``l``-levels.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_nest\n\n    >>> dmp_nest([[ZZ(1)]], 2, ZZ)\n    [[[[1]]]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_raise",
    "full_id": "sympy.polys.densebasic.dmp_raise",
    "type": "function",
    "description": "\n    Return a multivariate polynomial raised ``l``-levels.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_raise\n\n    >>> f = ZZ.map([[], [1, 2]])\n\n    >>> dmp_raise(f, 2, 1, ZZ)\n    [[[[]]], [[[1]], [[2]]]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_deflate",
    "full_id": "sympy.polys.densebasic.dmp_deflate",
    "type": "function",
    "description": "\n    Map ``x_i**m_i`` to ``y_i`` in a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_deflate\n\n    >>> f = ZZ.map([[1, 0, 0, 2], [], [3, 0, 0, 4]])\n\n    >>> dmp_deflate(f, 1, ZZ)\n    ((2, 3), [[1, 2], [3, 4]])\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_multi_deflate",
    "full_id": "sympy.polys.densebasic.dmp_multi_deflate",
    "type": "function",
    "description": "\n    Map ``x_i**m_i`` to ``y_i`` in a set of polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_multi_deflate\n\n    >>> f = ZZ.map([[1, 0, 0, 2], [], [3, 0, 0, 4]])\n    >>> g = ZZ.map([[1, 0, 2], [], [3, 0, 4]])\n\n    >>> dmp_multi_deflate((f, g), 1, ZZ)\n    ((2, 1), ([[1, 0, 0, 2], [3, 0, 0, 4]], [[1, 0, 2], [3, 0, 4]]))\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_inflate",
    "full_id": "sympy.polys.densebasic.dmp_inflate",
    "type": "function",
    "description": "\n    Map ``y_i`` to ``x_i**k_i`` in a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_inflate\n\n    >>> f = ZZ.map([[1, 2], [3, 4]])\n\n    >>> dmp_inflate(f, (2, 3), 1, ZZ)\n    [[1, 0, 0, 2], [], [3, 0, 0, 4]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_exclude",
    "full_id": "sympy.polys.densebasic.dmp_exclude",
    "type": "function",
    "description": "\n    Exclude useless levels from ``f``.\n\n    Return the levels excluded, the new excluded ``f``, and the new ``u``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_exclude\n\n    >>> f = ZZ.map([[[1]], [[1], [2]]])\n\n    >>> dmp_exclude(f, 2, ZZ)\n    ([2], [[1], [1, 2]], 1)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_include",
    "full_id": "sympy.polys.densebasic.dmp_include",
    "type": "function",
    "description": "\n    Include useless levels in ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_include\n\n    >>> f = ZZ.map([[1], [1, 2]])\n\n    >>> dmp_include(f, [2], 1, ZZ)\n    [[[1]], [[1], [2]]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_inject",
    "full_id": "sympy.polys.densebasic.dmp_inject",
    "type": "function",
    "description": "\n    Convert ``f`` from ``K[X][Y]`` to ``K[X,Y]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_inject\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> dmp_inject([R(1), x + 2], 0, R.to_domain())\n    ([[[1]], [[1], [2]]], 2)\n    >>> dmp_inject([R(1), x + 2], 0, R.to_domain(), front=True)\n    ([[[1]], [[1, 2]]], 2)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_eject",
    "full_id": "sympy.polys.densebasic.dmp_eject",
    "type": "function",
    "description": "\n    Convert ``f`` from ``K[X,Y]`` to ``K[X][Y]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_eject\n\n    >>> dmp_eject([[[1]], [[1], [2]]], 2, ZZ['x', 'y'])\n    [1, x + 2]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_terms_gcd",
    "full_id": "sympy.polys.densebasic.dmp_terms_gcd",
    "type": "function",
    "description": "\n    Remove GCD of terms from ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_terms_gcd\n\n    >>> f = ZZ.map([[1, 0], [1, 0, 0], [], []])\n\n    >>> dmp_terms_gcd(f, 1, ZZ)\n    ((2, 1), [[1], [1, 0]])\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_list_terms",
    "full_id": "sympy.polys.densebasic.dmp_list_terms",
    "type": "function",
    "description": "\n    List all non-zero terms from ``f`` in the given order ``order``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_list_terms\n\n    >>> f = ZZ.map([[1, 1], [2, 3]])\n\n    >>> dmp_list_terms(f, 1, ZZ)\n    [((1, 1), 1), ((1, 0), 1), ((0, 1), 2), ((0, 0), 3)]\n    >>> dmp_list_terms(f, 1, ZZ, order='grevlex')\n    [((1, 1), 1), ((1, 0), 1), ((0, 1), 2), ((0, 0), 3)]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_apply_pairs",
    "full_id": "sympy.polys.densebasic.dmp_apply_pairs",
    "type": "function",
    "description": "\n    Apply ``h`` to pairs of coefficients of ``f`` and ``g``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dmp_apply_pairs\n\n    >>> h = lambda x, y, z: 2*x + y - z\n\n    >>> dmp_apply_pairs([[1], [2, 3]], [[3], [2, 1]], h, (1,), 1, ZZ)\n    [[4], [5, 6]]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_slice",
    "full_id": "sympy.polys.densebasic.dmp_slice",
    "type": "function",
    "description": "Take a continuous subsequence of terms of ``f`` in ``K[X]``.",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_random",
    "full_id": "sympy.polys.densebasic.dup_random",
    "type": "function",
    "description": "\n    Return a polynomial of degree ``n`` with coefficients in ``[a, b]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.densebasic import dup_random\n\n    >>> dup_random(3, -10, 10, ZZ) #doctest: +SKIP\n    [-2, -8, 9, -4]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_add_term",
    "full_id": "sympy.polys.densearith.dmp_add_term",
    "type": "function",
    "description": "\n    Add ``c(x_2..x_u)*x_0**i`` to ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_add_term(x*y + 1, 2, 2)\n    2*x**2 + x*y + 1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sub_term",
    "full_id": "sympy.polys.densearith.dmp_sub_term",
    "type": "function",
    "description": "\n    Subtract ``c(x_2..x_u)*x_0**i`` from ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sub_term(2*x**2 + x*y + 1, 2, 2)\n    x*y + 1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_mul_term",
    "full_id": "sympy.polys.densearith.dmp_mul_term",
    "type": "function",
    "description": "\n    Multiply ``f`` by ``c(x_2..x_u)*x_0**i`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul_term(x**2*y + x, 3*y, 2)\n    3*x**4*y**2 + 3*x**3*y\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_add_ground",
    "full_id": "sympy.polys.densearith.dmp_add_ground",
    "type": "function",
    "description": "\n    Add an element of the ground domain to ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_add_ground(x**3 + 2*x**2 + 3*x + 4, ZZ(4))\n    x**3 + 2*x**2 + 3*x + 8\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sub_ground",
    "full_id": "sympy.polys.densearith.dmp_sub_ground",
    "type": "function",
    "description": "\n    Subtract an element of the ground domain from ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sub_ground(x**3 + 2*x**2 + 3*x + 4, ZZ(4))\n    x**3 + 2*x**2 + 3*x\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_mul_ground",
    "full_id": "sympy.polys.densearith.dmp_mul_ground",
    "type": "function",
    "description": "\n    Multiply ``f`` by a constant value in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul_ground(2*x + 2*y, ZZ(3))\n    6*x + 6*y\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_quo_ground",
    "full_id": "sympy.polys.densearith.dmp_quo_ground",
    "type": "function",
    "description": "\n    Quotient by a constant in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> R.dmp_quo_ground(2*x**2*y + 3*x, ZZ(2))\n    x**2*y + x\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> R.dmp_quo_ground(2*x**2*y + 3*x, QQ(2))\n    x**2*y + 3/2*x\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_exquo_ground",
    "full_id": "sympy.polys.densearith.dmp_exquo_ground",
    "type": "function",
    "description": "\n    Exact quotient by a constant in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y = ring(\"x,y\", QQ)\n\n    >>> R.dmp_exquo_ground(x**2*y + 2*x, QQ(2))\n    1/2*x**2*y + x\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_lshift",
    "full_id": "sympy.polys.densearith.dup_lshift",
    "type": "function",
    "description": "\n    Efficiently multiply ``f`` by ``x**n`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_lshift(x**2 + 1, 2)\n    x**4 + x**2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_rshift",
    "full_id": "sympy.polys.densearith.dup_rshift",
    "type": "function",
    "description": "\n    Efficiently divide ``f`` by ``x**n`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_rshift(x**4 + x**2, 2)\n    x**2 + 1\n    >>> R.dup_rshift(x**4 + x**2 + 2, 2)\n    x**2 + 1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_abs",
    "full_id": "sympy.polys.densearith.dmp_abs",
    "type": "function",
    "description": "\n    Make all coefficients positive in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_abs(x**2*y - x)\n    x**2*y + x\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_neg",
    "full_id": "sympy.polys.densearith.dmp_neg",
    "type": "function",
    "description": "\n    Negate a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_neg(x**2*y - x)\n    -x**2*y + x\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_add",
    "full_id": "sympy.polys.densearith.dmp_add",
    "type": "function",
    "description": "\n    Add dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_add(x**2 + y, x**2*y + x)\n    x**2*y + x**2 + x + y\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sub",
    "full_id": "sympy.polys.densearith.dmp_sub",
    "type": "function",
    "description": "\n    Subtract dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sub(x**2 + y, x**2*y + x)\n    -x**2*y + x**2 - x + y\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_add_mul",
    "full_id": "sympy.polys.densearith.dmp_add_mul",
    "type": "function",
    "description": "\n    Returns ``f + g*h`` where ``f, g, h`` are in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_add_mul(x**2 + y, x, x + 2)\n    2*x**2 + 2*x + y\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sub_mul",
    "full_id": "sympy.polys.densearith.dmp_sub_mul",
    "type": "function",
    "description": "\n    Returns ``f - g*h`` where ``f, g, h`` are in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sub_mul(x**2 + y, x, x + 2)\n    -2*x + y\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_mul",
    "full_id": "sympy.polys.densearith.dmp_mul",
    "type": "function",
    "description": "\n    Multiply dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_mul(x*y + 1, x)\n    x**2*y + x\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sqr",
    "full_id": "sympy.polys.densearith.dmp_sqr",
    "type": "function",
    "description": "\n    Square dense polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sqr(x**2 + x*y + y**2)\n    x**4 + 2*x**3*y + 3*x**2*y**2 + 2*x*y**3 + y**4\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_pow",
    "full_id": "sympy.polys.densearith.dmp_pow",
    "type": "function",
    "description": "\n    Raise ``f`` to the ``n``-th power in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_pow(x*y + 1, 3)\n    x**3*y**3 + 3*x**2*y**2 + 3*x*y + 1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_pdiv",
    "full_id": "sympy.polys.densearith.dmp_pdiv",
    "type": "function",
    "description": "\n    Polynomial pseudo-division in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_pdiv(x**2 + x*y, 2*x + 2)\n    (2*x + 2*y - 2, -4*y + 4)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_prem",
    "full_id": "sympy.polys.densearith.dmp_prem",
    "type": "function",
    "description": "\n    Polynomial pseudo-remainder in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_prem(x**2 + x*y, 2*x + 2)\n    -4*y + 4\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_pquo",
    "full_id": "sympy.polys.densearith.dmp_pquo",
    "type": "function",
    "description": "\n    Polynomial exact pseudo-quotient in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + x*y\n    >>> g = 2*x + 2*y\n    >>> h = 2*x + 2\n\n    >>> R.dmp_pquo(f, g)\n    2*x\n\n    >>> R.dmp_pquo(f, h)\n    2*x + 2*y - 2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_pexquo",
    "full_id": "sympy.polys.densearith.dmp_pexquo",
    "type": "function",
    "description": "\n    Polynomial pseudo-quotient in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + x*y\n    >>> g = 2*x + 2*y\n    >>> h = 2*x + 2\n\n    >>> R.dmp_pexquo(f, g)\n    2*x\n\n    >>> R.dmp_pexquo(f, h)\n    Traceback (most recent call last):\n    ...\n    ExactQuotientFailed: [[2], [2]] does not divide [[1], [1, 0], []]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_rr_div",
    "full_id": "sympy.polys.densearith.dmp_rr_div",
    "type": "function",
    "description": "\n    Multivariate division with remainder over a ring.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_rr_div(x**2 + x*y, 2*x + 2)\n    (0, x**2 + x*y)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ff_div",
    "full_id": "sympy.polys.densearith.dmp_ff_div",
    "type": "function",
    "description": "\n    Polynomial division with remainder over a field.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y = ring(\"x,y\", QQ)\n\n    >>> R.dmp_ff_div(x**2 + x*y, 2*x + 2)\n    (1/2*x + 1/2*y - 1/2, -y + 1)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_div",
    "full_id": "sympy.polys.densearith.dmp_div",
    "type": "function",
    "description": "\n    Polynomial division with remainder in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> R.dmp_div(x**2 + x*y, 2*x + 2)\n    (0, x**2 + x*y)\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> R.dmp_div(x**2 + x*y, 2*x + 2)\n    (1/2*x + 1/2*y - 1/2, -y + 1)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_rem",
    "full_id": "sympy.polys.densearith.dmp_rem",
    "type": "function",
    "description": "\n    Returns polynomial remainder in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> R.dmp_rem(x**2 + x*y, 2*x + 2)\n    x**2 + x*y\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> R.dmp_rem(x**2 + x*y, 2*x + 2)\n    -y + 1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_quo",
    "full_id": "sympy.polys.densearith.dmp_quo",
    "type": "function",
    "description": "\n    Returns exact polynomial quotient in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> R.dmp_quo(x**2 + x*y, 2*x + 2)\n    0\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> R.dmp_quo(x**2 + x*y, 2*x + 2)\n    1/2*x + 1/2*y - 1/2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_exquo",
    "full_id": "sympy.polys.densearith.dmp_exquo",
    "type": "function",
    "description": "\n    Returns polynomial quotient in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + x*y\n    >>> g = x + y\n    >>> h = 2*x + 2\n\n    >>> R.dmp_exquo(f, g)\n    x\n\n    >>> R.dmp_exquo(f, h)\n    Traceback (most recent call last):\n    ...\n    ExactQuotientFailed: [[2], [2]] does not divide [[1], [1, 0], []]\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_max_norm",
    "full_id": "sympy.polys.densearith.dmp_max_norm",
    "type": "function",
    "description": "\n    Returns maximum norm of a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_max_norm(2*x*y - x - 3)\n    3\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_l1_norm",
    "full_id": "sympy.polys.densearith.dmp_l1_norm",
    "type": "function",
    "description": "\n    Returns l1 norm of a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_l1_norm(2*x*y - x - 3)\n    6\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_expand",
    "full_id": "sympy.polys.densearith.dmp_expand",
    "type": "function",
    "description": "\n    Multiply together several polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_expand([x**2 + y**2, x + 1])\n    x**3 + x**2 + x*y**2 + y**2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_integrate",
    "full_id": "sympy.polys.densetools.dmp_integrate",
    "type": "function",
    "description": "\n    Computes the indefinite integral of ``f`` in ``x_0`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y = ring(\"x,y\", QQ)\n\n    >>> R.dmp_integrate(x + 2*y, 1)\n    1/2*x**2 + 2*x*y\n    >>> R.dmp_integrate(x + 2*y, 2)\n    1/6*x**3 + x**2*y\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_integrate_in",
    "full_id": "sympy.polys.densetools.dmp_integrate_in",
    "type": "function",
    "description": "\n    Computes the indefinite integral of ``f`` in ``x_j`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y = ring(\"x,y\", QQ)\n\n    >>> R.dmp_integrate_in(x + 2*y, 1, 0)\n    1/2*x**2 + 2*x*y\n    >>> R.dmp_integrate_in(x + 2*y, 1, 1)\n    x*y + y**2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_diff",
    "full_id": "sympy.polys.densetools.dmp_diff",
    "type": "function",
    "description": "\n    ``m``-th order derivative in ``x_0`` of a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x*y**2 + 2*x*y + 3*x + 2*y**2 + 3*y + 1\n\n    >>> R.dmp_diff(f, 1)\n    y**2 + 2*y + 3\n    >>> R.dmp_diff(f, 2)\n    0\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_diff_in",
    "full_id": "sympy.polys.densetools.dmp_diff_in",
    "type": "function",
    "description": "\n    ``m``-th order derivative in ``x_j`` of a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x*y**2 + 2*x*y + 3*x + 2*y**2 + 3*y + 1\n\n    >>> R.dmp_diff_in(f, 1, 0)\n    y**2 + 2*y + 3\n    >>> R.dmp_diff_in(f, 1, 1)\n    2*x*y + 2*x + 4*y + 3\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_eval",
    "full_id": "sympy.polys.densetools.dmp_eval",
    "type": "function",
    "description": "\n    Evaluate a polynomial at ``x_0 = a`` in ``K[X]`` using the Horner scheme.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_eval(2*x*y + 3*x + y + 2, 2)\n    5*y + 8\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_eval_in",
    "full_id": "sympy.polys.densetools.dmp_eval_in",
    "type": "function",
    "description": "\n    Evaluate a polynomial at ``x_j = a`` in ``K[X]`` using the Horner scheme.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 2*x*y + 3*x + y + 2\n\n    >>> R.dmp_eval_in(f, 2, 0)\n    5*y + 8\n    >>> R.dmp_eval_in(f, 2, 1)\n    7*x + 4\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_eval_tail",
    "full_id": "sympy.polys.densetools.dmp_eval_tail",
    "type": "function",
    "description": "\n    Evaluate a polynomial at ``x_j = a_j, ...`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 2*x*y + 3*x + y + 2\n\n    >>> R.dmp_eval_tail(f, [2])\n    7*x + 4\n    >>> R.dmp_eval_tail(f, [2, 2])\n    18\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_diff_eval_in",
    "full_id": "sympy.polys.densetools.dmp_diff_eval_in",
    "type": "function",
    "description": "\n    Differentiate and evaluate a polynomial in ``x_j`` at ``a`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x*y**2 + 2*x*y + 3*x + 2*y**2 + 3*y + 1\n\n    >>> R.dmp_diff_eval_in(f, 1, 2, 0)\n    y**2 + 2*y + 3\n    >>> R.dmp_diff_eval_in(f, 1, 2, 1)\n    6*x + 11\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_trunc",
    "full_id": "sympy.polys.densetools.dmp_trunc",
    "type": "function",
    "description": "\n    Reduce a ``K[X]`` polynomial modulo a polynomial ``p`` in ``K[Y]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 3*x**2*y + 8*x**2 + 5*x*y + 6*x + 2*y + 3\n    >>> g = (y - 1).drop(x)\n\n    >>> R.dmp_trunc(f, g)\n    11*x**2 + 11*x + 5\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground_trunc",
    "full_id": "sympy.polys.densetools.dmp_ground_trunc",
    "type": "function",
    "description": "\n    Reduce a ``K[X]`` polynomial modulo a constant ``p`` in ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 3*x**2*y + 8*x**2 + 5*x*y + 6*x + 2*y + 3\n\n    >>> R.dmp_ground_trunc(f, ZZ(3))\n    -x**2 - x*y - y\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_monic",
    "full_id": "sympy.polys.densetools.dup_monic",
    "type": "function",
    "description": "\n    Divide all coefficients by ``LC(f)`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> R.dup_monic(3*x**2 + 6*x + 9)\n    x**2 + 2*x + 3\n\n    >>> R, x = ring(\"x\", QQ)\n    >>> R.dup_monic(3*x**2 + 4*x + 2)\n    x**2 + 4/3*x + 2/3\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground_monic",
    "full_id": "sympy.polys.densetools.dmp_ground_monic",
    "type": "function",
    "description": "\n    Divide all coefficients by ``LC(f)`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> f = 3*x**2*y + 6*x**2 + 3*x*y + 9*y + 3\n\n    >>> R.dmp_ground_monic(f)\n    x**2*y + 2*x**2 + x*y + 3*y + 1\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> f = 3*x**2*y + 8*x**2 + 5*x*y + 6*x + 2*y + 3\n\n    >>> R.dmp_ground_monic(f)\n    x**2*y + 8/3*x**2 + 5/3*x*y + 2*x + 2/3*y + 1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_content",
    "full_id": "sympy.polys.densetools.dup_content",
    "type": "function",
    "description": "\n    Compute the GCD of coefficients of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_content(f)\n    2\n\n    >>> R, x = ring(\"x\", QQ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_content(f)\n    2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground_content",
    "full_id": "sympy.polys.densetools.dmp_ground_content",
    "type": "function",
    "description": "\n    Compute the GCD of coefficients of ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_content(f)\n    2\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_content(f)\n    2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_primitive",
    "full_id": "sympy.polys.densetools.dup_primitive",
    "type": "function",
    "description": "\n    Compute content and the primitive form of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x = ring(\"x\", ZZ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_primitive(f)\n    (2, 3*x**2 + 4*x + 6)\n\n    >>> R, x = ring(\"x\", QQ)\n    >>> f = 6*x**2 + 8*x + 12\n\n    >>> R.dup_primitive(f)\n    (2, 3*x**2 + 4*x + 6)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground_primitive",
    "full_id": "sympy.polys.densetools.dmp_ground_primitive",
    "type": "function",
    "description": "\n    Compute content and the primitive form of ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ, QQ\n\n    >>> R, x,y = ring(\"x,y\", ZZ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_primitive(f)\n    (2, x*y + 3*x + 2*y + 6)\n\n    >>> R, x,y = ring(\"x,y\", QQ)\n    >>> f = 2*x*y + 6*x + 4*y + 12\n\n    >>> R.dmp_ground_primitive(f)\n    (2, x*y + 3*x + 2*y + 6)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_extract",
    "full_id": "sympy.polys.densetools.dup_extract",
    "type": "function",
    "description": "\n    Extract common content from a pair of polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_extract(6*x**2 + 12*x + 18, 4*x**2 + 8*x + 12)\n    (2, 3*x**2 + 6*x + 9, 2*x**2 + 4*x + 6)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ground_extract",
    "full_id": "sympy.polys.densetools.dmp_ground_extract",
    "type": "function",
    "description": "\n    Extract common content from a pair of polynomials in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_ground_extract(6*x*y + 12*x + 18, 4*x*y + 8*x + 12)\n    (2, 3*x*y + 6*x + 9, 2*x*y + 4*x + 6)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_real_imag",
    "full_id": "sympy.polys.densetools.dup_real_imag",
    "type": "function",
    "description": "\n    Find ``f1`` and ``f2``, such that ``f(x+I*y) = f1(x,y) + f2(x,y)*I``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dup_real_imag(x**3 + x**2 + x + 1)\n    (x**3 + x**2 - 3*x*y**2 + x - y**2 + 1, 3*x**2*y + 2*x*y - y**3 + y)\n\n    >>> from sympy.abc import x, y, z\n    >>> from sympy import I\n    >>> (z**3 + z**2 + z + 1).subs(z, x+I*y).expand().collect(I)\n    x**3 + x**2 - 3*x*y**2 + x - y**2 + I*(3*x**2*y + 2*x*y - y**3 + y) + 1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_mirror",
    "full_id": "sympy.polys.densetools.dup_mirror",
    "type": "function",
    "description": "\n    Evaluate efficiently the composition ``f(-x)`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_mirror(x**3 + 2*x**2 - 4*x + 2)\n    -x**3 + 2*x**2 + 4*x + 2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_scale",
    "full_id": "sympy.polys.densetools.dup_scale",
    "type": "function",
    "description": "\n    Evaluate efficiently composition ``f(a*x)`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_scale(x**2 - 2*x + 1, ZZ(2))\n    4*x**2 - 4*x + 1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_shift",
    "full_id": "sympy.polys.densetools.dup_shift",
    "type": "function",
    "description": "\n    Evaluate efficiently Taylor shift ``f(x + a)`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_shift(x**2 - 2*x + 1, ZZ(2))\n    x**2 + 2*x + 1\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_transform",
    "full_id": "sympy.polys.densetools.dup_transform",
    "type": "function",
    "description": "\n    Evaluate functional transformation ``q**n * f(p/q)`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_transform(x**2 - 2*x + 1, x**2 + 1, x - 1)\n    x**4 - 2*x**3 + 5*x**2 - 4*x + 4\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_compose",
    "full_id": "sympy.polys.densetools.dmp_compose",
    "type": "function",
    "description": "\n    Evaluate functional composition ``f(g)`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_compose(x*y + 2*x + y, y)\n    y**2 + 3*y\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_decompose",
    "full_id": "sympy.polys.densetools.dup_decompose",
    "type": "function",
    "description": "\n    Computes functional decomposition of ``f`` in ``K[x]``.\n\n    Given a univariate polynomial ``f`` with coefficients in a field of\n    characteristic zero, returns list ``[f_1, f_2, ..., f_n]``, where::\n\n              f = f_1 o f_2 o ... f_n = f_1(f_2(... f_n))\n\n    and ``f_2, ..., f_n`` are monic and homogeneous polynomials of at\n    least second degree.\n\n    Unlike factorization, complete functional decompositions of\n    polynomials are not unique, consider examples:\n\n    1. ``f o g = f(x + b) o (g - b)``\n    2. ``x**n o x**m = x**m o x**n``\n    3. ``T_n o T_m = T_m o T_n``\n\n    where ``T_n`` and ``T_m`` are Chebyshev polynomials.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_decompose(x**4 - 2*x**3 + x**2)\n    [x**2, x**2 - x]\n\n    References\n    ==========\n\n    .. [1] [Kozen89]_\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_lift",
    "full_id": "sympy.polys.densetools.dmp_lift",
    "type": "function",
    "description": "\n    Convert algebraic coefficients to integers in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> from sympy import I\n\n    >>> K = QQ.algebraic_field(I)\n    >>> R, x = ring(\"x\", K)\n\n    >>> f = x**2 + K([QQ(1), QQ(0)])*x + K([QQ(2), QQ(0)])\n\n    >>> R.dmp_lift(f)\n    x**8 + 2*x**6 + 9*x**4 - 8*x**2 + 16\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_sign_variations",
    "full_id": "sympy.polys.densetools.dup_sign_variations",
    "type": "function",
    "description": "\n    Compute the number of sign variations of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_sign_variations(x**4 - x**2 - x + 1)\n    2\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_clear_denoms",
    "full_id": "sympy.polys.densetools.dmp_clear_denoms",
    "type": "function",
    "description": "\n    Clear denominators, i.e. transform ``K_0`` to ``K_1``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y = ring(\"x,y\", QQ)\n\n    >>> f = QQ(1,2)*x + QQ(1,3)*y + 1\n\n    >>> R.dmp_clear_denoms(f, convert=False)\n    (6, 3*x + 2*y + 6)\n    >>> R.dmp_clear_denoms(f, convert=True)\n    (6, 3*x + 2*y + 6)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_revert",
    "full_id": "sympy.polys.densetools.dmp_revert",
    "type": "function",
    "description": "\n    Compute ``f**(-1)`` mod ``x**n`` using Newton iteration.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y = ring(\"x,y\", QQ)\n\n    ",
    "section": "Manipulation of dense, multivariate polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_crt",
    "full_id": "sympy.polys.galoistools.gf_crt",
    "type": "function",
    "description": "\n    Chinese Remainder Theorem.\n\n    Given a set of integer residues ``u_0,...,u_n`` and a set of\n    co-prime integer moduli ``m_0,...,m_n``, returns an integer\n    ``u``, such that ``u = u_i mod m_i`` for ``i = ``0,...,n``.\n\n    Examples\n    ========\n\n    Consider a set of residues ``U = [49, 76, 65]``\n    and a set of moduli ``M = [99, 97, 95]``. Then we have::\n\n       >>> from sympy.polys.domains import ZZ\n       >>> from sympy.polys.galoistools import gf_crt\n\n       >>> gf_crt([49, 76, 65], [99, 97, 95], ZZ)\n       639985\n\n    This is the correct result because::\n\n       >>> [639985 % m for m in [99, 97, 95]]\n       [49, 76, 65]\n\n    Note: this is a low-level routine with no error checking.\n\n    See Also\n    ========\n\n    sympy.ntheory.modular.crt : a higher level crt routine\n    sympy.ntheory.modular.solve_congruence\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_crt1",
    "full_id": "sympy.polys.galoistools.gf_crt1",
    "type": "function",
    "description": "\n    First part of the Chinese Remainder Theorem.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_crt, gf_crt1, gf_crt2\n    >>> U = [49, 76, 65]\n    >>> M = [99, 97, 95]\n\n    The following two codes have the same result.\n\n    >>> gf_crt(U, M, ZZ)\n    639985\n\n    >>> p, E, S = gf_crt1(M, ZZ)\n    >>> gf_crt2(U, M, p, E, S, ZZ)\n    639985\n\n    However, it is faster when we want to fix ``M`` and\n    compute for multiple U, i.e. the following cases:\n\n    >>> p, E, S = gf_crt1(M, ZZ)\n    >>> Us = [[49, 76, 65], [23, 42, 67]]\n    >>> for U in Us:\n    ...     print(gf_crt2(U, M, p, E, S, ZZ))\n    639985\n    236237\n\n    See Also\n    ========\n\n    sympy.ntheory.modular.crt1 : a higher level crt routine\n    sympy.polys.galoistools.gf_crt\n    sympy.polys.galoistools.gf_crt2\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_crt2",
    "full_id": "sympy.polys.galoistools.gf_crt2",
    "type": "function",
    "description": "\n    Second part of the Chinese Remainder Theorem.\n\n    See ``gf_crt1`` for usage.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_crt2\n\n    >>> U = [49, 76, 65]\n    >>> M = [99, 97, 95]\n    >>> p = 912285\n    >>> E = [9215, 9405, 9603]\n    >>> S = [62, 24, 12]\n\n    >>> gf_crt2(U, M, p, E, S, ZZ)\n    639985\n\n    See Also\n    ========\n\n    sympy.ntheory.modular.crt2 : a higher level crt routine\n    sympy.polys.galoistools.gf_crt\n    sympy.polys.galoistools.gf_crt1\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_int",
    "full_id": "sympy.polys.galoistools.gf_int",
    "type": "function",
    "description": "\n    Coerce ``a mod p`` to an integer in the range ``[-p/2, p/2]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_int\n\n    >>> gf_int(2, 7)\n    2\n    >>> gf_int(5, 7)\n    -2\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_degree",
    "full_id": "sympy.polys.galoistools.gf_degree",
    "type": "function",
    "description": "\n    Return the leading degree of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_degree\n\n    >>> gf_degree([1, 1, 2, 0])\n    3\n    >>> gf_degree([])\n    -1\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_LC",
    "full_id": "sympy.polys.galoistools.gf_LC",
    "type": "function",
    "description": "\n    Return the leading coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_LC\n\n    >>> gf_LC([3, 0, 1], ZZ)\n    3\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_TC",
    "full_id": "sympy.polys.galoistools.gf_TC",
    "type": "function",
    "description": "\n    Return the trailing coefficient of ``f``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_TC\n\n    >>> gf_TC([3, 0, 1], ZZ)\n    1\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_strip",
    "full_id": "sympy.polys.galoistools.gf_strip",
    "type": "function",
    "description": "\n    Remove leading zeros from ``f``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_strip\n\n    >>> gf_strip([0, 0, 0, 3, 0, 1])\n    [3, 0, 1]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_trunc",
    "full_id": "sympy.polys.galoistools.gf_trunc",
    "type": "function",
    "description": "\n    Reduce all coefficients modulo ``p``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_trunc\n\n    >>> gf_trunc([7, -2, 3], 5)\n    [2, 3, 3]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_normal",
    "full_id": "sympy.polys.galoistools.gf_normal",
    "type": "function",
    "description": "\n    Normalize all coefficients in ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_normal\n\n    >>> gf_normal([5, 10, 21, -3], 5, ZZ)\n    [1, 2]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_from_dict",
    "full_id": "sympy.polys.galoistools.gf_from_dict",
    "type": "function",
    "description": "\n    Create a ``GF(p)[x]`` polynomial from a dict.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_from_dict\n\n    >>> gf_from_dict({10: ZZ(4), 4: ZZ(33), 0: ZZ(-1)}, 5, ZZ)\n    [4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_to_dict",
    "full_id": "sympy.polys.galoistools.gf_to_dict",
    "type": "function",
    "description": "\n    Convert a ``GF(p)[x]`` polynomial to a dict.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_to_dict\n\n    >>> gf_to_dict([4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4], 5)\n    {0: -1, 4: -2, 10: -1}\n    >>> gf_to_dict([4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4], 5, symmetric=False)\n    {0: 4, 4: 3, 10: 4}\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_from_int_poly",
    "full_id": "sympy.polys.galoistools.gf_from_int_poly",
    "type": "function",
    "description": "\n    Create a ``GF(p)[x]`` polynomial from ``Z[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_from_int_poly\n\n    >>> gf_from_int_poly([7, -2, 3], 5)\n    [2, 3, 3]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_to_int_poly",
    "full_id": "sympy.polys.galoistools.gf_to_int_poly",
    "type": "function",
    "description": "\n    Convert a ``GF(p)[x]`` polynomial to ``Z[x]``.\n\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_to_int_poly\n\n    >>> gf_to_int_poly([2, 3, 3], 5)\n    [2, -2, -2]\n    >>> gf_to_int_poly([2, 3, 3], 5, symmetric=False)\n    [2, 3, 3]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_neg",
    "full_id": "sympy.polys.galoistools.gf_neg",
    "type": "function",
    "description": "\n    Negate a polynomial in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_neg\n\n    >>> gf_neg([3, 2, 1, 0], 5, ZZ)\n    [2, 3, 4, 0]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_add_ground",
    "full_id": "sympy.polys.galoistools.gf_add_ground",
    "type": "function",
    "description": "\n    Compute ``f + a`` where ``f`` in ``GF(p)[x]`` and ``a`` in ``GF(p)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_add_ground\n\n    >>> gf_add_ground([3, 2, 4], 2, 5, ZZ)\n    [3, 2, 1]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_sub_ground",
    "full_id": "sympy.polys.galoistools.gf_sub_ground",
    "type": "function",
    "description": "\n    Compute ``f - a`` where ``f`` in ``GF(p)[x]`` and ``a`` in ``GF(p)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_sub_ground\n\n    >>> gf_sub_ground([3, 2, 4], 2, 5, ZZ)\n    [3, 2, 2]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_mul_ground",
    "full_id": "sympy.polys.galoistools.gf_mul_ground",
    "type": "function",
    "description": "\n    Compute ``f * a`` where ``f`` in ``GF(p)[x]`` and ``a`` in ``GF(p)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_mul_ground\n\n    >>> gf_mul_ground([3, 2, 4], 2, 5, ZZ)\n    [1, 4, 3]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_quo_ground",
    "full_id": "sympy.polys.galoistools.gf_quo_ground",
    "type": "function",
    "description": "\n    Compute ``f/a`` where ``f`` in ``GF(p)[x]`` and ``a`` in ``GF(p)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_quo_ground\n\n    >>> gf_quo_ground(ZZ.map([3, 2, 4]), ZZ(2), 5, ZZ)\n    [4, 1, 2]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_add",
    "full_id": "sympy.polys.galoistools.gf_add",
    "type": "function",
    "description": "\n    Add polynomials in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_add\n\n    >>> gf_add([3, 2, 4], [2, 2, 2], 5, ZZ)\n    [4, 1]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_sub",
    "full_id": "sympy.polys.galoistools.gf_sub",
    "type": "function",
    "description": "\n    Subtract polynomials in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_sub\n\n    >>> gf_sub([3, 2, 4], [2, 2, 2], 5, ZZ)\n    [1, 0, 2]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_mul",
    "full_id": "sympy.polys.galoistools.gf_mul",
    "type": "function",
    "description": "\n    Multiply polynomials in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_mul\n\n    >>> gf_mul([3, 2, 4], [2, 2, 2], 5, ZZ)\n    [1, 0, 3, 2, 3]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_sqr",
    "full_id": "sympy.polys.galoistools.gf_sqr",
    "type": "function",
    "description": "\n    Square polynomials in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_sqr\n\n    >>> gf_sqr([3, 2, 4], 5, ZZ)\n    [4, 2, 3, 1, 1]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_add_mul",
    "full_id": "sympy.polys.galoistools.gf_add_mul",
    "type": "function",
    "description": "\n    Returns ``f + g*h`` where ``f``, ``g``, ``h`` in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_add_mul\n    >>> gf_add_mul([3, 2, 4], [2, 2, 2], [1, 4], 5, ZZ)\n    [2, 3, 2, 2]\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_sub_mul",
    "full_id": "sympy.polys.galoistools.gf_sub_mul",
    "type": "function",
    "description": "\n    Compute ``f - g*h`` where ``f``, ``g``, ``h`` in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_sub_mul\n\n    >>> gf_sub_mul([3, 2, 4], [2, 2, 2], [1, 4], 5, ZZ)\n    [3, 3, 2, 1]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_expand",
    "full_id": "sympy.polys.galoistools.gf_expand",
    "type": "function",
    "description": "\n    Expand results of :func:`~.factor` in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_expand\n\n    >>> gf_expand([([3, 2, 4], 1), ([2, 2], 2), ([3, 1], 3)], 5, ZZ)\n    [4, 3, 0, 3, 0, 1, 4, 1]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_div",
    "full_id": "sympy.polys.galoistools.gf_div",
    "type": "function",
    "description": "\n    Division with remainder in ``GF(p)[x]``.\n\n    Given univariate polynomials ``f`` and ``g`` with coefficients in a\n    finite field with ``p`` elements, returns polynomials ``q`` and ``r``\n    (quotient and remainder) such that ``f = q*g + r``.\n\n    Consider polynomials ``x**3 + x + 1`` and ``x**2 + x`` in GF(2)::\n\n       >>> from sympy.polys.domains import ZZ\n       >>> from sympy.polys.galoistools import gf_div, gf_add_mul\n\n       >>> gf_div(ZZ.map([1, 0, 1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n       ([1, 1], [1])\n\n    As result we obtained quotient ``x + 1`` and remainder ``1``, thus::\n\n       >>> gf_add_mul(ZZ.map([1]), ZZ.map([1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n       [1, 0, 1, 1]\n\n    References\n    ==========\n\n    .. [1] [Monagan93]_\n    .. [2] [Gathen99]_\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_rem",
    "full_id": "sympy.polys.galoistools.gf_rem",
    "type": "function",
    "description": "\n    Compute polynomial remainder in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_rem\n\n    >>> gf_rem(ZZ.map([1, 0, 1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n    [1]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_quo",
    "full_id": "sympy.polys.galoistools.gf_quo",
    "type": "function",
    "description": "\n    Compute exact quotient in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_quo\n\n    >>> gf_quo(ZZ.map([1, 0, 1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n    [1, 1]\n    >>> gf_quo(ZZ.map([1, 0, 3, 2, 3]), ZZ.map([2, 2, 2]), 5, ZZ)\n    [3, 2, 4]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_exquo",
    "full_id": "sympy.polys.galoistools.gf_exquo",
    "type": "function",
    "description": "\n    Compute polynomial quotient in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_exquo\n\n    >>> gf_exquo(ZZ.map([1, 0, 3, 2, 3]), ZZ.map([2, 2, 2]), 5, ZZ)\n    [3, 2, 4]\n\n    >>> gf_exquo(ZZ.map([1, 0, 1, 1]), ZZ.map([1, 1, 0]), 2, ZZ)\n    Traceback (most recent call last):\n    ...\n    ExactQuotientFailed: [1, 1, 0] does not divide [1, 0, 1, 1]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_lshift",
    "full_id": "sympy.polys.galoistools.gf_lshift",
    "type": "function",
    "description": "\n    Efficiently multiply ``f`` by ``x**n``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_lshift\n\n    >>> gf_lshift([3, 2, 4], 4, ZZ)\n    [3, 2, 4, 0, 0, 0, 0]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_rshift",
    "full_id": "sympy.polys.galoistools.gf_rshift",
    "type": "function",
    "description": "\n    Efficiently divide ``f`` by ``x**n``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_rshift\n\n    >>> gf_rshift([1, 2, 3, 4, 0], 3, ZZ)\n    ([1, 2], [3, 4, 0])\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_pow",
    "full_id": "sympy.polys.galoistools.gf_pow",
    "type": "function",
    "description": "\n    Compute ``f**n`` in ``GF(p)[x]`` using repeated squaring.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_pow\n\n    >>> gf_pow([3, 2, 4], 3, 5, ZZ)\n    [2, 4, 4, 2, 2, 1, 4]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_pow_mod",
    "full_id": "sympy.polys.galoistools.gf_pow_mod",
    "type": "function",
    "description": "\n    Compute ``f**n`` in ``GF(p)[x]/(g)`` using repeated squaring.\n\n    Given polynomials ``f`` and ``g`` in ``GF(p)[x]`` and a non-negative\n    integer ``n``, efficiently computes ``f**n (mod g)`` i.e. the remainder\n    of ``f**n`` from division by ``g``, using the repeated squaring algorithm.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_pow_mod\n\n    >>> gf_pow_mod(ZZ.map([3, 2, 4]), 3, ZZ.map([1, 1]), 5, ZZ)\n    []\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_gcd",
    "full_id": "sympy.polys.galoistools.gf_gcd",
    "type": "function",
    "description": "\n    Euclidean Algorithm in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_gcd\n\n    >>> gf_gcd(ZZ.map([3, 2, 4]), ZZ.map([2, 2, 3]), 5, ZZ)\n    [1, 3]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_lcm",
    "full_id": "sympy.polys.galoistools.gf_lcm",
    "type": "function",
    "description": "\n    Compute polynomial LCM in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_lcm\n\n    >>> gf_lcm(ZZ.map([3, 2, 4]), ZZ.map([2, 2, 3]), 5, ZZ)\n    [1, 2, 0, 4]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_cofactors",
    "full_id": "sympy.polys.galoistools.gf_cofactors",
    "type": "function",
    "description": "\n    Compute polynomial GCD and cofactors in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_cofactors\n\n    >>> gf_cofactors(ZZ.map([3, 2, 4]), ZZ.map([2, 2, 3]), 5, ZZ)\n    ([1, 3], [3, 3], [2, 1])\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_gcdex",
    "full_id": "sympy.polys.galoistools.gf_gcdex",
    "type": "function",
    "description": "\n    Extended Euclidean Algorithm in ``GF(p)[x]``.\n\n    Given polynomials ``f`` and ``g`` in ``GF(p)[x]``, computes polynomials\n    ``s``, ``t`` and ``h``, such that ``h = gcd(f, g)`` and ``s*f + t*g = h``.\n    The typical application of EEA is solving polynomial diophantine equations.\n\n    Consider polynomials ``f = (x + 7) (x + 1)``, ``g = (x + 7) (x**2 + 1)``\n    in ``GF(11)[x]``. Application of Extended Euclidean Algorithm gives::\n\n       >>> from sympy.polys.domains import ZZ\n       >>> from sympy.polys.galoistools import gf_gcdex, gf_mul, gf_add\n\n       >>> s, t, g = gf_gcdex(ZZ.map([1, 8, 7]), ZZ.map([1, 7, 1, 7]), 11, ZZ)\n       >>> s, t, g\n       ([5, 6], [6], [1, 7])\n\n    As result we obtained polynomials ``s = 5*x + 6`` and ``t = 6``, and\n    additionally ``gcd(f, g) = x + 7``. This is correct because::\n\n       >>> S = gf_mul(s, ZZ.map([1, 8, 7]), 11, ZZ)\n       >>> T = gf_mul(t, ZZ.map([1, 7, 1, 7]), 11, ZZ)\n\n       >>> gf_add(S, T, 11, ZZ) == [1, 7]\n       True\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_monic",
    "full_id": "sympy.polys.galoistools.gf_monic",
    "type": "function",
    "description": "\n    Compute LC and a monic polynomial in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_monic\n\n    >>> gf_monic(ZZ.map([3, 2, 4]), 5, ZZ)\n    (3, [1, 4, 3])\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_diff",
    "full_id": "sympy.polys.galoistools.gf_diff",
    "type": "function",
    "description": "\n    Differentiate polynomial in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_diff\n\n    >>> gf_diff([3, 2, 4], 5, ZZ)\n    [1, 2]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_eval",
    "full_id": "sympy.polys.galoistools.gf_eval",
    "type": "function",
    "description": "\n    Evaluate ``f(a)`` in ``GF(p)`` using Horner scheme.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_eval\n\n    >>> gf_eval([3, 2, 4], 2, 5, ZZ)\n    0\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_multi_eval",
    "full_id": "sympy.polys.galoistools.gf_multi_eval",
    "type": "function",
    "description": "\n    Evaluate ``f(a)`` for ``a`` in ``[a_1, ..., a_n]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_multi_eval\n\n    >>> gf_multi_eval([3, 2, 4], [0, 1, 2, 3, 4], 5, ZZ)\n    [4, 4, 0, 2, 0]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_compose",
    "full_id": "sympy.polys.galoistools.gf_compose",
    "type": "function",
    "description": "\n    Compute polynomial composition ``f(g)`` in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_compose\n\n    >>> gf_compose([3, 2, 4], [2, 2, 2], 5, ZZ)\n    [2, 4, 0, 3, 0]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_compose_mod",
    "full_id": "sympy.polys.galoistools.gf_compose_mod",
    "type": "function",
    "description": "\n    Compute polynomial composition ``g(h)`` in ``GF(p)[x]/(f)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_compose_mod\n\n    >>> gf_compose_mod(ZZ.map([3, 2, 4]), ZZ.map([2, 2, 2]), ZZ.map([4, 3]), 5, ZZ)\n    [4]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_trace_map",
    "full_id": "sympy.polys.galoistools.gf_trace_map",
    "type": "function",
    "description": "\n    Compute polynomial trace map in ``GF(p)[x]/(f)``.\n\n    Given a polynomial ``f`` in ``GF(p)[x]``, polynomials ``a``, ``b``,\n    ``c`` in the quotient ring ``GF(p)[x]/(f)`` such that ``b = c**t\n    (mod f)`` for some positive power ``t`` of ``p``, and a positive\n    integer ``n``, returns a mapping::\n\n       a -> a**t**n, a + a**t + a**t**2 + ... + a**t**n (mod f)\n\n    In factorization context, ``b = x**p mod f`` and ``c = x mod f``.\n    This way we can efficiently compute trace polynomials in equal\n    degree factorization routine, much faster than with other methods,\n    like iterated Frobenius algorithm, for large degrees.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_trace_map\n\n    >>> gf_trace_map([1, 2], [4, 4], [1, 1], 4, [3, 2, 4], 5, ZZ)\n    ([1, 3], [1, 3])\n\n    References\n    ==========\n\n    .. [1] [Gathen92]_\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_random",
    "full_id": "sympy.polys.galoistools.gf_random",
    "type": "function",
    "description": "\n    Generate a random polynomial in ``GF(p)[x]`` of degree ``n``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_random\n    >>> gf_random(10, 5, ZZ) #doctest: +SKIP\n    [1, 2, 3, 2, 1, 1, 1, 2, 0, 4, 2]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_irreducible",
    "full_id": "sympy.polys.galoistools.gf_irreducible",
    "type": "function",
    "description": "\n    Generate random irreducible polynomial of degree ``n`` in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_irreducible\n    >>> gf_irreducible(10, 5, ZZ) #doctest: +SKIP\n    [1, 4, 2, 2, 3, 2, 4, 1, 4, 0, 4]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_irreducible_p",
    "full_id": "sympy.polys.galoistools.gf_irreducible_p",
    "type": "function",
    "description": "\n    Test irreducibility of a polynomial ``f`` in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_irreducible_p\n\n    >>> gf_irreducible_p(ZZ.map([1, 4, 2, 2, 3, 2, 4, 1, 4, 0, 4]), 5, ZZ)\n    True\n    >>> gf_irreducible_p(ZZ.map([3, 2, 4]), 5, ZZ)\n    False\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_sqf_p",
    "full_id": "sympy.polys.galoistools.gf_sqf_p",
    "type": "function",
    "description": "\n    Return ``True`` if ``f`` is square-free in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_sqf_p\n\n    >>> gf_sqf_p(ZZ.map([3, 2, 4]), 5, ZZ)\n    True\n    >>> gf_sqf_p(ZZ.map([2, 4, 4, 2, 2, 1, 4]), 5, ZZ)\n    False\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_sqf_part",
    "full_id": "sympy.polys.galoistools.gf_sqf_part",
    "type": "function",
    "description": "\n    Return square-free part of a ``GF(p)[x]`` polynomial.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_sqf_part\n\n    >>> gf_sqf_part(ZZ.map([1, 1, 3, 0, 1, 0, 2, 2, 1]), 5, ZZ)\n    [1, 4, 3]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_sqf_list",
    "full_id": "sympy.polys.galoistools.gf_sqf_list",
    "type": "function",
    "description": "\n    Return the square-free decomposition of a ``GF(p)[x]`` polynomial.\n\n    Given a polynomial ``f`` in ``GF(p)[x]``, returns the leading coefficient\n    of ``f`` and a square-free decomposition ``f_1**e_1 f_2**e_2 ... f_k**e_k``\n    such that all ``f_i`` are monic polynomials and ``(f_i, f_j)`` for ``i != j``\n    are co-prime and ``e_1 ... e_k`` are given in increasing order. All trivial\n    terms (i.e. ``f_i = 1``) are not included in the output.\n\n    Consider polynomial ``f = x**11 + 1`` over ``GF(11)[x]``::\n\n       >>> from sympy.polys.domains import ZZ\n\n       >>> from sympy.polys.galoistools import (\n       ...     gf_from_dict, gf_diff, gf_sqf_list, gf_pow,\n       ... )\n       ... # doctest: +NORMALIZE_WHITESPACE\n\n       >>> f = gf_from_dict({11: ZZ(1), 0: ZZ(1)}, 11, ZZ)\n\n    Note that ``f'(x) = 0``::\n\n       >>> gf_diff(f, 11, ZZ)\n       []\n\n    This phenomenon does not happen in characteristic zero. However we can\n    still compute square-free decomposition of ``f`` using ``gf_sqf()``::\n\n       >>> gf_sqf_list(f, 11, ZZ)\n       (1, [([1, 1], 11)])\n\n    We obtained factorization ``f = (x + 1)**11``. This is correct because::\n\n       >>> gf_pow([1, 1], 11, 11, ZZ) == f\n       True\n\n    References\n    ==========\n\n    .. [1] [Geddes92]_\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_Qmatrix",
    "full_id": "sympy.polys.galoistools.gf_Qmatrix",
    "type": "function",
    "description": "\n    Calculate Berlekamp's ``Q`` matrix.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_Qmatrix\n\n    >>> gf_Qmatrix([3, 2, 4], 5, ZZ)\n    [[1, 0],\n     [3, 4]]\n\n    >>> gf_Qmatrix([1, 0, 0, 0, 1], 5, ZZ)\n    [[1, 0, 0, 0],\n     [0, 4, 0, 0],\n     [0, 0, 1, 0],\n     [0, 0, 0, 4]]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_Qbasis",
    "full_id": "sympy.polys.galoistools.gf_Qbasis",
    "type": "function",
    "description": "\n    Compute a basis of the kernel of ``Q``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_Qmatrix, gf_Qbasis\n\n    >>> gf_Qbasis(gf_Qmatrix([1, 0, 0, 0, 1], 5, ZZ), 5, ZZ)\n    [[1, 0, 0, 0], [0, 0, 1, 0]]\n\n    >>> gf_Qbasis(gf_Qmatrix([3, 2, 4], 5, ZZ), 5, ZZ)\n    [[1, 0]]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_berlekamp",
    "full_id": "sympy.polys.galoistools.gf_berlekamp",
    "type": "function",
    "description": "\n    Factor a square-free ``f`` in ``GF(p)[x]`` for small ``p``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_berlekamp\n\n    >>> gf_berlekamp([1, 0, 0, 0, 1], 5, ZZ)\n    [[1, 0, 2], [1, 0, 3]]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_zassenhaus",
    "full_id": "sympy.polys.galoistools.gf_zassenhaus",
    "type": "function",
    "description": "\n    Factor a square-free ``f`` in ``GF(p)[x]`` for medium ``p``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_zassenhaus\n\n    >>> gf_zassenhaus(ZZ.map([1, 4, 3]), 5, ZZ)\n    [[1, 1], [1, 3]]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_shoup",
    "full_id": "sympy.polys.galoistools.gf_shoup",
    "type": "function",
    "description": "\n    Factor a square-free ``f`` in ``GF(p)[x]`` for large ``p``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_shoup\n\n    >>> gf_shoup(ZZ.map([1, 4, 3]), 5, ZZ)\n    [[1, 1], [1, 3]]\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_factor_sqf",
    "full_id": "sympy.polys.galoistools.gf_factor_sqf",
    "type": "function",
    "description": "\n    Factor a square-free polynomial ``f`` in ``GF(p)[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import ZZ\n    >>> from sympy.polys.galoistools import gf_factor_sqf\n\n    >>> gf_factor_sqf(ZZ.map([3, 2, 4]), 5, ZZ)\n    (3, [[1, 1], [1, 3]])\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_factor",
    "full_id": "sympy.polys.galoistools.gf_factor",
    "type": "function",
    "description": "\n    Factor (non square-free) polynomials in ``GF(p)[x]``.\n\n    Given a possibly non square-free polynomial ``f`` in ``GF(p)[x]``,\n    returns its complete factorization into irreducibles::\n\n                 f_1(x)**e_1 f_2(x)**e_2 ... f_d(x)**e_d\n\n    where each ``f_i`` is a monic polynomial and ``gcd(f_i, f_j) == 1``,\n    for ``i != j``.  The result is given as a tuple consisting of the\n    leading coefficient of ``f`` and a list of factors of ``f`` with\n    their multiplicities.\n\n    The algorithm proceeds by first computing square-free decomposition\n    of ``f`` and then iteratively factoring each of square-free factors.\n\n    Consider a non square-free polynomial ``f = (7*x + 1) (x + 2)**2`` in\n    ``GF(11)[x]``. We obtain its factorization into irreducibles as follows::\n\n       >>> from sympy.polys.domains import ZZ\n       >>> from sympy.polys.galoistools import gf_factor\n\n       >>> gf_factor(ZZ.map([5, 2, 7, 2]), 11, ZZ)\n       (5, [([1, 2], 1), ([1, 8], 2)])\n\n    We arrived with factorization ``f = 5 (x + 2) (x + 8)**2``. We did not\n    recover the exact form of the input polynomial because we requested to\n    get monic factors of ``f`` and its leading coefficient separately.\n\n    Square-free factors of ``f`` can be factored into irreducibles over\n    ``GF(p)`` using three very different methods:\n\n    Berlekamp\n        efficient for very small values of ``p`` (usually ``p < 25``)\n    Cantor-Zassenhaus\n        efficient on average input and with \"typical\" ``p``\n    Shoup-Kaltofen-Gathen\n        efficient with very large inputs and modulus\n\n    If you want to use a specific factorization method, instead of the default\n    one, set ``GF_FACTOR_METHOD`` with one of ``berlekamp``, ``zassenhaus`` or\n    ``shoup`` values.\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_value",
    "full_id": "sympy.polys.galoistools.gf_value",
    "type": "function",
    "description": "\n    Value of polynomial 'f' at 'a' in field R.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.galoistools import gf_value\n\n    >>> gf_value([1, 7, 2, 4], 11)\n    2204\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "gf_csolve",
    "full_id": "sympy.polys.galoistools.gf_csolve",
    "type": "function",
    "description": "\n    To solve f(x) congruent 0 mod(n).\n\n    n is divided into canonical factors and f(x) cong 0 mod(p**e) will be\n    solved for each factor. Applying the Chinese Remainder Theorem to the\n    results returns the final answers.\n\n    Examples\n    ========\n\n    Solve [1, 1, 7] congruent 0 mod(189):\n\n    >>> from sympy.polys.galoistools import gf_csolve\n    >>> gf_csolve([1, 1, 7], 189)\n    [13, 49, 76, 112, 139, 175]\n\n    See Also\n    ========\n\n    sympy.ntheory.residue_ntheory.polynomial_congruence : a higher level solving routine\n\n    References\n    ==========\n\n    .. [1] 'An introduction to the Theory of Numbers' 5th Edition by Ivan Niven,\n           Zuckerman and Montgomery.\n\n    ",
    "section": "Manipulation of dense, univariate polynomials with finite field coefficients",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_monomial_mul",
    "full_id": "sympy.polys.distributedmodules.sdm_monomial_mul",
    "type": "function",
    "description": "\n    Multiply tuple ``X`` representing a monomial of `K[X]` into the tuple\n    ``M`` representing a monomial of `F`.\n\n    Examples\n    ========\n\n    Multiplying `xy^3` into `x f_1` yields `x^2 y^3 f_1`:\n\n    >>> from sympy.polys.distributedmodules import sdm_monomial_mul\n    >>> sdm_monomial_mul((1, 1, 0), (1, 3))\n    (1, 2, 3)\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_monomial_deg",
    "full_id": "sympy.polys.distributedmodules.sdm_monomial_deg",
    "type": "function",
    "description": "\n    Return the total degree of ``M``.\n\n    Examples\n    ========\n\n    For example, the total degree of `x^2 y f_5` is 3:\n\n    >>> from sympy.polys.distributedmodules import sdm_monomial_deg\n    >>> sdm_monomial_deg((5, 2, 1))\n    3\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_monomial_divides",
    "full_id": "sympy.polys.distributedmodules.sdm_monomial_divides",
    "type": "function",
    "description": "\n    Does there exist a (polynomial) monomial X such that XA = B?\n\n    Examples\n    ========\n\n    Positive examples:\n\n    In the following examples, the monomial is given in terms of x, y and the\n    generator(s), f_1, f_2 etc. The tuple form of that monomial is used in\n    the call to sdm_monomial_divides.\n    Note: the generator appears last in the expression but first in the tuple\n    and other factors appear in the same order that they appear in the monomial\n    expression.\n\n    `A = f_1` divides `B = f_1`\n\n    >>> from sympy.polys.distributedmodules import sdm_monomial_divides\n    >>> sdm_monomial_divides((1, 0, 0), (1, 0, 0))\n    True\n\n    `A = f_1` divides `B = x^2 y f_1`\n\n    >>> sdm_monomial_divides((1, 0, 0), (1, 2, 1))\n    True\n\n    `A = xy f_5` divides `B = x^2 y f_5`\n\n    >>> sdm_monomial_divides((5, 1, 1), (5, 2, 1))\n    True\n\n    Negative examples:\n\n    `A = f_1` does not divide `B = f_2`\n\n    >>> sdm_monomial_divides((1, 0, 0), (2, 0, 0))\n    False\n\n    `A = x f_1` does not divide `B = f_1`\n\n    >>> sdm_monomial_divides((1, 1, 0), (1, 0, 0))\n    False\n\n    `A = xy^2 f_5` does not divide `B = y f_5`\n\n    >>> sdm_monomial_divides((5, 1, 2), (5, 0, 1))\n    False\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_to_dict",
    "full_id": "sympy.polys.distributedmodules.sdm_to_dict",
    "type": "function",
    "description": "Make a dictionary from a distributed polynomial.",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_from_dict",
    "full_id": "sympy.polys.distributedmodules.sdm_from_dict",
    "type": "function",
    "description": "\n    Create an sdm from a dictionary.\n\n    Here ``O`` is the monomial order to use.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.distributedmodules import sdm_from_dict\n    >>> from sympy.polys import QQ, lex\n    >>> dic = {(1, 1, 0): QQ(1), (1, 0, 0): QQ(2), (0, 1, 0): QQ(0)}\n    >>> sdm_from_dict(dic, lex)\n    [((1, 1, 0), 1), ((1, 0, 0), 2)]\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_add",
    "full_id": "sympy.polys.distributedmodules.sdm_add",
    "type": "function",
    "description": "\n    Add two module elements ``f``, ``g``.\n\n    Addition is done over the ground field ``K``, monomials are ordered\n    according to ``O``.\n\n    Examples\n    ========\n\n    All examples use lexicographic order.\n\n    `(xy f_1) + (f_2) = f_2 + xy f_1`\n\n    >>> from sympy.polys.distributedmodules import sdm_add\n    >>> from sympy.polys import lex, QQ\n    >>> sdm_add([((1, 1, 1), QQ(1))], [((2, 0, 0), QQ(1))], lex, QQ)\n    [((2, 0, 0), 1), ((1, 1, 1), 1)]\n\n    `(xy f_1) + (-xy f_1)` = 0`\n\n    >>> sdm_add([((1, 1, 1), QQ(1))], [((1, 1, 1), QQ(-1))], lex, QQ)\n    []\n\n    `(f_1) + (2f_1) = 3f_1`\n\n    >>> sdm_add([((1, 0, 0), QQ(1))], [((1, 0, 0), QQ(2))], lex, QQ)\n    [((1, 0, 0), 3)]\n\n    `(yf_1) + (xf_1) = xf_1 + yf_1`\n\n    >>> sdm_add([((1, 0, 1), QQ(1))], [((1, 1, 0), QQ(1))], lex, QQ)\n    [((1, 1, 0), 1), ((1, 0, 1), 1)]\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_LM",
    "full_id": "sympy.polys.distributedmodules.sdm_LM",
    "type": "function",
    "description": "\n    Returns the leading monomial of ``f``.\n\n    Only valid if `f \\ne 0`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.distributedmodules import sdm_LM, sdm_from_dict\n    >>> from sympy.polys import QQ, lex\n    >>> dic = {(1, 2, 3): QQ(1), (4, 0, 0): QQ(1), (4, 0, 1): QQ(1)}\n    >>> sdm_LM(sdm_from_dict(dic, lex))\n    (4, 0, 1)\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_LT",
    "full_id": "sympy.polys.distributedmodules.sdm_LT",
    "type": "function",
    "description": "\n    Returns the leading term of ``f``.\n\n    Only valid if `f \\ne 0`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.distributedmodules import sdm_LT, sdm_from_dict\n    >>> from sympy.polys import QQ, lex\n    >>> dic = {(1, 2, 3): QQ(1), (4, 0, 0): QQ(2), (4, 0, 1): QQ(3)}\n    >>> sdm_LT(sdm_from_dict(dic, lex))\n    ((4, 0, 1), 3)\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_mul_term",
    "full_id": "sympy.polys.distributedmodules.sdm_mul_term",
    "type": "function",
    "description": "\n    Multiply a distributed module element ``f`` by a (polynomial) term ``term``.\n\n    Multiplication of coefficients is done over the ground field ``K``, and\n    monomials are ordered according to ``O``.\n\n    Examples\n    ========\n\n    `0 f_1 = 0`\n\n    >>> from sympy.polys.distributedmodules import sdm_mul_term\n    >>> from sympy.polys import lex, QQ\n    >>> sdm_mul_term([((1, 0, 0), QQ(1))], ((0, 0), QQ(0)), lex, QQ)\n    []\n\n    `x 0 = 0`\n\n    >>> sdm_mul_term([], ((1, 0), QQ(1)), lex, QQ)\n    []\n\n    `(x) (f_1) = xf_1`\n\n    >>> sdm_mul_term([((1, 0, 0), QQ(1))], ((1, 0), QQ(1)), lex, QQ)\n    [((1, 1, 0), 1)]\n\n    `(2xy) (3x f_1 + 4y f_2) = 8xy^2 f_2 + 6x^2y f_1`\n\n    >>> f = [((2, 0, 1), QQ(4)), ((1, 1, 0), QQ(3))]\n    >>> sdm_mul_term(f, ((1, 1), QQ(2)), lex, QQ)\n    [((2, 1, 2), 8), ((1, 2, 1), 6)]\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_zero",
    "full_id": "sympy.polys.distributedmodules.sdm_zero",
    "type": "function",
    "description": "Return the zero module element.",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_deg",
    "full_id": "sympy.polys.distributedmodules.sdm_deg",
    "type": "function",
    "description": "\n    Degree of ``f``.\n\n    This is the maximum of the degrees of all its monomials.\n    Invalid if ``f`` is zero.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.distributedmodules import sdm_deg\n    >>> sdm_deg([((1, 2, 3), 1), ((10, 0, 1), 1), ((2, 3, 4), 4)])\n    7\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_from_vector",
    "full_id": "sympy.polys.distributedmodules.sdm_from_vector",
    "type": "function",
    "description": "\n    Create an sdm from an iterable of expressions.\n\n    Coefficients are created in the ground field ``K``, and terms are ordered\n    according to monomial order ``O``. Named arguments are passed on to the\n    polys conversion code and can be used to specify for example generators.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.distributedmodules import sdm_from_vector\n    >>> from sympy.abc import x, y, z\n    >>> from sympy.polys import QQ, lex\n    >>> sdm_from_vector([x**2+y**2, 2*z], lex, QQ)\n    [((1, 0, 0, 1), 2), ((0, 2, 0, 0), 1), ((0, 0, 2, 0), 1)]\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_to_vector",
    "full_id": "sympy.polys.distributedmodules.sdm_to_vector",
    "type": "function",
    "description": "\n    Convert sdm ``f`` into a list of polynomial expressions.\n\n    The generators for the polynomial ring are specified via ``gens``. The rank\n    of the module is guessed, or passed via ``n``. The ground field is assumed\n    to be ``K``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.distributedmodules import sdm_to_vector\n    >>> from sympy.abc import x, y, z\n    >>> from sympy.polys import QQ\n    >>> f = [((1, 0, 0, 1), QQ(2)), ((0, 2, 0, 0), QQ(1)), ((0, 0, 2, 0), QQ(1))]\n    >>> sdm_to_vector(f, [x, y, z], QQ)\n    [x**2 + y**2, 2*z]\n    ",
    "section": "Manipulation of sparse, distributed polynomials and vectors",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_half_gcdex",
    "full_id": "sympy.polys.euclidtools.dmp_half_gcdex",
    "type": "function",
    "description": "\n    Half extended Euclidean algorithm in `F[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    ",
    "section": "Classical remainder sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_gcdex",
    "full_id": "sympy.polys.euclidtools.dmp_gcdex",
    "type": "function",
    "description": "\n    Extended Euclidean algorithm in `F[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    ",
    "section": "Classical remainder sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_invert",
    "full_id": "sympy.polys.euclidtools.dmp_invert",
    "type": "function",
    "description": "\n    Compute multiplicative inverse of `f` modulo `g` in `F[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x = ring(\"x\", QQ)\n\n    ",
    "section": "Classical remainder sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_euclidean_prs",
    "full_id": "sympy.polys.euclidtools.dmp_euclidean_prs",
    "type": "function",
    "description": "\n    Euclidean polynomial remainder sequence (PRS) in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    ",
    "section": "Classical remainder sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_primitive_prs",
    "full_id": "sympy.polys.euclidtools.dmp_primitive_prs",
    "type": "function",
    "description": "\n    Primitive polynomial remainder sequence (PRS) in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    ",
    "section": "Simplified remainder sequences",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_inner_subresultants",
    "full_id": "sympy.polys.euclidtools.dmp_inner_subresultants",
    "type": "function",
    "description": "\n    Subresultant PRS algorithm in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 3*x**2*y - y**3 - 4\n    >>> g = x**2 + x*y**3 - 9\n\n    >>> a = 3*x*y**4 + y**3 - 27*y + 4\n    >>> b = -3*y**10 - 12*y**7 + y**6 - 54*y**4 + 8*y**3 + 729*y**2 - 216*y + 16\n\n    >>> prs = [f, g, a, b]\n    >>> sres = [[1], [1], [3, 0, 0, 0, 0], [-3, 0, 0, -12, 1, 0, -54, 8, 729, -216, 16]]\n\n    >>> R.dmp_inner_subresultants(f, g) == (prs, sres)\n    True\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_subresultants",
    "full_id": "sympy.polys.euclidtools.dmp_subresultants",
    "type": "function",
    "description": "\n    Computes subresultant PRS of two polynomials in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 3*x**2*y - y**3 - 4\n    >>> g = x**2 + x*y**3 - 9\n\n    >>> a = 3*x*y**4 + y**3 - 27*y + 4\n    >>> b = -3*y**10 - 12*y**7 + y**6 - 54*y**4 + 8*y**3 + 729*y**2 - 216*y + 16\n\n    >>> R.dmp_subresultants(f, g) == [f, g, a, b]\n    True\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_prs_resultant",
    "full_id": "sympy.polys.euclidtools.dmp_prs_resultant",
    "type": "function",
    "description": "\n    Resultant algorithm in `K[X]` using subresultant PRS.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 3*x**2*y - y**3 - 4\n    >>> g = x**2 + x*y**3 - 9\n\n    >>> a = 3*x*y**4 + y**3 - 27*y + 4\n    >>> b = -3*y**10 - 12*y**7 + y**6 - 54*y**4 + 8*y**3 + 729*y**2 - 216*y + 16\n\n    >>> res, prs = R.dmp_prs_resultant(f, g)\n\n    >>> res == b             # resultant has n-1 variables\n    False\n    >>> res == b.drop(x)\n    True\n    >>> prs == [f, g, a, b]\n    True\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_modular_resultant",
    "full_id": "sympy.polys.euclidtools.dmp_zz_modular_resultant",
    "type": "function",
    "description": "\n    Compute resultant of `f` and `g` modulo a prime `p`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x + y + 2\n    >>> g = 2*x*y + x + 3\n\n    >>> R.dmp_zz_modular_resultant(f, g, 5)\n    -2*y**2 + 1\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_collins_resultant",
    "full_id": "sympy.polys.euclidtools.dmp_zz_collins_resultant",
    "type": "function",
    "description": "\n    Collins's modular resultant algorithm in `Z[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x + y + 2\n    >>> g = 2*x*y + x + 3\n\n    >>> R.dmp_zz_collins_resultant(f, g)\n    -2*y**2 - 5*y + 1\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_qq_collins_resultant",
    "full_id": "sympy.polys.euclidtools.dmp_qq_collins_resultant",
    "type": "function",
    "description": "\n    Collins's modular resultant algorithm in `Q[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y = ring(\"x,y\", QQ)\n\n    >>> f = QQ(1,2)*x + y + QQ(2,3)\n    >>> g = 2*x*y + x + 3\n\n    >>> R.dmp_qq_collins_resultant(f, g)\n    -2*y**2 - 7/3*y + 5/6\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_resultant",
    "full_id": "sympy.polys.euclidtools.dmp_resultant",
    "type": "function",
    "description": "\n    Computes resultant of two polynomials in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = 3*x**2*y - y**3 - 4\n    >>> g = x**2 + x*y**3 - 9\n\n    >>> R.dmp_resultant(f, g)\n    -3*y**10 - 12*y**7 + y**6 - 54*y**4 + 8*y**3 + 729*y**2 - 216*y + 16\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_discriminant",
    "full_id": "sympy.polys.euclidtools.dmp_discriminant",
    "type": "function",
    "description": "\n    Computes discriminant of a polynomial in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y,z,t = ring(\"x,y,z,t\", ZZ)\n\n    >>> R.dmp_discriminant(x**2*y + x*z + t)\n    -4*y*t + z**2\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_rr_prs_gcd",
    "full_id": "sympy.polys.euclidtools.dmp_rr_prs_gcd",
    "type": "function",
    "description": "\n    Computes polynomial GCD using subresultants over a ring.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``, ``cff = quo(f, h)``,\n    and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_rr_prs_gcd(f, g)\n    (x + y, x + y, x)\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ff_prs_gcd",
    "full_id": "sympy.polys.euclidtools.dmp_ff_prs_gcd",
    "type": "function",
    "description": "\n    Computes polynomial GCD using subresultants over a field.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``, ``cff = quo(f, h)``,\n    and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y, = ring(\"x,y\", QQ)\n\n    >>> f = QQ(1,2)*x**2 + x*y + QQ(1,2)*y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_ff_prs_gcd(f, g)\n    (x + y, 1/2*x + 1/2*y, x)\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_heu_gcd",
    "full_id": "sympy.polys.euclidtools.dmp_zz_heu_gcd",
    "type": "function",
    "description": "\n    Heuristic polynomial GCD in `Z[X]`.\n\n    Given univariate polynomials `f` and `g` in `Z[X]`, returns\n    their GCD and cofactors, i.e. polynomials ``h``, ``cff`` and ``cfg``\n    such that::\n\n          h = gcd(f, g), cff = quo(f, h) and cfg = quo(g, h)\n\n    The algorithm is purely heuristic which means it may fail to compute\n    the GCD. This will be signaled by raising an exception. In this case\n    you will need to switch to another GCD method.\n\n    The algorithm computes the polynomial GCD by evaluating polynomials\n    f and g at certain points and computing (fast) integer GCD of those\n    evaluations. The polynomial GCD is recovered from the integer image\n    by interpolation. The evaluation process reduces f and g variable by\n    variable into a large integer.  The final step is to verify if the\n    interpolated polynomial is the correct GCD. This gives cofactors of\n    the input polynomials as a side effect.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_zz_heu_gcd(f, g)\n    (x + y, x + y, x)\n\n    References\n    ==========\n\n    .. [1] [Liao95]_\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_qq_heu_gcd",
    "full_id": "sympy.polys.euclidtools.dmp_qq_heu_gcd",
    "type": "function",
    "description": "\n    Heuristic polynomial GCD in `Q[X]`.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``,\n    ``cff = quo(f, h)``, and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, QQ\n    >>> R, x,y, = ring(\"x,y\", QQ)\n\n    >>> f = QQ(1,4)*x**2 + x*y + y**2\n    >>> g = QQ(1,2)*x**2 + x*y\n\n    >>> R.dmp_qq_heu_gcd(f, g)\n    (x + 2*y, 1/4*x + 1/2*y, 1/2*x)\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_inner_gcd",
    "full_id": "sympy.polys.euclidtools.dmp_inner_gcd",
    "type": "function",
    "description": "\n    Computes polynomial GCD and cofactors of `f` and `g` in `K[X]`.\n\n    Returns ``(h, cff, cfg)`` such that ``a = gcd(f, g)``,\n    ``cff = quo(f, h)``, and ``cfg = quo(g, h)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_inner_gcd(f, g)\n    (x + y, x + y, x)\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_gcd",
    "full_id": "sympy.polys.euclidtools.dmp_gcd",
    "type": "function",
    "description": "\n    Computes polynomial GCD of `f` and `g` in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_gcd(f, g)\n    x + y\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_lcm",
    "full_id": "sympy.polys.euclidtools.dmp_lcm",
    "type": "function",
    "description": "\n    Computes polynomial LCM of `f` and `g` in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> f = x**2 + 2*x*y + y**2\n    >>> g = x**2 + x*y\n\n    >>> R.dmp_lcm(f, g)\n    x**3 + 2*x**2*y + x*y**2\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_content",
    "full_id": "sympy.polys.euclidtools.dmp_content",
    "type": "function",
    "description": "\n    Returns GCD of multivariate coefficients.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_content(2*x*y + 6*x + 4*y + 12)\n    2*y + 6\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_primitive",
    "full_id": "sympy.polys.euclidtools.dmp_primitive",
    "type": "function",
    "description": "\n    Returns multivariate content and a primitive polynomial.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y, = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_primitive(2*x*y + 6*x + 4*y + 12)\n    (2*y + 6, x + 2)\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_cancel",
    "full_id": "sympy.polys.euclidtools.dmp_cancel",
    "type": "function",
    "description": "\n    Cancel common factors in a rational function `f/g`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_cancel(2*x**2 - 2, x**2 - 2*x + 1)\n    (2*x + 2, x - 1)\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_trial_division",
    "full_id": "sympy.polys.factortools.dup_trial_division",
    "type": "function",
    "description": "\n    Determine multiplicities of factors for a univariate polynomial\n    using trial division.\n\n    An error will be raised if any factor does not divide ``f``.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_trial_division",
    "full_id": "sympy.polys.factortools.dmp_trial_division",
    "type": "function",
    "description": "\n    Determine multiplicities of factors for a multivariate polynomial\n    using trial division.\n\n    An error will be raised if any factor does not divide ``f``.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_mignotte_bound",
    "full_id": "sympy.polys.factortools.dup_zz_mignotte_bound",
    "type": "function",
    "description": "\n    The Knuth-Cohen variant of Mignotte bound for\n    univariate polynomials in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> f = x**3 + 14*x**2 + 56*x + 64\n    >>> R.dup_zz_mignotte_bound(f)\n    152\n\n    By checking ``factor(f)`` we can see that max coeff is 8\n\n    Also consider a case that ``f`` is irreducible for example\n    ``f = 2*x**2 + 3*x + 4``. To avoid a bug for these cases, we return the\n    bound plus the max coefficient of ``f``\n\n    >>> f = 2*x**2 + 3*x + 4\n    >>> R.dup_zz_mignotte_bound(f)\n    6\n\n    Lastly, to see the difference between the new and the old Mignotte bound\n    consider the irreducible polynomial:\n\n    >>> f = 87*x**7 + 4*x**6 + 80*x**5 + 17*x**4 + 9*x**3 + 12*x**2 + 49*x + 26\n    >>> R.dup_zz_mignotte_bound(f)\n    744\n\n    The new Mignotte bound is 744 whereas the old one (SymPy 1.5.1) is 1937664.\n\n\n    References\n    ==========\n\n    ..[1] [Abbott13]_\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_mignotte_bound",
    "full_id": "sympy.polys.factortools.dmp_zz_mignotte_bound",
    "type": "function",
    "description": "Mignotte bound for multivariate polynomials in `K[X]`.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_hensel_step",
    "full_id": "sympy.polys.factortools.dup_zz_hensel_step",
    "type": "function",
    "description": "\n    One step in Hensel lifting in `Z[x]`.\n\n    Given positive integer `m` and `Z[x]` polynomials `f`, `g`, `h`, `s`\n    and `t` such that::\n\n        f = g*h (mod m)\n        s*g + t*h = 1 (mod m)\n\n        lc(f) is not a zero divisor (mod m)\n        lc(h) = 1\n\n        deg(f) = deg(g) + deg(h)\n        deg(s) < deg(h)\n        deg(t) < deg(g)\n\n    returns polynomials `G`, `H`, `S` and `T`, such that::\n\n        f = G*H (mod m**2)\n        S*G + T*H = 1 (mod m**2)\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_hensel_lift",
    "full_id": "sympy.polys.factortools.dup_zz_hensel_lift",
    "type": "function",
    "description": "\n    Multifactor Hensel lifting in `Z[x]`.\n\n    Given a prime `p`, polynomial `f` over `Z[x]` such that `lc(f)`\n    is a unit modulo `p`, monic pair-wise coprime polynomials `f_i`\n    over `Z[x]` satisfying::\n\n        f = lc(f) f_1 ... f_r (mod p)\n\n    and a positive integer `l`, returns a list of monic polynomials\n    `F_1,\\ F_2,\\ \\dots,\\ F_r` satisfying::\n\n       f = lc(f) F_1 ... F_r (mod p**l)\n\n       F_i = f_i (mod p), i = 1..r\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_zassenhaus",
    "full_id": "sympy.polys.factortools.dup_zz_zassenhaus",
    "type": "function",
    "description": "Factor primitive square-free polynomials in `Z[x]`.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_irreducible_p",
    "full_id": "sympy.polys.factortools.dup_zz_irreducible_p",
    "type": "function",
    "description": "Test irreducibility using Eisenstein's criterion.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_cyclotomic_p",
    "full_id": "sympy.polys.factortools.dup_cyclotomic_p",
    "type": "function",
    "description": "\n    Efficiently test if ``f`` is a cyclotomic polynomial.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> f = x**16 + x**14 - x**10 + x**8 - x**6 + x**2 + 1\n    >>> R.dup_cyclotomic_p(f)\n    False\n\n    >>> g = x**16 + x**14 - x**10 - x**8 - x**6 + x**2 + 1\n    >>> R.dup_cyclotomic_p(g)\n    True\n\n    References\n    ==========\n\n    Bradford, Russell J., and James H. Davenport. \"Effective tests for\n    cyclotomic polynomials.\" In International Symposium on Symbolic and\n    Algebraic Computation, pp. 244-251. Springer, Berlin, Heidelberg, 1988.\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_cyclotomic_poly",
    "full_id": "sympy.polys.factortools.dup_zz_cyclotomic_poly",
    "type": "function",
    "description": "Efficiently generate n-th cyclotomic polynomial.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_cyclotomic_factor",
    "full_id": "sympy.polys.factortools.dup_zz_cyclotomic_factor",
    "type": "function",
    "description": "\n    Efficiently factor polynomials `x**n - 1` and `x**n + 1` in `Z[x]`.\n\n    Given a univariate polynomial `f` in `Z[x]` returns a list of factors\n    of `f`, provided that `f` is in the form `x**n - 1` or `x**n + 1` for\n    `n >= 1`. Otherwise returns None.\n\n    Factorization is performed using cyclotomic decomposition of `f`,\n    which makes this method much faster that any other direct factorization\n    approach (e.g. Zassenhaus's).\n\n    References\n    ==========\n\n    .. [1] [Weisstein09]_\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_factor_sqf",
    "full_id": "sympy.polys.factortools.dup_zz_factor_sqf",
    "type": "function",
    "description": "Factor square-free (non-primitive) polynomials in `Z[x]`.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_factor",
    "full_id": "sympy.polys.factortools.dup_zz_factor",
    "type": "function",
    "description": "\n    Factor (non square-free) polynomials in `Z[x]`.\n\n    Given a univariate polynomial `f` in `Z[x]` computes its complete\n    factorization `f_1, ..., f_n` into irreducibles over integers::\n\n                f = content(f) f_1**k_1 ... f_n**k_n\n\n    The factorization is computed by reducing the input polynomial\n    into a primitive square-free polynomial and factoring it using\n    Zassenhaus algorithm. Trial division is used to recover the\n    multiplicities of factors.\n\n    The result is returned as a tuple consisting of::\n\n              (content(f), [(f_1, k_1), ..., (f_n, k_n))\n\n    Examples\n    ========\n\n    Consider the polynomial `f = 2*x**4 - 2`::\n\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x = ring(\"x\", ZZ)\n\n        >>> R.dup_zz_factor(2*x**4 - 2)\n        (2, [(x - 1, 1), (x + 1, 1), (x**2 + 1, 1)])\n\n    In result we got the following factorization::\n\n                 f = 2 (x - 1) (x + 1) (x**2 + 1)\n\n    Note that this is a complete factorization over integers,\n    however over Gaussian integers we can factor the last term.\n\n    By default, polynomials `x**n - 1` and `x**n + 1` are factored\n    using cyclotomic decomposition to speedup computations. To\n    disable this behaviour set cyclotomic=False.\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_wang_non_divisors",
    "full_id": "sympy.polys.factortools.dmp_zz_wang_non_divisors",
    "type": "function",
    "description": "Wang/EEZ: Compute a set of valid divisors.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_wang_test_points",
    "full_id": "sympy.polys.factortools.dmp_zz_wang_test_points",
    "type": "function",
    "description": "Wang/EEZ: Test evaluation points for suitability.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_wang_lead_coeffs",
    "full_id": "sympy.polys.factortools.dmp_zz_wang_lead_coeffs",
    "type": "function",
    "description": "Wang/EEZ: Compute correct leading coefficients.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_diophantine",
    "full_id": "sympy.polys.factortools.dup_zz_diophantine",
    "type": "function",
    "description": "Wang/EEZ: Solve univariate Diophantine equations.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_diophantine",
    "full_id": "sympy.polys.factortools.dmp_zz_diophantine",
    "type": "function",
    "description": "Wang/EEZ: Solve multivariate Diophantine equations.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_wang_hensel_lifting",
    "full_id": "sympy.polys.factortools.dmp_zz_wang_hensel_lifting",
    "type": "function",
    "description": "Wang/EEZ: Parallel Hensel lifting algorithm.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_wang",
    "full_id": "sympy.polys.factortools.dmp_zz_wang",
    "type": "function",
    "description": "\n    Factor primitive square-free polynomials in `Z[X]`.\n\n    Given a multivariate polynomial `f` in `Z[x_1,...,x_n]`, which is\n    primitive and square-free in `x_1`, computes factorization of `f` into\n    irreducibles over integers.\n\n    The procedure is based on Wang's Enhanced Extended Zassenhaus\n    algorithm. The algorithm works by viewing `f` as a univariate polynomial\n    in `Z[x_2,...,x_n][x_1]`, for which an evaluation mapping is computed::\n\n                      x_2 -> a_2, ..., x_n -> a_n\n\n    where `a_i`, for `i = 2, \\dots, n`, are carefully chosen integers.  The\n    mapping is used to transform `f` into a univariate polynomial in `Z[x_1]`,\n    which can be factored efficiently using Zassenhaus algorithm. The last\n    step is to lift univariate factors to obtain true multivariate\n    factors. For this purpose a parallel Hensel lifting procedure is used.\n\n    The parameter ``seed`` is passed to _randint and can be used to seed randint\n    (when an integer) or (for testing purposes) can be a sequence of numbers.\n\n    References\n    ==========\n\n    .. [1] [Wang78]_\n    .. [2] [Geddes92]_\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_factor",
    "full_id": "sympy.polys.factortools.dmp_zz_factor",
    "type": "function",
    "description": "\n    Factor (non square-free) polynomials in `Z[X]`.\n\n    Given a multivariate polynomial `f` in `Z[x]` computes its complete\n    factorization `f_1, \\dots, f_n` into irreducibles over integers::\n\n                 f = content(f) f_1**k_1 ... f_n**k_n\n\n    The factorization is computed by reducing the input polynomial\n    into a primitive square-free polynomial and factoring it using\n    Enhanced Extended Zassenhaus (EEZ) algorithm. Trial division\n    is used to recover the multiplicities of factors.\n\n    The result is returned as a tuple consisting of::\n\n             (content(f), [(f_1, k_1), ..., (f_n, k_n))\n\n    Consider polynomial `f = 2*(x**2 - y**2)`::\n\n        >>> from sympy.polys import ring, ZZ\n        >>> R, x,y = ring(\"x,y\", ZZ)\n\n        >>> R.dmp_zz_factor(2*x**2 - 2*y**2)\n        (2, [(x - y, 1), (x + y, 1)])\n\n    In result we got the following factorization::\n\n                    f = 2 (x - y) (x + y)\n\n    References\n    ==========\n\n    .. [1] [Gathen99]_\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_qq_i_factor",
    "full_id": "sympy.polys.factortools.dup_qq_i_factor",
    "type": "function",
    "description": "Factor univariate polynomials into irreducibles in `QQ_I[x]`.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_zz_i_factor",
    "full_id": "sympy.polys.factortools.dup_zz_i_factor",
    "type": "function",
    "description": "Factor univariate polynomials into irreducibles in `ZZ_I[x]`.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_qq_i_factor",
    "full_id": "sympy.polys.factortools.dmp_qq_i_factor",
    "type": "function",
    "description": "Factor multivariate polynomials into irreducibles in `QQ_I[X]`.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_zz_i_factor",
    "full_id": "sympy.polys.factortools.dmp_zz_i_factor",
    "type": "function",
    "description": "Factor multivariate polynomials into irreducibles in `ZZ_I[X]`.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_ext_factor",
    "full_id": "sympy.polys.factortools.dup_ext_factor",
    "type": "function",
    "description": "Factor univariate polynomials over algebraic number fields.\n\n    The domain `K` must be an algebraic number field `k(a)` (see :ref:`QQ(a)`).\n\n    Examples\n    ========\n\n    First define the algebraic number field `K = \\mathbb{Q}(\\sqrt{2})`:\n\n    >>> from sympy import QQ, sqrt\n    >>> from sympy.polys.factortools import dup_ext_factor\n    >>> K = QQ.algebraic_field(sqrt(2))\n\n    We can now factorise the polynomial `x^2 - 2` over `K`:\n\n    >>> p = [K(1), K(0), K(-2)] # x^2 - 2\n    >>> p1 = [K(1), -K.unit]    # x - sqrt(2)\n    >>> p2 = [K(1), +K.unit]    # x + sqrt(2)\n    >>> dup_ext_factor(p, K) == (K.one, [(p1, 1), (p2, 1)])\n    True\n\n    Usually this would be done at a higher level:\n\n    >>> from sympy import factor\n    >>> from sympy.abc import x\n    >>> factor(x**2 - 2, extension=sqrt(2))\n    (x - sqrt(2))*(x + sqrt(2))\n\n    Explanation\n    ===========\n\n    Uses Trager's algorithm. In particular this function is algorithm\n    ``alg_factor`` from [Trager76]_.\n\n    If `f` is a polynomial in `k(a)[x]` then its norm `g(x)` is a polynomial in\n    `k[x]`. If `g(x)` is square-free and has irreducible factors `g_1(x)`,\n    `g_2(x)`, `\\cdots` then the irreducible factors of `f` in `k(a)[x]` are\n    given by `f_i(x) = \\gcd(f(x), g_i(x))` where the GCD is computed in\n    `k(a)[x]`.\n\n    The first step in Trager's algorithm is to find an integer shift `s` so\n    that `f(x-sa)` has square-free norm. Then the norm is factorized in `k[x]`\n    and the GCD of (shifted) `f` with each factor gives the shifted factors of\n    `f`. At the end the shift is undone to recover the unshifted factors of `f`\n    in `k(a)[x]`.\n\n    The algorithm reduces the problem of factorization in `k(a)[x]` to\n    factorization in `k[x]` with the main additional steps being to compute the\n    norm (a resultant calculation in `k[x,y]`) and some polynomial GCDs in\n    `k(a)[x]`.\n\n    In practice in SymPy the base field `k` will be the rationals :ref:`QQ` and\n    this function factorizes a polynomial with coefficients in an algebraic\n    number field  like `\\mathbb{Q}(\\sqrt{2})`.\n\n    See Also\n    ========\n\n    dmp_ext_factor:\n        Analogous function for multivariate polynomials over ``k(a)``.\n    dup_sqf_norm:\n        Subroutine ``sqfr_norm`` also from [Trager76]_.\n    sympy.polys.polytools.factor:\n        The high-level function that ultimately uses this function as needed.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_ext_factor",
    "full_id": "sympy.polys.factortools.dmp_ext_factor",
    "type": "function",
    "description": "Factor multivariate polynomials over algebraic number fields.\n\n    The domain `K` must be an algebraic number field `k(a)` (see :ref:`QQ(a)`).\n\n    Examples\n    ========\n\n    First define the algebraic number field `K = \\mathbb{Q}(\\sqrt{2})`:\n\n    >>> from sympy import QQ, sqrt\n    >>> from sympy.polys.factortools import dmp_ext_factor\n    >>> K = QQ.algebraic_field(sqrt(2))\n\n    We can now factorise the polynomial `x^2 y^2 - 2` over `K`:\n\n    >>> p = [[K(1),K(0),K(0)], [], [K(-2)]] # x**2*y**2 - 2\n    >>> p1 = [[K(1),K(0)], [-K.unit]]       # x*y - sqrt(2)\n    >>> p2 = [[K(1),K(0)], [+K.unit]]       # x*y + sqrt(2)\n    >>> dmp_ext_factor(p, 1, K) == (K.one, [(p1, 1), (p2, 1)])\n    True\n\n    Usually this would be done at a higher level:\n\n    >>> from sympy import factor\n    >>> from sympy.abc import x, y\n    >>> factor(x**2*y**2 - 2, extension=sqrt(2))\n    (x*y - sqrt(2))*(x*y + sqrt(2))\n\n    Explanation\n    ===========\n\n    This is Trager's algorithm for multivariate polynomials. In particular this\n    function is algorithm ``alg_factor`` from [Trager76]_.\n\n    See :func:`dup_ext_factor` for explanation.\n\n    See Also\n    ========\n\n    dup_ext_factor:\n        Analogous function for univariate polynomials over ``k(a)``.\n    dmp_sqf_norm:\n        Multivariate version of subroutine ``sqfr_norm`` also from [Trager76]_.\n    sympy.polys.polytools.factor:\n        The high-level function that ultimately uses this function as needed.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_gf_factor",
    "full_id": "sympy.polys.factortools.dup_gf_factor",
    "type": "function",
    "description": "Factor univariate polynomials over finite fields.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_gf_factor",
    "full_id": "sympy.polys.factortools.dmp_gf_factor",
    "type": "function",
    "description": "Factor multivariate polynomials over finite fields.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_factor_list",
    "full_id": "sympy.polys.factortools.dup_factor_list",
    "type": "function",
    "description": "Factor univariate polynomials into irreducibles in `K[x]`.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_factor_list",
    "full_id": "sympy.polys.factortools.dmp_factor_list",
    "type": "function",
    "description": "Factor multivariate polynomials into irreducibles in `K[X]`.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_irreducible_p",
    "full_id": "sympy.polys.factortools.dup_irreducible_p",
    "type": "function",
    "description": "\n    Returns ``True`` if a univariate polynomial ``f`` has no factors\n    over its domain.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_irreducible_p",
    "full_id": "sympy.polys.factortools.dmp_irreducible_p",
    "type": "function",
    "description": "\n    Returns ``True`` if a multivariate polynomial ``f`` has no factors\n    over its domain.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_sqf_p",
    "full_id": "sympy.polys.sqfreetools.dup_sqf_p",
    "type": "function",
    "description": "\n    Return ``True`` if ``f`` is a square-free polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_sqf_p(x**2 - 2*x + 1)\n    False\n    >>> R.dup_sqf_p(x**2 - 1)\n    True\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sqf_p",
    "full_id": "sympy.polys.sqfreetools.dmp_sqf_p",
    "type": "function",
    "description": "\n    Return ``True`` if ``f`` is a square-free polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sqf_p(x**2 + 2*x*y + y**2)\n    False\n    >>> R.dmp_sqf_p(x**2 + y**2)\n    True\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_sqf_norm",
    "full_id": "sympy.polys.sqfreetools.dup_sqf_norm",
    "type": "function",
    "description": "\n    Find a shift of `f` in `K[x]` that has square-free norm.\n\n    The domain `K` must be an algebraic number field `k(a)` (see :ref:`QQ(a)`).\n\n    Returns `(s,g,r)`, such that `g(x)=f(x-sa)`, `r(x)=\\text{Norm}(g(x))` and\n    `r` is a square-free polynomial over `k`.\n\n    Examples\n    ========\n\n    We first create the algebraic number field `K=k(a)=\\mathbb{Q}(\\sqrt{3})`\n    and rings `K[x]` and `k[x]`:\n\n    >>> from sympy.polys import ring, QQ\n    >>> from sympy import sqrt\n\n    >>> K = QQ.algebraic_field(sqrt(3))\n    >>> R, x = ring(\"x\", K)\n    >>> _, X = ring(\"x\", QQ)\n\n    We can now find a square free norm for a shift of `f`:\n\n    >>> f = x**2 - 1\n    >>> s, g, r = R.dup_sqf_norm(f)\n\n    The choice of shift `s` is arbitrary and the particular values returned for\n    `g` and `r` are determined by `s`.\n\n    >>> s == 1\n    True\n    >>> g == x**2 - 2*sqrt(3)*x + 2\n    True\n    >>> r == X**4 - 8*X**2 + 4\n    True\n\n    The invariants are:\n\n    >>> g == f.shift(-s*K.unit)\n    True\n    >>> g.norm() == r\n    True\n    >>> r.is_squarefree\n    True\n\n    Explanation\n    ===========\n\n    This is part of Trager's algorithm for factorizing polynomials over\n    algebraic number fields. In particular this function is algorithm\n    ``sqfr_norm`` from [Trager76]_.\n\n    See Also\n    ========\n\n    dmp_sqf_norm:\n        Analogous function for multivariate polynomials over ``k(a)``.\n    dmp_norm:\n        Computes the norm of `f` directly without any shift.\n    dup_ext_factor:\n        Function implementing Trager's algorithm that uses this.\n    sympy.polys.polytools.sqf_norm:\n        High-level interface for using this function.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sqf_norm",
    "full_id": "sympy.polys.sqfreetools.dmp_sqf_norm",
    "type": "function",
    "description": "\n    Find a shift of ``f`` in ``K[X]`` that has square-free norm.\n\n    The domain `K` must be an algebraic number field `k(a)` (see :ref:`QQ(a)`).\n\n    Returns `(s,g,r)`, such that `g(x_1,x_2,\\cdots)=f(x_1-s_1 a, x_2 - s_2 a,\n    \\cdots)`, `r(x)=\\text{Norm}(g(x))` and `r` is a square-free polynomial over\n    `k`.\n\n    Examples\n    ========\n\n    We first create the algebraic number field `K=k(a)=\\mathbb{Q}(i)` and rings\n    `K[x,y]` and `k[x,y]`:\n\n    >>> from sympy.polys import ring, QQ\n    >>> from sympy import I\n\n    >>> K = QQ.algebraic_field(I)\n    >>> R, x, y = ring(\"x,y\", K)\n    >>> _, X, Y = ring(\"x,y\", QQ)\n\n    We can now find a square free norm for a shift of `f`:\n\n    >>> f = x*y + y**2\n    >>> s, g, r = R.dmp_sqf_norm(f)\n\n    The choice of shifts ``s`` is arbitrary and the particular values returned\n    for ``g`` and ``r`` are determined by ``s``.\n\n    >>> s\n    [0, 1]\n    >>> g == x*y - I*x + y**2 - 2*I*y - 1\n    True\n    >>> r == X**2*Y**2 + X**2 + 2*X*Y**3 + 2*X*Y + Y**4 + 2*Y**2 + 1\n    True\n\n    The required invariants are:\n\n    >>> g == f.shift_list([-si*K.unit for si in s])\n    True\n    >>> g.norm() == r\n    True\n    >>> r.is_squarefree\n    True\n\n    Explanation\n    ===========\n\n    This is part of Trager's algorithm for factorizing polynomials over\n    algebraic number fields. In particular this function is a multivariate\n    generalization of algorithm ``sqfr_norm`` from [Trager76]_.\n\n    See Also\n    ========\n\n    dup_sqf_norm:\n        Analogous function for univariate polynomials over ``k(a)``.\n    dmp_norm:\n        Computes the norm of `f` directly without any shift.\n    dmp_ext_factor:\n        Function implementing Trager's algorithm that uses this.\n    sympy.polys.polytools.sqf_norm:\n        High-level interface for using this function.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_norm",
    "full_id": "sympy.polys.sqfreetools.dmp_norm",
    "type": "function",
    "description": "\n    Norm of ``f`` in ``K[X]``, often not square-free.\n\n    The domain `K` must be an algebraic number field `k(a)` (see :ref:`QQ(a)`).\n\n    Examples\n    ========\n\n    We first define the algebraic number field `K = k(a) = \\mathbb{Q}(\\sqrt{2})`:\n\n    >>> from sympy import QQ, sqrt\n    >>> from sympy.polys.sqfreetools import dmp_norm\n    >>> k = QQ\n    >>> K = k.algebraic_field(sqrt(2))\n\n    We can now compute the norm of a polynomial `p` in `K[x,y]`:\n\n    >>> p = [[K(1)], [K(1),K.unit]]                  # x + y + sqrt(2)\n    >>> N = [[k(1)], [k(2),k(0)], [k(1),k(0),k(-2)]] # x**2 + 2*x*y + y**2 - 2\n    >>> dmp_norm(p, 1, K) == N\n    True\n\n    In higher level functions that is:\n\n    >>> from sympy import expand, roots, minpoly\n    >>> from sympy.abc import x, y\n    >>> from math import prod\n    >>> a = sqrt(2)\n    >>> e = (x + y + a)\n    >>> e.as_poly([x, y], extension=a).norm()\n    Poly(x**2 + 2*x*y + y**2 - 2, x, y, domain='QQ')\n\n    This is equal to the product of the expressions `x + y + a_i` where the\n    `a_i` are the conjugates of `a`:\n\n    >>> pa = minpoly(a)\n    >>> pa\n    _x**2 - 2\n    >>> rs = roots(pa, multiple=True)\n    >>> rs\n    [sqrt(2), -sqrt(2)]\n    >>> n = prod(e.subs(a, r) for r in rs)\n    >>> n\n    (x + y - sqrt(2))*(x + y + sqrt(2))\n    >>> expand(n)\n    x**2 + 2*x*y + y**2 - 2\n\n    Explanation\n    ===========\n\n    Given an algebraic number field `K = k(a)` any element `b` of `K` can be\n    represented as polynomial function `b=g(a)` where `g` is in `k[x]`. If the\n    minimal polynomial of `a` over `k` is `p_a` then the roots `a_1`, `a_2`,\n    `\\cdots` of `p_a(x)` are the conjugates of `a`. The norm of `b` is the\n    product `g(a1) \\times g(a2) \\times \\cdots` and is an element of `k`.\n\n    As in [Trager76]_ we extend this norm to multivariate polynomials over `K`.\n    If `b(x)` is a polynomial in `k(a)[X]` then we can think of `b` as being\n    alternately a function `g_X(a)` where `g_X` is an element of `k[X][y]` i.e.\n    a polynomial function with coefficients that are elements of `k[X]`. Then\n    the norm of `b` is the product `g_X(a1) \\times g_X(a2) \\times \\cdots` and\n    will be an element of `k[X]`.\n\n    See Also\n    ========\n\n    dmp_sqf_norm:\n        Compute a shift of `f` so that the `\\text{Norm}(f)` is square-free.\n    sympy.polys.polytools.Poly.norm:\n        Higher-level function that calls this.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_gf_sqf_part",
    "full_id": "sympy.polys.sqfreetools.dup_gf_sqf_part",
    "type": "function",
    "description": "Compute square-free part of ``f`` in ``GF(p)[x]``.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_gf_sqf_part",
    "full_id": "sympy.polys.sqfreetools.dmp_gf_sqf_part",
    "type": "function",
    "description": "Compute square-free part of ``f`` in ``GF(p)[X]``.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_sqf_part",
    "full_id": "sympy.polys.sqfreetools.dup_sqf_part",
    "type": "function",
    "description": "\n    Returns square-free part of a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_sqf_part(x**3 - 3*x - 2)\n    x**2 - x - 2\n\n    See Also\n    ========\n\n    sympy.polys.polytools.Poly.sqf_part\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sqf_part",
    "full_id": "sympy.polys.sqfreetools.dmp_sqf_part",
    "type": "function",
    "description": "\n    Returns square-free part of a polynomial in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> R.dmp_sqf_part(x**3 + 2*x**2*y + x*y**2)\n    x**2 + x*y\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_gf_sqf_list",
    "full_id": "sympy.polys.sqfreetools.dup_gf_sqf_list",
    "type": "function",
    "description": "Compute square-free decomposition of ``f`` in ``GF(p)[x]``.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_gf_sqf_list",
    "full_id": "sympy.polys.sqfreetools.dmp_gf_sqf_list",
    "type": "function",
    "description": "Compute square-free decomposition of ``f`` in ``GF(p)[X]``.",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_sqf_list",
    "full_id": "sympy.polys.sqfreetools.dup_sqf_list",
    "type": "function",
    "description": "\n    Return square-free decomposition of a polynomial in ``K[x]``.\n\n    Uses Yun's algorithm from [Yun76]_.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> f = 2*x**5 + 16*x**4 + 50*x**3 + 76*x**2 + 56*x + 16\n\n    >>> R.dup_sqf_list(f)\n    (2, [(x + 1, 2), (x + 2, 3)])\n    >>> R.dup_sqf_list(f, all=True)\n    (2, [(1, 1), (x + 1, 2), (x + 2, 3)])\n\n    See Also\n    ========\n\n    dmp_sqf_list:\n        Corresponding function for multivariate polynomials.\n    sympy.polys.polytools.sqf_list:\n        High-level function for square-free factorization of expressions.\n    sympy.polys.polytools.Poly.sqf_list:\n        Analogous method on :class:`~.Poly`.\n\n    References\n    ==========\n\n    [Yun76]_\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_sqf_list_include",
    "full_id": "sympy.polys.sqfreetools.dup_sqf_list_include",
    "type": "function",
    "description": "\n    Return square-free decomposition of a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> f = 2*x**5 + 16*x**4 + 50*x**3 + 76*x**2 + 56*x + 16\n\n    >>> R.dup_sqf_list_include(f)\n    [(2, 1), (x + 1, 2), (x + 2, 3)]\n    >>> R.dup_sqf_list_include(f, all=True)\n    [(2, 1), (x + 1, 2), (x + 2, 3)]\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sqf_list",
    "full_id": "sympy.polys.sqfreetools.dmp_sqf_list",
    "type": "function",
    "description": "\n    Return square-free decomposition of a polynomial in `K[X]`.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x**5 + 2*x**4*y + x**3*y**2\n\n    >>> R.dmp_sqf_list(f)\n    (1, [(x + y, 2), (x, 3)])\n    >>> R.dmp_sqf_list(f, all=True)\n    (1, [(1, 1), (x + y, 2), (x, 3)])\n\n    Explanation\n    ===========\n\n    Uses Yun's algorithm for univariate polynomials from [Yun76]_ recrusively.\n    The multivariate polynomial is treated as a univariate polynomial in its\n    leading variable. Then Yun's algorithm computes the square-free\n    factorization of the primitive and the content is factored recursively.\n\n    It would be better to use a dedicated algorithm for multivariate\n    polynomials instead.\n\n    See Also\n    ========\n\n    dup_sqf_list:\n        Corresponding function for univariate polynomials.\n    sympy.polys.polytools.sqf_list:\n        High-level function for square-free factorization of expressions.\n    sympy.polys.polytools.Poly.sqf_list:\n        Analogous method on :class:`~.Poly`.\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_sqf_list_include",
    "full_id": "sympy.polys.sqfreetools.dmp_sqf_list_include",
    "type": "function",
    "description": "\n    Return square-free decomposition of a polynomial in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    >>> f = x**5 + 2*x**4*y + x**3*y**2\n\n    >>> R.dmp_sqf_list_include(f)\n    [(1, 1), (x + y, 2), (x, 3)]\n    >>> R.dmp_sqf_list_include(f, all=True)\n    [(1, 1), (x + y, 2), (x, 3)]\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dup_gff_list",
    "full_id": "sympy.polys.sqfreetools.dup_gff_list",
    "type": "function",
    "description": "\n    Compute greatest factorial factorization of ``f`` in ``K[x]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> R.dup_gff_list(x**5 + 2*x**4 - x**3 - 2*x**2)\n    [(x, 1), (x + 2, 4)]\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "dmp_gff_list",
    "full_id": "sympy.polys.sqfreetools.dmp_gff_list",
    "type": "function",
    "description": "\n    Compute greatest factorial factorization of ``f`` in ``K[X]``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys import ring, ZZ\n    >>> R, x,y = ring(\"x,y\", ZZ)\n\n    ",
    "section": "Subresultant sequence",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "groebner",
    "full_id": "sympy.polys.groebnertools.groebner",
    "type": "function",
    "description": "\n    Computes Groebner basis for a set of polynomials in `K[X]`.\n\n    Wrapper around the (default) improved Buchberger and the other algorithms\n    for computing Groebner bases. The choice of algorithm can be changed via\n    ``method`` argument or :func:`sympy.polys.polyconfig.setup`, where\n    ``method`` can be either ``buchberger`` or ``f5b``.\n\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "spoly",
    "full_id": "sympy.polys.groebnertools.spoly",
    "type": "function",
    "description": "\n    Compute LCM(LM(p1), LM(p2))/LM(p1)*p1 - LCM(LM(p1), LM(p2))/LM(p2)*p2\n    This is the S-poly provided p1 and p2 are monic\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "red_groebner",
    "full_id": "sympy.polys.groebnertools.red_groebner",
    "type": "function",
    "description": "\n    Compute reduced Groebner basis, from BeckerWeispfenning93, p. 216\n\n    Selects a subset of generators, that already generate the ideal\n    and computes a reduced Groebner basis for them.\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "is_groebner",
    "full_id": "sympy.polys.groebnertools.is_groebner",
    "type": "function",
    "description": "\n    Check if G is a Groebner basis.\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "is_minimal",
    "full_id": "sympy.polys.groebnertools.is_minimal",
    "type": "function",
    "description": "\n    Checks if G is a minimal Groebner basis.\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "is_reduced",
    "full_id": "sympy.polys.groebnertools.is_reduced",
    "type": "function",
    "description": "\n    Checks if G is a reduced Groebner basis.\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "matrix_fglm",
    "full_id": "sympy.polys.fglmtools.matrix_fglm",
    "type": "function",
    "description": "\n    Converts the reduced Groebner basis ``F`` of a zero-dimensional\n    ideal w.r.t. ``O_from`` to a reduced Groebner basis\n    w.r.t. ``O_to``.\n\n    References\n    ==========\n\n    .. [1] J.C. Faugere, P. Gianni, D. Lazard, T. Mora (1994). Efficient\n           Computation of Zero-dimensional Groebner Bases by Change of\n           Ordering\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_spoly",
    "full_id": "sympy.polys.distributedmodules.sdm_spoly",
    "type": "function",
    "description": "\n    Compute the generalized s-polynomial of ``f`` and ``g``.\n\n    The ground field is assumed to be ``K``, and monomials ordered according to\n    ``O``.\n\n    This is invalid if either of ``f`` or ``g`` is zero.\n\n    If the leading terms of `f` and `g` involve different basis elements of\n    `F`, their s-poly is defined to be zero. Otherwise it is a certain linear\n    combination of `f` and `g` in which the leading terms cancel.\n    See [SCA, defn 2.3.6] for details.\n\n    If ``phantom`` is not ``None``, it should be a pair of module elements on\n    which to perform the same operation(s) as on ``f`` and ``g``. The in this\n    case both results are returned.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.distributedmodules import sdm_spoly\n    >>> from sympy.polys import QQ, lex\n    >>> f = [((2, 1, 1), QQ(1)), ((1, 0, 1), QQ(1))]\n    >>> g = [((2, 3, 0), QQ(1))]\n    >>> h = [((1, 2, 3), QQ(1))]\n    >>> sdm_spoly(f, h, lex, QQ)\n    []\n    >>> sdm_spoly(f, g, lex, QQ)\n    [((1, 2, 1), 1)]\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_ecart",
    "full_id": "sympy.polys.distributedmodules.sdm_ecart",
    "type": "function",
    "description": "\n    Compute the ecart of ``f``.\n\n    This is defined to be the difference of the total degree of `f` and the\n    total degree of the leading monomial of `f` [SCA, defn 2.3.7].\n\n    Invalid if f is zero.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.distributedmodules import sdm_ecart\n    >>> sdm_ecart([((1, 2, 3), 1), ((1, 0, 1), 1)])\n    0\n    >>> sdm_ecart([((2, 2, 1), 1), ((1, 5, 1), 1)])\n    3\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_nf_mora",
    "full_id": "sympy.polys.distributedmodules.sdm_nf_mora",
    "type": "function",
    "description": "\n    Compute a weak normal form of ``f`` with respect to ``G`` and order ``O``.\n\n    The ground field is assumed to be ``K``, and monomials ordered according to\n    ``O``.\n\n    Weak normal forms are defined in [SCA, defn 2.3.3]. They are not unique.\n    This function deterministically computes a weak normal form, depending on\n    the order of `G`.\n\n    The most important property of a weak normal form is the following: if\n    `R` is the ring associated with the monomial ordering (if the ordering is\n    global, we just have `R = K[x_1, \\ldots, x_n]`, otherwise it is a certain\n    localization thereof), `I` any ideal of `R` and `G` a standard basis for\n    `I`, then for any `f \\in R`, we have `f \\in I` if and only if\n    `NF(f | G) = 0`.\n\n    This is the generalized Mora algorithm for computing weak normal forms with\n    respect to arbitrary monomial orders [SCA, algorithm 2.3.9].\n\n    If ``phantom`` is not ``None``, it should be a pair of \"phantom\" arguments\n    on which to perform the same computations as on ``f``, ``G``, both results\n    are then returned.\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "sdm_groebner",
    "full_id": "sympy.polys.distributedmodules.sdm_groebner",
    "type": "function",
    "description": "\n    Compute a minimal standard basis of ``G`` with respect to order ``O``.\n\n    The algorithm uses a normal form ``NF``, for example ``sdm_nf_mora``.\n    The ground field is assumed to be ``K``, and monomials ordered according\n    to ``O``.\n\n    Let `N` denote the submodule generated by elements of `G`. A standard\n    basis for `N` is a subset `S` of `N`, such that `in(S) = in(N)`, where for\n    any subset `X` of `F`, `in(X)` denotes the submodule generated by the\n    initial forms of elements of `X`. [SCA, defn 2.3.2]\n\n    A standard basis is called minimal if no subset of it is a standard basis.\n\n    One may show that standard bases are always generating sets.\n\n    Minimal standard bases are not unique. This algorithm computes a\n    deterministic result, depending on the particular order of `G`.\n\n    If ``extended=True``, also compute the transition matrix from the initial\n    generators to the groebner basis. That is, return a list of coefficient\n    vectors, expressing the elements of the groebner basis in terms of the\n    elements of ``G``.\n\n    This functions implements the \"sugar\" strategy, see\n\n    Giovini et al: \"One sugar cube, please\" OR Selection strategies in\n    Buchberger algorithm.\n    ",
    "section": "Groebner basis algorithms",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "clone",
    "full_id": "sympy.polys.polyoptions.Options.clone",
    "type": "method",
    "description": "Clone ``self`` and update specified options.",
    "section": "Options",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "build_options",
    "full_id": "sympy.polys.polyoptions.build_options",
    "type": "function",
    "description": "Construct options from keyword arguments or ... options.",
    "section": "Options",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "setup",
    "full_id": "sympy.polys.polyconfig.setup",
    "type": "function",
    "description": "Assign a value to (or reset) a configuration item.",
    "section": "Configuration",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "modgcd_univariate",
    "full_id": "sympy.polys.modulargcd.modgcd_univariate",
    "type": "function",
    "description": "\n    Computes the GCD of two polynomials in `\\mathbb{Z}[x]` using a modular\n    algorithm.\n\n    The algorithm computes the GCD of two univariate integer polynomials\n    `f` and `g` by computing the GCD in `\\mathbb{Z}_p[x]` for suitable\n    primes `p` and then reconstructing the coefficients with the Chinese\n    Remainder Theorem. Trial division is only made for candidates which\n    are very likely the desired GCD.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        univariate integer polynomial\n    g : PolyElement\n        univariate integer polynomial\n\n    Returns\n    =======\n\n    h : PolyElement\n        GCD of the polynomials `f` and `g`\n    cff : PolyElement\n        cofactor of `f`, i.e. `\\frac{f}{h}`\n    cfg : PolyElement\n        cofactor of `g`, i.e. `\\frac{g}{h}`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import modgcd_univariate\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x = ring(\"x\", ZZ)\n\n    >>> f = x**5 - 1\n    >>> g = x - 1\n\n    >>> h, cff, cfg = modgcd_univariate(f, g)\n    >>> h, cff, cfg\n    (x - 1, x**4 + x**3 + x**2 + x + 1, 1)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> f = 6*x**2 - 6\n    >>> g = 2*x**2 + 4*x + 2\n\n    >>> h, cff, cfg = modgcd_univariate(f, g)\n    >>> h, cff, cfg\n    (2*x + 2, 3*x - 3, x + 1)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    References\n    ==========\n\n    1. [Monagan00]_\n\n    ",
    "section": "Modular GCD",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "modgcd_bivariate",
    "full_id": "sympy.polys.modulargcd.modgcd_bivariate",
    "type": "function",
    "description": "\n    Computes the GCD of two polynomials in `\\mathbb{Z}[x, y]` using a\n    modular algorithm.\n\n    The algorithm computes the GCD of two bivariate integer polynomials\n    `f` and `g` by calculating the GCD in `\\mathbb{Z}_p[x, y]` for\n    suitable primes `p` and then reconstructing the coefficients with the\n    Chinese Remainder Theorem. To compute the bivariate GCD over\n    `\\mathbb{Z}_p`, the polynomials `f \\; \\mathrm{mod} \\, p` and\n    `g \\; \\mathrm{mod} \\, p` are evaluated at `y = a` for certain\n    `a \\in \\mathbb{Z}_p` and then their univariate GCD in `\\mathbb{Z}_p[x]`\n    is computed. Interpolating those yields the bivariate GCD in\n    `\\mathbb{Z}_p[x, y]`. To verify the result in `\\mathbb{Z}[x, y]`, trial\n    division is done, but only for candidates which are very likely the\n    desired GCD.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        bivariate integer polynomial\n    g : PolyElement\n        bivariate integer polynomial\n\n    Returns\n    =======\n\n    h : PolyElement\n        GCD of the polynomials `f` and `g`\n    cff : PolyElement\n        cofactor of `f`, i.e. `\\frac{f}{h}`\n    cfg : PolyElement\n        cofactor of `g`, i.e. `\\frac{g}{h}`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import modgcd_bivariate\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x, y = ring(\"x, y\", ZZ)\n\n    >>> f = x**2 - y**2\n    >>> g = x**2 + 2*x*y + y**2\n\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\n    >>> h, cff, cfg\n    (x + y, x - y, x + y)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> f = x**2*y - x**2 - 4*y + 4\n    >>> g = x + 2\n\n    >>> h, cff, cfg = modgcd_bivariate(f, g)\n    >>> h, cff, cfg\n    (x + 2, x*y - x - 2*y + 2, 1)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    References\n    ==========\n\n    1. [Monagan00]_\n\n    ",
    "section": "Modular GCD",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "modgcd_multivariate",
    "full_id": "sympy.polys.modulargcd.modgcd_multivariate",
    "type": "function",
    "description": "\n    Compute the GCD of two polynomials in `\\mathbb{Z}[x_0, \\ldots, x_{k-1}]`\n    using a modular algorithm.\n\n    The algorithm computes the GCD of two multivariate integer polynomials\n    `f` and `g` by calculating the GCD in\n    `\\mathbb{Z}_p[x_0, \\ldots, x_{k-1}]` for suitable primes `p` and then\n    reconstructing the coefficients with the Chinese Remainder Theorem. To\n    compute the multivariate GCD over `\\mathbb{Z}_p` the recursive\n    subroutine :func:`_modgcd_multivariate_p` is used. To verify the result in\n    `\\mathbb{Z}[x_0, \\ldots, x_{k-1}]`, trial division is done, but only for\n    candidates which are very likely the desired GCD.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        multivariate integer polynomial\n    g : PolyElement\n        multivariate integer polynomial\n\n    Returns\n    =======\n\n    h : PolyElement\n        GCD of the polynomials `f` and `g`\n    cff : PolyElement\n        cofactor of `f`, i.e. `\\frac{f}{h}`\n    cfg : PolyElement\n        cofactor of `g`, i.e. `\\frac{g}{h}`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import modgcd_multivariate\n    >>> from sympy.polys import ring, ZZ\n\n    >>> R, x, y = ring(\"x, y\", ZZ)\n\n    >>> f = x**2 - y**2\n    >>> g = x**2 + 2*x*y + y**2\n\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\n    >>> h, cff, cfg\n    (x + y, x - y, x + y)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> R, x, y, z = ring(\"x, y, z\", ZZ)\n\n    >>> f = x*z**2 - y*z**2\n    >>> g = x**2*z + z\n\n    >>> h, cff, cfg = modgcd_multivariate(f, g)\n    >>> h, cff, cfg\n    (z, x*z - y*z, x**2 + 1)\n\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    References\n    ==========\n\n    1. [Monagan00]_\n    2. [Brown71]_\n\n    See also\n    ========\n\n    _modgcd_multivariate_p\n\n    ",
    "section": "Modular GCD",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "_modgcd_multivariate_p",
    "full_id": "sympy.polys.modulargcd._modgcd_multivariate_p",
    "type": "function",
    "description": "\n    Compute the GCD of two polynomials in\n    `\\mathbb{Z}_p[x_0, \\ldots, x_{k-1}]`.\n\n    The algorithm reduces the problem step by step by evaluating the\n    polynomials `f` and `g` at `x_{k-1} = a` for suitable\n    `a \\in \\mathbb{Z}_p` and then calls itself recursively to compute the GCD\n    in `\\mathbb{Z}_p[x_0, \\ldots, x_{k-2}]`. If these recursive calls are\n    successful for enough evaluation points, the GCD in `k` variables is\n    interpolated, otherwise the algorithm returns ``None``. Every time a GCD\n    or a content is computed, their degrees are compared with the bounds. If\n    a degree greater then the bound is encountered, then the current call\n    returns ``None`` and a new evaluation point has to be chosen. If at some\n    point the degree is smaller, the correspondent bound is updated and the\n    algorithm fails.\n\n    Parameters\n    ==========\n\n    f : PolyElement\n        multivariate integer polynomial with coefficients in `\\mathbb{Z}_p`\n    g : PolyElement\n        multivariate integer polynomial with coefficients in `\\mathbb{Z}_p`\n    p : Integer\n        prime number, modulus of `f` and `g`\n    degbound : list of Integer objects\n        ``degbound[i]`` is an upper bound for the degree of the GCD of `f`\n        and `g` in the variable `x_i`\n    contbound : list of Integer objects\n        ``contbound[i]`` is an upper bound for the degree of the content of\n        the GCD in `\\mathbb{Z}_p[x_i][x_0, \\ldots, x_{i-1}]`,\n        ``contbound[0]`` is not used can therefore be chosen\n        arbitrarily.\n\n    Returns\n    =======\n\n    h : PolyElement\n        GCD of the polynomials `f` and `g` or ``None``\n\n    References\n    ==========\n\n    1. [Monagan00]_\n    2. [Brown71]_\n\n    ",
    "section": "Modular GCD",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "func_field_modgcd",
    "full_id": "sympy.polys.modulargcd.func_field_modgcd",
    "type": "function",
    "description": "\n    Compute the GCD of two polynomials `f` and `g` in\n    `\\mathbb Q(\\alpha)[x_0, \\ldots, x_{n-1}]` using a modular algorithm.\n\n    The algorithm first computes the primitive associate\n    `\\check m_{\\alpha}(z)` of the minimal polynomial `m_{\\alpha}` in\n    `\\mathbb{Z}[z]` and the primitive associates of `f` and `g` in\n    `\\mathbb{Z}[x_1, \\ldots, x_{n-1}][z]/(\\check m_{\\alpha})[x_0]`. Then it\n    computes the GCD in\n    `\\mathbb Q(x_1, \\ldots, x_{n-1})[z]/(m_{\\alpha}(z))[x_0]`.\n    This is done by calculating the GCD in\n    `\\mathbb{Z}_p(x_1, \\ldots, x_{n-1})[z]/(\\check m_{\\alpha}(z))[x_0]` for\n    suitable primes `p` and then reconstructing the coefficients with the\n    Chinese Remainder Theorem and Rational Reconstuction. The GCD over\n    `\\mathbb{Z}_p(x_1, \\ldots, x_{n-1})[z]/(\\check m_{\\alpha}(z))[x_0]` is\n    computed with a recursive subroutine, which evaluates the polynomials at\n    `x_{n-1} = a` for suitable evaluation points `a \\in \\mathbb Z_p` and\n    then calls itself recursively until the ground domain does no longer\n    contain any parameters. For\n    `\\mathbb{Z}_p[z]/(\\check m_{\\alpha}(z))[x_0]` the Euclidean Algorithm is\n    used. The results of those recursive calls are then interpolated and\n    Rational Function Reconstruction is used to obtain the correct\n    coefficients. The results, both in\n    `\\mathbb Q(x_1, \\ldots, x_{n-1})[z]/(m_{\\alpha}(z))[x_0]` and\n    `\\mathbb{Z}_p(x_1, \\ldots, x_{n-1})[z]/(\\check m_{\\alpha}(z))[x_0]`, are\n    verified by a fraction free trial division.\n\n    Apart from the above GCD computation some GCDs in\n    `\\mathbb Q(\\alpha)[x_1, \\ldots, x_{n-1}]` have to be calculated,\n    because treating the polynomials as univariate ones can result in\n    a spurious content of the GCD. For this ``func_field_modgcd`` is\n    called recursively.\n\n    Parameters\n    ==========\n\n    f, g : PolyElement\n        polynomials in `\\mathbb Q(\\alpha)[x_0, \\ldots, x_{n-1}]`\n\n    Returns\n    =======\n\n    h : PolyElement\n        monic GCD of the polynomials `f` and `g`\n    cff : PolyElement\n        cofactor of `f`, i.e. `\\frac f h`\n    cfg : PolyElement\n        cofactor of `g`, i.e. `\\frac g h`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.modulargcd import func_field_modgcd\n    >>> from sympy.polys import AlgebraicField, QQ, ring\n    >>> from sympy import sqrt\n\n    >>> A = AlgebraicField(QQ, sqrt(2))\n    >>> R, x = ring('x', A)\n\n    >>> f = x**2 - 2\n    >>> g = x + sqrt(2)\n\n    >>> h, cff, cfg = func_field_modgcd(f, g)\n\n    >>> h == x + sqrt(2)\n    True\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> R, x, y = ring('x, y', A)\n\n    >>> f = x**2 + 2*sqrt(2)*x*y + 2*y**2\n    >>> g = x + sqrt(2)*y\n\n    >>> h, cff, cfg = func_field_modgcd(f, g)\n\n    >>> h == x + sqrt(2)*y\n    True\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    >>> f = x + sqrt(2)*y\n    >>> g = x + y\n\n    >>> h, cff, cfg = func_field_modgcd(f, g)\n\n    >>> h == R.one\n    True\n    >>> cff * h == f\n    True\n    >>> cfg * h == g\n    True\n\n    References\n    ==========\n\n    1. [Hoeij04]_\n\n    ",
    "section": "Modular GCD",
    "url": "https://docs.sympy.org/latest/modules/polys/internals.html"
  },
  {
    "name": "rs_log",
    "full_id": "sympy.polys.ring_series.rs_log",
    "type": "function",
    "description": "\n    The Logarithm of ``p`` modulo ``O(x**prec)``.\n\n    Notes\n    =====\n\n    Truncation of ``integral dx p**-1*d p/dx`` is used.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_log\n    >>> R, x = ring('x', QQ)\n    >>> rs_log(1 + x, x, 8)\n    1/7*x**7 - 1/6*x**6 + 1/5*x**5 - 1/4*x**4 + 1/3*x**3 - 1/2*x**2 + x\n    >>> rs_log(x**QQ(3, 2) + 1, x, 5)\n    1/3*x**(9/2) - 1/2*x**3 + x**(3/2)\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_LambertW",
    "full_id": "sympy.polys.ring_series.rs_LambertW",
    "type": "function",
    "description": "\n    Calculate the series expansion of the principal branch of the Lambert W\n    function.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_LambertW\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_LambertW(x + x*y, x, 3)\n    -x**2*y**2 - 2*x**2*y - x**2 + x*y + x\n\n    See Also\n    ========\n\n    LambertW\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_exp",
    "full_id": "sympy.polys.ring_series.rs_exp",
    "type": "function",
    "description": "\n    Exponentiation of a series modulo ``O(x**prec)``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_exp\n    >>> R, x = ring('x', QQ)\n    >>> rs_exp(x**2, x, 7)\n    1/6*x**6 + 1/2*x**4 + x**2 + 1\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_atan",
    "full_id": "sympy.polys.ring_series.rs_atan",
    "type": "function",
    "description": "\n    The arctangent of a series\n\n    Return the series expansion of the atan of ``p``, about 0.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_atan\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_atan(x + x*y, x, 4)\n    -1/3*x**3*y**3 - x**3*y**2 - x**3*y - 1/3*x**3 + x*y + x\n\n    See Also\n    ========\n\n    atan\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_asin",
    "full_id": "sympy.polys.ring_series.rs_asin",
    "type": "function",
    "description": "\n    Arcsine of a series\n\n    Return the series expansion of the asin of ``p``, about 0.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_asin\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_asin(x, x, 8)\n    5/112*x**7 + 3/40*x**5 + 1/6*x**3 + x\n\n    See Also\n    ========\n\n    asin\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_tan",
    "full_id": "sympy.polys.ring_series.rs_tan",
    "type": "function",
    "description": "\n     Tangent of a series.\n\n     Return the series expansion of the tan of ``p``, about 0.\n\n     Examples\n     ========\n\n     >>> from sympy.polys.domains import QQ\n     >>> from sympy.polys.rings import ring\n     >>> from sympy.polys.ring_series import rs_tan\n     >>> R, x, y = ring('x, y', QQ)\n     >>> rs_tan(x + x*y, x, 4)\n     1/3*x**3*y**3 + x**3*y**2 + x**3*y + 1/3*x**3 + x*y + x\n\n    See Also\n    ========\n\n    _tan1, tan\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "_tan1",
    "full_id": "sympy.polys.ring_series._tan1",
    "type": "function",
    "description": "\n    Helper function of :func:`rs_tan`.\n\n    Return the series expansion of tan of a univariate series using Newton's\n    method. It takes advantage of the fact that series expansion of atan is\n    easier than that of tan.\n\n    Consider `f(x) = y - \\arctan(x)`\n    Let r be a root of f(x) found using Newton's method.\n    Then `f(r) = 0`\n    Or `y = \\arctan(x)` where `x = \\tan(y)` as required.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_cot",
    "full_id": "sympy.polys.ring_series.rs_cot",
    "type": "function",
    "description": "\n    Cotangent of a series\n\n    Return the series expansion of the cot of ``p``, about 0.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_cot\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_cot(x, x, 6)\n    -2/945*x**5 - 1/45*x**3 - 1/3*x + x**(-1)\n\n    See Also\n    ========\n\n    cot\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_sin",
    "full_id": "sympy.polys.ring_series.rs_sin",
    "type": "function",
    "description": "\n    Sine of a series\n\n    Return the series expansion of the sin of ``p``, about 0.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_sin\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_sin(x + x*y, x, 4)\n    -1/6*x**3*y**3 - 1/2*x**3*y**2 - 1/2*x**3*y - 1/6*x**3 + x*y + x\n    >>> rs_sin(x**QQ(3, 2) + x*y**QQ(7, 5), x, 4)\n    -1/2*x**(7/2)*y**(14/5) - 1/6*x**3*y**(21/5) + x**(3/2) + x*y**(7/5)\n\n    See Also\n    ========\n\n    sin\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_cos",
    "full_id": "sympy.polys.ring_series.rs_cos",
    "type": "function",
    "description": "\n    Cosine of a series\n\n    Return the series expansion of the cos of ``p``, about 0.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_cos\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_cos(x + x*y, x, 4)\n    -1/2*x**2*y**2 - x**2*y - 1/2*x**2 + 1\n    >>> rs_cos(x + x*y, x, 4)/x**QQ(7, 5)\n    -1/2*x**(3/5)*y**2 - x**(3/5)*y - 1/2*x**(3/5) + x**(-7/5)\n\n    See Also\n    ========\n\n    cos\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_cos_sin",
    "full_id": "sympy.polys.ring_series.rs_cos_sin",
    "type": "function",
    "description": "\n    Return the tuple ``(rs_cos(p, x, prec)`, `rs_sin(p, x, prec))``.\n\n    Is faster than calling rs_cos and rs_sin separately\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_atanh",
    "full_id": "sympy.polys.ring_series.rs_atanh",
    "type": "function",
    "description": "\n    Hyperbolic arctangent of a series\n\n    Return the series expansion of the atanh of ``p``, about 0.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_atanh\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_atanh(x + x*y, x, 4)\n    1/3*x**3*y**3 + x**3*y**2 + x**3*y + 1/3*x**3 + x*y + x\n\n    See Also\n    ========\n\n    atanh\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_sinh",
    "full_id": "sympy.polys.ring_series.rs_sinh",
    "type": "function",
    "description": "\n    Hyperbolic sine of a series\n\n    Return the series expansion of the sinh of ``p``, about 0.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_sinh\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_sinh(x + x*y, x, 4)\n    1/6*x**3*y**3 + 1/2*x**3*y**2 + 1/2*x**3*y + 1/6*x**3 + x*y + x\n\n    See Also\n    ========\n\n    sinh\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_cosh",
    "full_id": "sympy.polys.ring_series.rs_cosh",
    "type": "function",
    "description": "\n    Hyperbolic cosine of a series\n\n    Return the series expansion of the cosh of ``p``, about 0.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_cosh\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_cosh(x + x*y, x, 4)\n    1/2*x**2*y**2 + x**2*y + 1/2*x**2 + 1\n\n    See Also\n    ========\n\n    cosh\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_tanh",
    "full_id": "sympy.polys.ring_series.rs_tanh",
    "type": "function",
    "description": "\n    Hyperbolic tangent of a series\n\n    Return the series expansion of the tanh of ``p``, about 0.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_tanh\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_tanh(x + x*y, x, 4)\n    -1/3*x**3*y**3 - x**3*y**2 - x**3*y - 1/3*x**3 + x*y + x\n\n    See Also\n    ========\n\n    tanh\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_hadamard_exp",
    "full_id": "sympy.polys.ring_series.rs_hadamard_exp",
    "type": "function",
    "description": "\n    Return ``sum f_i/i!*x**i`` from ``sum f_i*x**i``,\n    where ``x`` is the first variable.\n\n    If ``invers=True`` return ``sum f_i*i!*x**i``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_hadamard_exp\n    >>> R, x = ring('x', QQ)\n    >>> p = 1 + x + x**2 + x**3\n    >>> rs_hadamard_exp(p)\n    1/6*x**3 + 1/2*x**2 + x + 1\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_mul",
    "full_id": "sympy.polys.ring_series.rs_mul",
    "type": "function",
    "description": "\n    Return the product of the given two series, modulo ``O(x**prec)``.\n\n    ``x`` is the series variable or its position in the generators.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_mul\n    >>> R, x = ring('x', QQ)\n    >>> p1 = x**2 + 2*x + 1\n    >>> p2 = x + 1\n    >>> rs_mul(p1, p2, x, 3)\n    3*x**2 + 3*x + 1\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_square",
    "full_id": "sympy.polys.ring_series.rs_square",
    "type": "function",
    "description": "\n    Square the series modulo ``O(x**prec)``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_square\n    >>> R, x = ring('x', QQ)\n    >>> p = x**2 + 2*x + 1\n    >>> rs_square(p, x, 3)\n    6*x**2 + 4*x + 1\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_pow",
    "full_id": "sympy.polys.ring_series.rs_pow",
    "type": "function",
    "description": "\n    Return ``p1**n`` modulo ``O(x**prec)``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_pow\n    >>> R, x = ring('x', QQ)\n    >>> p = x + 1\n    >>> rs_pow(p, 4, x, 3)\n    6*x**2 + 4*x + 1\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_series_inversion",
    "full_id": "sympy.polys.ring_series.rs_series_inversion",
    "type": "function",
    "description": "\n    Multivariate series inversion ``1/p`` modulo ``O(x**prec)``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_series_inversion\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_series_inversion(1 + x*y**2, x, 4)\n    -x**3*y**6 + x**2*y**4 - x*y**2 + 1\n    >>> rs_series_inversion(1 + x*y**2, y, 4)\n    -x*y**2 + 1\n    >>> rs_series_inversion(x + x**2, x, 4)\n    x**3 - x**2 + x - 1 + x**(-1)\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_series_reversion",
    "full_id": "sympy.polys.ring_series.rs_series_reversion",
    "type": "function",
    "description": "\n    Reversion of a series.\n\n    ``p`` is a series with ``O(x**n)`` of the form $p = ax + f(x)$\n    where $a$ is a number different from 0.\n\n    $f(x) = \\sum_{k=2}^{n-1} a_kx_k$\n\n    Parameters\n    ==========\n\n      a_k : Can depend polynomially on other variables, not indicated.\n      x : Variable with name x.\n      y : Variable with name y.\n\n    Returns\n    =======\n\n    Solve $p = y$, that is, given $ax + f(x) - y = 0$,\n    find the solution $x = r(y)$ up to $O(y^n)$.\n\n    Algorithm\n    =========\n\n    If $r_i$ is the solution at order $i$, then:\n    $ar_i + f(r_i) - y = O\\left(y^{i + 1}\\right)$\n\n    and if $r_{i + 1}$ is the solution at order $i + 1$, then:\n    $ar_{i + 1} + f(r_{i + 1}) - y = O\\left(y^{i + 2}\\right)$\n\n    We have, $r_{i + 1} = r_i + e$, such that,\n    $ae + f(r_i) = O\\left(y^{i + 2}\\right)$\n    or $e = -f(r_i)/a$\n\n    So we use the recursion relation:\n    $r_{i + 1} = r_i - f(r_i)/a$\n    with the boundary condition: $r_1 = y$\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_series_reversion, rs_trunc\n    >>> R, x, y, a, b = ring('x, y, a, b', QQ)\n    >>> p = x - x**2 - 2*b*x**2 + 2*a*b*x**2\n    >>> p1 = rs_series_reversion(p, x, 3, y); p1\n    -2*y**2*a*b + 2*y**2*b + y**2 + y\n    >>> rs_trunc(p.compose(x, p1), y, 3)\n    y\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_nth_root",
    "full_id": "sympy.polys.ring_series.rs_nth_root",
    "type": "function",
    "description": "\n    Multivariate series expansion of the nth root of ``p``.\n\n    Parameters\n    ==========\n\n    p : Expr\n        The polynomial to computer the root of.\n    n : integer\n        The order of the root to be computed.\n    x : :class:`~.PolyElement`\n    prec : integer\n        Order of the expanded series.\n\n    Notes\n    =====\n\n    The result of this function is dependent on the ring over which the\n    polynomial has been defined. If the answer involves a root of a constant,\n    make sure that the polynomial is over a real field. It cannot yet handle\n    roots of symbols.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ, RR\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_nth_root\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_nth_root(1 + x + x*y, -3, x, 3)\n    2/9*x**2*y**2 + 4/9*x**2*y + 2/9*x**2 - 1/3*x*y - 1/3*x + 1\n    >>> R, x, y = ring('x, y', RR)\n    >>> rs_nth_root(3 + x + x*y, 3, x, 2)\n    0.160249952256379*x*y + 0.160249952256379*x + 1.44224957030741\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_trunc",
    "full_id": "sympy.polys.ring_series.rs_trunc",
    "type": "function",
    "description": "\n    Truncate the series in the ``x`` variable with precision ``prec``,\n    that is, modulo ``O(x**prec)``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_trunc\n    >>> R, x = ring('x', QQ)\n    >>> p = x**10 + x**5 + x + 1\n    >>> rs_trunc(p, x, 12)\n    x**10 + x**5 + x + 1\n    >>> rs_trunc(p, x, 10)\n    x**5 + x + 1\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_subs",
    "full_id": "sympy.polys.ring_series.rs_subs",
    "type": "function",
    "description": "\n    Substitution with truncation according to the mapping in ``rules``.\n\n    Return a series with precision ``prec`` in the generator ``x``\n\n    Note that substitutions are not done one after the other\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_subs\n    >>> R, x, y = ring('x, y', QQ)\n    >>> p = x**2 + y**2\n    >>> rs_subs(p, {x: x+ y, y: x+ 2*y}, x, 3)\n    2*x**2 + 6*x*y + 5*y**2\n    >>> (x + y)**2 + (x + 2*y)**2\n    2*x**2 + 6*x*y + 5*y**2\n\n    which differs from\n\n    >>> rs_subs(rs_subs(p, {x: x+ y}, x, 3), {y: x+ 2*y}, x, 3)\n    5*x**2 + 12*x*y + 8*y**2\n\n    Parameters\n    ----------\n    p : :class:`~.PolyElement` Input series.\n    rules : ``dict`` with substitution mappings.\n    x : :class:`~.PolyElement` in which the series truncation is to be done.\n    prec : :class:`~.Integer` order of the series after truncation.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_subs\n    >>> R, x, y = ring('x, y', QQ)\n    >>> rs_subs(x**2+y**2, {y: (x+y)**2}, x, 3)\n     6*x**2*y**2 + x**2 + 4*x*y**3 + y**4\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_diff",
    "full_id": "sympy.polys.ring_series.rs_diff",
    "type": "function",
    "description": "\n    Return partial derivative of ``p`` with respect to ``x``.\n\n    Parameters\n    ==========\n\n    x : :class:`~.PolyElement` with respect to which ``p`` is differentiated.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_diff\n    >>> R, x, y = ring('x, y', QQ)\n    >>> p = x + x**2*y**3\n    >>> rs_diff(p, x)\n    2*x*y**3 + 1\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_integrate",
    "full_id": "sympy.polys.ring_series.rs_integrate",
    "type": "function",
    "description": "\n    Integrate ``p`` with respect to ``x``.\n\n    Parameters\n    ==========\n\n    x : :class:`~.PolyElement` with respect to which ``p`` is integrated.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_integrate\n    >>> R, x, y = ring('x, y', QQ)\n    >>> p = x + x**2*y**3\n    >>> rs_integrate(p, x)\n    1/3*x**3*y**3 + 1/2*x**2\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_newton",
    "full_id": "sympy.polys.ring_series.rs_newton",
    "type": "function",
    "description": "\n    Compute the truncated Newton sum of the polynomial ``p``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_newton\n    >>> R, x = ring('x', QQ)\n    >>> p = x**2 - 2\n    >>> rs_newton(p, x, 5)\n    8*x**4 + 4*x**2 + 2\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_compose_add",
    "full_id": "sympy.polys.ring_series.rs_compose_add",
    "type": "function",
    "description": "\n    compute the composed sum ``prod(p2(x - beta) for beta root of p1)``\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_compose_add\n    >>> R, x = ring('x', QQ)\n    >>> f = x**2 - 2\n    >>> g = x**2 - 3\n    >>> rs_compose_add(f, g)\n    x**4 - 10*x**2 + 1\n\n    References\n    ==========\n\n    .. [1] A. Bostan, P. Flajolet, B. Salvy and E. Schost\n           \"Fast Computation with Two Algebraic Numbers\",\n           (2002) Research Report 4579, Institut\n           National de Recherche en Informatique et en Automatique\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_is_puiseux",
    "full_id": "sympy.polys.ring_series.rs_is_puiseux",
    "type": "function",
    "description": "\n    Test if ``p`` is Puiseux series in ``x``.\n\n    Raise an exception if it has a negative power in ``x``.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_is_puiseux\n    >>> R, x = ring('x', QQ)\n    >>> p = x**QQ(2,5) + x**QQ(2,3) + x\n    >>> rs_is_puiseux(p, x)\n    True\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_puiseux",
    "full_id": "sympy.polys.ring_series.rs_puiseux",
    "type": "function",
    "description": "\n    Return the puiseux series for `f(p, x, prec)`.\n\n    To be used when function ``f`` is implemented only for regular series.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_puiseux, rs_exp\n    >>> R, x = ring('x', QQ)\n    >>> p = x**QQ(2,5) + x**QQ(2,3) + x\n    >>> rs_puiseux(rs_exp,p, x, 1)\n    1/2*x**(4/5) + x**(2/3) + x**(2/5) + 1\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_puiseux2",
    "full_id": "sympy.polys.ring_series.rs_puiseux2",
    "type": "function",
    "description": "\n    Return the puiseux series for `f(p, q, x, prec)`.\n\n    To be used when function ``f`` is implemented only for regular series.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_series_from_list",
    "full_id": "sympy.polys.ring_series.rs_series_from_list",
    "type": "function",
    "description": "\n    Return a series `sum c[n]*p**n` modulo `O(x**prec)`.\n\n    It reduces the number of multiplications by summing concurrently.\n\n    `ax = [1, p, p**2, .., p**(J - 1)]`\n    `s = sum(c[i]*ax[i]` for i in `range(r, (r + 1)*J))*p**((K - 1)*J)`\n    with `K >= (n + 1)/J`\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_series_from_list, rs_trunc\n    >>> R, x = ring('x', QQ)\n    >>> p = x**2 + x + 1\n    >>> c = [1, 2, 3]\n    >>> rs_series_from_list(p, c, x, 4)\n    6*x**3 + 11*x**2 + 8*x + 6\n    >>> rs_trunc(1 + 2*p + 3*p**2, x, 4)\n    6*x**3 + 11*x**2 + 8*x + 6\n    >>> pc = R.from_list(list(reversed(c)))\n    >>> rs_trunc(pc.compose(x, p), x, 4)\n    6*x**3 + 11*x**2 + 8*x + 6\n\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "rs_fun",
    "full_id": "sympy.polys.ring_series.rs_fun",
    "type": "function",
    "description": "\n    Function of a multivariate series computed by substitution.\n\n    The case with f method name is used to compute `rs\\_tan` and `rs\\_nth\\_root`\n    of a multivariate series:\n\n        `rs\\_fun(p, tan, iv, prec)`\n\n        tan series is first computed for a dummy variable _x,\n        i.e, `rs\\_tan(\\_x, iv, prec)`. Then we substitute _x with p to get the\n        desired series\n\n    Parameters\n    ==========\n\n    p : :class:`~.PolyElement` The multivariate series to be expanded.\n    f : `ring\\_series` function to be applied on `p`.\n    args[-2] : :class:`~.PolyElement` with respect to which, the series is to be expanded.\n    args[-1] : Required order of the expanded series.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import rs_fun, _tan1\n    >>> R, x, y = ring('x, y', QQ)\n    >>> p = x + x*y + x**2*y + x**3*y**2\n    >>> rs_fun(p, _tan1, x, 4)\n    1/3*x**3*y**3 + 2*x**3*y**2 + x**3*y + 1/3*x**3 + x**2*y + x*y + x\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "mul_xin",
    "full_id": "sympy.polys.ring_series.mul_xin",
    "type": "function",
    "description": "\n    Return `p*x_i**n`.\n\n    `x\\_i` is the ith variable in ``p``.\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "pow_xin",
    "full_id": "sympy.polys.ring_series.pow_xin",
    "type": "function",
    "description": "\n    >>> from sympy.polys.domains import QQ\n    >>> from sympy.polys.rings import ring\n    >>> from sympy.polys.ring_series import pow_xin\n    >>> R, x, y = ring('x, y', QQ)\n    >>> p = x**QQ(2,5) + x + x**QQ(2,3)\n    >>> index = p.ring.gens.index(x)\n    >>> pow_xin(p, index, 15)\n    x**15 + x**10 + x**6\n    ",
    "section": "Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/ringseries.html"
  },
  {
    "name": "solve_lin_sys",
    "full_id": "sympy.polys.solvers.solve_lin_sys",
    "type": "function",
    "description": "Solve a system of linear equations from a PolynomialRing\n\n    Explanation\n    ===========\n\n    Solves a system of linear equations given as PolyElement instances of a\n    PolynomialRing. The basic arithmetic is carried out using instance of\n    DomainElement which is more efficient than :class:`~sympy.core.expr.Expr`\n    for the most common inputs.\n\n    While this is a public function it is intended primarily for internal use\n    so its interface is not necessarily convenient. Users are suggested to use\n    the :func:`sympy.solvers.solveset.linsolve` function (which uses this\n    function internally) instead.\n\n    Parameters\n    ==========\n\n    eqs: list[PolyElement]\n        The linear equations to be solved as elements of a\n        PolynomialRing (assumed equal to zero).\n    ring: PolynomialRing\n        The polynomial ring from which eqs are drawn. The generators of this\n        ring are the unknowns to be solved for and the domain of the ring is\n        the domain of the coefficients of the system of equations.\n    _raw: bool\n        If *_raw* is False, the keys and values in the returned dictionary\n        will be of type Expr (and the unit of the field will be removed from\n        the keys) otherwise the low-level polys types will be returned, e.g.\n        PolyElement: PythonRational.\n\n    Returns\n    =======\n\n    ``None`` if the system has no solution.\n\n    dict[Symbol, Expr] if _raw=False\n\n    dict[Symbol, DomainElement] if _raw=True.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.polys.solvers import solve_lin_sys, sympy_eqs_to_ring\n    >>> x, y = symbols('x, y')\n    >>> eqs = [x - y, x + y - 2]\n    >>> eqs_ring, ring = sympy_eqs_to_ring(eqs, [x, y])\n    >>> solve_lin_sys(eqs_ring, ring)\n    {y: 1, x: 1}\n\n    Passing ``_raw=False`` returns the same result except that the keys are\n    ``Expr`` rather than low-level poly types.\n\n    >>> solve_lin_sys(eqs_ring, ring, _raw=False)\n    {x: 1, y: 1}\n\n    See also\n    ========\n\n    sympy_eqs_to_ring: prepares the inputs to ``solve_lin_sys``.\n    linsolve: ``linsolve`` uses ``solve_lin_sys`` internally.\n    sympy.solvers.solvers.solve: ``solve`` uses ``solve_lin_sys`` internally.\n    ",
    "section": "Poly solvers",
    "url": "https://docs.sympy.org/latest/modules/polys/solvers.html"
  },
  {
    "name": "eqs_to_matrix",
    "full_id": "sympy.polys.solvers.eqs_to_matrix",
    "type": "function",
    "description": "Get matrix from linear equations in dict format.\n\n    Explanation\n    ===========\n\n    Get the matrix representation of a system of linear equations represented\n    as dicts with low-level DomainElement coefficients. This is an\n    *internal* function that is used by solve_lin_sys.\n\n    Parameters\n    ==========\n\n    eqs_coeffs: list[dict[Symbol, DomainElement]]\n        The left hand sides of the equations as dicts mapping from symbols to\n        coefficients where the coefficients are instances of\n        DomainElement.\n    eqs_rhs: list[DomainElements]\n        The right hand sides of the equations as instances of\n        DomainElement.\n    gens: list[Symbol]\n        The unknowns in the system of equations.\n    domain: Domain\n        The domain for coefficients of both lhs and rhs.\n\n    Returns\n    =======\n\n    The augmented matrix representation of the system as a DomainMatrix.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols, ZZ\n    >>> from sympy.polys.solvers import eqs_to_matrix\n    >>> x, y = symbols('x, y')\n    >>> eqs_coeff = [{x:ZZ(1), y:ZZ(1)}, {x:ZZ(1), y:ZZ(-1)}]\n    >>> eqs_rhs = [ZZ(0), ZZ(-1)]\n    >>> eqs_to_matrix(eqs_coeff, eqs_rhs, [x, y], ZZ)\n    DomainMatrix([[1, 1, 0], [1, -1, 1]], (2, 3), ZZ)\n\n    See also\n    ========\n\n    solve_lin_sys: Uses :func:`~eqs_to_matrix` internally\n    ",
    "section": "Poly solvers",
    "url": "https://docs.sympy.org/latest/modules/polys/solvers.html"
  },
  {
    "name": "sympy_eqs_to_ring",
    "full_id": "sympy.polys.solvers.sympy_eqs_to_ring",
    "type": "function",
    "description": "Convert a system of equations from Expr to a PolyRing\n\n    Explanation\n    ===========\n\n    High-level functions like ``solve`` expect Expr as inputs but can use\n    ``solve_lin_sys`` internally. This function converts equations from\n    ``Expr`` to the low-level poly types used by the ``solve_lin_sys``\n    function.\n\n    Parameters\n    ==========\n\n    eqs: List of Expr\n        A list of equations as Expr instances\n    symbols: List of Symbol\n        A list of the symbols that are the unknowns in the system of\n        equations.\n\n    Returns\n    =======\n\n    Tuple[List[PolyElement], Ring]: The equations as PolyElement instances\n    and the ring of polynomials within which each equation is represented.\n\n    Examples\n    ========\n\n    >>> from sympy import symbols\n    >>> from sympy.polys.solvers import sympy_eqs_to_ring\n    >>> a, x, y = symbols('a, x, y')\n    >>> eqs = [x-y, x+a*y]\n    >>> eqs_ring, ring = sympy_eqs_to_ring(eqs, [x, y])\n    >>> eqs_ring\n    [x - y, x + a*y]\n    >>> type(eqs_ring[0])\n    <class 'sympy.polys.rings.PolyElement'>\n    >>> ring\n    ZZ(a)[x,y]\n\n    With the equations in this form they can be passed to ``solve_lin_sys``:\n\n    >>> from sympy.polys.solvers import solve_lin_sys\n    >>> solve_lin_sys(eqs_ring, ring)\n    {y: 0, x: 0}\n    ",
    "section": "Poly solvers",
    "url": "https://docs.sympy.org/latest/modules/polys/solvers.html"
  },
  {
    "name": "_solve_lin_sys",
    "full_id": "sympy.polys.solvers._solve_lin_sys",
    "type": "function",
    "description": "Solve a linear system from dict of PolynomialRing coefficients\n\n    Explanation\n    ===========\n\n    This is an **internal** function used by :func:`solve_lin_sys` after the\n    equations have been preprocessed. The role of this function is to split\n    the system into connected components and pass those to\n    :func:`_solve_lin_sys_component`.\n\n    Examples\n    ========\n\n    Setup a system for $x-y=0$ and $x+y=2$ and solve:\n\n    >>> from sympy import symbols, sring\n    >>> from sympy.polys.solvers import _solve_lin_sys\n    >>> x, y = symbols('x, y')\n    >>> R, (xr, yr) = sring([x, y], [x, y])\n    >>> eqs = [{xr:R.one, yr:-R.one}, {xr:R.one, yr:R.one}]\n    >>> eqs_rhs = [R.zero, -2*R.one]\n    >>> _solve_lin_sys(eqs, eqs_rhs, R)\n    {y: 1, x: 1}\n\n    See also\n    ========\n\n    solve_lin_sys: This function is used internally by :func:`solve_lin_sys`.\n    ",
    "section": "Poly solvers",
    "url": "https://docs.sympy.org/latest/modules/polys/solvers.html"
  },
  {
    "name": "_solve_lin_sys_component",
    "full_id": "sympy.polys.solvers._solve_lin_sys_component",
    "type": "function",
    "description": "Solve a linear system from dict of PolynomialRing coefficients\n\n    Explanation\n    ===========\n\n    This is an **internal** function used by :func:`solve_lin_sys` after the\n    equations have been preprocessed. After :func:`_solve_lin_sys` splits the\n    system into connected components this function is called for each\n    component. The system of equations is solved using Gauss-Jordan\n    elimination with division followed by back-substitution.\n\n    Examples\n    ========\n\n    Setup a system for $x-y=0$ and $x+y=2$ and solve:\n\n    >>> from sympy import symbols, sring\n    >>> from sympy.polys.solvers import _solve_lin_sys_component\n    >>> x, y = symbols('x, y')\n    >>> R, (xr, yr) = sring([x, y], [x, y])\n    >>> eqs = [{xr:R.one, yr:-R.one}, {xr:R.one, yr:R.one}]\n    >>> eqs_rhs = [R.zero, -2*R.one]\n    >>> _solve_lin_sys_component(eqs, eqs_rhs, R)\n    {y: 1, x: 1}\n\n    See also\n    ========\n\n    solve_lin_sys: This function is used internally by :func:`solve_lin_sys`.\n    ",
    "section": "Poly solvers",
    "url": "https://docs.sympy.org/latest/modules/polys/solvers.html"
  },
  {
    "name": "DM",
    "full_id": "sympy.polys.matrices.domainmatrix.DM",
    "type": "function",
    "description": "Convenient alias for DomainMatrix.from_list\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DM\n    >>> DM([[1, 2], [3, 4]], ZZ)\n    DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n\n    See Also\n    ========\n\n    DomainMatrix.from_list\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.add",
    "type": "method",
    "description": "\n        Adds two DomainMatrix matrices of the same Domain\n\n        Parameters\n        ==========\n\n        A, B: DomainMatrix\n            matrices to add\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix after Addition\n\n        Raises\n        ======\n\n        DMShapeError\n            If the dimensions of the two DomainMatrix are not equal\n\n        ValueError\n            If the domain of the two DomainMatrix are not same\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> B = DomainMatrix([\n        ...    [ZZ(4), ZZ(3)],\n        ...    [ZZ(2), ZZ(1)]], (2, 2), ZZ)\n\n        >>> A.add(B)\n        DomainMatrix([[5, 5], [5, 5]], (2, 2), ZZ)\n\n        See Also\n        ========\n\n        sub, matmul\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "adj_det",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.adj_det",
    "type": "method",
    "description": "\n        Adjugate and determinant of a square :class:`DomainMatrix`.\n\n        Returns\n        =======\n\n        (adjugate, determinant) : (DomainMatrix, DomainScalar)\n            The adjugate matrix and determinant of this matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([\n        ...     [ZZ(1), ZZ(2)],\n        ...     [ZZ(3), ZZ(4)]], ZZ)\n        >>> adjA, detA = A.adj_det()\n        >>> adjA\n        DomainMatrix([[4, -2], [-3, 1]], (2, 2), ZZ)\n        >>> detA\n        -2\n\n        See Also\n        ========\n\n        adjugate\n            Returns only the adjugate matrix.\n        det\n            Returns only the determinant.\n        inv_den\n            Returns a matrix/denominator pair representing the inverse matrix\n            but perhaps differing from the adjugate and determinant by a common\n            factor.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "adj_poly_det",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.adj_poly_det",
    "type": "method",
    "description": "\n        Return the polynomial $p$ such that $p(A) = adj(A)$ and also the\n        determinant of $A$.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)\n        >>> p, detA = A.adj_poly_det()\n        >>> p\n        [-1, 5]\n        >>> p_A = A.eval_poly(p)\n        >>> p_A\n        DomainMatrix([[4, -2], [-3, 1]], (2, 2), QQ)\n        >>> p[0]*A**1 + p[1]*A**0 == p_A\n        True\n        >>> p_A == A.adjugate()\n        True\n        >>> A * A.adjugate() == detA * A.eye(A.shape, A.domain).to_dense()\n        True\n\n        See Also\n        ========\n\n        adjugate\n        eval_poly\n        adj_det\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "adjugate",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.adjugate",
    "type": "method",
    "description": "\n        Adjugate of a square :class:`DomainMatrix`.\n\n        The adjugate matrix is the transpose of the cofactor matrix and is\n        related to the inverse by::\n\n            adj(A) = det(A) * A.inv()\n\n        Unlike the inverse matrix the adjugate matrix can be computed and\n        expressed without division or fractions in the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n        >>> A.adjugate()\n        DomainMatrix([[4, -2], [-3, 1]], (2, 2), ZZ)\n\n        Returns\n        =======\n\n        DomainMatrix\n            The adjugate matrix of this matrix with the same domain.\n\n        See Also\n        ========\n\n        adj_det\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "cancel_denom",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.cancel_denom",
    "type": "method",
    "description": "\n        Cancel factors between a matrix and a denominator.\n\n        Returns a matrix and denominator on lowest terms.\n\n        Requires ``gcd`` in the ground domain.\n\n        Methods like :meth:`solve_den`, :meth:`inv_den` and :meth:`rref_den`\n        return a matrix and denominator but not necessarily on lowest terms.\n        Reduction to lowest terms without fractions can be performed with\n        :meth:`cancel_denom`.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DM\n        >>> from sympy import ZZ\n        >>> M = DM([[2, 2, 0],\n        ...         [0, 2, 2],\n        ...         [0, 0, 2]], ZZ)\n        >>> Minv, den = M.inv_den()\n        >>> Minv.to_Matrix()\n        Matrix([\n        [1, -1,  1],\n        [0,  1, -1],\n        [0,  0,  1]])\n        >>> den\n        2\n        >>> Minv_reduced, den_reduced = Minv.cancel_denom(den)\n        >>> Minv_reduced.to_Matrix()\n        Matrix([\n        [1, -1,  1],\n        [0,  1, -1],\n        [0,  0,  1]])\n        >>> den_reduced\n        2\n        >>> Minv_reduced.to_field() / den_reduced == Minv.to_field() / den\n        True\n\n        The denominator is made canonical with respect to units (e.g. a\n        negative denominator is made positive):\n\n        >>> M = DM([[2, 2, 0]], ZZ)\n        >>> den = ZZ(-4)\n        >>> M.cancel_denom(den)\n        (DomainMatrix([[-1, -1, 0]], (1, 3), ZZ), 2)\n\n        Any factor common to _all_ elements will be cancelled but there can\n        still be factors in common between _some_ elements of the matrix and\n        the denominator. To cancel factors between each element and the\n        denominator, use :meth:`cancel_denom_elementwise` or otherwise convert\n        to a field and use division:\n\n        >>> M = DM([[4, 6]], ZZ)\n        >>> den = ZZ(12)\n        >>> M.cancel_denom(den)\n        (DomainMatrix([[2, 3]], (1, 2), ZZ), 6)\n        >>> numers, denoms = M.cancel_denom_elementwise(den)\n        >>> numers\n        DomainMatrix([[1, 1]], (1, 2), ZZ)\n        >>> denoms\n        DomainMatrix([[3, 2]], (1, 2), ZZ)\n        >>> M.to_field() / den\n        DomainMatrix([[1/3, 1/2]], (1, 2), QQ)\n\n        See Also\n        ========\n\n        solve_den\n        inv_den\n        rref_den\n        cancel_denom_elementwise\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "cancel_denom_elementwise",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.cancel_denom_elementwise",
    "type": "method",
    "description": "\n        Cancel factors between the elements of a matrix and a denominator.\n\n        Returns a matrix of numerators and matrix of denominators.\n\n        Requires ``gcd`` in the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DM\n        >>> from sympy import ZZ\n        >>> M = DM([[2, 3], [4, 12]], ZZ)\n        >>> denom = ZZ(6)\n        >>> numers, denoms = M.cancel_denom_elementwise(denom)\n        >>> numers.to_Matrix()\n        Matrix([\n        [1, 1],\n        [2, 2]])\n        >>> denoms.to_Matrix()\n        Matrix([\n        [3, 2],\n        [3, 1]])\n        >>> M_frac = (M.to_field() / denom).to_Matrix()\n        >>> M_frac\n        Matrix([\n        [1/3, 1/2],\n        [2/3,   2]])\n        >>> denoms_inverted = denoms.to_Matrix().applyfunc(lambda e: 1/e)\n        >>> numers.to_Matrix().multiply_elementwise(denoms_inverted) == M_frac\n        True\n\n        Use :meth:`cancel_denom` to cancel factors between the matrix and the\n        denominator while preserving the form of a matrix with a scalar\n        denominator.\n\n        See Also\n        ========\n\n        cancel_denom\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "charpoly",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly",
    "type": "method",
    "description": "\n        Characteristic polynomial of a square matrix.\n\n        Computes the characteristic polynomial in a fully expanded form using\n        division free arithmetic. If a factorization of the characteristic\n        polynomial is needed then it is more efficient to call\n        :meth:`charpoly_factor_list` than calling :meth:`charpoly` and then\n        factorizing the result.\n\n        Returns\n        =======\n\n        list: list of DomainElement\n            coefficients of the characteristic polynomial\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n        >>> A.charpoly()\n        [1, -5, -2]\n\n        See Also\n        ========\n\n        charpoly_factor_list\n            Compute the factorisation of the characteristic polynomial.\n        charpoly_factor_blocks\n            A partial factorisation of the characteristic polynomial that can\n            be computed more efficiently than either the full factorisation or\n            the fully expanded polynomial.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "charpoly_base",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_base",
    "type": "method",
    "description": "\n        Base case for :meth:`charpoly_factor_blocks` after block decomposition.\n\n        This method is used internally by :meth:`charpoly_factor_blocks` as the\n        base case for computing the characteristic polynomial of a block. It is\n        more efficient to call :meth:`charpoly_factor_blocks`, :meth:`charpoly`\n        or :meth:`charpoly_factor_list` rather than call this method directly.\n\n        This will use either the dense or the sparse implementation depending\n        on the sparsity of the matrix and will clear denominators if possible\n        before calling :meth:`charpoly_berk` to compute the characteristic\n        polynomial using the Berkowitz algorithm.\n\n        See Also\n        ========\n\n        charpoly\n        charpoly_factor_list\n        charpoly_factor_blocks\n        charpoly_berk\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "charpoly_berk",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_berk",
    "type": "method",
    "description": "Compute the characteristic polynomial using the Berkowitz algorithm.\n\n        This method directly calls the underlying implementation of the\n        Berkowitz algorithm (:meth:`sympy.polys.matrices.dense.ddm_berk` or\n        :meth:`sympy.polys.matrices.sdm.sdm_berk`).\n\n        This is used by :meth:`charpoly` and other methods as the base case for\n        for computing the characteristic polynomial. However those methods will\n        apply other optimizations such as block decomposition, clearing\n        denominators and converting between dense and sparse representations\n        before calling this method. It is more efficient to call those methods\n        instead of this one but this method is provided for direct access to\n        the Berkowitz algorithm.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DM\n        >>> from sympy import QQ\n        >>> M = DM([[6, -1, 0, 0],\n        ...         [9, 12, 0, 0],\n        ...         [0,  0, 1, 2],\n        ...         [0,  0, 5, 6]], QQ)\n        >>> M.charpoly_berk()\n        [1, -25, 203, -495, -324]\n\n        See Also\n        ========\n\n        charpoly\n        charpoly_base\n        charpoly_factor_list\n        charpoly_factor_blocks\n        sympy.polys.matrices.dense.ddm_berk\n        sympy.polys.matrices.sdm.sdm_berk\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "charpoly_factor_blocks",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_factor_blocks",
    "type": "method",
    "description": "\n        Partial factorisation of the characteristic polynomial.\n\n        This factorisation arises from a block structure of the matrix (if any)\n        and so the factors are not guaranteed to be irreducible. The\n        :meth:`charpoly_factor_blocks` method is the most efficient way to get\n        a representation of the characteristic polynomial but the result is\n        neither fully expanded nor fully factored.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DM\n        >>> from sympy import ZZ\n        >>> M = DM([[6, -1, 0, 0],\n        ...         [9, 12, 0, 0],\n        ...         [0,  0, 1, 2],\n        ...         [0,  0, 5, 6]], ZZ)\n\n        This computes a partial factorization using only the block structure of\n        the matrix to reveal factors:\n\n        >>> M.charpoly_factor_blocks()\n        [([1, -18, 81], 1), ([1, -7, -4], 1)]\n\n        These factors correspond to the two diagonal blocks in the matrix:\n\n        >>> DM([[6, -1], [9, 12]], ZZ).charpoly()\n        [1, -18, 81]\n        >>> DM([[1, 2], [5, 6]], ZZ).charpoly()\n        [1, -7, -4]\n\n        Use :meth:`charpoly_factor_list` to get a complete factorization into\n        irreducibles:\n\n        >>> M.charpoly_factor_list()\n        [([1, -9], 2), ([1, -7, -4], 1)]\n\n        Use :meth:`charpoly` to get the expanded characteristic polynomial:\n\n        >>> M.charpoly()\n        [1, -25, 203, -495, -324]\n\n        Returns\n        =======\n\n        list: list of pairs (factor, multiplicity)\n            A partial factorization of the characteristic polynomial.\n\n        See Also\n        ========\n\n        charpoly\n            Compute the fully expanded characteristic polynomial.\n        charpoly_factor_list\n            Compute a full factorization of the characteristic polynomial.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "charpoly_factor_list",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly_factor_list",
    "type": "method",
    "description": "\n        Full factorization of the characteristic polynomial.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DM\n        >>> from sympy import ZZ\n        >>> M = DM([[6, -1, 0, 0],\n        ...         [9, 12, 0, 0],\n        ...         [0,  0, 1, 2],\n        ...         [0,  0, 5, 6]], ZZ)\n\n        Compute the factorization of the characteristic polynomial:\n\n        >>> M.charpoly_factor_list()\n        [([1, -9], 2), ([1, -7, -4], 1)]\n\n        Use :meth:`charpoly` to get the unfactorized characteristic polynomial:\n\n        >>> M.charpoly()\n        [1, -25, 203, -495, -324]\n\n        The same calculations with ``Matrix``:\n\n        >>> M.to_Matrix().charpoly().as_expr()\n        lambda**4 - 25*lambda**3 + 203*lambda**2 - 495*lambda - 324\n        >>> M.to_Matrix().charpoly().as_expr().factor()\n        (lambda - 9)**2*(lambda**2 - 7*lambda - 4)\n\n        Returns\n        =======\n\n        list: list of pairs (factor, multiplicity)\n            A full factorization of the characteristic polynomial.\n\n        See Also\n        ========\n\n        charpoly\n            Expanded form of the characteristic polynomial.\n        charpoly_factor_blocks\n            A partial factorisation of the characteristic polynomial that can\n            be computed more efficiently.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "choose_domain",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.choose_domain",
    "type": "method",
    "description": "Convert to a domain found by :func:`~.construct_domain`.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> M = DM([[1, 2], [3, 4]], ZZ)\n        >>> M\n        DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n        >>> M.choose_domain(field=True)\n        DomainMatrix([[1, 2], [3, 4]], (2, 2), QQ)\n\n        >>> from sympy.abc import x\n        >>> M = DM([[1, x], [x**2, x**3]], ZZ[x])\n        >>> M.choose_domain(field=True).domain\n        ZZ(x)\n\n        Keyword arguments are passed to :func:`~.construct_domain`.\n\n        See Also\n        ========\n\n        construct_domain\n        convert_to\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "clear_denoms",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.clear_denoms",
    "type": "method",
    "description": "\n        Clear denominators, but keep the domain unchanged.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[(1,2), (1,3)], [(1,4), (1,5)]], QQ)\n        >>> den, Anum = A.clear_denoms()\n        >>> den.to_sympy()\n        60\n        >>> Anum.to_Matrix()\n        Matrix([\n        [30, 20],\n        [15, 12]])\n        >>> den * A == Anum\n        True\n\n        The numerator matrix will be in the same domain as the original matrix\n        unless ``convert`` is set to ``True``:\n\n        >>> A.clear_denoms()[1].domain\n        QQ\n        >>> A.clear_denoms(convert=True)[1].domain\n        ZZ\n\n        The denominator is always in the associated ring:\n\n        >>> A.clear_denoms()[0].domain\n        ZZ\n        >>> A.domain.get_ring()\n        ZZ\n\n        See Also\n        ========\n\n        sympy.polys.polytools.Poly.clear_denoms\n        clear_denoms_rowwise\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "clear_denoms_rowwise",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.clear_denoms_rowwise",
    "type": "method",
    "description": "\n        Clear denominators from each row of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[(1,2), (1,3), (1,4)], [(1,5), (1,6), (1,7)]], QQ)\n        >>> den, Anum = A.clear_denoms_rowwise()\n        >>> den.to_Matrix()\n        Matrix([\n        [12,   0],\n        [ 0, 210]])\n        >>> Anum.to_Matrix()\n        Matrix([\n        [ 6,  4,  3],\n        [42, 35, 30]])\n\n        The denominator matrix is a diagonal matrix with the denominators of\n        each row on the diagonal. The invariants are:\n\n        >>> den * A == Anum\n        True\n        >>> A == den.to_field().inv() * Anum\n        True\n\n        The numerator matrix will be in the same domain as the original matrix\n        unless ``convert`` is set to ``True``:\n\n        >>> A.clear_denoms_rowwise()[1].domain\n        QQ\n        >>> A.clear_denoms_rowwise(convert=True)[1].domain\n        ZZ\n\n        The domain of the denominator matrix is the associated ring:\n\n        >>> A.clear_denoms_rowwise()[0].domain\n        ZZ\n\n        See Also\n        ========\n\n        sympy.polys.polytools.Poly.clear_denoms\n        clear_denoms\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "columnspace",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.columnspace",
    "type": "method",
    "description": "\n        Returns the columnspace for the DomainMatrix\n\n        Returns\n        =======\n\n        DomainMatrix\n            The columns of this matrix form a basis for the columnspace.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [QQ(1), QQ(-1)],\n        ...    [QQ(2), QQ(-2)]], (2, 2), QQ)\n        >>> A.columnspace()\n        DomainMatrix([[1], [2]], (2, 1), QQ)\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "content",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.content",
    "type": "method",
    "description": "\n        Return the gcd of the elements of the matrix.\n\n        Requires ``gcd`` in the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DM\n        >>> from sympy import ZZ\n        >>> M = DM([[2, 4], [4, 12]], ZZ)\n        >>> M.content()\n        2\n\n        See Also\n        ========\n\n        primitive\n        cancel_denom\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "convert_to",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.convert_to",
    "type": "method",
    "description": "\n        Change the domain of DomainMatrix to desired domain or field\n\n        Parameters\n        ==========\n\n        K : Represents the desired domain or field.\n            Alternatively, ``None`` may be passed, in which case this method\n            just returns a copy of this DomainMatrix.\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix with the desired domain or field\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ, ZZ_I\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n        >>> A.convert_to(ZZ_I)\n        DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ_I)\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "det",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.det",
    "type": "method",
    "description": "\n        Returns the determinant of a square :class:`DomainMatrix`.\n\n        Returns\n        =======\n\n        determinant: DomainElement\n            Determinant of the matrix.\n\n        Raises\n        ======\n\n        ValueError\n            If the domain of DomainMatrix is not a Field\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n        >>> A.det()\n        -2\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "diag",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.diag",
    "type": "method",
    "description": "\n        Return diagonal matrix with entries from ``diagonal``.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import ZZ\n        >>> DomainMatrix.diag([ZZ(5), ZZ(6)], ZZ)\n        DomainMatrix({0: {0: 5}, 1: {1: 6}}, (2, 2), ZZ)\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "diagonal",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.diagonal",
    "type": "method",
    "description": "\n        Get the diagonal entries of the matrix as a list.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> M = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n        >>> M.diagonal()\n        [1, 4]\n\n        See Also\n        ========\n\n        is_diagonal\n        diag\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "eval_poly",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.eval_poly",
    "type": "method",
    "description": "\n        Evaluate polynomial function of a matrix $p(A)$.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)\n        >>> p = [QQ(1), QQ(2), QQ(3)]\n        >>> p_A = A.eval_poly(p)\n        >>> p_A\n        DomainMatrix([[12, 14], [21, 33]], (2, 2), QQ)\n        >>> p_A == p[0]*A**2 + p[1]*A + p[2]*A**0\n        True\n\n        See Also\n        ========\n\n        eval_poly_mul\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "eval_poly_mul",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.eval_poly_mul",
    "type": "method",
    "description": "\n        Evaluate polynomial matrix product $p(A) \\times B$.\n\n        Evaluate the polynomial matrix product $p(A) \\times B$ using Horner's\n        method without creating the matrix $p(A)$ explicitly. If $B$ is a\n        column matrix then this method will only use matrix-vector multiplies\n        and no matrix-matrix multiplies are needed.\n\n        If $B$ is square or wide or if $A$ can be represented in a simpler\n        domain than $B$ then it might be faster to evaluate $p(A)$ explicitly\n        (see :func:`eval_poly`) and then multiply with $B$.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)\n        >>> b = DM([[QQ(5)], [QQ(6)]], QQ)\n        >>> p = [QQ(1), QQ(2), QQ(3)]\n        >>> p_A_b = A.eval_poly_mul(p, b)\n        >>> p_A_b\n        DomainMatrix([[144], [303]], (2, 1), QQ)\n        >>> p_A_b == p[0]*A**2*b + p[1]*A*b + p[2]*b\n        True\n        >>> A.eval_poly_mul(p, b) == A.eval_poly(p)*b\n        True\n\n        See Also\n        ========\n\n        eval_poly\n        solve_den_charpoly\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "eye",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.eye",
    "type": "method",
    "description": "\n        Return identity matrix of size n or shape (m, n).\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import QQ\n        >>> DomainMatrix.eye(3, QQ)\n        DomainMatrix({0: {0: 1}, 1: {1: 1}, 2: {2: 1}}, (3, 3), QQ)\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_Matrix",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_Matrix",
    "type": "method",
    "description": "\n        Convert Matrix to DomainMatrix\n\n        Parameters\n        ==========\n\n        M: Matrix\n\n        Returns\n        =======\n\n        Returns DomainMatrix with identical elements as M\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> M = Matrix([\n        ...    [1.0, 3.4],\n        ...    [2.4, 1]])\n        >>> A = DomainMatrix.from_Matrix(M)\n        >>> A\n        DomainMatrix({0: {0: 1.0, 1: 3.4}, 1: {0: 2.4, 1: 1.0}}, (2, 2), RR)\n\n        We can keep internal representation as ddm using fmt='dense'\n        >>> from sympy import Matrix, QQ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix.from_Matrix(Matrix([[QQ(1, 2), QQ(3, 4)], [QQ(0, 1), QQ(0, 1)]]), fmt='dense')\n        >>> A.rep\n        [[1/2, 3/4], [0, 0]]\n\n        See Also\n        ========\n\n        Matrix\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dict_sympy",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_dict_sympy",
    "type": "method",
    "description": "\n\n        Parameters\n        ==========\n\n        nrows: number of rows\n        ncols: number of cols\n        elemsdict: dict of dicts containing non-zero elements of the DomainMatrix\n\n        Returns\n        =======\n\n        DomainMatrix containing elements of elemsdict\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy.abc import x,y,z\n        >>> elemsdict = {0: {0:x}, 1:{1: y}, 2: {2: z}}\n        >>> A = DomainMatrix.from_dict_sympy(3, 3, elemsdict)\n        >>> A\n        DomainMatrix({0: {0: x}, 1: {1: y}, 2: {2: z}}, (3, 3), ZZ[x,y,z])\n\n        See Also\n        ========\n\n        from_list_sympy\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dod",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_dod",
    "type": "method",
    "description": "\n        Create sparse :class:`DomainMatrix` from dict of dict (dod) format.\n\n        See :meth:`to_dod` for explanation.\n\n        See Also\n        ========\n\n        to_dod\n        from_dod_like\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dod_like",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_dod_like",
    "type": "method",
    "description": "\n        Create :class:`DomainMatrix` like ``self`` from dict of dict (dod) format.\n\n        See :meth:`to_dod` for explanation.\n\n        See Also\n        ========\n\n        to_dod\n        from_dod\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dok",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_dok",
    "type": "method",
    "description": "\n        Create :class:`DomainMatrix` from dictionary of keys (dok) format.\n\n        See :meth:`to_dok` for explanation.\n\n        See Also\n        ========\n\n        to_dok\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_flat_nz",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_flat_nz",
    "type": "method",
    "description": "\n        Reconstruct :class:`DomainMatrix` after calling :meth:`to_flat_nz`.\n\n        See :meth:`to_flat_nz` for explanation.\n\n        See Also\n        ========\n\n        to_flat_nz\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_list",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_list",
    "type": "method",
    "description": "\n        Convert a list of lists into a DomainMatrix\n\n        Parameters\n        ==========\n\n        rows: list of lists\n            Each element of the inner lists should be either the single arg,\n            or tuple of args, that would be passed to the domain constructor\n            in order to form an element of the domain. See examples.\n\n        Returns\n        =======\n\n        DomainMatrix containing elements defined in rows\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import FF, QQ, ZZ\n        >>> A = DomainMatrix.from_list([[1, 0, 1], [0, 0, 1]], ZZ)\n        >>> A\n        DomainMatrix([[1, 0, 1], [0, 0, 1]], (2, 3), ZZ)\n        >>> B = DomainMatrix.from_list([[1, 0, 1], [0, 0, 1]], FF(7))\n        >>> B\n        DomainMatrix([[1 mod 7, 0 mod 7, 1 mod 7], [0 mod 7, 0 mod 7, 1 mod 7]], (2, 3), GF(7))\n        >>> C = DomainMatrix.from_list([[(1, 2), (3, 1)], [(1, 4), (5, 1)]], QQ)\n        >>> C\n        DomainMatrix([[1/2, 3], [1/4, 5]], (2, 2), QQ)\n\n        See Also\n        ========\n\n        from_list_sympy\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_list_flat",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_list_flat",
    "type": "method",
    "description": "\n        Create :class:`DomainMatrix` from flat list.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> element_list = [ZZ(1), ZZ(2), ZZ(3), ZZ(4)]\n        >>> A = DomainMatrix.from_list_flat(element_list, (2, 2), ZZ)\n        >>> A\n        DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n        >>> A == A.from_list_flat(A.to_list_flat(), A.shape, A.domain)\n        True\n\n        See Also\n        ========\n\n        to_list_flat\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_list_sympy",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_list_sympy",
    "type": "method",
    "description": "\n        Convert a list of lists of Expr into a DomainMatrix using construct_domain\n\n        Parameters\n        ==========\n\n        nrows: number of rows\n        ncols: number of columns\n        rows: list of lists\n\n        Returns\n        =======\n\n        DomainMatrix containing elements of rows\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy.abc import x, y, z\n        >>> A = DomainMatrix.from_list_sympy(1, 3, [[x, y, z]])\n        >>> A\n        DomainMatrix([[x, y, z]], (1, 3), ZZ[x,y,z])\n\n        See Also\n        ========\n\n        sympy.polys.constructor.construct_domain, from_dict_sympy\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_rep",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.from_rep",
    "type": "method",
    "description": "Create a new DomainMatrix efficiently from DDM/SDM.\n\n        Examples\n        ========\n\n        Create a :py:class:`~.DomainMatrix` with an dense internal\n        representation as :py:class:`~.DDM`:\n\n        >>> from sympy.polys.domains import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> drep = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> dM = DomainMatrix.from_rep(drep)\n        >>> dM\n        DomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n\n        Create a :py:class:`~.DomainMatrix` with a sparse internal\n        representation as :py:class:`~.SDM`:\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import ZZ\n        >>> drep = SDM({0:{1:ZZ(1)},1:{0:ZZ(2)}}, (2, 2), ZZ)\n        >>> dM = DomainMatrix.from_rep(drep)\n        >>> dM\n        DomainMatrix({0: {1: 1}, 1: {0: 2}}, (2, 2), ZZ)\n\n        Parameters\n        ==========\n\n        rep: SDM or DDM\n            The internal sparse or dense representation of the matrix.\n\n        Returns\n        =======\n\n        DomainMatrix\n            A :py:class:`~.DomainMatrix` wrapping *rep*.\n\n        Notes\n        =====\n\n        This takes ownership of rep as its internal representation. If rep is\n        being mutated elsewhere then a copy should be provided to\n        ``from_rep``. Only minimal verification or checking is done on *rep*\n        as this is supposed to be an efficient internal routine.\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "hstack",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.hstack",
    "type": "method",
    "description": "Horizontally stack the given matrices.\n\n        Parameters\n        ==========\n\n        B: DomainMatrix\n            Matrices to stack horizontally.\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix by stacking horizontally.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n\n        >>> A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> B = DomainMatrix([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)\n        >>> A.hstack(B)\n        DomainMatrix([[1, 2, 5, 6], [3, 4, 7, 8]], (2, 4), ZZ)\n\n        >>> C = DomainMatrix([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)\n        >>> A.hstack(B, C)\n        DomainMatrix([[1, 2, 5, 6, 9, 10], [3, 4, 7, 8, 11, 12]], (2, 6), ZZ)\n\n        See Also\n        ========\n\n        unify\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "inv",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.inv",
    "type": "method",
    "description": "\n        Finds the inverse of the DomainMatrix if exists\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix after inverse\n\n        Raises\n        ======\n\n        ValueError\n            If the domain of DomainMatrix not a Field\n\n        DMNonSquareMatrixError\n            If the DomainMatrix is not a not Square DomainMatrix\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...     [QQ(2), QQ(-1), QQ(0)],\n        ...     [QQ(-1), QQ(2), QQ(-1)],\n        ...     [QQ(0), QQ(0), QQ(2)]], (3, 3), QQ)\n        >>> A.inv()\n        DomainMatrix([[2/3, 1/3, 1/6], [1/3, 2/3, 1/3], [0, 0, 1/2]], (3, 3), QQ)\n\n        See Also\n        ========\n\n        neg\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "inv_den",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.inv_den",
    "type": "method",
    "description": "\n        Return the inverse as a :class:`DomainMatrix` with denominator.\n\n        Returns\n        =======\n\n        (inv, den) : (:class:`DomainMatrix`, :class:`~.DomainElement`)\n            The inverse matrix and its denominator.\n\n        This is more or less equivalent to :meth:`adj_det` except that ``inv``\n        and ``den`` are not guaranteed to be the adjugate and inverse. The\n        ratio ``inv/den`` is equivalent to ``adj/det`` but some factors\n        might be cancelled between ``inv`` and ``den``. In simple cases this\n        might just be a minus sign so that ``(inv, den) == (-adj, -det)`` but\n        factors more complicated than ``-1`` can also be cancelled.\n        Cancellation is not guaranteed to be complete so ``inv`` and ``den``\n        may not be on lowest terms. The denominator ``den`` will be zero if and\n        only if the determinant is zero.\n\n        If the actual adjugate and determinant are needed, use :meth:`adj_det`\n        instead. If the intention is to compute the inverse matrix or solve a\n        system of equations then :meth:`inv_den` is more efficient.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...     [ZZ(2), ZZ(-1), ZZ(0)],\n        ...     [ZZ(-1), ZZ(2), ZZ(-1)],\n        ...     [ZZ(0), ZZ(0), ZZ(2)]], (3, 3), ZZ)\n        >>> Ainv, den = A.inv_den()\n        >>> den\n        6\n        >>> Ainv\n        DomainMatrix([[4, 2, 1], [2, 4, 2], [0, 0, 3]], (3, 3), ZZ)\n        >>> A * Ainv == den * A.eye(A.shape, A.domain).to_dense()\n        True\n\n        Parameters\n        ==========\n\n        method : str, optional\n            The method to use to compute the inverse. Can be one of ``None``,\n            ``'rref'`` or ``'charpoly'``. If ``None`` then the method is\n            chosen automatically (see :meth:`solve_den` for details).\n\n        See Also\n        ========\n\n        inv\n        det\n        adj_det\n        solve_den\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_diagonal",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.is_diagonal",
    "type": "property",
    "description": "\n        True if the matrix is diagonal.\n\n        Can return true for non-square matrices. A matrix is diagonal if\n        ``M[i,j] == 0`` whenever ``i != j``.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> M = DM([[ZZ(1), ZZ(0)], [ZZ(0), ZZ(1)]], ZZ)\n        >>> M.is_diagonal\n        True\n\n        See Also\n        ========\n\n        is_upper\n        is_lower\n        is_square\n        diagonal\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_lower",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.is_lower",
    "type": "property",
    "description": "\n        Says whether this matrix is lower-triangular. True can be returned\n        even if the matrix is not square.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_square",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.is_square",
    "type": "property",
    "description": "\n        True if the matrix is square.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_upper",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.is_upper",
    "type": "property",
    "description": "\n        Says whether this matrix is upper-triangular. True can be returned\n        even if the matrix is not square.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "iter_items",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.iter_items",
    "type": "method",
    "description": "\n        Iterate over indices and values of nonzero elements of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([[ZZ(1), ZZ(0)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> list(A.iter_items())\n        [((0, 0), 1), ((1, 0), 3), ((1, 1), 4)]\n\n        See Also\n        ========\n\n        iter_values\n        to_dok\n        sympy.matrices.matrixbase.MatrixBase.iter_items\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "iter_values",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.iter_values",
    "type": "method",
    "description": "\n        Iterate over nonzero elements of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([[ZZ(1), ZZ(0)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> list(A.iter_values())\n        [1, 3, 4]\n\n        See Also\n        ========\n\n        iter_items\n        to_list_flat\n        sympy.matrices.matrixbase.MatrixBase.iter_values\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lll",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.lll",
    "type": "method",
    "description": "\n        Performs the Lenstra\u2013Lenstra\u2013Lov\u00e1sz (LLL) basis reduction algorithm.\n        See [1]_ and [2]_.\n\n        Parameters\n        ==========\n\n        delta : QQ, optional\n            The Lov\u00e1sz parameter. Must be in the interval (0.25, 1), with larger\n            values producing a more reduced basis. The default is 0.75 for\n            historical reasons.\n\n        Returns\n        =======\n\n        The reduced basis as a DomainMatrix over ZZ.\n\n        Throws\n        ======\n\n        DMValueError: if delta is not in the range (0.25, 1)\n        DMShapeError: if the matrix is not of shape (m, n) with m <= n\n        DMDomainError: if the matrix domain is not ZZ\n        DMRankError: if the matrix contains linearly dependent rows\n\n        Examples\n        ========\n\n        >>> from sympy.polys.domains import ZZ, QQ\n        >>> from sympy.polys.matrices import DM\n        >>> x = DM([[1, 0, 0, 0, -20160],\n        ...         [0, 1, 0, 0, 33768],\n        ...         [0, 0, 1, 0, 39578],\n        ...         [0, 0, 0, 1, 47757]], ZZ)\n        >>> y = DM([[10, -3, -2, 8, -4],\n        ...         [3, -9, 8, 1, -11],\n        ...         [-3, 13, -9, -3, -9],\n        ...         [-12, -7, -11, 9, -1]], ZZ)\n        >>> assert x.lll(delta=QQ(5, 6)) == y\n\n        Notes\n        =====\n\n        The implementation is derived from the Maple code given in Figures 4.3\n        and 4.4 of [3]_ (pp.68-69). It uses the efficient method of only calculating\n        state updates as they are required.\n\n        See also\n        ========\n\n        lll_transform\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm\n        .. [2] https://web.archive.org/web/20221029115428/https://web.cs.elte.hu/~lovasz/scans/lll.pdf\n        .. [3] Murray R. Bremner, \"Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications\"\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lll_transform",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.lll_transform",
    "type": "method",
    "description": "\n        Performs the Lenstra\u2013Lenstra\u2013Lov\u00e1sz (LLL) basis reduction algorithm\n        and returns the reduced basis and transformation matrix.\n\n        Explanation\n        ===========\n\n        Parameters, algorithm and basis are the same as for :meth:`lll` except that\n        the return value is a tuple `(B, T)` with `B` the reduced basis and\n        `T` a transformation matrix. The original basis `A` is transformed to\n        `B` with `T*A == B`. If only `B` is needed then :meth:`lll` should be\n        used as it is a little faster.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.domains import ZZ, QQ\n        >>> from sympy.polys.matrices import DM\n        >>> X = DM([[1, 0, 0, 0, -20160],\n        ...         [0, 1, 0, 0, 33768],\n        ...         [0, 0, 1, 0, 39578],\n        ...         [0, 0, 0, 1, 47757]], ZZ)\n        >>> B, T = X.lll_transform(delta=QQ(5, 6))\n        >>> T * X == B\n        True\n\n        See also\n        ========\n\n        lll\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lu",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.lu",
    "type": "method",
    "description": "\n        Returns Lower and Upper decomposition of the DomainMatrix\n\n        Returns\n        =======\n\n        (L, U, exchange)\n            L, U are Lower and Upper decomposition of the DomainMatrix,\n            exchange is the list of indices of rows exchanged in the\n            decomposition.\n\n        Raises\n        ======\n\n        ValueError\n            If the domain of DomainMatrix not a Field\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [QQ(1), QQ(-1)],\n        ...    [QQ(2), QQ(-2)]], (2, 2), QQ)\n        >>> L, U, exchange = A.lu()\n        >>> L\n        DomainMatrix([[1, 0], [2, 1]], (2, 2), QQ)\n        >>> U\n        DomainMatrix([[1, -1], [0, 0]], (2, 2), QQ)\n        >>> exchange\n        []\n\n        See Also\n        ========\n\n        lu_solve\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lu_solve",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.lu_solve",
    "type": "method",
    "description": "\n        Solver for DomainMatrix x in the A*x = B\n\n        Parameters\n        ==========\n\n        rhs : DomainMatrix B\n\n        Returns\n        =======\n\n        DomainMatrix\n            x in A*x = B\n\n        Raises\n        ======\n\n        DMShapeError\n            If the DomainMatrix A and rhs have different number of rows\n\n        ValueError\n            If the domain of DomainMatrix A not a Field\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [QQ(1), QQ(2)],\n        ...    [QQ(3), QQ(4)]], (2, 2), QQ)\n        >>> B = DomainMatrix([\n        ...    [QQ(1), QQ(1)],\n        ...    [QQ(0), QQ(1)]], (2, 2), QQ)\n\n        >>> A.lu_solve(B)\n        DomainMatrix([[-2, -1], [3/2, 1]], (2, 2), QQ)\n\n        See Also\n        ========\n\n        lu\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "matmul",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.matmul",
    "type": "method",
    "description": "\n        Performs matrix multiplication of two DomainMatrix matrices\n\n        Parameters\n        ==========\n\n        A, B: DomainMatrix\n            to multiply\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix after multiplication\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> B = DomainMatrix([\n        ...    [ZZ(1), ZZ(1)],\n        ...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)\n\n        >>> A.matmul(B)\n        DomainMatrix([[1, 3], [3, 7]], (2, 2), ZZ)\n\n        See Also\n        ========\n\n        mul, pow, add, sub\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.mul",
    "type": "method",
    "description": "\n        Performs term by term multiplication for the second DomainMatrix\n        w.r.t first DomainMatrix. Returns a DomainMatrix whose rows are\n        list of DomainMatrix matrices created after term by term multiplication.\n\n        Parameters\n        ==========\n\n        A, B: DomainMatrix\n            matrices to multiply term-wise\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix after term by term multiplication\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> b = ZZ(2)\n\n        >>> A.mul(b)\n        DomainMatrix([[2, 4], [6, 8]], (2, 2), ZZ)\n\n        See Also\n        ========\n\n        matmul\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "neg",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.neg",
    "type": "method",
    "description": "\n        Returns the negative of DomainMatrix\n\n        Parameters\n        ==========\n\n        A : Represents a DomainMatrix\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix after Negation\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n        >>> A.neg()\n        DomainMatrix([[-1, -2], [-3, -4]], (2, 2), ZZ)\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nnz",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.nnz",
    "type": "method",
    "description": "\n        Number of nonzero elements in the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[1, 0], [0, 4]], ZZ)\n        >>> A.nnz()\n        2\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nullspace",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace",
    "type": "method",
    "description": "\n        Returns the nullspace for the DomainMatrix\n\n        Returns\n        =======\n\n        DomainMatrix\n            The rows of this matrix form a basis for the nullspace.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([\n        ...    [QQ(2), QQ(-2)],\n        ...    [QQ(4), QQ(-4)]], QQ)\n        >>> A.nullspace()\n        DomainMatrix([[1, 1]], (1, 2), QQ)\n\n        The returned matrix is a basis for the nullspace:\n\n        >>> A_null = A.nullspace().transpose()\n        >>> A * A_null\n        DomainMatrix([[0], [0]], (2, 1), QQ)\n        >>> rows, cols = A.shape\n        >>> nullity = rows - A.rank()\n        >>> A_null.shape == (cols, nullity)\n        True\n\n        Nullspace can also be computed for non-field rings. If the ring is not\n        a field then division is not used. Setting ``divide_last`` to True will\n        raise an error in this case:\n\n        >>> from sympy import ZZ\n        >>> B = DM([[6, -3],\n        ...         [4, -2]], ZZ)\n        >>> B.nullspace()\n        DomainMatrix([[3, 6]], (1, 2), ZZ)\n        >>> B.nullspace(divide_last=True)\n        Traceback (most recent call last):\n        ...\n        DMNotAField: Cannot normalize vectors over a non-field\n\n        Over a ring with ``gcd`` defined the nullspace can potentially be\n        reduced with :meth:`primitive`:\n\n        >>> B.nullspace().primitive()\n        (3, DomainMatrix([[1, 2]], (1, 2), ZZ))\n\n        A matrix over a ring can often be normalized by converting it to a\n        field but it is often a bad idea to do so:\n\n        >>> from sympy.abc import a, b, c\n        >>> from sympy import Matrix\n        >>> M = Matrix([[        a*b,       b + c,        c],\n        ...             [      a - b,         b*c,     c**2],\n        ...             [a*b + a - b, b*c + b + c, c**2 + c]])\n        >>> M.to_DM().domain\n        ZZ[a,b,c]\n        >>> M.to_DM().nullspace().to_Matrix().transpose()\n        Matrix([\n        [                             c**3],\n        [            -a*b*c**2 + a*c - b*c],\n        [a*b**2*c - a*b - a*c + b**2 + b*c]])\n\n        The unnormalized form here is nicer than the normalized form that\n        spreads a large denominator throughout the matrix:\n\n        >>> M.to_DM().to_field().nullspace(divide_last=True).to_Matrix().transpose()\n        Matrix([\n        [                   c**3/(a*b**2*c - a*b - a*c + b**2 + b*c)],\n        [(-a*b*c**2 + a*c - b*c)/(a*b**2*c - a*b - a*c + b**2 + b*c)],\n        [                                                          1]])\n\n        Parameters\n        ==========\n\n        divide_last : bool, optional\n            If False (the default), the vectors are not normalized and the RREF\n            is computed using :meth:`rref_den` and the denominator is\n            discarded. If True, then each row is divided by its final element;\n            the domain must be a field in this case.\n\n        See Also\n        ========\n\n        nullspace_from_rref\n        rref\n        rref_den\n        rowspace\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nullspace_from_rref",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace_from_rref",
    "type": "method",
    "description": "\n        Compute nullspace from rref and pivots.\n\n        The domain of the matrix can be any domain.\n\n        The matrix must be in reduced row echelon form already. Otherwise the\n        result will be incorrect. Use :meth:`rref` or :meth:`rref_den` first\n        to get the reduced row echelon form or use :meth:`nullspace` instead.\n\n        See Also\n        ========\n\n        nullspace\n        rref\n        rref_den\n        sympy.polys.matrices.sdm.SDM.nullspace_from_rref\n        sympy.polys.matrices.ddm.DDM.nullspace_from_rref\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ones",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.ones",
    "type": "method",
    "description": "Returns a DomainMatrix of 1s, of size shape, belonging to the specified domain\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import QQ\n        >>> DomainMatrix.ones((2,3), QQ)\n        DomainMatrix([[1, 1, 1], [1, 1, 1]], (2, 3), QQ)\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "pow",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.pow",
    "type": "method",
    "description": "\n        Computes A**n\n\n        Parameters\n        ==========\n\n        A : DomainMatrix\n\n        n : exponent for A\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix on computing A**n\n\n        Raises\n        ======\n\n        NotImplementedError\n            if n is negative.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(1)],\n        ...    [ZZ(0), ZZ(1)]], (2, 2), ZZ)\n\n        >>> A.pow(2)\n        DomainMatrix([[1, 2], [0, 1]], (2, 2), ZZ)\n\n        See Also\n        ========\n\n        matmul\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "primitive",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.primitive",
    "type": "method",
    "description": "\n        Factor out gcd of the elements of a matrix.\n\n        Requires ``gcd`` in the ground domain.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DM\n        >>> from sympy import ZZ\n        >>> M = DM([[2, 4], [4, 12]], ZZ)\n        >>> content, M_primitive = M.primitive()\n        >>> content\n        2\n        >>> M_primitive\n        DomainMatrix([[1, 2], [2, 6]], (2, 2), ZZ)\n        >>> content * M_primitive == M\n        True\n        >>> M_primitive.content() == ZZ(1)\n        True\n\n        See Also\n        ========\n\n        content\n        cancel_denom\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "rowspace",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.rowspace",
    "type": "method",
    "description": "\n        Returns the rowspace for the DomainMatrix\n\n        Returns\n        =======\n\n        DomainMatrix\n            The rows of this matrix form a basis for the rowspace.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [QQ(1), QQ(-1)],\n        ...    [QQ(2), QQ(-2)]], (2, 2), QQ)\n        >>> A.rowspace()\n        DomainMatrix([[1, -1]], (1, 2), QQ)\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "rref",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.rref",
    "type": "method",
    "description": "\n        Returns reduced-row echelon form (RREF) and list of pivots.\n\n        If the domain is not a field then it will be converted to a field. See\n        :meth:`rref_den` for the fraction-free version of this routine that\n        returns RREF with denominator instead.\n\n        The domain must either be a field or have an associated fraction field\n        (see :meth:`to_field`).\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...     [QQ(2), QQ(-1), QQ(0)],\n        ...     [QQ(-1), QQ(2), QQ(-1)],\n        ...     [QQ(0), QQ(0), QQ(2)]], (3, 3), QQ)\n\n        >>> rref_matrix, rref_pivots = A.rref()\n        >>> rref_matrix\n        DomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)\n        >>> rref_pivots\n        (0, 1, 2)\n\n        Parameters\n        ==========\n\n        method : str, optional (default: 'auto')\n            The method to use to compute the RREF. The default is ``'auto'``,\n            which will attempt to choose the fastest method. The other options\n            are:\n\n            - ``A.rref(method='GJ')`` uses Gauss-Jordan elimination with\n              division. If the domain is not a field then it will be converted\n              to a field with :meth:`to_field` first and RREF will be computed\n              by inverting the pivot elements in each row. This is most\n              efficient for very sparse matrices or for matrices whose elements\n              have complex denominators.\n\n            - ``A.rref(method='FF')`` uses fraction-free Gauss-Jordan\n              elimination. Elimination is performed using exact division\n              (``exquo``) to control the growth of the coefficients. In this\n              case the current domain is always used for elimination but if\n              the domain is not a field then it will be converted to a field\n              at the end and divided by the denominator. This is most efficient\n              for dense matrices or for matrices with simple denominators.\n\n            - ``A.rref(method='CD')`` clears the denominators before using\n              fraction-free Gauss-Jordan elimination in the assoicated ring.\n              This is most efficient for dense matrices with very simple\n              denominators.\n\n            - ``A.rref(method='GJ_dense')``, ``A.rref(method='FF_dense')``, and\n              ``A.rref(method='CD_dense')`` are the same as the above methods\n              except that the dense implementations of the algorithms are used.\n              By default ``A.rref(method='auto')`` will usually choose the\n              sparse implementations for RREF.\n\n            Regardless of which algorithm is used the returned matrix will\n            always have the same format (sparse or dense) as the input and its\n            domain will always be the field of fractions of the input domain.\n\n        Returns\n        =======\n\n        (DomainMatrix, list)\n            reduced-row echelon form and list of pivots for the DomainMatrix\n\n        See Also\n        ========\n\n        rref_den\n            RREF with denominator\n        sympy.polys.matrices.sdm.sdm_irref\n            Sparse implementation of ``method='GJ'``.\n        sympy.polys.matrices.sdm.sdm_rref_den\n            Sparse implementation of ``method='FF'`` and ``method='CD'``.\n        sympy.polys.matrices.dense.ddm_irref\n            Dense implementation of ``method='GJ'``.\n        sympy.polys.matrices.dense.ddm_irref_den\n            Dense implementation of ``method='FF'`` and ``method='CD'``.\n        clear_denoms\n            Clear denominators from a matrix, used by ``method='CD'`` and\n            by ``method='GJ'`` when the original domain is not a field.\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "rref_den",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.rref_den",
    "type": "method",
    "description": "\n        Returns reduced-row echelon form with denominator and list of pivots.\n\n        Requires exact division in the ground domain (``exquo``).\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ, QQ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...     [ZZ(2), ZZ(-1), ZZ(0)],\n        ...     [ZZ(-1), ZZ(2), ZZ(-1)],\n        ...     [ZZ(0), ZZ(0), ZZ(2)]], (3, 3), ZZ)\n\n        >>> A_rref, denom, pivots = A.rref_den()\n        >>> A_rref\n        DomainMatrix([[6, 0, 0], [0, 6, 0], [0, 0, 6]], (3, 3), ZZ)\n        >>> denom\n        6\n        >>> pivots\n        (0, 1, 2)\n        >>> A_rref.to_field() / denom\n        DomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)\n        >>> A_rref.to_field() / denom == A.convert_to(QQ).rref()[0]\n        True\n\n        Parameters\n        ==========\n\n        method : str, optional (default: 'auto')\n            The method to use to compute the RREF. The default is ``'auto'``,\n            which will attempt to choose the fastest method. The other options\n            are:\n\n            - ``A.rref(method='FF')`` uses fraction-free Gauss-Jordan\n              elimination. Elimination is performed using exact division\n              (``exquo``) to control the growth of the coefficients. In this\n              case the current domain is always used for elimination and the\n              result is always returned as a matrix over the current domain.\n              This is most efficient for dense matrices or for matrices with\n              simple denominators.\n\n            - ``A.rref(method='CD')`` clears denominators before using\n              fraction-free Gauss-Jordan elimination in the assoicated ring.\n              The result will be converted back to the original domain unless\n              ``keep_domain=False`` is passed in which case the result will be\n              over the ring used for elimination. This is most efficient for\n              dense matrices with very simple denominators.\n\n            - ``A.rref(method='GJ')`` uses Gauss-Jordan elimination with\n              division. If the domain is not a field then it will be converted\n              to a field with :meth:`to_field` first and RREF will be computed\n              by inverting the pivot elements in each row. The result is\n              converted back to the original domain by clearing denominators\n              unless ``keep_domain=False`` is passed in which case the result\n              will be over the field used for elimination. This is most\n              efficient for very sparse matrices or for matrices whose elements\n              have complex denominators.\n\n            - ``A.rref(method='GJ_dense')``, ``A.rref(method='FF_dense')``, and\n              ``A.rref(method='CD_dense')`` are the same as the above methods\n              except that the dense implementations of the algorithms are used.\n              By default ``A.rref(method='auto')`` will usually choose the\n              sparse implementations for RREF.\n\n            Regardless of which algorithm is used the returned matrix will\n            always have the same format (sparse or dense) as the input and if\n            ``keep_domain=True`` its domain will always be the same as the\n            input.\n\n        keep_domain : bool, optional\n            If True (the default), the domain of the returned matrix and\n            denominator are the same as the domain of the input matrix. If\n            False, the domain of the returned matrix might be changed to an\n            associated ring or field if the algorithm used a different domain.\n            This is useful for efficiency if the caller does not need the\n            result to be in the original domain e.g. it avoids clearing\n            denominators in the case of ``A.rref(method='GJ')``.\n\n        Returns\n        =======\n\n        (DomainMatrix, scalar, list)\n            Reduced-row echelon form, denominator and list of pivot indices.\n\n        See Also\n        ========\n\n        rref\n            RREF without denominator for field domains.\n        sympy.polys.matrices.sdm.sdm_irref\n            Sparse implementation of ``method='GJ'``.\n        sympy.polys.matrices.sdm.sdm_rref_den\n            Sparse implementation of ``method='FF'`` and ``method='CD'``.\n        sympy.polys.matrices.dense.ddm_irref\n            Dense implementation of ``method='GJ'``.\n        sympy.polys.matrices.dense.ddm_irref_den\n            Dense implementation of ``method='FF'`` and ``method='CD'``.\n        clear_denoms\n            Clear denominators from a matrix, used by ``method='CD'``.\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "scc",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.scc",
    "type": "method",
    "description": "Compute the strongly connected components of a DomainMatrix\n\n        Explanation\n        ===========\n\n        A square matrix can be considered as the adjacency matrix for a\n        directed graph where the row and column indices are the vertices. In\n        this graph if there is an edge from vertex ``i`` to vertex ``j`` if\n        ``M[i, j]`` is nonzero. This routine computes the strongly connected\n        components of that graph which are subsets of the rows and columns that\n        are connected by some nonzero element of the matrix. The strongly\n        connected components are useful because many operations such as the\n        determinant can be computed by working with the submatrices\n        corresponding to each component.\n\n        Examples\n        ========\n\n        Find the strongly connected components of a matrix:\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> M = DomainMatrix([[ZZ(1), ZZ(0), ZZ(2)],\n        ...                   [ZZ(0), ZZ(3), ZZ(0)],\n        ...                   [ZZ(4), ZZ(6), ZZ(5)]], (3, 3), ZZ)\n        >>> M.scc()\n        [[1], [0, 2]]\n\n        Compute the determinant from the components:\n\n        >>> MM = M.to_Matrix()\n        >>> MM\n        Matrix([\n        [1, 0, 2],\n        [0, 3, 0],\n        [4, 6, 5]])\n        >>> MM[[1], [1]]\n        Matrix([[3]])\n        >>> MM[[0, 2], [0, 2]]\n        Matrix([\n        [1, 2],\n        [4, 5]])\n        >>> MM.det()\n        -9\n        >>> MM[[1], [1]].det() * MM[[0, 2], [0, 2]].det()\n        -9\n\n        The components are given in reverse topological order and represent a\n        permutation of the rows and columns that will bring the matrix into\n        block lower-triangular form:\n\n        >>> MM[[1, 0, 2], [1, 0, 2]]\n        Matrix([\n        [3, 0, 0],\n        [0, 1, 2],\n        [6, 4, 5]])\n\n        Returns\n        =======\n\n        List of lists of integers\n            Each list represents a strongly connected component.\n\n        See also\n        ========\n\n        sympy.matrices.matrixbase.MatrixBase.strongly_connected_components\n        sympy.utilities.iterables.strongly_connected_components\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "solve_den",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.solve_den",
    "type": "method",
    "description": "\n        Solve matrix equation $Ax = b$ without fractions in the ground domain.\n\n        Examples\n        ========\n\n        Solve a matrix equation over the integers:\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n        >>> b = DM([[ZZ(5)], [ZZ(6)]], ZZ)\n        >>> xnum, xden = A.solve_den(b)\n        >>> xden\n        -2\n        >>> xnum\n        DomainMatrix([[8], [-9]], (2, 1), ZZ)\n        >>> A * xnum == xden * b\n        True\n\n        Solve a matrix equation over a polynomial ring:\n\n        >>> from sympy import ZZ\n        >>> from sympy.abc import x, y, z, a, b\n        >>> R = ZZ[x, y, z, a, b]\n        >>> M = DM([[x*y, x*z], [y*z, x*z]], R)\n        >>> b = DM([[a], [b]], R)\n        >>> M.to_Matrix()\n        Matrix([\n        [x*y, x*z],\n        [y*z, x*z]])\n        >>> b.to_Matrix()\n        Matrix([\n        [a],\n        [b]])\n        >>> xnum, xden = M.solve_den(b)\n        >>> xden\n        x**2*y*z - x*y*z**2\n        >>> xnum.to_Matrix()\n        Matrix([\n        [ a*x*z - b*x*z],\n        [-a*y*z + b*x*y]])\n        >>> M * xnum == xden * b\n        True\n\n        The solution can be expressed over a fraction field which will cancel\n        gcds between the denominator and the elements of the numerator:\n\n        >>> xsol = xnum.to_field() / xden\n        >>> xsol.to_Matrix()\n        Matrix([\n        [           (a - b)/(x*y - y*z)],\n        [(-a*z + b*x)/(x**2*z - x*z**2)]])\n        >>> (M * xsol).to_Matrix() == b.to_Matrix()\n        True\n\n        When solving a large system of equations this cancellation step might\n        be a lot slower than :func:`solve_den` itself. The solution can also be\n        expressed as a ``Matrix`` without attempting any polynomial\n        cancellation between the numerator and denominator giving a less\n        simplified result more quickly:\n\n        >>> xsol_uncancelled = xnum.to_Matrix() / xnum.domain.to_sympy(xden)\n        >>> xsol_uncancelled\n        Matrix([\n        [ (a*x*z - b*x*z)/(x**2*y*z - x*y*z**2)],\n        [(-a*y*z + b*x*y)/(x**2*y*z - x*y*z**2)]])\n        >>> from sympy import cancel\n        >>> cancel(xsol_uncancelled) == xsol.to_Matrix()\n        True\n\n        Parameters\n        ==========\n\n        self : :class:`DomainMatrix`\n            The ``m x n`` matrix $A$ in the equation $Ax = b$. Underdetermined\n            systems are not supported so ``m >= n``: $A$ should be square or\n            have more rows than columns.\n        b : :class:`DomainMatrix`\n            The ``n x m`` matrix $b$ for the rhs.\n        cp : list of :class:`~.DomainElement`, optional\n            The characteristic polynomial of the matrix $A$. If not given, it\n            will be computed using :meth:`charpoly`.\n        method: str, optional\n            The method to use for solving the system. Can be one of ``None``,\n            ``'charpoly'`` or ``'rref'``. If ``None`` (the default) then the\n            method will be chosen automatically.\n\n            The ``charpoly`` method uses :meth:`solve_den_charpoly` and can\n            only be used if the matrix is square. This method is division free\n            and can be used with any domain.\n\n            The ``rref`` method is fraction free but requires exact division\n            in the ground domain (``exquo``). This is also suitable for most\n            domains. This method can be used with overdetermined systems (more\n            equations than unknowns) but not underdetermined systems as a\n            unique solution is sought.\n\n        Returns\n        =======\n\n        (xnum, xden) : (DomainMatrix, DomainElement)\n            The solution of the equation $Ax = b$ as a pair consisting of an\n            ``n x m`` matrix numerator ``xnum`` and a scalar denominator\n            ``xden``.\n\n        The solution $x$ is given by ``x = xnum / xden``. The division free\n        invariant is ``A * xnum == xden * b``. If $A$ is square then the\n        denominator ``xden`` will be a divisor of the determinant $det(A)$.\n\n        Raises\n        ======\n\n        DMNonInvertibleMatrixError\n            If the system $Ax = b$ does not have a unique solution.\n\n        See Also\n        ========\n\n        solve_den_charpoly\n        solve_den_rref\n        inv_den\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "solve_den_charpoly",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.solve_den_charpoly",
    "type": "method",
    "description": "\n        Solve matrix equation $Ax = b$ using the characteristic polynomial.\n\n        This method solves the square matrix equation $Ax = b$ for $x$ using\n        the characteristic polynomial without any division or fractions in the\n        ground domain.\n\n        Examples\n        ========\n\n        Solve a matrix equation over the integers:\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n        >>> b = DM([[ZZ(5)], [ZZ(6)]], ZZ)\n        >>> xnum, detA = A.solve_den_charpoly(b)\n        >>> detA\n        -2\n        >>> xnum\n        DomainMatrix([[8], [-9]], (2, 1), ZZ)\n        >>> A * xnum == detA * b\n        True\n\n        Parameters\n        ==========\n\n        self : DomainMatrix\n            The ``n x n`` matrix `A` in the equation `Ax = b`. Must be square\n            and invertible.\n        b : DomainMatrix\n            The ``n x m`` matrix `b` for the rhs.\n        cp : list, optional\n            The characteristic polynomial of the matrix `A` if known. If not\n            given, it will be computed using :meth:`charpoly`.\n        check : bool, optional\n            If ``True`` (the default) check that the determinant is not zero\n            and raise an error if it is. If ``False`` then if the determinant\n            is zero the return value will be equal to ``(A.adjugate()*b, 0)``.\n\n        Returns\n        =======\n\n        (xnum, detA) : (DomainMatrix, DomainElement)\n            The solution of the equation `Ax = b` as a matrix numerator and\n            scalar denominator pair. The denominator is equal to the\n            determinant of `A` and the numerator is ``adj(A)*b``.\n\n        The solution $x$ is given by ``x = xnum / detA``. The division free\n        invariant is ``A * xnum == detA * b``.\n\n        If ``b`` is the identity matrix, then ``xnum`` is the adjugate matrix\n        and we have ``A * adj(A) == detA * I``.\n\n        See Also\n        ========\n\n        solve_den\n            Main frontend for solving matrix equations with denominator.\n        solve_den_rref\n            Solve matrix equations using fraction-free RREF.\n        inv_den\n            Invert a matrix using the characteristic polynomial.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "solve_den_rref",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.solve_den_rref",
    "type": "method",
    "description": "\n        Solve matrix equation $Ax = b$ using fraction-free RREF\n\n        Solves the matrix equation $Ax = b$ for $x$ and returns the solution\n        as a numerator/denominator pair.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n        >>> b = DM([[ZZ(5)], [ZZ(6)]], ZZ)\n        >>> xnum, xden = A.solve_den_rref(b)\n        >>> xden\n        -2\n        >>> xnum\n        DomainMatrix([[8], [-9]], (2, 1), ZZ)\n        >>> A * xnum == xden * b\n        True\n\n        See Also\n        ========\n\n        solve_den\n        solve_den_charpoly\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "sub",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.sub",
    "type": "method",
    "description": "\n        Subtracts two DomainMatrix matrices of the same Domain\n\n        Parameters\n        ==========\n\n        A, B: DomainMatrix\n            matrices to subtract\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix after Subtraction\n\n        Raises\n        ======\n\n        DMShapeError\n            If the dimensions of the two DomainMatrix are not equal\n\n        ValueError\n            If the domain of the two DomainMatrix are not same\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> B = DomainMatrix([\n        ...    [ZZ(4), ZZ(3)],\n        ...    [ZZ(2), ZZ(1)]], (2, 2), ZZ)\n\n        >>> A.sub(B)\n        DomainMatrix([[-3, -1], [1, 3]], (2, 2), ZZ)\n\n        See Also\n        ========\n\n        add, matmul\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_Matrix",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_Matrix",
    "type": "method",
    "description": "\n        Convert DomainMatrix to Matrix\n\n        Returns\n        =======\n\n        Matrix\n            MutableDenseMatrix for the DomainMatrix\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n        >>> A.to_Matrix()\n        Matrix([\n            [1, 2],\n            [3, 4]])\n\n        See Also\n        ========\n\n        from_Matrix\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_ddm",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_ddm",
    "type": "method",
    "description": "\n        Return a :class:`~.DDM` representation of *self*.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import QQ\n        >>> A = DomainMatrix({0: {0: 1}, 1: {1: 2}}, (2, 2), QQ)\n        >>> ddm = A.to_ddm()\n        >>> ddm\n        [[1, 0], [0, 2]]\n        >>> type(ddm)\n        <class 'sympy.polys.matrices.ddm.DDM'>\n\n        See Also\n        ========\n\n        to_sdm\n        to_dense\n        sympy.polys.matrices.ddm.DDM.to_sdm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dense",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_dense",
    "type": "method",
    "description": "\n        Return a dense DomainMatrix representation of *self*.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import QQ\n        >>> A = DomainMatrix({0: {0: 1}, 1: {1: 2}}, (2, 2), QQ)\n        >>> A.rep\n        {0: {0: 1}, 1: {1: 2}}\n        >>> B = A.to_dense()\n        >>> B.rep\n        [[1, 0], [0, 2]]\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dfm",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm",
    "type": "method",
    "description": "\n        Return a :class:`~.DFM` representation of *self*.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import QQ\n        >>> A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)\n        >>> dfm = A.to_dfm()\n        >>> dfm\n        [[1, 0], [0, 2]]\n        >>> type(dfm)\n        <class 'sympy.polys.matrices._dfm.DFM'>\n\n        See Also\n        ========\n\n        to_ddm\n        to_dense\n        DFM\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dfm_or_ddm",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm_or_ddm",
    "type": "method",
    "description": "\n        Return a :class:`~.DFM` or :class:`~.DDM` representation of *self*.\n\n        Explanation\n        ===========\n\n        The :class:`~.DFM` representation can only be used if the ground types\n        are ``flint`` and the ground domain is supported by ``python-flint``.\n        This method will return a :class:`~.DFM` representation if possible,\n        but will return a :class:`~.DDM` representation otherwise.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import QQ\n        >>> A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)\n        >>> dfm = A.to_dfm_or_ddm()\n        >>> dfm\n        [[1, 0], [0, 2]]\n        >>> type(dfm)  # Depends on the ground domain and ground types\n        <class 'sympy.polys.matrices._dfm.DFM'>\n\n        See Also\n        ========\n\n        to_ddm: Always return a :class:`~.DDM` representation.\n        to_dfm: Returns a :class:`~.DFM` representation or raise an error.\n        to_dense: Convert internally to a :class:`~.DFM` or :class:`~.DDM`\n        DFM: The :class:`~.DFM` dense FLINT matrix representation.\n        DDM: The Python :class:`~.DDM` dense domain matrix representation.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dod",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_dod",
    "type": "method",
    "description": "\n        Convert :class:`DomainMatrix` to dictionary of dictionaries (dod) format.\n\n        Explanation\n        ===========\n\n        Returns a dictionary of dictionaries representing the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> A = DM([[ZZ(1), ZZ(2), ZZ(0)], [ZZ(3), ZZ(0), ZZ(4)]], ZZ)\n        >>> A.to_dod()\n        {0: {0: 1, 1: 2}, 1: {0: 3, 2: 4}}\n        >>> A.to_sparse() == A.from_dod(A.to_dod(), A.shape, A.domain)\n        True\n        >>> A == A.from_dod_like(A.to_dod())\n        True\n\n        See Also\n        ========\n\n        from_dod\n        from_dod_like\n        to_dok\n        to_list\n        to_list_flat\n        to_flat_nz\n        sympy.matrices.matrixbase.MatrixBase.todod\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dok",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_dok",
    "type": "method",
    "description": "\n        Convert :class:`DomainMatrix` to dictionary of keys (dok) format.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(0)],\n        ...    [ZZ(0), ZZ(4)]], (2, 2), ZZ)\n        >>> A.to_dok()\n        {(0, 0): 1, (1, 1): 4}\n\n        The matrix can be reconstructed by calling :meth:`from_dok` although\n        the reconstructed matrix will always be in sparse format:\n\n        >>> A.to_sparse() == A.from_dok(A.to_dok(), A.shape, A.domain)\n        True\n\n        See Also\n        ========\n\n        from_dok\n        to_list\n        to_list_flat\n        to_flat_nz\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_field",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_field",
    "type": "method",
    "description": "\n        Returns a DomainMatrix with the appropriate field\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix with the appropriate field\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n\n        >>> A.to_field()\n        DomainMatrix([[1, 2], [3, 4]], (2, 2), QQ)\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_flat_nz",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_flat_nz",
    "type": "method",
    "description": "\n        Convert :class:`DomainMatrix` to list of nonzero elements and data.\n\n        Explanation\n        ===========\n\n        Returns a tuple ``(elements, data)`` where ``elements`` is a list of\n        elements of the matrix with zeros possibly excluded. The matrix can be\n        reconstructed by passing these to :meth:`from_flat_nz`. The idea is to\n        be able to modify a flat list of the elements and then create a new\n        matrix of the same shape with the modified elements in the same\n        positions.\n\n        The format of ``data`` differs depending on whether the underlying\n        representation is dense or sparse but either way it represents the\n        positions of the elements in the list in a way that\n        :meth:`from_flat_nz` can use to reconstruct the matrix. The\n        :meth:`from_flat_nz` method should be called on the same\n        :class:`DomainMatrix` that was used to call :meth:`to_flat_nz`.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([\n        ...    [ZZ(1), ZZ(2)],\n        ...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> elements, data = A.to_flat_nz()\n        >>> elements\n        [1, 2, 3, 4]\n        >>> A == A.from_flat_nz(elements, data, A.domain)\n        True\n\n        Create a matrix with the elements doubled:\n\n        >>> elements_doubled = [2*x for x in elements]\n        >>> A2 = A.from_flat_nz(elements_doubled, data, A.domain)\n        >>> A2 == 2*A\n        True\n\n        See Also\n        ========\n\n        from_flat_nz\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_list",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_list",
    "type": "method",
    "description": "\n        Convert :class:`DomainMatrix` to list of lists.\n\n        See Also\n        ========\n\n        from_list\n        to_list_flat\n        to_flat_nz\n        to_dok\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_list_flat",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_list_flat",
    "type": "method",
    "description": "\n        Convert :class:`DomainMatrix` to flat list.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> A.to_list_flat()\n        [1, 2, 3, 4]\n\n        See Also\n        ========\n\n        from_list_flat\n        to_list\n        to_flat_nz\n        to_dok\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_sdm",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_sdm",
    "type": "method",
    "description": "\n        Return a :class:`~.SDM` representation of *self*.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import QQ\n        >>> A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)\n        >>> sdm = A.to_sdm()\n        >>> sdm\n        {0: {0: 1}, 1: {1: 2}}\n        >>> type(sdm)\n        <class 'sympy.polys.matrices.sdm.SDM'>\n\n        See Also\n        ========\n\n        to_ddm\n        to_sparse\n        sympy.polys.matrices.sdm.SDM.to_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_sparse",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.to_sparse",
    "type": "method",
    "description": "\n        Return a sparse DomainMatrix representation of *self*.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import QQ\n        >>> A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)\n        >>> A.rep\n        [[1, 0], [0, 2]]\n        >>> B = A.to_sparse()\n        >>> B.rep\n        {0: {0: 1}, 1: {1: 2}}\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "transpose",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.transpose",
    "type": "method",
    "description": "Matrix transpose of ``self``",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "unify",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.unify",
    "type": "method",
    "description": "\n        Unifies the domains and the format of self and other\n        matrices.\n\n        Parameters\n        ==========\n\n        others : DomainMatrix\n\n        fmt: string 'dense', 'sparse' or `None` (default)\n            The preferred format to convert to if self and other are not\n            already in the same format. If `None` or not specified then no\n            conversion if performed.\n\n        Returns\n        =======\n\n        Tuple[DomainMatrix]\n            Matrices with unified domain and format\n\n        Examples\n        ========\n\n        Unify the domain of DomainMatrix that have different domains:\n\n        >>> from sympy import ZZ, QQ\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n        >>> B = DomainMatrix([[QQ(1, 2), QQ(2)]], (1, 2), QQ)\n        >>> Aq, Bq = A.unify(B)\n        >>> Aq\n        DomainMatrix([[1, 2]], (1, 2), QQ)\n        >>> Bq\n        DomainMatrix([[1/2, 2]], (1, 2), QQ)\n\n        Unify the format (dense or sparse):\n\n        >>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n        >>> B = DomainMatrix({0:{0: ZZ(1)}}, (2, 2), ZZ)\n        >>> B.rep\n        {0: {0: 1}}\n\n        >>> A2, B2 = A.unify(B, fmt='dense')\n        >>> B2.rep\n        [[1, 0], [0, 0]]\n\n        See Also\n        ========\n\n        convert_to, to_dense, to_sparse\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "vstack",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.vstack",
    "type": "method",
    "description": "Vertically stack the given matrices.\n\n        Parameters\n        ==========\n\n        B: DomainMatrix\n            Matrices to stack vertically.\n\n        Returns\n        =======\n\n        DomainMatrix\n            DomainMatrix by stacking vertically.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices import DomainMatrix\n\n        >>> A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> B = DomainMatrix([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)\n        >>> A.vstack(B)\n        DomainMatrix([[1, 2], [3, 4], [5, 6], [7, 8]], (4, 2), ZZ)\n\n        >>> C = DomainMatrix([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)\n        >>> A.vstack(B, C)\n        DomainMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]], (6, 2), ZZ)\n\n        See Also\n        ========\n\n        unify\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "zeros",
    "full_id": "sympy.polys.matrices.domainmatrix.DomainMatrix.zeros",
    "type": "method",
    "description": "Returns a zero DomainMatrix of size shape, belonging to the specified domain\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy import QQ\n        >>> DomainMatrix.zeros((2, 3), QQ)\n        DomainMatrix({}, (2, 3), QQ)\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.matrices.ddm.DDM.add",
    "type": "method",
    "description": "a + b",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "charpoly",
    "full_id": "sympy.polys.matrices.ddm.DDM.charpoly",
    "type": "method",
    "description": "Coefficients of characteristic polynomial of a",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "det",
    "full_id": "sympy.polys.matrices.ddm.DDM.det",
    "type": "method",
    "description": "Determinant of a",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "diag",
    "full_id": "sympy.polys.matrices.ddm.DDM.diag",
    "type": "method",
    "description": "Returns a square diagonal matrix with *values* on the diagonal.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import DDM\n        >>> DDM.diag([ZZ(1), ZZ(2), ZZ(3)], ZZ)\n        [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\n\n        See also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.diag\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "diagonal",
    "full_id": "sympy.polys.matrices.ddm.DDM.diagonal",
    "type": "method",
    "description": "\n        Returns a list of the elements from the diagonal of the matrix.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dod",
    "full_id": "sympy.polys.matrices.ddm.DDM.from_dod",
    "type": "method",
    "description": "\n        Create a :class:`DDM` from a dictionary of dictionaries (dod) format.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> dod = {0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}\n        >>> A = DDM.from_dod(dod, (2, 2), QQ)\n        >>> A\n        [[1, 2], [3, 4]]\n\n        See Also\n        ========\n\n        to_dod\n        sympy.polys.matrices.sdm.SDM.from_dod\n        sympy.polys.matrices.domainmatrix.DomainMatrix.from_dod\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dok",
    "full_id": "sympy.polys.matrices.ddm.DDM.from_dok",
    "type": "method",
    "description": "\n        Create a :class:`DDM` from a dictionary of keys (dok) format.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> dok = {(0, 0): 1, (0, 1): 2, (1, 0): 3, (1, 1): 4}\n        >>> A = DDM.from_dok(dok, (2, 2), QQ)\n        >>> A\n        [[1, 2], [3, 4]]\n\n        See Also\n        ========\n\n        to_dok\n        sympy.polys.matrices.sdm.SDM.from_dok\n        sympy.polys.matrices.domainmatrix.DomainMatrix.from_dok\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_flat_nz",
    "full_id": "sympy.polys.matrices.ddm.DDM.from_flat_nz",
    "type": "method",
    "description": "\n        Reconstruct a :class:`DDM` after calling :meth:`to_flat_nz`.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n        >>> elements, data = A.to_flat_nz()\n        >>> elements\n        [1, 2, 3, 4]\n        >>> A == DDM.from_flat_nz(elements, data, A.domain)\n        True\n\n        See Also\n        ========\n\n        to_flat_nz\n        sympy.polys.matrices.sdm.SDM.from_flat_nz\n        sympy.polys.matrices.domainmatrix.DomainMatrix.from_flat_nz\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_list",
    "full_id": "sympy.polys.matrices.ddm.DDM.from_list",
    "type": "method",
    "description": "\n        Create a :class:`DDM` from a list of lists.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> A = DDM.from_list([[ZZ(0), ZZ(1)], [ZZ(-1), ZZ(0)]], (2, 2), ZZ)\n        >>> A\n        [[0, 1], [-1, 0]]\n        >>> A == DDM([[ZZ(0), ZZ(1)], [ZZ(-1), ZZ(0)]], (2, 2), ZZ)\n        True\n\n        See Also\n        ========\n\n        from_list_flat\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_list_flat",
    "full_id": "sympy.polys.matrices.ddm.DDM.from_list_flat",
    "type": "method",
    "description": "\n        Create a :class:`DDM` from a flat list of elements.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> A = DDM.from_list_flat([1, 2, 3, 4], (2, 2), QQ)\n        >>> A\n        [[1, 2], [3, 4]]\n        >>> A == DDM.from_list_flat(A.to_list_flat(), A.shape, A.domain)\n        True\n\n        See Also\n        ========\n\n        to_list_flat\n        sympy.polys.matrices.domainmatrix.DomainMatrix.from_list_flat\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "hstack",
    "full_id": "sympy.polys.matrices.ddm.DDM.hstack",
    "type": "method",
    "description": "Horizontally stacks :py:class:`~.DDM` matrices.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import DDM\n\n        >>> A = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> B = DDM([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)\n        >>> A.hstack(B)\n        [[1, 2, 5, 6], [3, 4, 7, 8]]\n\n        >>> C = DDM([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)\n        >>> A.hstack(B, C)\n        [[1, 2, 5, 6, 9, 10], [3, 4, 7, 8, 11, 12]]\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "inv",
    "full_id": "sympy.polys.matrices.ddm.DDM.inv",
    "type": "method",
    "description": "Inverse of a",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_diagonal",
    "full_id": "sympy.polys.matrices.ddm.DDM.is_diagonal",
    "type": "method",
    "description": "\n        Says whether this matrix is diagonal. True can be returned even if\n        the matrix is not square.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_zero_matrix",
    "full_id": "sympy.polys.matrices.ddm.DDM.is_zero_matrix",
    "type": "method",
    "description": "\n        Says whether this matrix has all zero entries.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "iter_items",
    "full_id": "sympy.polys.matrices.ddm.DDM.iter_items",
    "type": "method",
    "description": "\n        Iterate over indices and values of nonzero elements of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> A = DDM([[QQ(1), QQ(0)], [QQ(3), QQ(4)]], (2, 2), QQ)\n        >>> list(A.iter_items())\n        [((0, 0), 1), ((1, 0), 3), ((1, 1), 4)]\n\n        See Also\n        ========\n\n        iter_values\n        to_dok\n        sympy.polys.matrices.domainmatrix.DomainMatrix.iter_items\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "iter_values",
    "full_id": "sympy.polys.matrices.ddm.DDM.iter_values",
    "type": "method",
    "description": "\n        Iterater over the non-zero values of the matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> A = DDM([[QQ(1), QQ(0)], [QQ(3), QQ(4)]], (2, 2), QQ)\n        >>> list(A.iter_values())\n        [1, 3, 4]\n\n        See Also\n        ========\n\n        iter_items\n        to_list_flat\n        sympy.polys.matrices.domainmatrix.DomainMatrix.iter_values\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lu",
    "full_id": "sympy.polys.matrices.ddm.DDM.lu",
    "type": "method",
    "description": "L, U decomposition of a",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lu_solve",
    "full_id": "sympy.polys.matrices.ddm.DDM.lu_solve",
    "type": "method",
    "description": "x where a*x = b",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "matmul",
    "full_id": "sympy.polys.matrices.ddm.DDM.matmul",
    "type": "method",
    "description": "a @ b (matrix product)",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "neg",
    "full_id": "sympy.polys.matrices.ddm.DDM.neg",
    "type": "method",
    "description": "-a",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nnz",
    "full_id": "sympy.polys.matrices.ddm.DDM.nnz",
    "type": "method",
    "description": "Number of non-zero entries in :py:class:`~.DDM` matrix.\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.nnz\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nullspace",
    "full_id": "sympy.polys.matrices.ddm.DDM.nullspace",
    "type": "method",
    "description": "Returns a basis for the nullspace of a.\n\n        The domain of the matrix must be a field.\n\n        See Also\n        ========\n\n        rref\n        sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nullspace_from_rref",
    "full_id": "sympy.polys.matrices.ddm.DDM.nullspace_from_rref",
    "type": "method",
    "description": "Compute the nullspace of a matrix from its rref.\n\n        The domain of the matrix can be any domain.\n\n        Returns a tuple (basis, nonpivots).\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace\n            The higher level interface to this function.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "rref",
    "full_id": "sympy.polys.matrices.ddm.DDM.rref",
    "type": "method",
    "description": "Reduced-row echelon form of a and list of pivots.\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.rref\n            Higher level interface to this function.\n        sympy.polys.matrices.dense.ddm_irref\n            The underlying algorithm.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "rref_den",
    "full_id": "sympy.polys.matrices.ddm.DDM.rref_den",
    "type": "method",
    "description": "Reduced-row echelon form of a with denominator and list of pivots\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.rref_den\n            Higher level interface to this function.\n        sympy.polys.matrices.dense.ddm_irref_den\n            The underlying algorithm.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "scc",
    "full_id": "sympy.polys.matrices.ddm.DDM.scc",
    "type": "method",
    "description": "Strongly connected components of a square matrix *a*.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import DDM\n        >>> A = DDM([[ZZ(1), ZZ(0)], [ZZ(0), ZZ(1)]], (2, 2), ZZ)\n        >>> A.scc()\n        [[0], [1]]\n\n        See also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.scc\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "sub",
    "full_id": "sympy.polys.matrices.ddm.DDM.sub",
    "type": "method",
    "description": "a - b",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_ddm",
    "full_id": "sympy.polys.matrices.ddm.DDM.to_ddm",
    "type": "method",
    "description": "\n        Convert to a :class:`DDM`.\n\n        This just returns ``self`` but exists to parallel the corresponding\n        method in other matrix types like :class:`~.SDM`.\n\n        See Also\n        ========\n\n        to_sdm\n        to_dfm\n        to_dfm_or_ddm\n        sympy.polys.matrices.sdm.SDM.to_ddm\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dfm",
    "full_id": "sympy.polys.matrices.ddm.DDM.to_dfm",
    "type": "method",
    "description": "\n        Convert to :class:`~.DDM` to :class:`~.DFM`.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n        >>> A.to_dfm()\n        [[1, 2], [3, 4]]\n        >>> type(A.to_dfm())\n        <class 'sympy.polys.matrices._dfm.DFM'>\n\n        See Also\n        ========\n\n        DFM\n        sympy.polys.matrices._dfm.DFM.to_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dfm_or_ddm",
    "full_id": "sympy.polys.matrices.ddm.DDM.to_dfm_or_ddm",
    "type": "method",
    "description": "\n        Convert to :class:`~.DFM` if possible or otherwise return self.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n        >>> A.to_dfm_or_ddm()\n        [[1, 2], [3, 4]]\n        >>> type(A.to_dfm_or_ddm())\n        <class 'sympy.polys.matrices._dfm.DFM'>\n\n        See Also\n        ========\n\n        to_dfm\n        to_ddm\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm_or_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dod",
    "full_id": "sympy.polys.matrices.ddm.DDM.to_dod",
    "type": "method",
    "description": "\n        Convert to a dictionary of dictionaries (dod) format.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n        >>> A.to_dod()\n        {0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}\n\n        See Also\n        ========\n\n        from_dod\n        sympy.polys.matrices.sdm.SDM.to_dod\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_dod\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dok",
    "full_id": "sympy.polys.matrices.ddm.DDM.to_dok",
    "type": "method",
    "description": "\n        Convert :class:`DDM` to dictionary of keys (dok) format.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n        >>> A.to_dok()\n        {(0, 0): 1, (0, 1): 2, (1, 0): 3, (1, 1): 4}\n\n        See Also\n        ========\n\n        from_dok\n        sympy.polys.matrices.sdm.SDM.to_dok\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_dok\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_flat_nz",
    "full_id": "sympy.polys.matrices.ddm.DDM.to_flat_nz",
    "type": "method",
    "description": "\n        Convert to a flat list of nonzero elements and data.\n\n        Explanation\n        ===========\n\n        This is used to operate on a list of the elements of a matrix and then\n        reconstruct a matrix using :meth:`from_flat_nz`. Zero elements are\n        included in the list but that may change in the future.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n        >>> elements, data = A.to_flat_nz()\n        >>> elements\n        [1, 2, 3, 4]\n        >>> A == DDM.from_flat_nz(elements, data, A.domain)\n        True\n\n        See Also\n        ========\n\n        from_flat_nz\n        sympy.polys.matrices.sdm.SDM.to_flat_nz\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_flat_nz\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_list",
    "full_id": "sympy.polys.matrices.ddm.DDM.to_list",
    "type": "method",
    "description": "\n        Convert to a list of lists.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n        >>> A.to_list()\n        [[1, 2], [3, 4]]\n\n        See Also\n        ========\n\n        to_list_flat\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_list\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_list_flat",
    "full_id": "sympy.polys.matrices.ddm.DDM.to_list_flat",
    "type": "method",
    "description": "\n        Convert to a flat list of elements.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n        >>> A.to_list_flat()\n        [1, 2, 3, 4]\n        >>> A == DDM.from_list_flat(A.to_list_flat(), A.shape, A.domain)\n        True\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_list_flat\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_sdm",
    "full_id": "sympy.polys.matrices.ddm.DDM.to_sdm",
    "type": "method",
    "description": "\n        Convert to a :class:`~.SDM`.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy import QQ\n        >>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n        >>> A.to_sdm()\n        {0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}\n        >>> type(A.to_sdm())\n        <class 'sympy.polys.matrices.sdm.SDM'>\n\n        See Also\n        ========\n\n        SDM\n        sympy.polys.matrices.sdm.SDM.to_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "vstack",
    "full_id": "sympy.polys.matrices.ddm.DDM.vstack",
    "type": "method",
    "description": "Vertically stacks :py:class:`~.DDM` matrices.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import DDM\n\n        >>> A = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n        >>> B = DDM([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)\n        >>> A.vstack(B)\n        [[1, 2], [3, 4], [5, 6], [7, 8]]\n\n        >>> C = DDM([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)\n        >>> A.vstack(B, C)\n        [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_berk",
    "full_id": "sympy.polys.matrices.dense.ddm_berk",
    "type": "function",
    "description": "\n    Berkowitz algorithm for computing the characteristic polynomial.\n\n    Explanation\n    ===========\n\n    The Berkowitz algorithm is a division-free algorithm for computing the\n    characteristic polynomial of a matrix over any commutative ring using only\n    arithmetic in the coefficient ring.\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> from sympy.polys.matrices.dense import ddm_berk\n    >>> from sympy.polys.domains import ZZ\n    >>> M = [[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]]\n    >>> ddm_berk(M, ZZ)\n    [[1], [-5], [-2]]\n    >>> Matrix(M).charpoly()\n    PurePoly(lambda**2 - 5*lambda - 2, lambda, domain='ZZ')\n\n    See Also\n    ========\n\n    sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly\n        The high-level interface to this function.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Samuelson%E2%80%93Berkowitz_algorithm\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_iadd",
    "full_id": "sympy.polys.matrices.dense.ddm_iadd",
    "type": "function",
    "description": "a += b",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_idet",
    "full_id": "sympy.polys.matrices.dense.ddm_idet",
    "type": "function",
    "description": "a  <--  echelon(a); return det\n\n    Explanation\n    ===========\n\n    Compute the determinant of $a$ using the Bareiss fraction-free algorithm.\n    The matrix $a$ is modified in place. Its diagonal elements are the\n    determinants of the leading principal minors. The determinant of $a$ is\n    returned.\n\n    The domain $K$ must support exact division (``K.exquo``). This method is\n    suitable for most exact rings and fields like :ref:`ZZ`, :ref:`QQ` and\n    :ref:`QQ(a)` but not for inexact domains like :ref:`RR` and :ref:`CC`.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices.ddm import ddm_idet\n    >>> a = [[ZZ(1), ZZ(2), ZZ(3)], [ZZ(4), ZZ(5), ZZ(6)], [ZZ(7), ZZ(8), ZZ(9)]]\n    >>> a\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    >>> ddm_idet(a, ZZ)\n    0\n    >>> a\n    [[1, 2, 3], [4, -3, -6], [7, -6, 0]]\n    >>> [a[i][i] for i in range(len(a))]\n    [1, -3, 0]\n\n    See Also\n    ========\n\n    sympy.polys.matrices.domainmatrix.DomainMatrix.det\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Bareiss_algorithm\n    .. [2] https://www.math.usm.edu/perry/Research/Thesis_DRL.pdf\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_iinv",
    "full_id": "sympy.polys.matrices.dense.ddm_iinv",
    "type": "function",
    "description": "ainv  <--  inv(a)\n\n    Compute the inverse of a matrix $a$ over a field $K$ using Gauss-Jordan\n    elimination. The result is stored in $ainv$.\n\n    Uses division in the ground domain which should be an exact field.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.ddm import ddm_iinv, ddm_imatmul\n    >>> from sympy import QQ\n    >>> a = [[QQ(1), QQ(2)], [QQ(3), QQ(4)]]\n    >>> ainv = [[None, None], [None, None]]\n    >>> ddm_iinv(ainv, a, QQ)\n    >>> ainv\n    [[-2, 1], [3/2, -1/2]]\n    >>> result = [[QQ(0), QQ(0)], [QQ(0), QQ(0)]]\n    >>> ddm_imatmul(result, a, ainv)\n    >>> result\n    [[1, 0], [0, 1]]\n\n    See Also\n    ========\n\n    ddm_irref: the underlying routine.\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_ilu",
    "full_id": "sympy.polys.matrices.dense.ddm_ilu",
    "type": "function",
    "description": "a  <--  LU(a)\n\n    Computes the LU decomposition of a matrix in place. Returns a list of\n    row swaps that were performed.\n\n    Uses division in the ground domain which should be an exact field.\n\n    This is only suitable for domains like :ref:`GF(p)`, :ref:`QQ`, :ref:`QQ_I`\n    and :ref:`QQ(a)`. With a rational function field like :ref:`K(x)` it is\n    better to clear denominators and use division-free algorithms. Pivoting is\n    used to avoid exact zeros but not for floating point accuracy so :ref:`RR`\n    and :ref:`CC` are not suitable (use :func:`ddm_irref` instead).\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.dense import ddm_ilu\n    >>> from sympy import QQ\n    >>> a = [[QQ(1, 2), QQ(1, 3)], [QQ(1, 4), QQ(1, 5)]]\n    >>> swaps = ddm_ilu(a)\n    >>> swaps\n    []\n    >>> a\n    [[1/2, 1/3], [1/2, 1/30]]\n\n    The same example using ``Matrix``:\n\n    >>> from sympy import Matrix, S\n    >>> M = Matrix([[S(1)/2, S(1)/3], [S(1)/4, S(1)/5]])\n    >>> L, U, swaps = M.LUdecomposition()\n    >>> L\n    Matrix([\n    [  1, 0],\n    [1/2, 1]])\n    >>> U\n    Matrix([\n    [1/2,  1/3],\n    [  0, 1/30]])\n    >>> swaps\n    []\n\n    See Also\n    ========\n\n    ddm_irref\n    ddm_ilu_solve\n    sympy.matrices.matrixbase.MatrixBase.LUdecomposition\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_ilu_solve",
    "full_id": "sympy.polys.matrices.dense.ddm_ilu_solve",
    "type": "function",
    "description": "x  <--  solve(L*U*x = swaps(b))\n\n    Solve a linear system, $A*x = b$, given an LU factorization of $A$.\n\n    Uses division in the ground domain which must be a field.\n\n    Modifies $x$ in place.\n\n    Examples\n    ========\n\n    Compute the LU decomposition of $A$ (in place):\n\n    >>> from sympy import QQ\n    >>> from sympy.polys.matrices.dense import ddm_ilu, ddm_ilu_solve\n    >>> A = [[QQ(1), QQ(2)], [QQ(3), QQ(4)]]\n    >>> swaps = ddm_ilu(A)\n    >>> A\n    [[1, 2], [3, -2]]\n    >>> L = U = A\n\n    Solve the linear system:\n\n    >>> b = [[QQ(5)], [QQ(6)]]\n    >>> x = [[None], [None]]\n    >>> ddm_ilu_solve(x, L, U, swaps, b)\n    >>> x\n    [[-4], [9/2]]\n\n    See Also\n    ========\n\n    ddm_ilu\n        Compute the LU decomposition of a matrix in place.\n    ddm_ilu_split\n        Compute the LU decomposition of a matrix and separate $L$ and $U$.\n    sympy.polys.matrices.domainmatrix.DomainMatrix.lu_solve\n        Higher level interface to this function.\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_ilu_split",
    "full_id": "sympy.polys.matrices.dense.ddm_ilu_split",
    "type": "function",
    "description": "L, U  <--  LU(U)\n\n    Compute the LU decomposition of a matrix $L$ in place and store the lower\n    and upper triangular matrices in $L$ and $U$, respectively. Returns a list\n    of row swaps that were performed.\n\n    Uses division in the ground domain which should be an exact field.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.ddm import ddm_ilu_split\n    >>> from sympy import QQ\n    >>> L = [[QQ(0), QQ(0)], [QQ(0), QQ(0)]]\n    >>> U = [[QQ(1), QQ(2)], [QQ(3), QQ(4)]]\n    >>> swaps = ddm_ilu_split(L, U, QQ)\n    >>> swaps\n    []\n    >>> L\n    [[0, 0], [3, 0]]\n    >>> U\n    [[1, 2], [0, -2]]\n\n    See Also\n    ========\n\n    ddm_ilu\n    ddm_ilu_solve\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_imatmul",
    "full_id": "sympy.polys.matrices.dense.ddm_imatmul",
    "type": "function",
    "description": "a += b @ c",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_imul",
    "full_id": "sympy.polys.matrices.dense.ddm_imul",
    "type": "function",
    "description": "a <-- a*b",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_ineg",
    "full_id": "sympy.polys.matrices.dense.ddm_ineg",
    "type": "function",
    "description": "a <-- -a",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_irmul",
    "full_id": "sympy.polys.matrices.dense.ddm_irmul",
    "type": "function",
    "description": "a <-- b*a",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_irref",
    "full_id": "sympy.polys.matrices.dense.ddm_irref",
    "type": "function",
    "description": "In-place reduced row echelon form of a matrix.\n\n    Compute the reduced row echelon form of $a$. Modifies $a$ in place and\n    returns a list of the pivot columns.\n\n    Uses naive Gauss-Jordan elimination in the ground domain which must be a\n    field.\n\n    This routine is only really suitable for use with simple field domains like\n    :ref:`GF(p)`, :ref:`QQ` and :ref:`QQ(a)` although even for :ref:`QQ` with\n    larger matrices it is possibly more efficient to use fraction free\n    approaches.\n\n    This method is not suitable for use with rational function fields\n    (:ref:`K(x)`) because the elements will blowup leading to costly gcd\n    operations. In this case clearing denominators and using fraction free\n    approaches is likely to be more efficient.\n\n    For inexact numeric domains like :ref:`RR` and :ref:`CC` pass\n    ``_partial_pivot=True`` to use partial pivoting to control rounding errors.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.dense import ddm_irref\n    >>> from sympy import QQ\n    >>> M = [[QQ(1), QQ(2), QQ(3)], [QQ(4), QQ(5), QQ(6)]]\n    >>> pivots = ddm_irref(M)\n    >>> M\n    [[1, 0, -1], [0, 1, 2]]\n    >>> pivots\n    [0, 1]\n\n    See Also\n    ========\n\n    sympy.polys.matrices.domainmatrix.DomainMatrix.rref\n        Higher level interface to this routine.\n    ddm_irref_den\n        The fraction free version of this routine.\n    sdm_irref\n        A sparse version of this routine.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Row_echelon_form#Reduced_row_echelon_form\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_irref_den",
    "full_id": "sympy.polys.matrices.dense.ddm_irref_den",
    "type": "function",
    "description": "a  <--  rref(a); return (den, pivots)\n\n    Compute the fraction-free reduced row echelon form (RREF) of $a$. Modifies\n    $a$ in place and returns a tuple containing the denominator of the RREF and\n    a list of the pivot columns.\n\n    Explanation\n    ===========\n\n    The algorithm used is the fraction-free version of Gauss-Jordan elimination\n    described as FFGJ in [1]_. Here it is modified to handle zero or missing\n    pivots and to avoid redundant arithmetic.\n\n    The domain $K$ must support exact division (``K.exquo``) but does not need\n    to be a field. This method is suitable for most exact rings and fields like\n    :ref:`ZZ`, :ref:`QQ` and :ref:`QQ(a)`. In the case of :ref:`QQ` or\n    :ref:`K(x)` it might be more efficient to clear denominators and use\n    :ref:`ZZ` or :ref:`K[x]` instead.\n\n    For inexact domains like :ref:`RR` and :ref:`CC` use ``ddm_irref`` instead.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.dense import ddm_irref_den\n    >>> from sympy import ZZ, Matrix\n    >>> M = [[ZZ(1), ZZ(2), ZZ(3)], [ZZ(4), ZZ(5), ZZ(6)]]\n    >>> den, pivots = ddm_irref_den(M, ZZ)\n    >>> M\n    [[-3, 0, 3], [0, -3, -6]]\n    >>> den\n    -3\n    >>> pivots\n    [0, 1]\n    >>> Matrix(M).rref()[0]\n    Matrix([\n    [1, 0, -1],\n    [0, 1,  2]])\n\n    See Also\n    ========\n\n    ddm_irref\n        A version of this routine that uses field division.\n    sdm_irref\n        A sparse version of :func:`ddm_irref`.\n    sdm_rref_den\n        A sparse version of :func:`ddm_irref_den`.\n    sympy.polys.matrices.domainmatrix.DomainMatrix.rref_den\n        Higher level interface.\n\n    References\n    ==========\n\n    .. [1] Fraction-free algorithms for linear and polynomial equations.\n        George C. Nakos , Peter R. Turner , Robert M. Williams.\n        https://dl.acm.org/doi/10.1145/271130.271133\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_isub",
    "full_id": "sympy.polys.matrices.dense.ddm_isub",
    "type": "function",
    "description": "a -= b",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ddm_transpose",
    "full_id": "sympy.polys.matrices.dense.ddm_transpose",
    "type": "function",
    "description": "matrix transpose",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.matrices.sdm.SDM.add",
    "type": "method",
    "description": "\n\n        Adds two :py:class:`~.SDM` matrices\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n        >>> B = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)\n        >>> A.add(B)\n        {0: {0: 3, 1: 2}, 1: {0: 1, 1: 4}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "charpoly",
    "full_id": "sympy.polys.matrices.sdm.SDM.charpoly",
    "type": "method",
    "description": "\n        Returns the coefficients of the characteristic polynomial\n        of the :py:class:`~.SDM` matrix. These elements will be domain elements.\n        The domain of the elements will be same as domain of the :py:class:`~.SDM`.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ, Symbol\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy.polys import Poly\n        >>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n        >>> A.charpoly()\n        [1, -5, -2]\n\n        We can create a polynomial using the\n        coefficients using :py:class:`~.Poly`\n\n        >>> x = Symbol('x')\n        >>> p = Poly(A.charpoly(), x, domain=A.domain)\n        >>> p\n        Poly(x**2 - 5*x - 2, x, domain='QQ')\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "convert_to",
    "full_id": "sympy.polys.matrices.sdm.SDM.convert_to",
    "type": "method",
    "description": "\n        Converts the :py:class:`~.Domain` of a :py:class:`~.SDM` matrix to K\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ, QQ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n        >>> A.convert_to(QQ)\n        {0: {1: 2}, 1: {0: 1}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "copy",
    "full_id": "sympy.polys.matrices.sdm.SDM.copy",
    "type": "method",
    "description": "\n        Returns the copy of a :py:class:`~.SDM` object\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> elemsdict = {0:{1:QQ(2)}, 1:{}}\n        >>> A = SDM(elemsdict, (2, 2), QQ)\n        >>> B = A.copy()\n        >>> B\n        {0: {1: 2}, 1: {}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "det",
    "full_id": "sympy.polys.matrices.sdm.SDM.det",
    "type": "method",
    "description": "\n        Returns determinant of A\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n        >>> A.det()\n        -2\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "diagonal",
    "full_id": "sympy.polys.matrices.sdm.SDM.diagonal",
    "type": "method",
    "description": "\n        Returns the diagonal of the matrix as a list.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "eye",
    "full_id": "sympy.polys.matrices.sdm.SDM.eye",
    "type": "method",
    "description": "\n\n        Returns a identity :py:class:`~.SDM` matrix of dimensions\n        size x size, belonging to the specified domain\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> I = SDM.eye((2, 2), QQ)\n        >>> I\n        {0: {0: 1}, 1: {1: 1}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_ddm",
    "full_id": "sympy.polys.matrices.sdm.SDM.from_ddm",
    "type": "method",
    "description": "\n        Create :py:class:`~.SDM` from a :py:class:`~.DDM`.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.ddm import DDM\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> ddm = DDM( [[QQ(1, 2), 0], [0, QQ(3, 4)]], (2, 2), QQ)\n        >>> A = SDM.from_ddm(ddm)\n        >>> A\n        {0: {0: 1/2}, 1: {1: 3/4}}\n        >>> SDM.from_ddm(ddm).to_ddm() == ddm\n        True\n\n        See Also\n        ========\n\n        to_ddm\n        from_list\n        from_list_flat\n        from_dok\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dod",
    "full_id": "sympy.polys.matrices.sdm.SDM.from_dod",
    "type": "method",
    "description": "\n        Create :py:class:`~.SDM` from dictionary of dictionaries (dod) format.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> dod = {0: {1: QQ(2)}, 1: {0: QQ(3)}}\n        >>> A = SDM.from_dod(dod, (2, 2), QQ)\n        >>> A\n        {0: {1: 2}, 1: {0: 3}}\n        >>> A == SDM.from_dod(A.to_dod(), A.shape, A.domain)\n        True\n\n        See Also\n        ========\n\n        to_dod\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_dod\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dok",
    "full_id": "sympy.polys.matrices.sdm.SDM.from_dok",
    "type": "method",
    "description": "\n        Create :py:class:`~.SDM` from dictionary of keys (dok) format.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> dok = {(0, 1): QQ(2), (1, 0): QQ(3)}\n        >>> A = SDM.from_dok(dok, (2, 2), QQ)\n        >>> A\n        {0: {1: 2}, 1: {0: 3}}\n        >>> A == SDM.from_dok(A.to_dok(), A.shape, A.domain)\n        True\n\n        See Also\n        ========\n\n        to_dok\n        from_list\n        from_list_flat\n        from_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_flat_nz",
    "full_id": "sympy.polys.matrices.sdm.SDM.from_flat_nz",
    "type": "method",
    "description": "\n        Reconstruct a :class:`~.SDM` after calling :meth:`to_flat_nz`.\n\n        See :meth:`to_flat_nz` for explanation.\n\n        See Also\n        ========\n\n        to_flat_nz\n        from_list_flat\n        sympy.polys.matrices.ddm.DDM.from_flat_nz\n        sympy.polys.matrices.domainmatrix.DomainMatrix.from_flat_nz\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_list",
    "full_id": "sympy.polys.matrices.sdm.SDM.from_list",
    "type": "method",
    "description": "\n        Create :py:class:`~.SDM` object from a list of lists.\n\n        Parameters\n        ==========\n\n        ddm:\n            list of lists containing domain elements\n        shape:\n            Dimensions of :py:class:`~.SDM` matrix\n        domain:\n            Represents :py:class:`~.Domain` of :py:class:`~.SDM` object\n\n        Returns\n        =======\n\n        :py:class:`~.SDM` containing elements of ddm\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> ddm = [[QQ(1, 2), QQ(0)], [QQ(0), QQ(3, 4)]]\n        >>> A = SDM.from_list(ddm, (2, 2), QQ)\n        >>> A\n        {0: {0: 1/2}, 1: {1: 3/4}}\n\n        See Also\n        ========\n\n        to_list\n        from_list_flat\n        from_dok\n        from_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_list_flat",
    "full_id": "sympy.polys.matrices.sdm.SDM.from_list_flat",
    "type": "method",
    "description": "\n        Create :py:class:`~.SDM` from a flat list of elements.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM.from_list_flat([QQ(0), QQ(2), QQ(0), QQ(0)], (2, 2), QQ)\n        >>> A\n        {0: {1: 2}}\n        >>> A == A.from_list_flat(A.to_list_flat(), A.shape, A.domain)\n        True\n\n        See Also\n        ========\n\n        to_list_flat\n        from_list\n        from_dok\n        from_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "hstack",
    "full_id": "sympy.polys.matrices.sdm.SDM.hstack",
    "type": "method",
    "description": "Horizontally stacks :py:class:`~.SDM` matrices.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import SDM\n\n        >>> A = SDM({0: {0: ZZ(1), 1: ZZ(2)}, 1: {0: ZZ(3), 1: ZZ(4)}}, (2, 2), ZZ)\n        >>> B = SDM({0: {0: ZZ(5), 1: ZZ(6)}, 1: {0: ZZ(7), 1: ZZ(8)}}, (2, 2), ZZ)\n        >>> A.hstack(B)\n        {0: {0: 1, 1: 2, 2: 5, 3: 6}, 1: {0: 3, 1: 4, 2: 7, 3: 8}}\n\n        >>> C = SDM({0: {0: ZZ(9), 1: ZZ(10)}, 1: {0: ZZ(11), 1: ZZ(12)}}, (2, 2), ZZ)\n        >>> A.hstack(B, C)\n        {0: {0: 1, 1: 2, 2: 5, 3: 6, 4: 9, 5: 10}, 1: {0: 3, 1: 4, 2: 7, 3: 8, 4: 11, 5: 12}}\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "inv",
    "full_id": "sympy.polys.matrices.sdm.SDM.inv",
    "type": "method",
    "description": "\n\n        Returns inverse of a matrix A\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n        >>> A.inv()\n        {0: {0: -2, 1: 1}, 1: {0: 3/2, 1: -1/2}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_diagonal",
    "full_id": "sympy.polys.matrices.sdm.SDM.is_diagonal",
    "type": "method",
    "description": "\n        Says whether this matrix is diagonal. True can be returned\n        even if the matrix is not square.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "iter_items",
    "full_id": "sympy.polys.matrices.sdm.SDM.iter_items",
    "type": "method",
    "description": "\n        Iterate over indices and values of the nonzero elements.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0: {1: QQ(2)}, 1: {0: QQ(3)}}, (2, 2), QQ)\n        >>> list(A.iter_items())\n        [((0, 1), 2), ((1, 0), 3)]\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.iter_items\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "iter_values",
    "full_id": "sympy.polys.matrices.sdm.SDM.iter_values",
    "type": "method",
    "description": "\n        Iterate over the nonzero values of a :py:class:`~.SDM` matrix.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0: {1: QQ(2)}, 1: {0: QQ(3)}}, (2, 2), QQ)\n        >>> list(A.iter_values())\n        [2, 3]\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lll",
    "full_id": "sympy.polys.matrices.sdm.SDM.lll",
    "type": "method",
    "description": "\n        Returns the LLL-reduced basis for the :py:class:`~.SDM` matrix.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lll_transform",
    "full_id": "sympy.polys.matrices.sdm.SDM.lll_transform",
    "type": "method",
    "description": "\n        Returns the LLL-reduced basis and transformation matrix.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lu",
    "full_id": "sympy.polys.matrices.sdm.SDM.lu",
    "type": "method",
    "description": "\n\n        Returns LU decomposition for a matrix A\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n        >>> A.lu()\n        ({0: {0: 1}, 1: {0: 3, 1: 1}}, {0: {0: 1, 1: 2}, 1: {1: -2}}, [])\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lu_solve",
    "full_id": "sympy.polys.matrices.sdm.SDM.lu_solve",
    "type": "method",
    "description": "\n\n        Uses LU decomposition to solve Ax = b,\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n        >>> b = SDM({0:{0:QQ(1)}, 1:{0:QQ(2)}}, (2, 1), QQ)\n        >>> A.lu_solve(b)\n        {1: {0: 1/2}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "matmul",
    "full_id": "sympy.polys.matrices.sdm.SDM.matmul",
    "type": "method",
    "description": "\n        Performs matrix multiplication of two SDM matrices\n\n        Parameters\n        ==========\n\n        A, B: SDM to multiply\n\n        Returns\n        =======\n\n        SDM\n            SDM after multiplication\n\n        Raises\n        ======\n\n        DomainError\n            If domain of A does not match\n            with that of B\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n        >>> B = SDM({0:{0:ZZ(2), 1:ZZ(3)}, 1:{0:ZZ(4)}}, (2, 2), ZZ)\n        >>> A.matmul(B)\n        {0: {0: 8}, 1: {0: 2, 1: 3}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.polys.matrices.sdm.SDM.mul",
    "type": "method",
    "description": "\n        Multiplies each element of A with a scalar b\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n        >>> A.mul(ZZ(3))\n        {0: {1: 6}, 1: {0: 3}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "neg",
    "full_id": "sympy.polys.matrices.sdm.SDM.neg",
    "type": "method",
    "description": "\n\n        Returns the negative of a :py:class:`~.SDM` matrix\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n        >>> A.neg()\n        {0: {1: -2}, 1: {0: -1}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "new",
    "full_id": "sympy.polys.matrices.sdm.SDM.new",
    "type": "method",
    "description": "\n\n        Parameters\n        ==========\n\n        sdm: A dict of dicts for non-zero elements in SDM\n        shape: tuple representing dimension of SDM\n        domain: Represents :py:class:`~.Domain` of SDM\n\n        Returns\n        =======\n\n        An :py:class:`~.SDM` object\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> elemsdict = {0:{1: QQ(2)}}\n        >>> A = SDM.new(elemsdict, (2, 2), QQ)\n        >>> A\n        {0: {1: 2}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nnz",
    "full_id": "sympy.polys.matrices.sdm.SDM.nnz",
    "type": "method",
    "description": "Number of non-zero elements in the :py:class:`~.SDM` matrix.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n        >>> A.nnz()\n        2\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.nnz\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nullspace",
    "full_id": "sympy.polys.matrices.sdm.SDM.nullspace",
    "type": "method",
    "description": "\n        Nullspace of a :py:class:`~.SDM` matrix A.\n\n        The domain of the matrix must be a field.\n\n        It is better to use the :meth:`~.DomainMatrix.nullspace` method rather\n        than this method which is otherwise no longer used.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0: QQ(2), 1: QQ(4)}}, (2, 2), QQ)\n        >>> A.nullspace()\n        ({0: {0: -2, 1: 1}}, [1])\n\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace\n            The preferred way to get the nullspace of a matrix.\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nullspace_from_rref",
    "full_id": "sympy.polys.matrices.sdm.SDM.nullspace_from_rref",
    "type": "method",
    "description": "\n        Returns nullspace for a :py:class:`~.SDM` matrix ``A`` in RREF.\n\n        The domain of the matrix can be any domain.\n\n        The matrix must already be in reduced row echelon form (RREF).\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0: QQ(2), 1: QQ(4)}}, (2, 2), QQ)\n        >>> A_rref, pivots = A.rref()\n        >>> A_null, nonpivots = A_rref.nullspace_from_rref(pivots)\n        >>> A_null\n        {0: {0: -2, 1: 1}}\n        >>> pivots\n        [0]\n        >>> nonpivots\n        [1]\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace\n            The higher-level function that would usually be called instead of\n            calling this one directly.\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.nullspace_from_rref\n            The higher-level direct equivalent of this function.\n\n        sympy.polys.matrices.ddm.DDM.nullspace_from_rref\n            The equivalent function for dense :py:class:`~.DDM` matrices.\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "rref",
    "full_id": "sympy.polys.matrices.sdm.SDM.rref",
    "type": "method",
    "description": "\n\n        Returns reduced-row echelon form and list of pivots for the :py:class:`~.SDM`\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(2), 1:QQ(4)}}, (2, 2), QQ)\n        >>> A.rref()\n        ({0: {0: 1, 1: 2}}, [0])\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "rref_den",
    "full_id": "sympy.polys.matrices.sdm.SDM.rref_den",
    "type": "method",
    "description": "\n\n        Returns reduced-row echelon form (RREF) with denominator and pivots.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(2), 1:QQ(4)}}, (2, 2), QQ)\n        >>> A.rref_den()\n        ({0: {0: 1, 1: 2}}, 1, [0])\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "scc",
    "full_id": "sympy.polys.matrices.sdm.SDM.scc",
    "type": "method",
    "description": "Strongly connected components of a square matrix *A*.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{0: ZZ(2)}, 1:{1:ZZ(1)}}, (2, 2), ZZ)\n        >>> A.scc()\n        [[0], [1]]\n\n        See also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.scc\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "sub",
    "full_id": "sympy.polys.matrices.sdm.SDM.sub",
    "type": "method",
    "description": "\n\n        Subtracts two :py:class:`~.SDM` matrices\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n        >>> B  = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)\n        >>> A.sub(B)\n        {0: {0: -3, 1: 2}, 1: {0: 1, 1: -4}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_ddm",
    "full_id": "sympy.polys.matrices.sdm.SDM.to_ddm",
    "type": "method",
    "description": "\n        Convert a :py:class:`~.SDM` object to a :py:class:`~.DDM` object\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0:{1:QQ(2)}, 1:{}}, (2, 2), QQ)\n        >>> A.to_ddm()\n        [[0, 2], [0, 0]]\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dfm",
    "full_id": "sympy.polys.matrices.sdm.SDM.to_dfm",
    "type": "method",
    "description": "\n        Convert a :py:class:`~.SDM` object to a :py:class:`~.DFM` object\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0:{1:QQ(2)}, 1:{}}, (2, 2), QQ)\n        >>> A.to_dfm()\n        [[0, 2], [0, 0]]\n\n        See Also\n        ========\n\n        to_ddm\n        to_dfm_or_ddm\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dfm_or_ddm",
    "full_id": "sympy.polys.matrices.sdm.SDM.to_dfm_or_ddm",
    "type": "method",
    "description": "\n        Convert to :py:class:`~.DFM` if possible, else :py:class:`~.DDM`.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0:{1:QQ(2)}, 1:{}}, (2, 2), QQ)\n        >>> A.to_dfm_or_ddm()\n        [[0, 2], [0, 0]]\n        >>> type(A.to_dfm_or_ddm())  # depends on the ground types\n        <class 'sympy.polys.matrices._dfm.DFM'>\n\n        See Also\n        ========\n\n        to_ddm\n        to_dfm\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm_or_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dod",
    "full_id": "sympy.polys.matrices.sdm.SDM.to_dod",
    "type": "method",
    "description": "\n        Convert to dictionary of dictionaries (dod) format.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0: {1: QQ(2)}, 1: {0: QQ(3)}}, (2, 2), QQ)\n        >>> A.to_dod()\n        {0: {1: 2}, 1: {0: 3}}\n\n        See Also\n        ========\n\n        from_dod\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_dod\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dok",
    "full_id": "sympy.polys.matrices.sdm.SDM.to_dok",
    "type": "method",
    "description": "\n        Convert to dictionary of keys (dok) format.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0: {1: QQ(2)}, 1: {0: QQ(3)}}, (2, 2), QQ)\n        >>> A.to_dok()\n        {(0, 1): 2, (1, 0): 3}\n\n        See Also\n        ========\n\n        from_dok\n        to_list\n        to_list_flat\n        to_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_flat_nz",
    "full_id": "sympy.polys.matrices.sdm.SDM.to_flat_nz",
    "type": "method",
    "description": "\n        Convert :class:`SDM` to a flat list of nonzero elements and data.\n\n        Explanation\n        ===========\n\n        This is used to operate on a list of the elements of a matrix and then\n        reconstruct a modified matrix with elements in the same positions using\n        :meth:`from_flat_nz`. Zero elements are omitted from the list.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0:{1:QQ(2)}, 1:{0: QQ(3)}}, (2, 2), QQ)\n        >>> elements, data = A.to_flat_nz()\n        >>> elements\n        [2, 3]\n        >>> A == A.from_flat_nz(elements, data, A.domain)\n        True\n\n        See Also\n        ========\n\n        from_flat_nz\n        to_list_flat\n        sympy.polys.matrices.ddm.DDM.to_flat_nz\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_flat_nz\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_list",
    "full_id": "sympy.polys.matrices.sdm.SDM.to_list",
    "type": "method",
    "description": "\n        Convert a :py:class:`~.SDM` object to a list of lists.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> elemsdict = {0:{1:QQ(2)}, 1:{}}\n        >>> A = SDM(elemsdict, (2, 2), QQ)\n        >>> A.to_list()\n        [[0, 2], [0, 0]]\n\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_list_flat",
    "full_id": "sympy.polys.matrices.sdm.SDM.to_list_flat",
    "type": "method",
    "description": "\n        Convert :py:class:`~.SDM` to a flat list.\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0:{1:QQ(2)}, 1:{0: QQ(3)}}, (2, 2), QQ)\n        >>> A.to_list_flat()\n        [0, 2, 3, 0]\n        >>> A == A.from_list_flat(A.to_list_flat(), A.shape, A.domain)\n        True\n\n        See Also\n        ========\n\n        from_list_flat\n        to_list\n        to_dok\n        to_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_sdm",
    "full_id": "sympy.polys.matrices.sdm.SDM.to_sdm",
    "type": "method",
    "description": "\n        Convert to :py:class:`~.SDM` format (returns self).\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "transpose",
    "full_id": "sympy.polys.matrices.sdm.SDM.transpose",
    "type": "method",
    "description": "\n\n        Returns the transpose of a :py:class:`~.SDM` matrix\n\n        Examples\n        ========\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM({0:{1:QQ(2)}, 1:{}}, (2, 2), QQ)\n        >>> A.transpose()\n        {1: {0: 2}}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "vstack",
    "full_id": "sympy.polys.matrices.sdm.SDM.vstack",
    "type": "method",
    "description": "Vertically stacks :py:class:`~.SDM` matrices.\n\n        Examples\n        ========\n\n        >>> from sympy import ZZ\n        >>> from sympy.polys.matrices.sdm import SDM\n\n        >>> A = SDM({0: {0: ZZ(1), 1: ZZ(2)}, 1: {0: ZZ(3), 1: ZZ(4)}}, (2, 2), ZZ)\n        >>> B = SDM({0: {0: ZZ(5), 1: ZZ(6)}, 1: {0: ZZ(7), 1: ZZ(8)}}, (2, 2), ZZ)\n        >>> A.vstack(B)\n        {0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}, 2: {0: 5, 1: 6}, 3: {0: 7, 1: 8}}\n\n        >>> C = SDM({0: {0: ZZ(9), 1: ZZ(10)}, 1: {0: ZZ(11), 1: ZZ(12)}}, (2, 2), ZZ)\n        >>> A.vstack(B, C)\n        {0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}, 2: {0: 5, 1: 6}, 3: {0: 7, 1: 8}, 4: {0: 9, 1: 10}, 5: {0: 11, 1: 12}}\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "zeros",
    "full_id": "sympy.polys.matrices.sdm.SDM.zeros",
    "type": "method",
    "description": "\n\n        Returns a :py:class:`~.SDM` of size shape,\n        belonging to the specified domain\n\n        In the example below we declare a matrix A where,\n\n        .. math::\n            A := \\left[\\begin{array}{ccc}\n            0 & 0 & 0 \\\\\n            0 & 0 & 0 \\end{array} \\right]\n\n        >>> from sympy.polys.matrices.sdm import SDM\n        >>> from sympy import QQ\n        >>> A = SDM.zeros((2, 3), QQ)\n        >>> A\n        {}\n\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "sdm_berk",
    "full_id": "sympy.polys.matrices.sdm.sdm_berk",
    "type": "function",
    "description": "\n    Berkowitz algorithm for computing the characteristic polynomial.\n\n    Explanation\n    ===========\n\n    The Berkowitz algorithm is a division-free algorithm for computing the\n    characteristic polynomial of a matrix over any commutative ring using only\n    arithmetic in the coefficient ring. This implementation is for sparse\n    matrices represented in a dict-of-dicts format (like :class:`SDM`).\n\n    Examples\n    ========\n\n    >>> from sympy import Matrix\n    >>> from sympy.polys.matrices.sdm import sdm_berk\n    >>> from sympy.polys.domains import ZZ\n    >>> M = {0: {0: ZZ(1), 1:ZZ(2)}, 1: {0:ZZ(3), 1:ZZ(4)}}\n    >>> sdm_berk(M, 2, ZZ)\n    {0: 1, 1: -5, 2: -2}\n    >>> Matrix([[1, 2], [3, 4]]).charpoly()\n    PurePoly(lambda**2 - 5*lambda - 2, lambda, domain='ZZ')\n\n    See Also\n    ========\n\n    sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly\n        The high-level interface to this function.\n    sympy.polys.matrices.dense.ddm_berk\n        The dense version of this function.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Samuelson%E2%80%93Berkowitz_algorithm\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "sdm_irref",
    "full_id": "sympy.polys.matrices.sdm.sdm_irref",
    "type": "function",
    "description": "RREF and pivots of a sparse matrix *A*.\n\n    Compute the reduced row echelon form (RREF) of the matrix *A* and return a\n    list of the pivot columns. This routine does not work in place and leaves\n    the original matrix *A* unmodified.\n\n    The domain of the matrix must be a field.\n\n    Examples\n    ========\n\n    This routine works with a dict of dicts sparse representation of a matrix:\n\n    >>> from sympy import QQ\n    >>> from sympy.polys.matrices.sdm import sdm_irref\n    >>> A = {0: {0: QQ(1), 1: QQ(2)}, 1: {0: QQ(3), 1: QQ(4)}}\n    >>> Arref, pivots, _ = sdm_irref(A)\n    >>> Arref\n    {0: {0: 1}, 1: {1: 1}}\n    >>> pivots\n    [0, 1]\n\n    The analogous calculation with :py:class:`~.MutableDenseMatrix` would be\n\n    >>> from sympy import Matrix\n    >>> M = Matrix([[1, 2], [3, 4]])\n    >>> Mrref, pivots = M.rref()\n    >>> Mrref\n    Matrix([\n    [1, 0],\n    [0, 1]])\n    >>> pivots\n    (0, 1)\n\n    Notes\n    =====\n\n    The cost of this algorithm is determined purely by the nonzero elements of\n    the matrix. No part of the cost of any step in this algorithm depends on\n    the number of rows or columns in the matrix. No step depends even on the\n    number of nonzero rows apart from the primary loop over those rows. The\n    implementation is much faster than ddm_rref for sparse matrices. In fact\n    at the time of writing it is also (slightly) faster than the dense\n    implementation even if the input is a fully dense matrix so it seems to be\n    faster in all cases.\n\n    The elements of the matrix should support exact division with ``/``. For\n    example elements of any domain that is a field (e.g. ``QQ``) should be\n    fine. No attempt is made to handle inexact arithmetic.\n\n    See Also\n    ========\n\n    sympy.polys.matrices.domainmatrix.DomainMatrix.rref\n        The higher-level function that would normally be used to call this\n        routine.\n    sympy.polys.matrices.dense.ddm_irref\n        The dense equivalent of this routine.\n    sdm_rref_den\n        Fraction-free version of this routine.\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "sdm_nullspace_from_rref",
    "full_id": "sympy.polys.matrices.sdm.sdm_nullspace_from_rref",
    "type": "function",
    "description": "Get nullspace from A which is in RREF",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "sdm_particular_from_rref",
    "full_id": "sympy.polys.matrices.sdm.sdm_particular_from_rref",
    "type": "function",
    "description": "Get a particular solution from A which is in RREF",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "sdm_rref_den",
    "full_id": "sympy.polys.matrices.sdm.sdm_rref_den",
    "type": "function",
    "description": "\n    Return the reduced row echelon form (RREF) of A with denominator.\n\n    The RREF is computed using fraction-free Gauss-Jordan elimination.\n\n    Explanation\n    ===========\n\n    The algorithm used is the fraction-free version of Gauss-Jordan elimination\n    described as FFGJ in [1]_. Here it is modified to handle zero or missing\n    pivots and to avoid redundant arithmetic. This implementation is also\n    optimized for sparse matrices.\n\n    The domain $K$ must support exact division (``K.exquo``) but does not need\n    to be a field. This method is suitable for most exact rings and fields like\n    :ref:`ZZ`, :ref:`QQ` and :ref:`QQ(a)`. In the case of :ref:`QQ` or\n    :ref:`K(x)` it might be more efficient to clear denominators and use\n    :ref:`ZZ` or :ref:`K[x]` instead.\n\n    For inexact domains like :ref:`RR` and :ref:`CC` use ``ddm_irref`` instead.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.matrices.sdm import sdm_rref_den\n    >>> from sympy.polys.domains import ZZ\n    >>> A = {0: {0: ZZ(1), 1: ZZ(2)}, 1: {0: ZZ(3), 1: ZZ(4)}}\n    >>> A_rref, den, pivots = sdm_rref_den(A, ZZ)\n    >>> A_rref\n    {0: {0: -2}, 1: {1: -2}}\n    >>> den\n    -2\n    >>> pivots\n    [0, 1]\n\n    See Also\n    ========\n\n    sympy.polys.matrices.domainmatrix.DomainMatrix.rref_den\n        Higher-level interface to ``sdm_rref_den`` that would usually be used\n        instead of calling this function directly.\n    sympy.polys.matrices.sdm.sdm_rref_den\n        The ``SDM`` method that uses this function.\n    sdm_irref\n        Computes RREF using field division.\n    ddm_irref_den\n        The dense version of this algorithm.\n\n    References\n    ==========\n\n    .. [1] Fraction-free algorithms for linear and polynomial equations.\n        George C. Nakos , Peter R. Turner , Robert M. Williams.\n        https://dl.acm.org/doi/10.1145/271130.271133\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.matrices._dfm.DFM.add",
    "type": "method",
    "description": "Add two DFM matrices.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "applyfunc",
    "full_id": "sympy.polys.matrices._dfm.DFM.applyfunc",
    "type": "method",
    "description": "Apply a function to each entry of a DFM matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "charpoly",
    "full_id": "sympy.polys.matrices._dfm.DFM.charpoly",
    "type": "method",
    "description": "\n        Compute the characteristic polynomial of the matrix using FLINT.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> M = Matrix([[1, 2], [3, 4]])\n        >>> dfm = M.to_DM().to_dfm()  # need ground types = 'flint'\n        >>> dfm\n        [[1, 2], [3, 4]]\n        >>> dfm.charpoly()\n        [1, -5, -2]\n\n        Notes\n        =====\n\n        Calls the ``.charpoly()`` method of the underlying FLINT matrix.\n\n        For :ref:`ZZ` or :ref:`QQ` this calls ``fmpz_mat_charpoly`` or\n        ``fmpq_mat_charpoly`` respectively.\n\n        At the time of writing the implementation of ``fmpq_mat_charpoly``\n        clears a denominator from the whole matrix and then calls\n        ``fmpz_mat_charpoly``. The coefficients of the characteristic\n        polynomial are then multiplied by powers of the denominator.\n\n        The ``fmpz_mat_charpoly`` method uses a modular algorithm with CRT\n        reconstruction. The modular algorithm uses ``nmod_mat_charpoly`` which\n        uses Berkowitz for small matrices and non-prime moduli or otherwise\n        the Danilevsky method.\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.charpoly\n            Higher level interface to compute the characteristic polynomial of\n            a matrix.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "convert_to",
    "full_id": "sympy.polys.matrices._dfm.DFM.convert_to",
    "type": "method",
    "description": "Convert to a new domain.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "copy",
    "full_id": "sympy.polys.matrices._dfm.DFM.copy",
    "type": "method",
    "description": "Return a copy of self.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "det",
    "full_id": "sympy.polys.matrices._dfm.DFM.det",
    "type": "method",
    "description": "\n        Compute the determinant of the matrix using FLINT.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> M = Matrix([[1, 2], [3, 4]])\n        >>> dfm = M.to_DM().to_dfm()\n        >>> dfm\n        [[1, 2], [3, 4]]\n        >>> dfm.det()\n        -2\n\n        Notes\n        =====\n\n        Calls the ``.det()`` method of the underlying FLINT matrix.\n\n        For :ref:`ZZ` or :ref:`QQ` this calls ``fmpz_mat_det`` or\n        ``fmpq_mat_det`` respectively.\n\n        At the time of writing the implementation of ``fmpz_mat_det`` uses one\n        of several algorithms depending on the size of the matrix and bit size\n        of the entries. The algorithms used are:\n\n        - Cofactor for very small (up to 4x4) matrices.\n        - Bareiss for small (up to 25x25) matrices.\n        - Modular algorithms for larger matrices (up to 60x60) or for larger\n          matrices with large bit sizes.\n        - Modular \"accelerated\" for larger matrices (60x60 upwards) if the bit\n          size is smaller than the dimensions of the matrix.\n\n        The implementation of ``fmpq_mat_det`` clears denominators from each\n        row (not the whole matrix) and then calls ``fmpz_mat_det`` and divides\n        by the product of the denominators.\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.det\n            Higher level interface to compute the determinant of a matrix.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "diag",
    "full_id": "sympy.polys.matrices._dfm.DFM.diag",
    "type": "method",
    "description": "Return a diagonal matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "diagonal",
    "full_id": "sympy.polys.matrices._dfm.DFM.diagonal",
    "type": "method",
    "description": "Return the diagonal of a DFM matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "extract",
    "full_id": "sympy.polys.matrices._dfm.DFM.extract",
    "type": "method",
    "description": "Extract a submatrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "extract_slice",
    "full_id": "sympy.polys.matrices._dfm.DFM.extract_slice",
    "type": "method",
    "description": "Slice a DFM.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "eye",
    "full_id": "sympy.polys.matrices._dfm.DFM.eye",
    "type": "method",
    "description": "Return the identity matrix of size n.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_ddm",
    "full_id": "sympy.polys.matrices._dfm.DFM.from_ddm",
    "type": "method",
    "description": "Convert from a DDM.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dod",
    "full_id": "sympy.polys.matrices._dfm.DFM.from_dod",
    "type": "method",
    "description": "Inverse of :meth:`to_dod`.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_dok",
    "full_id": "sympy.polys.matrices._dfm.DFM.from_dok",
    "type": "method",
    "description": "Inverse of :math:`to_dod`.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_flat_nz",
    "full_id": "sympy.polys.matrices._dfm.DFM.from_flat_nz",
    "type": "method",
    "description": "Inverse of :meth:`to_flat_nz`.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_list",
    "full_id": "sympy.polys.matrices._dfm.DFM.from_list",
    "type": "method",
    "description": "Construct from a nested list.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "from_list_flat",
    "full_id": "sympy.polys.matrices._dfm.DFM.from_list_flat",
    "type": "method",
    "description": "Inverse of :meth:`to_list_flat`.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "getitem",
    "full_id": "sympy.polys.matrices._dfm.DFM.getitem",
    "type": "method",
    "description": "Get the ``(i, j)``-th entry.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "hstack",
    "full_id": "sympy.polys.matrices._dfm.DFM.hstack",
    "type": "method",
    "description": "Horizontally stack matrices.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "inv",
    "full_id": "sympy.polys.matrices._dfm.DFM.inv",
    "type": "method",
    "description": "\n        Compute the inverse of a matrix using FLINT.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, QQ\n        >>> M = Matrix([[1, 2], [3, 4]])\n        >>> dfm = M.to_DM().to_dfm().convert_to(QQ)\n        >>> dfm\n        [[1, 2], [3, 4]]\n        >>> dfm.inv()\n        [[-2, 1], [3/2, -1/2]]\n        >>> dfm.matmul(dfm.inv())\n        [[1, 0], [0, 1]]\n\n        Notes\n        =====\n\n        Calls the ``.inv()`` method of the underlying FLINT matrix.\n\n        For now this will raise an error if the domain is :ref:`ZZ` but will\n        use the FLINT method for :ref:`QQ`.\n\n        The FLINT methods for :ref:`ZZ` and :ref:`QQ` are ``fmpz_mat_inv`` and\n        ``fmpq_mat_inv`` respectively. The ``fmpz_mat_inv`` method computes an\n        inverse with denominator. This is implemented by calling\n        ``fmpz_mat_solve`` (see notes in :meth:`lu_solve` about the algorithm).\n\n        The ``fmpq_mat_inv`` method clears denominators from each row and then\n        multiplies those into the rhs identity matrix before calling\n        ``fmpz_mat_solve``.\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.inv\n            Higher level method for computing the inverse of a matrix.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_diagonal",
    "full_id": "sympy.polys.matrices._dfm.DFM.is_diagonal",
    "type": "method",
    "description": "Return ``True`` if the matrix is diagonal.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_lower",
    "full_id": "sympy.polys.matrices._dfm.DFM.is_lower",
    "type": "method",
    "description": "Return ``True`` if the matrix is lower triangular.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_upper",
    "full_id": "sympy.polys.matrices._dfm.DFM.is_upper",
    "type": "method",
    "description": "Return ``True`` if the matrix is upper triangular.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "is_zero_matrix",
    "full_id": "sympy.polys.matrices._dfm.DFM.is_zero_matrix",
    "type": "method",
    "description": "Return ``True`` if the matrix is the zero matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "iter_items",
    "full_id": "sympy.polys.matrices._dfm.DFM.iter_items",
    "type": "method",
    "description": "Iterate over indices and values of nonzero elements of the matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "iter_values",
    "full_id": "sympy.polys.matrices._dfm.DFM.iter_values",
    "type": "method",
    "description": "Iterater over the non-zero values of the matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lll",
    "full_id": "sympy.polys.matrices._dfm.DFM.lll",
    "type": "method",
    "description": "Compute LLL-reduced basis using FLINT.\n\n        See :meth:`lll_transform` for more information.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> M = Matrix([[1, 2, 3], [4, 5, 6]])\n        >>> M.to_DM().to_dfm().lll()\n        [[2, 1, 0], [-1, 1, 3]]\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.lll\n            Higher level interface to compute LLL-reduced basis.\n        lll_transform\n            Compute LLL-reduced basis and transform matrix.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lll_transform",
    "full_id": "sympy.polys.matrices._dfm.DFM.lll_transform",
    "type": "method",
    "description": "Compute LLL-reduced basis and transform using FLINT.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix\n        >>> M = Matrix([[1, 2, 3], [4, 5, 6]]).to_DM().to_dfm()\n        >>> M_lll, T = M.lll_transform()\n        >>> M_lll\n        [[2, 1, 0], [-1, 1, 3]]\n        >>> T\n        [[-2, 1], [3, -1]]\n        >>> T.matmul(M) == M_lll\n        True\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.lll\n            Higher level interface to compute LLL-reduced basis.\n        lll\n            Compute LLL-reduced basis without transform matrix.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lu",
    "full_id": "sympy.polys.matrices._dfm.DFM.lu",
    "type": "method",
    "description": "Return the LU decomposition of the matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "lu_solve",
    "full_id": "sympy.polys.matrices._dfm.DFM.lu_solve",
    "type": "method",
    "description": "\n        Solve a matrix equation using FLINT.\n\n        Examples\n        ========\n\n        >>> from sympy import Matrix, QQ\n        >>> M = Matrix([[1, 2], [3, 4]])\n        >>> dfm = M.to_DM().to_dfm().convert_to(QQ)\n        >>> dfm\n        [[1, 2], [3, 4]]\n        >>> rhs = Matrix([1, 2]).to_DM().to_dfm().convert_to(QQ)\n        >>> dfm.lu_solve(rhs)\n        [[0], [1/2]]\n\n        Notes\n        =====\n\n        Calls the ``.solve()`` method of the underlying FLINT matrix.\n\n        For now this will raise an error if the domain is :ref:`ZZ` but will\n        use the FLINT method for :ref:`QQ`.\n\n        The FLINT methods for :ref:`ZZ` and :ref:`QQ` are ``fmpz_mat_solve``\n        and ``fmpq_mat_solve`` respectively. The ``fmpq_mat_solve`` method\n        uses one of two algorithms:\n\n        - For small matrices (<25 rows) it clears denominators between the\n          matrix and rhs and uses ``fmpz_mat_solve``.\n        - For larger matrices it uses ``fmpq_mat_solve_dixon`` which is a\n          modular approach with CRT reconstruction over :ref:`QQ`.\n\n        The ``fmpz_mat_solve`` method uses one of four algorithms:\n\n        - For very small (<= 3x3) matrices it uses a Cramer's rule.\n        - For small (<= 15x15) matrices it uses a fraction-free LU solve.\n        - Otherwise it uses either Dixon or another multimodular approach.\n\n        See Also\n        ========\n\n        sympy.polys.matrices.domainmatrix.DomainMatrix.lu_solve\n            Higher level interface to solve a matrix equation.\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "matmul",
    "full_id": "sympy.polys.matrices._dfm.DFM.matmul",
    "type": "method",
    "description": "Multiply two DFM matrices.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.polys.matrices._dfm.DFM.mul",
    "type": "method",
    "description": "Multiply a DFM matrix from the right by a scalar.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "mul_elementwise",
    "full_id": "sympy.polys.matrices._dfm.DFM.mul_elementwise",
    "type": "method",
    "description": "Elementwise multiplication of two DFM matrices.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "neg",
    "full_id": "sympy.polys.matrices._dfm.DFM.neg",
    "type": "method",
    "description": "Negate a DFM matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nnz",
    "full_id": "sympy.polys.matrices._dfm.DFM.nnz",
    "type": "method",
    "description": "Return the number of non-zero elements in the matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "nullspace",
    "full_id": "sympy.polys.matrices._dfm.DFM.nullspace",
    "type": "method",
    "description": "Return a basis for the nullspace of the matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "ones",
    "full_id": "sympy.polys.matrices._dfm.DFM.ones",
    "type": "method",
    "description": "Return a one DFM matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "particular",
    "full_id": "sympy.polys.matrices._dfm.DFM.particular",
    "type": "method",
    "description": "Return a particular solution to the system.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "rmul",
    "full_id": "sympy.polys.matrices._dfm.DFM.rmul",
    "type": "method",
    "description": "Multiply a DFM matrix from the left by a scalar.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "scc",
    "full_id": "sympy.polys.matrices._dfm.DFM.scc",
    "type": "method",
    "description": "Return the strongly connected components of the matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "setitem",
    "full_id": "sympy.polys.matrices._dfm.DFM.setitem",
    "type": "method",
    "description": "Set the ``(i, j)``-th entry.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "sub",
    "full_id": "sympy.polys.matrices._dfm.DFM.sub",
    "type": "method",
    "description": "Subtract two DFM matrices.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_ddm",
    "full_id": "sympy.polys.matrices._dfm.DFM.to_ddm",
    "type": "method",
    "description": "Convert to a DDM.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dfm",
    "full_id": "sympy.polys.matrices._dfm.DFM.to_dfm",
    "type": "method",
    "description": "Return self.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dfm_or_ddm",
    "full_id": "sympy.polys.matrices._dfm.DFM.to_dfm_or_ddm",
    "type": "method",
    "description": "\n        Convert to a :class:`DFM`.\n\n        This :class:`DFM` method exists to parallel the :class:`~.DDM` and\n        :class:`~.SDM` methods. For :class:`DFM` it will always return self.\n\n        See Also\n        ========\n\n        to_ddm\n        to_sdm\n        sympy.polys.matrices.domainmatrix.DomainMatrix.to_dfm_or_ddm\n        ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dod",
    "full_id": "sympy.polys.matrices._dfm.DFM.to_dod",
    "type": "method",
    "description": "Convert to a DOD.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_dok",
    "full_id": "sympy.polys.matrices._dfm.DFM.to_dok",
    "type": "method",
    "description": "Convert to a DOK.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_flat_nz",
    "full_id": "sympy.polys.matrices._dfm.DFM.to_flat_nz",
    "type": "method",
    "description": "Convert to a flat list of non-zeros.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_list",
    "full_id": "sympy.polys.matrices._dfm.DFM.to_list",
    "type": "method",
    "description": "Convert to a nested list.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_list_flat",
    "full_id": "sympy.polys.matrices._dfm.DFM.to_list_flat",
    "type": "method",
    "description": "Convert to a flat list.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "to_sdm",
    "full_id": "sympy.polys.matrices._dfm.DFM.to_sdm",
    "type": "method",
    "description": "Convert to a SDM.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "transpose",
    "full_id": "sympy.polys.matrices._dfm.DFM.transpose",
    "type": "method",
    "description": "Transpose a DFM matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "vstack",
    "full_id": "sympy.polys.matrices._dfm.DFM.vstack",
    "type": "method",
    "description": "Vertically stack matrices.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "zeros",
    "full_id": "sympy.polys.matrices._dfm.DFM.zeros",
    "type": "method",
    "description": "Return a zero DFM matrix.",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "smith_normal_form",
    "full_id": "sympy.polys.matrices.normalforms.smith_normal_form",
    "type": "function",
    "description": "\n    Return the Smith Normal Form of a matrix `m` over the ring `domain`.\n    This will only work if the ring is a principal ideal domain.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.normalforms import smith_normal_form\n    >>> m = DomainMatrix([[ZZ(12), ZZ(6), ZZ(4)],\n    ...                   [ZZ(3), ZZ(9), ZZ(6)],\n    ...                   [ZZ(2), ZZ(16), ZZ(14)]], (3, 3), ZZ)\n    >>> print(smith_normal_form(m).to_Matrix())\n    Matrix([[1, 0, 0], [0, 10, 0], [0, 0, -30]])\n\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "hermite_normal_form",
    "full_id": "sympy.polys.matrices.normalforms.hermite_normal_form",
    "type": "function",
    "description": "\n    Compute the Hermite Normal Form of :py:class:`~.DomainMatrix` *A* over\n    :ref:`ZZ`.\n\n    Examples\n    ========\n\n    >>> from sympy import ZZ\n    >>> from sympy.polys.matrices import DomainMatrix\n    >>> from sympy.polys.matrices.normalforms import hermite_normal_form\n    >>> m = DomainMatrix([[ZZ(12), ZZ(6), ZZ(4)],\n    ...                   [ZZ(3), ZZ(9), ZZ(6)],\n    ...                   [ZZ(2), ZZ(16), ZZ(14)]], (3, 3), ZZ)\n    >>> print(hermite_normal_form(m).to_Matrix())\n    Matrix([[10, 0, 2], [0, 15, 3], [0, 0, 2]])\n\n    Parameters\n    ==========\n\n    A : $m \\times n$ ``DomainMatrix`` over :ref:`ZZ`.\n\n    D : :ref:`ZZ`, optional\n        Let $W$ be the HNF of *A*. If known in advance, a positive integer *D*\n        being any multiple of $\\det(W)$ may be provided. In this case, if *A*\n        also has rank $m$, then we may use an alternative algorithm that works\n        mod *D* in order to prevent coefficient explosion.\n\n    check_rank : boolean, optional (default=False)\n        The basic assumption is that, if you pass a value for *D*, then\n        you already believe that *A* has rank $m$, so we do not waste time\n        checking it for you. If you do want this to be checked (and the\n        ordinary, non-modulo *D* algorithm to be used if the check fails), then\n        set *check_rank* to ``True``.\n\n    Returns\n    =======\n\n    :py:class:`~.DomainMatrix`\n        The HNF of matrix *A*.\n\n    Raises\n    ======\n\n    DMDomainError\n        If the domain of the matrix is not :ref:`ZZ`, or\n        if *D* is given but is not in :ref:`ZZ`.\n\n    DMShapeError\n        If the mod *D* algorithm is used but the matrix has more rows than\n        columns.\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n       (See Algorithms 2.4.5 and 2.4.8.)\n\n    ",
    "section": "What is domainmatrix?",
    "url": "https://docs.sympy.org/latest/modules/polys/domainmatrix.html"
  },
  {
    "name": "round_two",
    "full_id": "sympy.polys.numberfields.basis.round_two",
    "type": "function",
    "description": "\n    Zassenhaus's \"Round 2\" algorithm.\n\n    Explanation\n    ===========\n\n    Carry out Zassenhaus's \"Round 2\" algorithm on an irreducible polynomial\n    *T* over :ref:`ZZ` or :ref:`QQ`. This computes an integral basis and the\n    discriminant for the field $K = \\mathbb{Q}[x]/(T(x))$.\n\n    Alternatively, you may pass an :py:class:`~.AlgebraicField` instance, in\n    place of the polynomial *T*, in which case the algorithm is applied to the\n    minimal polynomial for the field's primitive element.\n\n    Ordinarily this function need not be called directly, as one can instead\n    access the :py:meth:`~.AlgebraicField.maximal_order`,\n    :py:meth:`~.AlgebraicField.integral_basis`, and\n    :py:meth:`~.AlgebraicField.discriminant` methods of an\n    :py:class:`~.AlgebraicField`.\n\n    Examples\n    ========\n\n    Working through an AlgebraicField:\n\n    >>> from sympy import Poly, QQ\n    >>> from sympy.abc import x\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\n    >>> K = QQ.alg_field_from_poly(T, \"theta\")\n    >>> print(K.maximal_order())\n    Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2\n    >>> print(K.discriminant())\n    -503\n    >>> print(K.integral_basis(fmt='sympy'))\n    [1, theta, theta/2 + theta**2/2]\n\n    Calling directly:\n\n    >>> from sympy import Poly\n    >>> from sympy.abc import x\n    >>> from sympy.polys.numberfields.basis import round_two\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\n    >>> print(round_two(T))\n    (Submodule[[2, 0, 0], [0, 2, 0], [0, 1, 1]]/2, -503)\n\n    The nilradicals mod $p$ that are sometimes computed during the Round Two\n    algorithm may be useful in further calculations. Pass a dictionary under\n    `radicals` to receive these:\n\n    >>> T = Poly(x**3 + 3*x**2 + 5)\n    >>> rad = {}\n    >>> ZK, dK = round_two(T, radicals=rad)\n    >>> print(rad)\n    {3: Submodule[[-1, 1, 0], [-1, 0, 1]]}\n\n    Parameters\n    ==========\n\n    T : :py:class:`~.Poly`, :py:class:`~.AlgebraicField`\n        Either (1) the irreducible polynomial over :ref:`ZZ` or :ref:`QQ`\n        defining the number field, or (2) an :py:class:`~.AlgebraicField`\n        representing the number field itself.\n\n    radicals : dict, optional\n        This is a way for any $p$-radicals (if computed) to be returned by\n        reference. If desired, pass an empty dictionary. If the algorithm\n        reaches the point where it computes the nilradical mod $p$ of the ring\n        of integers $Z_K$, then an $\\mathbb{F}_p$-basis for this ideal will be\n        stored in this dictionary under the key ``p``. This can be useful for\n        other algorithms, such as prime decomposition.\n\n    Returns\n    =======\n\n    Pair ``(ZK, dK)``, where:\n\n        ``ZK`` is a :py:class:`~sympy.polys.numberfields.modules.Submodule`\n        representing the maximal order.\n\n        ``dK`` is the discriminant of the field $K = \\mathbb{Q}[x]/(T(x))$.\n\n    See Also\n    ========\n\n    .AlgebraicField.maximal_order\n    .AlgebraicField.integral_basis\n    .AlgebraicField.discriminant\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n\n    ",
    "section": "Integral Basis",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "prime_decomp",
    "full_id": "sympy.polys.numberfields.primes.prime_decomp",
    "type": "function",
    "description": "\n    Compute the decomposition of rational prime *p* in a number field.\n\n    Explanation\n    ===========\n\n    Ordinarily this should be accessed through the\n    :py:meth:`~.AlgebraicField.primes_above` method of an\n    :py:class:`~.AlgebraicField`.\n\n    Examples\n    ========\n\n    >>> from sympy import Poly, QQ\n    >>> from sympy.abc import x, theta\n    >>> T = Poly(x ** 3 + x ** 2 - 2 * x + 8)\n    >>> K = QQ.algebraic_field((T, theta))\n    >>> print(K.primes_above(2))\n    [[ (2, x**2 + 1) e=1, f=1 ], [ (2, (x**2 + 3*x + 2)/2) e=1, f=1 ],\n     [ (2, (3*x**2 + 3*x)/2) e=1, f=1 ]]\n\n    Parameters\n    ==========\n\n    p : int\n        The rational prime whose decomposition is desired.\n\n    T : :py:class:`~.Poly`, optional\n        Monic irreducible polynomial defining the number field $K$ in which to\n        factor. NOTE: at least one of *T* or *ZK* must be provided.\n\n    ZK : :py:class:`~.Submodule`, optional\n        The maximal order for $K$, if already known.\n        NOTE: at least one of *T* or *ZK* must be provided.\n\n    dK : int, optional\n        The discriminant of the field $K$, if already known.\n\n    radical : :py:class:`~.Submodule`, optional\n        The nilradical mod *p* in the integers of $K$, if already known.\n\n    Returns\n    =======\n\n    List of :py:class:`~.PrimeIdeal` instances.\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n       (See Algorithm 6.2.9.)\n\n    ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        ZK : :py:class:`~.Submodule`\n            The maximal order where this ideal lives.\n        p : int\n            The rational prime this ideal divides.\n        alpha : :py:class:`~.PowerBasisElement`\n            Such that the ideal is equal to ``p*ZK + alpha*ZK``.\n        f : int\n            The inertia degree.\n        e : int, ``None``, optional\n            The ramification index, if already known. If ``None``, we will\n            compute it here.\n\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__add__",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.__add__",
    "type": "method",
    "description": "\n        Convert to a :py:class:`~.Submodule` and add to another\n        :py:class:`~.Submodule`.\n\n        See Also\n        ========\n\n        as_submodule\n\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__mul__",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.__mul__",
    "type": "method",
    "description": "\n        Convert to a :py:class:`~.Submodule` and multiply by another\n        :py:class:`~.Submodule` or a rational number.\n\n        See Also\n        ========\n\n        as_submodule\n\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "as_submodule",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.as_submodule",
    "type": "method",
    "description": "\n        Represent this prime ideal as a :py:class:`~.Submodule`.\n\n        Explanation\n        ===========\n\n        The :py:class:`~.PrimeIdeal` class serves to bundle information about\n        a prime ideal, such as its inertia degree, ramification index, and\n        two-generator representation, as well as to offer helpful methods like\n        :py:meth:`~.PrimeIdeal.valuation` and\n        :py:meth:`~.PrimeIdeal.test_factor`.\n\n        However, in order to be added and multiplied by other ideals or\n        rational numbers, it must first be converted into a\n        :py:class:`~.Submodule`, which is a class that supports these\n        operations.\n\n        In many cases, the user need not perform this conversion deliberately,\n        since it is automatically performed by the arithmetic operator methods\n        :py:meth:`~.PrimeIdeal.__add__` and :py:meth:`~.PrimeIdeal.__mul__`.\n\n        Raising a :py:class:`~.PrimeIdeal` to a non-negative integer power is\n        also supported.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, cyclotomic_poly, prime_decomp\n        >>> T = Poly(cyclotomic_poly(7))\n        >>> P0 = prime_decomp(7, T)[0]\n        >>> print(P0**6 == 7*P0.ZK)\n        True\n\n        Note that, on both sides of the equation above, we had a\n        :py:class:`~.Submodule`. In the next equation we recall that adding\n        ideals yields their GCD. This time, we need a deliberate conversion\n        to :py:class:`~.Submodule` on the right:\n\n        >>> print(P0 + 7*P0.ZK == P0.as_submodule())\n        True\n\n        Returns\n        =======\n\n        :py:class:`~.Submodule`\n            Will be equal to ``self.p * self.ZK + self.alpha * self.ZK``.\n\n        See Also\n        ========\n\n        __add__\n        __mul__\n\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "is_inert",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.is_inert",
    "type": "property",
    "description": "\n        Say whether the rational prime we divide is inert, i.e. stays prime in\n        our ring of integers.\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "reduce_ANP",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.reduce_ANP",
    "type": "method",
    "description": "\n        Reduce an :py:class:`~.ANP` to a \"small representative\" modulo this\n        prime ideal.\n\n        Parameters\n        ==========\n\n        elt : :py:class:`~.ANP`\n            The element to be reduced.\n\n        Returns\n        =======\n\n        :py:class:`~.ANP`\n            The reduced element.\n\n        See Also\n        ========\n\n        reduce_element\n        reduce_alg_num\n        .Submodule.reduce_element\n\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "reduce_alg_num",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.reduce_alg_num",
    "type": "method",
    "description": "\n        Reduce an :py:class:`~.AlgebraicNumber` to a \"small representative\"\n        modulo this prime ideal.\n\n        Parameters\n        ==========\n\n        elt : :py:class:`~.AlgebraicNumber`\n            The element to be reduced.\n\n        Returns\n        =======\n\n        :py:class:`~.AlgebraicNumber`\n            The reduced element.\n\n        See Also\n        ========\n\n        reduce_element\n        reduce_ANP\n        .Submodule.reduce_element\n\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "reduce_element",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.reduce_element",
    "type": "method",
    "description": "\n        Reduce a :py:class:`~.PowerBasisElement` to a \"small representative\"\n        modulo this prime ideal.\n\n        Parameters\n        ==========\n\n        elt : :py:class:`~.PowerBasisElement`\n            The element to be reduced.\n\n        Returns\n        =======\n\n        :py:class:`~.PowerBasisElement`\n            The reduced element.\n\n        See Also\n        ========\n\n        reduce_ANP\n        reduce_alg_num\n        .Submodule.reduce_element\n\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "repr",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.repr",
    "type": "method",
    "description": "\n        Print a representation of this prime ideal.\n\n        Examples\n        ========\n\n        >>> from sympy import cyclotomic_poly, QQ\n        >>> from sympy.abc import x, zeta\n        >>> T = cyclotomic_poly(7, x)\n        >>> K = QQ.algebraic_field((T, zeta))\n        >>> P = K.primes_above(11)\n        >>> print(P[0].repr())\n        [ (11, x**3 + 5*x**2 + 4*x - 1) e=1, f=3 ]\n        >>> print(P[0].repr(field_gen=zeta))\n        [ (11, zeta**3 + 5*zeta**2 + 4*zeta - 1) e=1, f=3 ]\n        >>> print(P[0].repr(field_gen=zeta, just_gens=True))\n        (11, zeta**3 + 5*zeta**2 + 4*zeta - 1)\n\n        Parameters\n        ==========\n\n        field_gen : :py:class:`~.Symbol`, ``None``, optional (default=None)\n            The symbol to use for the generator of the field. This will appear\n            in our representation of ``self.alpha``. If ``None``, we use the\n            variable of the defining polynomial of ``self.ZK``.\n        just_gens : bool, optional (default=False)\n            If ``True``, just print the \"(p, alpha)\" part, showing \"just the\n            generators\" of the prime ideal. Otherwise, print a string of the\n            form \"[ (p, alpha) e=..., f=... ]\", giving the ramification index\n            and inertia degree, along with the generators.\n\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "test_factor",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.test_factor",
    "type": "method",
    "description": "\n        Compute a test factor for this prime ideal.\n\n        Explanation\n        ===========\n\n        Write $\\mathfrak{p}$ for this prime ideal, $p$ for the rational prime\n        it divides. Then, for computing $\\mathfrak{p}$-adic valuations it is\n        useful to have a number $\\beta \\in \\mathbb{Z}_K$ such that\n        $p/\\mathfrak{p} = p \\mathbb{Z}_K + \\beta \\mathbb{Z}_K$.\n\n        Essentially, this is the same as the number $\\Psi$ (or the \"reagent\")\n        from Kummer's 1847 paper (*Ueber die Zerlegung...*, Crelle vol. 35) in\n        which ideal divisors were invented.\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "valuation",
    "full_id": "sympy.polys.numberfields.primes.PrimeIdeal.valuation",
    "type": "method",
    "description": "\n        Compute the $\\mathfrak{p}$-adic valuation of integral ideal I at this\n        prime ideal.\n\n        Parameters\n        ==========\n\n        I : :py:class:`~.Submodule`\n\n        See Also\n        ========\n\n        prime_valuation\n\n        ",
    "section": "Prime Decomposition",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "prime_valuation",
    "full_id": "sympy.polys.numberfields.primes.prime_valuation",
    "type": "function",
    "description": "\n    Compute the *P*-adic valuation for an integral ideal *I*.\n\n    Examples\n    ========\n\n    >>> from sympy import QQ\n    >>> from sympy.polys.numberfields import prime_valuation\n    >>> K = QQ.cyclotomic_field(5)\n    >>> P = K.primes_above(5)\n    >>> ZK = K.maximal_order()\n    >>> print(prime_valuation(25*ZK, P[0]))\n    8\n\n    Parameters\n    ==========\n\n    I : :py:class:`~.Submodule`\n        An integral ideal whose valuation is desired.\n\n    P : :py:class:`~.PrimeIdeal`\n        The prime at which to compute the valuation.\n\n    Returns\n    =======\n\n    int\n\n    See Also\n    ========\n\n    .PrimeIdeal.valuation\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n       (See Algorithm 4.8.17.)\n\n    ",
    "section": "p-adic Valuation",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "galois_group",
    "full_id": "sympy.polys.numberfields.galoisgroups.galois_group",
    "type": "function",
    "description": "\n    Compute the Galois group for polynomials *f* up to degree 6.\n\n    Examples\n    ========\n\n    >>> from sympy import galois_group\n    >>> from sympy.abc import x\n    >>> f = x**4 + 1\n    >>> G, alt = galois_group(f)\n    >>> print(G)\n    PermutationGroup([\n    (0 1)(2 3),\n    (0 2)(1 3)])\n\n    The group is returned along with a boolean, indicating whether it is\n    contained in the alternating group $A_n$, where $n$ is the degree of *T*.\n    Along with other group properties, this can help determine which group it\n    is:\n\n    >>> alt\n    True\n    >>> G.order()\n    4\n\n    Alternatively, the group can be returned by name:\n\n    >>> G_name, _ = galois_group(f, by_name=True)\n    >>> print(G_name)\n    S4TransitiveSubgroups.V\n\n    The group itself can then be obtained by calling the name's\n    ``get_perm_group()`` method:\n\n    >>> G_name.get_perm_group()\n    PermutationGroup([\n    (0 1)(2 3),\n    (0 2)(1 3)])\n\n    Group names are values of the enum classes\n    :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`,\n    :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`,\n    etc.\n\n    Parameters\n    ==========\n\n    f : Expr\n        Irreducible polynomial over :ref:`ZZ` or :ref:`QQ`, whose Galois group\n        is to be determined.\n    gens : optional list of symbols\n        For converting *f* to Poly, and will be passed on to the\n        :py:func:`~.poly_from_expr` function.\n    by_name : bool, default False\n        If ``True``, the Galois group will be returned by name.\n        Otherwise it will be returned as a :py:class:`~.PermutationGroup`.\n    max_tries : int, default 30\n        Make at most this many attempts in those steps that involve\n        generating Tschirnhausen transformations.\n    randomize : bool, default False\n        If ``True``, then use random coefficients when generating Tschirnhausen\n        transformations. Otherwise try transformations in a fixed order. Both\n        approaches start with small coefficients and degrees and work upward.\n    args : optional\n        For converting *f* to Poly, and will be passed on to the\n        :py:func:`~.poly_from_expr` function.\n\n    Returns\n    =======\n\n    Pair ``(G, alt)``\n        The first element ``G`` indicates the Galois group. It is an instance\n        of one of the :py:class:`sympy.combinatorics.galois.S1TransitiveSubgroups`\n        :py:class:`sympy.combinatorics.galois.S2TransitiveSubgroups`, etc. enum\n        classes if *by_name* was ``True``, and a :py:class:`~.PermutationGroup`\n        if ``False``.\n\n        The second element is a boolean, saying whether the group is contained\n        in the alternating group $A_n$ ($n$ the degree of *T*).\n\n    Raises\n    ======\n\n    ValueError\n        if *f* is of an unsupported degree.\n\n    MaxTriesException\n        if could not complete before exceeding *max_tries* in those steps\n        that involve generating Tschirnhausen transformations.\n\n    See Also\n    ========\n\n    .Poly.galois_group\n\n    ",
    "section": "Galois Groups",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "minimal_polynomial",
    "full_id": "sympy.polys.numberfields.minpoly.minimal_polynomial",
    "type": "function",
    "description": "\n    Computes the minimal polynomial of an algebraic element.\n\n    Parameters\n    ==========\n\n    ex : Expr\n        Element or expression whose minimal polynomial is to be calculated.\n\n    x : Symbol, optional\n        Independent variable of the minimal polynomial\n\n    compose : boolean, optional (default=True)\n        Method to use for computing minimal polynomial. If ``compose=True``\n        (default) then ``_minpoly_compose`` is used, if ``compose=False`` then\n        groebner bases are used.\n\n    polys : boolean, optional (default=False)\n        If ``True`` returns a ``Poly`` object else an ``Expr`` object.\n\n    domain : Domain, optional\n        Ground domain\n\n    Notes\n    =====\n\n    By default ``compose=True``, the minimal polynomial of the subexpressions of ``ex``\n    are computed, then the arithmetic operations on them are performed using the resultant\n    and factorization.\n    If ``compose=False``, a bottom-up algorithm is used with ``groebner``.\n    The default algorithm stalls less frequently.\n\n    If no ground domain is given, it will be generated automatically from the expression.\n\n    Examples\n    ========\n\n    >>> from sympy import minimal_polynomial, sqrt, solve, QQ\n    >>> from sympy.abc import x, y\n\n    >>> minimal_polynomial(sqrt(2), x)\n    x**2 - 2\n    >>> minimal_polynomial(sqrt(2), x, domain=QQ.algebraic_field(sqrt(2)))\n    x - sqrt(2)\n    >>> minimal_polynomial(sqrt(2) + sqrt(3), x)\n    x**4 - 10*x**2 + 1\n    >>> minimal_polynomial(solve(x**3 + x + 3)[0], x)\n    x**3 + x + 3\n    >>> minimal_polynomial(sqrt(y), x)\n    x**2 - y\n\n    ",
    "section": "Finding Minimal Polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "minpoly",
    "full_id": "sympy.polys.numberfields.minpoly.minpoly",
    "type": "function",
    "description": "This is a synonym for :py:func:`~.minimal_polynomial`.",
    "section": "Finding Minimal Polynomials",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "field_isomorphism",
    "full_id": "sympy.polys.numberfields.subfield.field_isomorphism",
    "type": "function",
    "description": "\n    Find an embedding of one number field into another.\n\n    Explanation\n    ===========\n\n    This function looks for an isomorphism from $\\mathbb{Q}(a)$ onto some\n    subfield of $\\mathbb{Q}(b)$. Thus, it solves the Subfield Problem.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt, field_isomorphism, I\n    >>> print(field_isomorphism(3, sqrt(2)))  # doctest: +SKIP\n    [3]\n    >>> print(field_isomorphism( I*sqrt(3), I*sqrt(3)/2))  # doctest: +SKIP\n    [2, 0]\n\n    Parameters\n    ==========\n\n    a : :py:class:`~.Expr`\n        Any expression representing an algebraic number.\n    b : :py:class:`~.Expr`\n        Any expression representing an algebraic number.\n    fast : boolean, optional (default=True)\n        If ``True``, we first attempt a potentially faster way of computing the\n        isomorphism, falling back on a slower method if this fails. If\n        ``False``, we go directly to the slower method, which is guaranteed to\n        return a result.\n\n    Returns\n    =======\n\n    List of rational numbers, or None\n        If $\\mathbb{Q}(a)$ is not isomorphic to some subfield of\n        $\\mathbb{Q}(b)$, then return ``None``. Otherwise, return a list of\n        rational numbers representing an element of $\\mathbb{Q}(b)$ to which\n        $a$ may be mapped, in order to define a monomorphism, i.e. an\n        isomorphism from $\\mathbb{Q}(a)$ to some subfield of $\\mathbb{Q}(b)$.\n        The elements of the list are the coefficients of falling powers of $b$.\n\n    ",
    "section": "The Subfield Problem",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "primitive_element",
    "full_id": "sympy.polys.numberfields.subfield.primitive_element",
    "type": "function",
    "description": "\n    Find a single generator for a number field given by several generators.\n\n    Explanation\n    ===========\n\n    The basic problem is this: Given several algebraic numbers\n    $\\alpha_1, \\alpha_2, \\ldots, \\alpha_n$, find a single algebraic number\n    $\\theta$ such that\n    $\\mathbb{Q}(\\alpha_1, \\alpha_2, \\ldots, \\alpha_n) = \\mathbb{Q}(\\theta)$.\n\n    This function actually guarantees that $\\theta$ will be a linear\n    combination of the $\\alpha_i$, with non-negative integer coefficients.\n\n    Furthermore, if desired, this function will tell you how to express each\n    $\\alpha_i$ as a $\\mathbb{Q}$-linear combination of the powers of $\\theta$.\n\n    Examples\n    ========\n\n    >>> from sympy import primitive_element, sqrt, S, minpoly, simplify\n    >>> from sympy.abc import x\n    >>> f, lincomb, reps = primitive_element([sqrt(2), sqrt(3)], x, ex=True)\n\n    Then ``lincomb`` tells us the primitive element as a linear combination of\n    the given generators ``sqrt(2)`` and ``sqrt(3)``.\n\n    >>> print(lincomb)\n    [1, 1]\n\n    This means the primtiive element is $\\sqrt{2} + \\sqrt{3}$.\n    Meanwhile ``f`` is the minimal polynomial for this primitive element.\n\n    >>> print(f)\n    x**4 - 10*x**2 + 1\n    >>> print(minpoly(sqrt(2) + sqrt(3), x))\n    x**4 - 10*x**2 + 1\n\n    Finally, ``reps`` (which was returned only because we set keyword arg\n    ``ex=True``) tells us how to recover each of the generators $\\sqrt{2}$ and\n    $\\sqrt{3}$ as $\\mathbb{Q}$-linear combinations of the powers of the\n    primitive element $\\sqrt{2} + \\sqrt{3}$.\n\n    >>> print([S(r) for r in reps[0]])\n    [1/2, 0, -9/2, 0]\n    >>> theta = sqrt(2) + sqrt(3)\n    >>> print(simplify(theta**3/2 - 9*theta/2))\n    sqrt(2)\n    >>> print([S(r) for r in reps[1]])\n    [-1/2, 0, 11/2, 0]\n    >>> print(simplify(-theta**3/2 + 11*theta/2))\n    sqrt(3)\n\n    Parameters\n    ==========\n\n    extension : list of :py:class:`~.Expr`\n        Each expression must represent an algebraic number $\\alpha_i$.\n    x : :py:class:`~.Symbol`, optional (default=None)\n        The desired symbol to appear in the computed minimal polynomial for the\n        primitive element $\\theta$. If ``None``, we use a dummy symbol.\n    ex : boolean, optional (default=False)\n        If and only if ``True``, compute the representation of each $\\alpha_i$\n        as a $\\mathbb{Q}$-linear combination over the powers of $\\theta$.\n    polys : boolean, optional (default=False)\n        If ``True``, return the minimal polynomial as a :py:class:`~.Poly`.\n        Otherwise return it as an :py:class:`~.Expr`.\n\n    Returns\n    =======\n\n    Pair (f, coeffs) or triple (f, coeffs, reps), where:\n        ``f`` is the minimal polynomial for the primitive element.\n        ``coeffs`` gives the primitive element as a linear combination of the\n        given generators.\n        ``reps`` is present if and only if argument ``ex=True`` was passed,\n        and is a list of lists of rational numbers. Each list gives the\n        coefficients of falling powers of the primitive element, to recover\n        one of the original, given generators.\n\n    ",
    "section": "The Subfield Problem",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "to_number_field",
    "full_id": "sympy.polys.numberfields.subfield.to_number_field",
    "type": "function",
    "description": "\n    Express one algebraic number in the field generated by another.\n\n    Explanation\n    ===========\n\n    Given two algebraic numbers $\\eta, \\theta$, this function either expresses\n    $\\eta$ as an element of $\\mathbb{Q}(\\theta)$, or else raises an exception\n    if $\\eta \\not\\in \\mathbb{Q}(\\theta)$.\n\n    This function is essentially just a convenience, utilizing\n    :py:func:`~.field_isomorphism` (our solution of the Subfield Problem) to\n    solve this, the Field Membership Problem.\n\n    As an additional convenience, this function allows you to pass a list of\n    algebraic numbers $\\alpha_1, \\alpha_2, \\ldots, \\alpha_n$ instead of $\\eta$.\n    It then computes $\\eta$ for you, as a solution of the Primitive Element\n    Problem, using :py:func:`~.primitive_element` on the list of $\\alpha_i$.\n\n    Examples\n    ========\n\n    >>> from sympy import sqrt, to_number_field\n    >>> eta = sqrt(2)\n    >>> theta = sqrt(2) + sqrt(3)\n    >>> a = to_number_field(eta, theta)\n    >>> print(type(a))\n    <class 'sympy.core.numbers.AlgebraicNumber'>\n    >>> a.root\n    sqrt(2) + sqrt(3)\n    >>> print(a)\n    sqrt(2)\n    >>> a.coeffs()\n    [1/2, 0, -9/2, 0]\n\n    We get an :py:class:`~.AlgebraicNumber`, whose ``.root`` is $\\theta$, whose\n    value is $\\eta$, and whose ``.coeffs()`` show how to write $\\eta$ as a\n    $\\mathbb{Q}$-linear combination in falling powers of $\\theta$.\n\n    Parameters\n    ==========\n\n    extension : :py:class:`~.Expr` or list of :py:class:`~.Expr`\n        Either the algebraic number that is to be expressed in the other field,\n        or else a list of algebraic numbers, a primitive element for which is\n        to be expressed in the other field.\n    theta : :py:class:`~.Expr`, None, optional (default=None)\n        If an :py:class:`~.Expr` representing an algebraic number, behavior is\n        as described under **Explanation**. If ``None``, then this function\n        reduces to a shorthand for calling :py:func:`~.primitive_element` on\n        ``extension`` and turning the computed primitive element into an\n        :py:class:`~.AlgebraicNumber`.\n    gen : :py:class:`~.Symbol`, None, optional (default=None)\n        If provided, this will be used as the generator symbol for the minimal\n        polynomial in the returned :py:class:`~.AlgebraicNumber`.\n    alias : str, :py:class:`~.Symbol`, None, optional (default=None)\n        If provided, this will be used as the alias symbol for the returned\n        :py:class:`~.AlgebraicNumber`.\n\n    Returns\n    =======\n\n    AlgebraicNumber\n        Belonging to $\\mathbb{Q}(\\theta)$ and equaling $\\eta$.\n\n    Raises\n    ======\n\n    IsomorphismFailed\n        If $\\eta \\not\\in \\mathbb{Q}(\\theta)$.\n\n    See Also\n    ========\n\n    field_isomorphism\n    primitive_element\n\n    ",
    "section": "The Subfield Problem",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__call__",
    "full_id": "sympy.polys.numberfields.modules.Module.__call__",
    "type": "method",
    "description": "\n        Generate a :py:class:`~.ModuleElement` belonging to this module.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import Poly, cyclotomic_poly\n        >>> from sympy.polys.numberfields.modules import PowerBasis, to_col\n        >>> T = Poly(cyclotomic_poly(5))\n        >>> A = PowerBasis(T)\n        >>> e = A(to_col([1, 2, 3, 4]), denom=3)\n        >>> print(e)  # doctest: +SKIP\n        [1, 2, 3, 4]/3\n        >>> f = A(2)\n        >>> print(f)  # doctest: +SKIP\n        [0, 0, 1, 0]\n\n        Parameters\n        ==========\n\n        spec : :py:class:`~.DomainMatrix`, int\n            Specifies the numerators of the coefficients of the\n            :py:class:`~.ModuleElement`. Can be either a column vector over\n            :ref:`ZZ`, whose length must equal the number $n$ of generators of\n            this module, or else an integer ``j``, $0 \\leq j < n$, which is a\n            shorthand for column $j$ of $I_n$, the $n \\times n$ identity\n            matrix.\n        denom : int, optional (default=1)\n            Denominator for the coefficients of the\n            :py:class:`~.ModuleElement`.\n\n        Returns\n        =======\n\n        :py:class:`~.ModuleElement`\n            The coefficients are the entries of the *spec* vector, divided by\n            *denom*.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "ancestors",
    "full_id": "sympy.polys.numberfields.modules.Module.ancestors",
    "type": "method",
    "description": "\n        Return the list of ancestor modules of this module, from the\n        foundational :py:class:`~.PowerBasis` downward, optionally including\n        ``self``.\n\n        See Also\n        ========\n\n        Module\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "basis_elements",
    "full_id": "sympy.polys.numberfields.modules.Module.basis_elements",
    "type": "method",
    "description": "\n        Get list of :py:class:`~.ModuleElement` being the generators of this\n        module.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "element_from_rational",
    "full_id": "sympy.polys.numberfields.modules.Module.element_from_rational",
    "type": "method",
    "description": "\n        Return a :py:class:`~.ModuleElement` representing a rational number.\n\n        Explanation\n        ===========\n\n        The returned :py:class:`~.ModuleElement` will belong to the first\n        module on this module's ancestor chain (including this module\n        itself) that starts with unity.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import Poly, cyclotomic_poly, QQ\n        >>> from sympy.polys.numberfields.modules import PowerBasis\n        >>> T = Poly(cyclotomic_poly(5))\n        >>> A = PowerBasis(T)\n        >>> a = A.element_from_rational(QQ(2, 3))\n        >>> print(a)  # doctest: +SKIP\n        [2, 0, 0, 0]/3\n\n        Parameters\n        ==========\n\n        a : int, :ref:`ZZ`, :ref:`QQ`\n\n        Returns\n        =======\n\n        :py:class:`~.ModuleElement`\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "endomorphism_ring",
    "full_id": "sympy.polys.numberfields.modules.Module.endomorphism_ring",
    "type": "method",
    "description": "Form the :py:class:`~.EndomorphismRing` for this module.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "is_compat_col",
    "full_id": "sympy.polys.numberfields.modules.Module.is_compat_col",
    "type": "method",
    "description": "Say whether *col* is a suitable column vector for this module.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "mult_tab",
    "full_id": "sympy.polys.numberfields.modules.Module.mult_tab",
    "type": "method",
    "description": "\n        Get the multiplication table for this module (if closed under mult).\n\n        Explanation\n        ===========\n\n        Computes a dictionary ``M`` of dictionaries of lists, representing the\n        upper triangular half of the multiplication table.\n\n        In other words, if ``0 <= i <= j < self.n``, then ``M[i][j]`` is the\n        list ``c`` of coefficients such that\n        ``g[i] * g[j] == sum(c[k]*g[k], k in range(self.n))``,\n        where ``g`` is the list of generators of this module.\n\n        If ``j < i`` then ``M[i][j]`` is undefined.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import Poly, cyclotomic_poly\n        >>> from sympy.polys.numberfields.modules import PowerBasis\n        >>> T = Poly(cyclotomic_poly(5))\n        >>> A = PowerBasis(T)\n        >>> print(A.mult_tab())  # doctest: +SKIP\n        {0: {0: [1, 0, 0, 0], 1: [0, 1, 0, 0], 2: [0, 0, 1, 0],     3: [0, 0, 0, 1]},\n                          1: {1: [0, 0, 1, 0], 2: [0, 0, 0, 1],     3: [-1, -1, -1, -1]},\n                                           2: {2: [-1, -1, -1, -1], 3: [1, 0, 0, 0]},\n                                                                3: {3: [0, 1, 0, 0]}}\n\n        Returns\n        =======\n\n        dict of dict of lists\n\n        Raises\n        ======\n\n        ClosureFailure\n            If the module is not closed under multiplication.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "n",
    "full_id": "sympy.polys.numberfields.modules.Module.n",
    "type": "property",
    "description": "The number of generators of this module.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "nearest_common_ancestor",
    "full_id": "sympy.polys.numberfields.modules.Module.nearest_common_ancestor",
    "type": "method",
    "description": "\n        Locate the nearest common ancestor of this module and another.\n\n        Returns\n        =======\n\n        :py:class:`~.Module`, ``None``\n\n        See Also\n        ========\n\n        Module\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "number_field",
    "full_id": "sympy.polys.numberfields.modules.Module.number_field",
    "type": "property",
    "description": "\n        Return the associated :py:class:`~.AlgebraicField`, if any.\n\n        Explanation\n        ===========\n\n        A :py:class:`~.PowerBasis` can be constructed on a :py:class:`~.Poly`\n        $f$ or on an :py:class:`~.AlgebraicField` $K$. In the latter case, the\n        :py:class:`~.PowerBasis` and all its descendant modules will return $K$\n        as their ``.number_field`` property, while in the former case they will\n        all return ``None``.\n\n        Returns\n        =======\n\n        :py:class:`~.AlgebraicField`, ``None``\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "one",
    "full_id": "sympy.polys.numberfields.modules.Module.one",
    "type": "method",
    "description": "\n        Return a :py:class:`~.ModuleElement` representing unity,\n        and belonging to the first ancestor of this module (including\n        itself) that starts with unity.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "parent",
    "full_id": "sympy.polys.numberfields.modules.Module.parent",
    "type": "property",
    "description": "\n        The parent module, if any, for this module.\n\n        Explanation\n        ===========\n\n        For a :py:class:`~.Submodule` this is its ``parent`` attribute; for a\n        :py:class:`~.PowerBasis` this is ``None``.\n\n        Returns\n        =======\n\n        :py:class:`~.Module`, ``None``\n\n        See Also\n        ========\n\n        Module\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "power_basis_ancestor",
    "full_id": "sympy.polys.numberfields.modules.Module.power_basis_ancestor",
    "type": "method",
    "description": "\n        Return the :py:class:`~.PowerBasis` that is an ancestor of this module.\n\n        See Also\n        ========\n\n        Module\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "represent",
    "full_id": "sympy.polys.numberfields.modules.Module.represent",
    "type": "method",
    "description": "\n        Represent a module element as an integer-linear combination over the\n        generators of this module.\n\n        Explanation\n        ===========\n\n        In our system, to \"represent\" always means to write a\n        :py:class:`~.ModuleElement` as a :ref:`ZZ`-linear combination over the\n        generators of the present :py:class:`~.Module`. Furthermore, the\n        incoming :py:class:`~.ModuleElement` must belong to an ancestor of\n        the present :py:class:`~.Module` (or to the present\n        :py:class:`~.Module` itself).\n\n        The most common application is to represent a\n        :py:class:`~.ModuleElement` in a :py:class:`~.Submodule`. For example,\n        this is involved in computing multiplication tables.\n\n        On the other hand, representing in a :py:class:`~.PowerBasis` is an\n        odd case, and one which tends not to arise in practice, except for\n        example when using a :py:class:`~.ModuleEndomorphism` on a\n        :py:class:`~.PowerBasis`.\n\n        In such a case, (1) the incoming :py:class:`~.ModuleElement` must\n        belong to the :py:class:`~.PowerBasis` itself (since the latter has no\n        proper ancestors) and (2) it is \"representable\" iff it belongs to\n        $\\mathbb{Z}[\\theta]$ (although generally a\n        :py:class:`~.PowerBasisElement` may represent any element of\n        $\\mathbb{Q}(\\theta)$, i.e. any algebraic number).\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, cyclotomic_poly\n        >>> from sympy.polys.numberfields.modules import PowerBasis, to_col\n        >>> from sympy.abc import zeta\n        >>> T = Poly(cyclotomic_poly(5))\n        >>> A = PowerBasis(T)\n        >>> a = A(to_col([2, 4, 6, 8]))\n\n        The :py:class:`~.ModuleElement` ``a`` has all even coefficients.\n        If we represent ``a`` in the submodule ``B = 2*A``, the coefficients in\n        the column vector will be halved:\n\n        >>> B = A.submodule_from_gens([2*A(i) for i in range(4)])\n        >>> b = B.represent(a)\n        >>> print(b.transpose())  # doctest: +SKIP\n        DomainMatrix([[1, 2, 3, 4]], (1, 4), ZZ)\n\n        However, the element of ``B`` so defined still represents the same\n        algebraic number:\n\n        >>> print(a.poly(zeta).as_expr())\n        8*zeta**3 + 6*zeta**2 + 4*zeta + 2\n        >>> print(B(b).over_power_basis().poly(zeta).as_expr())\n        8*zeta**3 + 6*zeta**2 + 4*zeta + 2\n\n        Parameters\n        ==========\n\n        elt : :py:class:`~.ModuleElement`\n            The module element to be represented. Must belong to some ancestor\n            module of this module (including this module itself).\n\n        Returns\n        =======\n\n        :py:class:`~.DomainMatrix` over :ref:`ZZ`\n            This will be a column vector, representing the coefficients of a\n            linear combination of this module's generators, which equals the\n            given element.\n\n        Raises\n        ======\n\n        ClosureFailure\n            If the given element cannot be represented as a :ref:`ZZ`-linear\n            combination over this module.\n\n        See Also\n        ========\n\n        .Submodule.represent\n        .PowerBasis.represent\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "starts_with_unity",
    "full_id": "sympy.polys.numberfields.modules.Module.starts_with_unity",
    "type": "method",
    "description": "Say whether the module's first generator equals unity.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "submodule_from_gens",
    "full_id": "sympy.polys.numberfields.modules.Module.submodule_from_gens",
    "type": "method",
    "description": "\n        Form the submodule generated by a list of :py:class:`~.ModuleElement`\n        belonging to this module.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import Poly, cyclotomic_poly\n        >>> from sympy.polys.numberfields.modules import PowerBasis\n        >>> T = Poly(cyclotomic_poly(5))\n        >>> A = PowerBasis(T)\n        >>> gens = [A(0), 2*A(1), 3*A(2), 4*A(3)//5]\n        >>> B = A.submodule_from_gens(gens)\n        >>> print(B)  # doctest: +SKIP\n        Submodule[[5, 0, 0, 0], [0, 10, 0, 0], [0, 0, 15, 0], [0, 0, 0, 4]]/5\n\n        Parameters\n        ==========\n\n        gens : list of :py:class:`~.ModuleElement` belonging to this module.\n        hnf : boolean, optional (default=True)\n            If True, we will reduce the matrix into Hermite Normal Form before\n            forming the :py:class:`~.Submodule`.\n        hnf_modulus : int, None, optional (default=None)\n            Modulus for use in the HNF reduction algorithm. See\n            :py:func:`~sympy.polys.matrices.normalforms.hermite_normal_form`.\n\n        Returns\n        =======\n\n        :py:class:`~.Submodule`\n\n        See Also\n        ========\n\n        submodule_from_matrix\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "submodule_from_matrix",
    "full_id": "sympy.polys.numberfields.modules.Module.submodule_from_matrix",
    "type": "method",
    "description": "\n        Form the submodule generated by the elements of this module indicated\n        by the columns of a matrix, with an optional denominator.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import Poly, cyclotomic_poly, ZZ\n        >>> from sympy.polys.matrices import DM\n        >>> from sympy.polys.numberfields.modules import PowerBasis\n        >>> T = Poly(cyclotomic_poly(5))\n        >>> A = PowerBasis(T)\n        >>> B = A.submodule_from_matrix(DM([\n        ...     [0, 10, 0, 0],\n        ...     [0,  0, 7, 0],\n        ... ], ZZ).transpose(), denom=15)\n        >>> print(B)  # doctest: +SKIP\n        Submodule[[0, 10, 0, 0], [0, 0, 7, 0]]/15\n\n        Parameters\n        ==========\n\n        B : :py:class:`~.DomainMatrix` over :ref:`ZZ`\n            Each column gives the numerators of the coefficients of one\n            generator of the submodule. Thus, the number of rows of *B* must\n            equal the number of generators of the present module.\n        denom : int, optional (default=1)\n            Common denominator for all generators of the submodule.\n\n        Returns\n        =======\n\n        :py:class:`~.Submodule`\n\n        Raises\n        ======\n\n        ValueError\n            If the given matrix *B* is not over :ref:`ZZ` or its number of rows\n            does not equal the number of generators of the present module.\n\n        See Also\n        ========\n\n        submodule_from_gens\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "whole_submodule",
    "full_id": "sympy.polys.numberfields.modules.Module.whole_submodule",
    "type": "method",
    "description": "\n        Return a submodule equal to this entire module.\n\n        Explanation\n        ===========\n\n        This is useful when you have a :py:class:`~.PowerBasis` and want to\n        turn it into a :py:class:`~.Submodule` (in order to use methods\n        belonging to the latter).\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "zero",
    "full_id": "sympy.polys.numberfields.modules.Module.zero",
    "type": "method",
    "description": "Return a :py:class:`~.ModuleElement` representing zero.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.polys.numberfields.modules.PowerBasis.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        T : :py:class:`~.Poly`, :py:class:`~.AlgebraicField`\n            Either (1) the monic, irreducible, univariate polynomial over\n            :ref:`ZZ`, a root of which is the generator of the power basis,\n            or (2) an :py:class:`~.AlgebraicField` whose primitive element\n            is the generator of the power basis.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "element_from_ANP",
    "full_id": "sympy.polys.numberfields.modules.PowerBasis.element_from_ANP",
    "type": "method",
    "description": "Convert an ANP into a PowerBasisElement.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "element_from_alg_num",
    "full_id": "sympy.polys.numberfields.modules.PowerBasis.element_from_alg_num",
    "type": "method",
    "description": "Convert an AlgebraicNumber into a PowerBasisElement.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "element_from_poly",
    "full_id": "sympy.polys.numberfields.modules.PowerBasis.element_from_poly",
    "type": "method",
    "description": "\n        Produce an element of this module, representing *f* after reduction mod\n        our defining minimal polynomial.\n\n        Parameters\n        ==========\n\n        f : :py:class:`~.Poly` over :ref:`ZZ` in same var as our defining poly.\n\n        Returns\n        =======\n\n        :py:class:`~.PowerBasisElement`\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "represent",
    "full_id": "sympy.polys.numberfields.modules.PowerBasis.represent",
    "type": "method",
    "description": "\n        Represent a module element as an integer-linear combination over the\n        generators of this module.\n\n        See Also\n        ========\n\n        .Module.represent\n        .Submodule.represent\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.polys.numberfields.modules.Submodule.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        parent : :py:class:`~.Module`\n            The module from which this one is derived.\n        matrix : :py:class:`~.DomainMatrix` over :ref:`ZZ`\n            The matrix whose columns define this submodule's generators as\n            linear combinations over the parent's generators.\n        denom : int, optional (default=1)\n            Denominator for the coefficients given by the matrix.\n        mult_tab : dict, ``None``, optional\n            If already known, the multiplication table for this module may be\n            supplied.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "QQ_matrix",
    "full_id": "sympy.polys.numberfields.modules.Submodule.QQ_matrix",
    "type": "property",
    "description": "\n        :py:class:`~.DomainMatrix` over :ref:`QQ`, equal to\n        ``self.matrix / self.denom``, and guaranteed to be dense.\n\n        Explanation\n        ===========\n\n        Depending on how it is formed, a :py:class:`~.DomainMatrix` may have\n        an internal representation that is sparse or dense. We guarantee a\n        dense representation here, so that tests for equivalence of submodules\n        always come out as expected.\n\n        Examples\n        ========\n\n        >>> from sympy.polys import Poly, cyclotomic_poly, ZZ\n        >>> from sympy.abc import x\n        >>> from sympy.polys.matrices import DomainMatrix\n        >>> from sympy.polys.numberfields.modules import PowerBasis\n        >>> T = Poly(cyclotomic_poly(5, x))\n        >>> A = PowerBasis(T)\n        >>> B = A.submodule_from_matrix(3*DomainMatrix.eye(4, ZZ), denom=6)\n        >>> C = A.submodule_from_matrix(DomainMatrix.eye(4, ZZ), denom=2)\n        >>> print(B.QQ_matrix == C.QQ_matrix)\n        True\n\n        Returns\n        =======\n\n        :py:class:`~.DomainMatrix` over :ref:`QQ`\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "add",
    "full_id": "sympy.polys.numberfields.modules.Submodule.add",
    "type": "method",
    "description": "\n        Add this :py:class:`~.Submodule` to another.\n\n        Explanation\n        ===========\n\n        This represents the module generated by the union of the two modules'\n        sets of generators.\n\n        Parameters\n        ==========\n\n        other : :py:class:`~.Submodule`\n        hnf : boolean, optional (default=True)\n            If ``True``, reduce the matrix of the combined module to its\n            Hermite Normal Form.\n        hnf_modulus : :ref:`ZZ`, None, optional\n            If a positive integer is provided, use this as modulus in the\n            HNF reduction. See\n            :py:func:`~sympy.polys.matrices.normalforms.hermite_normal_form`.\n\n        Returns\n        =======\n\n        :py:class:`~.Submodule`\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "basis_element_pullbacks",
    "full_id": "sympy.polys.numberfields.modules.Submodule.basis_element_pullbacks",
    "type": "method",
    "description": "\n        Return list of this submodule's basis elements as elements of the\n        submodule's parent module.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "discard_before",
    "full_id": "sympy.polys.numberfields.modules.Submodule.discard_before",
    "type": "method",
    "description": "\n        Produce a new module by discarding all generators before a given\n        index *r*.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "mul",
    "full_id": "sympy.polys.numberfields.modules.Submodule.mul",
    "type": "method",
    "description": "\n        Multiply this :py:class:`~.Submodule` by a rational number, a\n        :py:class:`~.ModuleElement`, or another :py:class:`~.Submodule`.\n\n        Explanation\n        ===========\n\n        To multiply by a rational number or :py:class:`~.ModuleElement` means\n        to form the submodule whose generators are the products of this\n        quantity with all the generators of the present submodule.\n\n        To multiply by another :py:class:`~.Submodule` means to form the\n        submodule whose generators are all the products of one generator from\n        the one submodule, and one generator from the other.\n\n        Parameters\n        ==========\n\n        other : int, :ref:`ZZ`, :ref:`QQ`, :py:class:`~.ModuleElement`, :py:class:`~.Submodule`\n        hnf : boolean, optional (default=True)\n            If ``True``, reduce the matrix of the product module to its\n            Hermite Normal Form.\n        hnf_modulus : :ref:`ZZ`, None, optional\n            If a positive integer is provided, use this as modulus in the\n            HNF reduction. See\n            :py:func:`~sympy.polys.matrices.normalforms.hermite_normal_form`.\n\n        Returns\n        =======\n\n        :py:class:`~.Submodule`\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "reduce_element",
    "full_id": "sympy.polys.numberfields.modules.Submodule.reduce_element",
    "type": "method",
    "description": "\n        If this submodule $B$ has defining matrix $W$ in square, maximal-rank\n        Hermite normal form, then, given an element $x$ of the parent module\n        $A$, we produce an element $y \\in A$ such that $x - y \\in B$, and the\n        $i$th coordinate of $y$ satisfies $0 \\leq y_i < w_{i,i}$. This\n        representative $y$ is unique, in the sense that every element of\n        the coset $x + B$ reduces to it under this procedure.\n\n        Explanation\n        ===========\n\n        In the special case where $A$ is a power basis for a number field $K$,\n        and $B$ is a submodule representing an ideal $I$, this operation\n        represents one of a few important ways of reducing an element of $K$\n        modulo $I$ to obtain a \"small\" representative. See [Cohen00]_ Section\n        1.4.3.\n\n        Examples\n        ========\n\n        >>> from sympy import QQ, Poly, symbols\n        >>> t = symbols('t')\n        >>> k = QQ.alg_field_from_poly(Poly(t**3 + t**2 - 2*t + 8))\n        >>> Zk = k.maximal_order()\n        >>> A = Zk.parent\n        >>> B = (A(2) - 3*A(0))*Zk\n        >>> B.reduce_element(A(2))\n        [3, 0, 0]\n\n        Parameters\n        ==========\n\n        elt : :py:class:`~.ModuleElement`\n            An element of this submodule's parent module.\n\n        Returns\n        =======\n\n        elt : :py:class:`~.ModuleElement`\n            An element of this submodule's parent module.\n\n        Raises\n        ======\n\n        NotImplementedError\n            If the given :py:class:`~.ModuleElement` does not belong to this\n            submodule's parent module.\n        StructureError\n            If this submodule's defining matrix is not in square, maximal-rank\n            Hermite normal form.\n\n        References\n        ==========\n\n        .. [Cohen00] Cohen, H. *Advanced Topics in Computational Number\n           Theory.*\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "reduced",
    "full_id": "sympy.polys.numberfields.modules.Submodule.reduced",
    "type": "method",
    "description": "\n        Produce a reduced version of this submodule.\n\n        Explanation\n        ===========\n\n        In the reduced version, it is guaranteed that 1 is the only positive\n        integer dividing both the submodule's denominator, and every entry in\n        the submodule's matrix.\n\n        Returns\n        =======\n\n        :py:class:`~.Submodule`\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "represent",
    "full_id": "sympy.polys.numberfields.modules.Submodule.represent",
    "type": "method",
    "description": "\n        Represent a module element as an integer-linear combination over the\n        generators of this module.\n\n        See Also\n        ========\n\n        .Module.represent\n        .PowerBasis.represent\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        module : :py:class:`~.Module`\n            The module to which this element belongs.\n        col : :py:class:`~.DomainMatrix` over :ref:`ZZ`\n            Column vector giving the numerators of the coefficients of this\n            element.\n        denom : int, optional (default=1)\n            Denominator for the coefficients of this element.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__add__",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.__add__",
    "type": "method",
    "description": "\n        A :py:class:`~.ModuleElement` can be added to a rational number, or to\n        another :py:class:`~.ModuleElement`.\n\n        Explanation\n        ===========\n\n        When the other summand is a rational number, it will be converted into\n        a :py:class:`~.ModuleElement` (belonging to the first ancestor of this\n        module that starts with unity).\n\n        In all cases, the sum belongs to the nearest common ancestor (NCA) of\n        the modules of the two summands. If the NCA does not exist, we return\n        ``NotImplemented``.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__mul__",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.__mul__",
    "type": "method",
    "description": "\n        A :py:class:`~.ModuleElement` can be multiplied by a rational number,\n        or by another :py:class:`~.ModuleElement`.\n\n        Explanation\n        ===========\n\n        When the multiplier is a rational number, the product is computed by\n        operating directly on the coefficients of this\n        :py:class:`~.ModuleElement`.\n\n        When the multiplier is another :py:class:`~.ModuleElement`, the product\n        will belong to the nearest common ancestor (NCA) of the modules of the\n        two operands, and that NCA must have a multiplication table. If the NCA\n        does not exist, we return ``NotImplemented``. If the NCA does not have\n        a mult. table, ``ClosureFailure`` will be raised.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__mod__",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.__mod__",
    "type": "method",
    "description": "\n        Reduce this :py:class:`~.ModuleElement` mod a :py:class:`~.Submodule`.\n\n        Parameters\n        ==========\n\n        m : int, :ref:`ZZ`, :ref:`QQ`, :py:class:`~.Submodule`\n            If a :py:class:`~.Submodule`, reduce ``self`` relative to this.\n            If an integer or rational, reduce relative to the\n            :py:class:`~.Submodule` that is our own module times this constant.\n\n        See Also\n        ========\n\n        .Submodule.reduce_element\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "QQ_col",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.QQ_col",
    "type": "property",
    "description": "\n        :py:class:`~.DomainMatrix` over :ref:`QQ`, equal to\n        ``self.col / self.denom``, and guaranteed to be dense.\n\n        See Also\n        ========\n\n        .Submodule.QQ_matrix\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "column",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.column",
    "type": "method",
    "description": "\n        Get a copy of this element's column, optionally converting to a domain.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "equiv",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.equiv",
    "type": "method",
    "description": "\n        A :py:class:`~.ModuleElement` may test as equivalent to a rational\n        number or another :py:class:`~.ModuleElement`, if they represent the\n        same algebraic number.\n\n        Explanation\n        ===========\n\n        This method is intended to check equivalence only in those cases in\n        which it is easy to test; namely, when *other* is either a\n        :py:class:`~.ModuleElement` that can be unified with this one (i.e. one\n        which shares a common :py:class:`~.PowerBasis` ancestor), or else a\n        rational number (which is easy because every :py:class:`~.PowerBasis`\n        represents every rational number).\n\n        Parameters\n        ==========\n\n        other : int, :ref:`ZZ`, :ref:`QQ`, :py:class:`~.ModuleElement`\n\n        Returns\n        =======\n\n        bool\n\n        Raises\n        ======\n\n        UnificationFailed\n            If ``self`` and ``other`` do not share a common\n            :py:class:`~.PowerBasis` ancestor.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "from_int_list",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.from_int_list",
    "type": "method",
    "description": "\n        Make a :py:class:`~.ModuleElement` from a list of ints (instead of a\n        column vector).\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "is_compat",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.is_compat",
    "type": "method",
    "description": "\n        Test whether other is another :py:class:`~.ModuleElement` with same\n        module.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "n",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.n",
    "type": "property",
    "description": "The length of this element's column.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "over_power_basis",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.over_power_basis",
    "type": "method",
    "description": "\n        Transform into a :py:class:`~.PowerBasisElement` over our\n        :py:class:`~.PowerBasis` ancestor.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "reduced",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.reduced",
    "type": "method",
    "description": "\n        Produce a reduced version of this ModuleElement, i.e. one in which the\n        gcd of the denominator together with all numerator coefficients is 1.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "reduced_mod_p",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.reduced_mod_p",
    "type": "method",
    "description": "\n        Produce a version of this :py:class:`~.ModuleElement` in which all\n        numerator coefficients have been reduced mod *p*.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "to_ancestor",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.to_ancestor",
    "type": "method",
    "description": "\n        Transform into a :py:class:`~.ModuleElement` belonging to a given\n        ancestor of this element's module.\n\n        Parameters\n        ==========\n\n        anc : :py:class:`~.Module`\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "to_parent",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.to_parent",
    "type": "method",
    "description": "\n        Transform into a :py:class:`~.ModuleElement` belonging to the parent of\n        this element's module.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "unify",
    "full_id": "sympy.polys.numberfields.modules.ModuleElement.unify",
    "type": "method",
    "description": "\n        Try to make a compatible pair of :py:class:`~.ModuleElement`, one\n        equivalent to this one, and one equivalent to the other.\n\n        Explanation\n        ===========\n\n        We search for the nearest common ancestor module for the pair of\n        elements, and represent each one there.\n\n        Returns\n        =======\n\n        Pair ``(e1, e2)``\n            Each ``ei`` is a :py:class:`~.ModuleElement`, they belong to the\n            same :py:class:`~.Module`, ``e1`` is equivalent to ``self``, and\n            ``e2`` is equivalent to ``other``.\n\n        Raises\n        ======\n\n        UnificationFailed\n            If ``self`` and ``other`` have no common ancestor module.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "T",
    "full_id": "sympy.polys.numberfields.modules.PowerBasisElement.T",
    "type": "property",
    "description": "Access the defining polynomial of the :py:class:`~.PowerBasis`.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "generator",
    "full_id": "sympy.polys.numberfields.modules.PowerBasisElement.generator",
    "type": "property",
    "description": "\n        Return a :py:class:`~.Symbol` to be used when expressing this element\n        as a polynomial.\n\n        If we have an associated :py:class:`~.AlgebraicField` whose primitive\n        element has an alias symbol, we use that. Otherwise we use the variable\n        of the minimal polynomial defining the power basis to which we belong.\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "is_rational",
    "full_id": "sympy.polys.numberfields.modules.PowerBasisElement.is_rational",
    "type": "property",
    "description": "Say whether this element represents a rational number.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "norm",
    "full_id": "sympy.polys.numberfields.modules.PowerBasisElement.norm",
    "type": "method",
    "description": "Compute the norm of this number.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "numerator",
    "full_id": "sympy.polys.numberfields.modules.PowerBasisElement.numerator",
    "type": "method",
    "description": "Obtain the numerator as a polynomial over :ref:`ZZ`.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "poly",
    "full_id": "sympy.polys.numberfields.modules.PowerBasisElement.poly",
    "type": "method",
    "description": "Obtain the number as a polynomial over :ref:`QQ`.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "to_ANP",
    "full_id": "sympy.polys.numberfields.modules.PowerBasisElement.to_ANP",
    "type": "method",
    "description": "Convert to an equivalent :py:class:`~.ANP`.",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "to_alg_num",
    "full_id": "sympy.polys.numberfields.modules.PowerBasisElement.to_alg_num",
    "type": "method",
    "description": "\n        Try to convert to an equivalent :py:class:`~.AlgebraicNumber`.\n\n        Explanation\n        ===========\n\n        In general, the conversion from an :py:class:`~.AlgebraicNumber` to a\n        :py:class:`~.PowerBasisElement` throws away information, because an\n        :py:class:`~.AlgebraicNumber` specifies a complex embedding, while a\n        :py:class:`~.PowerBasisElement` does not. However, in some cases it is\n        possible to convert a :py:class:`~.PowerBasisElement` back into an\n        :py:class:`~.AlgebraicNumber`, namely when the associated\n        :py:class:`~.PowerBasis` has a reference to an\n        :py:class:`~.AlgebraicField`.\n\n        Returns\n        =======\n\n        :py:class:`~.AlgebraicNumber`\n\n        Raises\n        ======\n\n        StructureError\n            If the :py:class:`~.PowerBasis` to which this element belongs does\n            not have an associated :py:class:`~.AlgebraicField`.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "make_mod_elt",
    "full_id": "sympy.polys.numberfields.modules.make_mod_elt",
    "type": "function",
    "description": "\n    Factory function which builds a :py:class:`~.ModuleElement`, but ensures\n    that it is a :py:class:`~.PowerBasisElement` if the module is a\n    :py:class:`~.PowerBasis`.\n    ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.polys.numberfields.modules.ModuleHomomorphism.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        domain : :py:class:`~.Module`\n            The domain of the mapping.\n\n        codomain : :py:class:`~.Module`\n            The codomain of the mapping.\n\n        mapping : callable\n            An arbitrary callable is accepted, but should be chosen so as\n            to represent an actual module homomorphism. In particular, should\n            accept elements of *domain* and return elements of *codomain*.\n\n        Examples\n        ========\n\n        >>> from sympy import Poly, cyclotomic_poly\n        >>> from sympy.polys.numberfields.modules import PowerBasis, ModuleHomomorphism\n        >>> T = Poly(cyclotomic_poly(5))\n        >>> A = PowerBasis(T)\n        >>> B = A.submodule_from_gens([2*A(j) for j in range(4)])\n        >>> phi = ModuleHomomorphism(A, B, lambda x: 6*x)\n        >>> print(phi.matrix())  # doctest: +SKIP\n        DomainMatrix([[3, 0, 0, 0], [0, 3, 0, 0], [0, 0, 3, 0], [0, 0, 0, 3]], (4, 4), ZZ)\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "kernel",
    "full_id": "sympy.polys.numberfields.modules.ModuleHomomorphism.kernel",
    "type": "method",
    "description": "\n        Compute a Submodule representing the kernel of this homomorphism.\n\n        Parameters\n        ==========\n\n        modulus : int, optional\n            A positive prime number $p$ if the kernel should be computed mod\n            $p$.\n\n        Returns\n        =======\n\n        :py:class:`~.Submodule`\n            This submodule's generators span the kernel of this\n            homomorphism over :ref:`ZZ`, or else over :ref:`GF(p)` if a\n            modulus was given.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "matrix",
    "full_id": "sympy.polys.numberfields.modules.ModuleHomomorphism.matrix",
    "type": "method",
    "description": "\n        Compute the matrix of this homomorphism.\n\n        Parameters\n        ==========\n\n        modulus : int, optional\n            A positive prime number $p$ if the matrix should be reduced mod\n            $p$.\n\n        Returns\n        =======\n\n        :py:class:`~.DomainMatrix`\n            The matrix is over :ref:`ZZ`, or else over :ref:`GF(p)` if a\n            modulus was given.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.polys.numberfields.modules.ModuleEndomorphism.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        domain : :py:class:`~.Module`\n            The common domain and codomain of the mapping.\n\n        mapping : callable\n            An arbitrary callable is accepted, but should be chosen so as\n            to represent an actual module endomorphism. In particular, should\n            accept and return elements of *domain*.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.polys.numberfields.modules.InnerEndomorphism.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        domain : :py:class:`~.Module`\n            The domain and codomain of the endomorphism.\n\n        multiplier : :py:class:`~.ModuleElement`\n            The element $a$ defining the mapping as $x \\mapsto a x$.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.polys.numberfields.modules.EndomorphismRing.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        domain : :py:class:`~.Module`\n            The domain and codomain of the endomorphisms.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "inner_endomorphism",
    "full_id": "sympy.polys.numberfields.modules.EndomorphismRing.inner_endomorphism",
    "type": "method",
    "description": "\n        Form an inner endomorphism belonging to this endomorphism ring.\n\n        Parameters\n        ==========\n\n        multiplier : :py:class:`~.ModuleElement`\n            Element $a$ defining the inner endomorphism $x \\mapsto a x$.\n\n        Returns\n        =======\n\n        :py:class:`~.InnerEndomorphism`\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "represent",
    "full_id": "sympy.polys.numberfields.modules.EndomorphismRing.represent",
    "type": "method",
    "description": "\n        Represent an element of this endomorphism ring, as a single column\n        vector.\n\n        Explanation\n        ===========\n\n        Let $M$ be a module, and $E$ its ring of endomorphisms. Let $N$ be\n        another module, and consider a homomorphism $\\varphi: N \\rightarrow E$.\n        In the event that $\\varphi$ is to be represented by a matrix $A$, each\n        column of $A$ must represent an element of $E$. This is possible when\n        the elements of $E$ are themselves representable as matrices, by\n        stacking the columns of such a matrix into a single column.\n\n        This method supports calculating such matrices $A$, by representing\n        an element of this endomorphism ring first as a matrix, and then\n        stacking that matrix's columns into a single column.\n\n        Examples\n        ========\n\n        Note that in these examples we print matrix transposes, to make their\n        columns easier to inspect.\n\n        >>> from sympy import Poly, cyclotomic_poly\n        >>> from sympy.polys.numberfields.modules import PowerBasis\n        >>> from sympy.polys.numberfields.modules import ModuleHomomorphism\n        >>> T = Poly(cyclotomic_poly(5))\n        >>> M = PowerBasis(T)\n        >>> E = M.endomorphism_ring()\n\n        Let $\\zeta$ be a primitive 5th root of unity, a generator of our field,\n        and consider the inner endomorphism $\\tau$ on the ring of integers,\n        induced by $\\zeta$:\n\n        >>> zeta = M(1)\n        >>> tau = E.inner_endomorphism(zeta)\n        >>> tau.matrix().transpose()  # doctest: +SKIP\n        DomainMatrix(\n            [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [-1, -1, -1, -1]],\n            (4, 4), ZZ)\n\n        The matrix representation of $\\tau$ is as expected. The first column\n        shows that multiplying by $\\zeta$ carries $1$ to $\\zeta$, the second\n        column that it carries $\\zeta$ to $\\zeta^2$, and so forth.\n\n        The ``represent`` method of the endomorphism ring ``E`` stacks these\n        into a single column:\n\n        >>> E.represent(tau).transpose()  # doctest: +SKIP\n        DomainMatrix(\n            [[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, -1, -1, -1, -1]],\n            (1, 16), ZZ)\n\n        This is useful when we want to consider a homomorphism $\\varphi$ having\n        ``E`` as codomain:\n\n        >>> phi = ModuleHomomorphism(M, E, lambda x: E.inner_endomorphism(x))\n\n        and we want to compute the matrix of such a homomorphism:\n\n        >>> phi.matrix().transpose()  # doctest: +SKIP\n        DomainMatrix(\n            [[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],\n            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, -1, -1, -1, -1],\n            [0, 0, 1, 0, 0, 0, 0, 1, -1, -1, -1, -1, 1, 0, 0, 0],\n            [0, 0, 0, 1, -1, -1, -1, -1, 1, 0, 0, 0, 0, 1, 0, 0]],\n            (4, 16), ZZ)\n\n        Note that the stacked matrix of $\\tau$ occurs as the second column in\n        this example. This is because $\\zeta$ is the second basis element of\n        ``M``, and $\\varphi(\\zeta) = \\tau$.\n\n        Parameters\n        ==========\n\n        element : :py:class:`~.ModuleEndomorphism` belonging to this ring.\n\n        Returns\n        =======\n\n        :py:class:`~.DomainMatrix`\n            Column vector equalling the vertical stacking of all the columns\n            of the matrix that represents the given *element* as a mapping.\n\n        ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "find_min_poly",
    "full_id": "sympy.polys.numberfields.modules.find_min_poly",
    "type": "function",
    "description": "\n    Find a polynomial of least degree (not necessarily irreducible) satisfied\n    by an element of a finitely-generated ring with unity.\n\n    Examples\n    ========\n\n    For the $n$th cyclotomic field, $n$ an odd prime, consider the quadratic\n    equation whose roots are the two periods of length $(n-1)/2$. Article 356\n    of Gauss tells us that we should get $x^2 + x - (n-1)/4$ or\n    $x^2 + x + (n+1)/4$ according to whether $n$ is 1 or 3 mod 4, respectively.\n\n    >>> from sympy import Poly, cyclotomic_poly, primitive_root, QQ\n    >>> from sympy.abc import x\n    >>> from sympy.polys.numberfields.modules import PowerBasis, find_min_poly\n    >>> n = 13\n    >>> g = primitive_root(n)\n    >>> C = PowerBasis(Poly(cyclotomic_poly(n, x)))\n    >>> ee = [g**(2*k+1) % n for k in range((n-1)//2)]\n    >>> eta = sum(C(e) for e in ee)\n    >>> print(find_min_poly(eta, QQ, x=x).as_expr())\n    x**2 + x - 3\n    >>> n = 19\n    >>> g = primitive_root(n)\n    >>> C = PowerBasis(Poly(cyclotomic_poly(n, x)))\n    >>> ee = [g**(2*k+2) % n for k in range((n-1)//2)]\n    >>> eta = sum(C(e) for e in ee)\n    >>> print(find_min_poly(eta, QQ, x=x).as_expr())\n    x**2 + x + 5\n\n    Parameters\n    ==========\n\n    alpha : :py:class:`~.ModuleElement`\n        The element whose min poly is to be found, and whose module has\n        multiplication and starts with unity.\n\n    domain : :py:class:`~.Domain`\n        The desired domain of the polynomial.\n\n    x : :py:class:`~.Symbol`, optional\n        The desired variable for the polynomial.\n\n    powers : list, optional\n        If desired, pass an empty list. The powers of *alpha* (as\n        :py:class:`~.ModuleElement` instances) from the zeroth up to the degree\n        of the min poly will be recorded here, as we compute them.\n\n    Returns\n    =======\n\n    :py:class:`~.Poly`, ``None``\n        The minimal polynomial for alpha, or ``None`` if no polynomial could be\n        found over the desired domain.\n\n    Raises\n    ======\n\n    MissingUnityError\n        If the module to which alpha belongs does not start with unity.\n    ClosureFailure\n        If the module to which alpha belongs is not closed under\n        multiplication.\n\n    ",
    "section": "Class Reference",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "is_rat",
    "full_id": "sympy.polys.numberfields.utilities.is_rat",
    "type": "function",
    "description": "\n    Test whether an argument is of an acceptable type to be used as a rational\n    number.\n\n    Explanation\n    ===========\n\n    Returns ``True`` on any argument of type ``int``, :ref:`ZZ`, or :ref:`QQ`.\n\n    See Also\n    ========\n\n    is_int\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "is_int",
    "full_id": "sympy.polys.numberfields.utilities.is_int",
    "type": "function",
    "description": "\n    Test whether an argument is of an acceptable type to be used as an integer.\n\n    Explanation\n    ===========\n\n    Returns ``True`` on any argument of type ``int`` or :ref:`ZZ`.\n\n    See Also\n    ========\n\n    is_rat\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "get_num_denom",
    "full_id": "sympy.polys.numberfields.utilities.get_num_denom",
    "type": "function",
    "description": "\n    Given any argument on which :py:func:`~.is_rat` is ``True``, return the\n    numerator and denominator of this number.\n\n    See Also\n    ========\n\n    is_rat\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "extract_fundamental_discriminant",
    "full_id": "sympy.polys.numberfields.utilities.extract_fundamental_discriminant",
    "type": "function",
    "description": "\n    Extract a fundamental discriminant from an integer *a*.\n\n    Explanation\n    ===========\n\n    Given any rational integer *a* that is 0 or 1 mod 4, write $a = d f^2$,\n    where $d$ is either 1 or a fundamental discriminant, and return a pair\n    of dictionaries ``(D, F)`` giving the prime factorizations of $d$ and $f$\n    respectively, in the same format returned by :py:func:`~.factorint`.\n\n    A fundamental discriminant $d$ is different from unity, and is either\n    1 mod 4 and squarefree, or is 0 mod 4 and such that $d/4$ is squarefree\n    and 2 or 3 mod 4. This is the same as being the discriminant of some\n    quadratic field.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.numberfields.utilities import extract_fundamental_discriminant\n    >>> print(extract_fundamental_discriminant(-432))\n    ({3: 1, -1: 1}, {2: 2, 3: 1})\n\n    For comparison:\n\n    >>> from sympy import factorint\n    >>> print(factorint(-432))\n    {2: 4, 3: 3, -1: 1}\n\n    Parameters\n    ==========\n\n    a: int, must be 0 or 1 mod 4\n\n    Returns\n    =======\n\n    Pair ``(D, F)``  of dictionaries.\n\n    Raises\n    ======\n\n    ValueError\n        If *a* is not 0 or 1 mod 4.\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n       (See Prop. 5.1.3)\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "__init__",
    "full_id": "sympy.polys.numberfields.utilities.AlgIntPowers.__init__",
    "type": "method",
    "description": "\n        Parameters\n        ==========\n\n        T : :py:class:`~.Poly`\n            The monic irreducible polynomial over :ref:`ZZ` defining the\n            algebraic integer.\n\n        modulus : int, None, optional\n            If not ``None``, all representations will be reduced w.r.t. this.\n\n        ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "coeff_search",
    "full_id": "sympy.polys.numberfields.utilities.coeff_search",
    "type": "function",
    "description": "\n    Generate coefficients for searching through polynomials.\n\n    Explanation\n    ===========\n\n    Lead coeff is always non-negative. Explore all combinations with coeffs\n    bounded in absolute value before increasing the bound. Skip the all-zero\n    list, and skip any repeats. See examples.\n\n    Examples\n    ========\n\n    >>> from sympy.polys.numberfields.utilities import coeff_search\n    >>> cs = coeff_search(2, 1)\n    >>> C = [next(cs) for i in range(13)]\n    >>> print(C)\n    [[1, 1], [1, 0], [1, -1], [0, 1], [2, 2], [2, 1], [2, 0], [2, -1], [2, -2],\n     [1, 2], [1, -2], [0, 2], [3, 3]]\n\n    Parameters\n    ==========\n\n    m : int\n        Length of coeff list.\n    R : int\n        Initial max abs val for coeffs (will increase as search proceeds).\n\n    Returns\n    =======\n\n    generator\n        Infinite generator of lists of coefficients.\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "supplement_a_subspace",
    "full_id": "sympy.polys.numberfields.utilities.supplement_a_subspace",
    "type": "function",
    "description": "\n    Extend a basis for a subspace to a basis for the whole space.\n\n    Explanation\n    ===========\n\n    Given an $n \\times r$ matrix *M* of rank $r$ (so $r \\leq n$), this function\n    computes an invertible $n \\times n$ matrix $B$ such that the first $r$\n    columns of $B$ equal *M*.\n\n    This operation can be interpreted as a way of extending a basis for a\n    subspace, to give a basis for the whole space.\n\n    To be precise, suppose you have an $n$-dimensional vector space $V$, with\n    basis $\\{v_1, v_2, \\ldots, v_n\\}$, and an $r$-dimensional subspace $W$ of\n    $V$, spanned by a basis $\\{w_1, w_2, \\ldots, w_r\\}$, where the $w_j$ are\n    given as linear combinations of the $v_i$. If the columns of *M* represent\n    the $w_j$ as such linear combinations, then the columns of the matrix $B$\n    computed by this function give a new basis $\\{u_1, u_2, \\ldots, u_n\\}$ for\n    $V$, again relative to the $\\{v_i\\}$ basis, and such that $u_j = w_j$\n    for $1 \\leq j \\leq r$.\n\n    Examples\n    ========\n\n    Note: The function works in terms of columns, so in these examples we\n    print matrix transposes in order to make the columns easier to inspect.\n\n    >>> from sympy.polys.matrices import DM\n    >>> from sympy import QQ, FF\n    >>> from sympy.polys.numberfields.utilities import supplement_a_subspace\n    >>> M = DM([[1, 7, 0], [2, 3, 4]], QQ).transpose()\n    >>> print(supplement_a_subspace(M).to_Matrix().transpose())\n    Matrix([[1, 7, 0], [2, 3, 4], [1, 0, 0]])\n\n    >>> M2 = M.convert_to(FF(7))\n    >>> print(M2.to_Matrix().transpose())\n    Matrix([[1, 0, 0], [2, 3, -3]])\n    >>> print(supplement_a_subspace(M2).to_Matrix().transpose())\n    Matrix([[1, 0, 0], [2, 3, -3], [0, 1, 0]])\n\n    Parameters\n    ==========\n\n    M : :py:class:`~.DomainMatrix`\n        The columns give the basis for the subspace.\n\n    Returns\n    =======\n\n    :py:class:`~.DomainMatrix`\n        This matrix is invertible and its first $r$ columns equal *M*.\n\n    Raises\n    ======\n\n    DMRankError\n        If *M* was not of maximal rank.\n\n    References\n    ==========\n\n    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory*\n       (See Sec. 2.3.2.)\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "isolate",
    "full_id": "sympy.polys.numberfields.utilities.isolate",
    "type": "function",
    "description": "\n    Find a rational isolating interval for a real algebraic number.\n\n    Examples\n    ========\n\n    >>> from sympy import isolate, sqrt, Rational\n    >>> print(isolate(sqrt(2)))  # doctest: +SKIP\n    (1, 2)\n    >>> print(isolate(sqrt(2), eps=Rational(1, 100)))\n    (24/17, 17/12)\n\n    Parameters\n    ==========\n\n    alg : str, int, :py:class:`~.Expr`\n        The algebraic number to be isolated. Must be a real number, to use this\n        particular function. However, see also :py:meth:`.Poly.intervals`,\n        which isolates complex roots when you pass ``all=True``.\n    eps : positive element of :ref:`QQ`, None, optional (default=None)\n        Precision to be passed to :py:meth:`.Poly.refine_root`\n    fast : boolean, optional (default=False)\n        Say whether fast refinement procedure should be used.\n        (Will be passed to :py:meth:`.Poly.refine_root`.)\n\n    Returns\n    =======\n\n    Pair of rational numbers defining an isolating interval for the given\n    algebraic number.\n\n    See Also\n    ========\n\n    .Poly.intervals\n\n    ",
    "section": "Utilities",
    "url": "https://docs.sympy.org/latest/modules/polys/numberfields.html"
  },
  {
    "name": "codomain",
    "full_id": "sympy.categories.Morphism.codomain",
    "type": "property",
    "description": "\n        Returns the codomain of the morphism.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> f.codomain\n        Object(\"B\")\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "compose",
    "full_id": "sympy.categories.Morphism.compose",
    "type": "method",
    "description": "\n        Composes self with the supplied morphism.\n\n        The order of elements in the composition is the usual order,\n        i.e., to construct `g\\circ f` use ``g.compose(f)``.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> g * f\n        CompositeMorphism((NamedMorphism(Object(\"A\"), Object(\"B\"), \"f\"),\n        NamedMorphism(Object(\"B\"), Object(\"C\"), \"g\")))\n        >>> (g * f).domain\n        Object(\"A\")\n        >>> (g * f).codomain\n        Object(\"C\")\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "domain",
    "full_id": "sympy.categories.Morphism.domain",
    "type": "property",
    "description": "\n        Returns the domain of the morphism.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> f.domain\n        Object(\"A\")\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "name",
    "full_id": "sympy.categories.NamedMorphism.name",
    "type": "property",
    "description": "\n        Returns the name of the morphism.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> f.name\n        'f'\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "codomain",
    "full_id": "sympy.categories.CompositeMorphism.codomain",
    "type": "property",
    "description": "\n        Returns the codomain of this composite morphism.\n\n        The codomain of the composite morphism is the codomain of its\n        last component.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> (g * f).codomain\n        Object(\"C\")\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "components",
    "full_id": "sympy.categories.CompositeMorphism.components",
    "type": "property",
    "description": "\n        Returns the components of this composite morphism.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> (g * f).components\n        (NamedMorphism(Object(\"A\"), Object(\"B\"), \"f\"),\n        NamedMorphism(Object(\"B\"), Object(\"C\"), \"g\"))\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "domain",
    "full_id": "sympy.categories.CompositeMorphism.domain",
    "type": "property",
    "description": "\n        Returns the domain of this composite morphism.\n\n        The domain of the composite morphism is the domain of its\n        first component.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> (g * f).domain\n        Object(\"A\")\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "flatten",
    "full_id": "sympy.categories.CompositeMorphism.flatten",
    "type": "method",
    "description": "\n        Forgets the composite structure of this morphism.\n\n        Explanation\n        ===========\n\n        If ``new_name`` is not empty, returns a :class:`NamedMorphism`\n        with the supplied name, otherwise returns a :class:`Morphism`.\n        In both cases the domain of the new morphism is the domain of\n        this composite morphism and the codomain of the new morphism\n        is the codomain of this composite morphism.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> (g * f).flatten(\"h\")\n        NamedMorphism(Object(\"A\"), Object(\"C\"), \"h\")\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "commutative_diagrams",
    "full_id": "sympy.categories.Category.commutative_diagrams",
    "type": "property",
    "description": "\n        Returns the :class:`~.FiniteSet` of diagrams which are known to\n        be commutative in this category.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism, Diagram, Category\n        >>> from sympy import FiniteSet\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> d = Diagram([f, g])\n        >>> K = Category(\"K\", commutative_diagrams=[d])\n        >>> K.commutative_diagrams == FiniteSet(d)\n        True\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "name",
    "full_id": "sympy.categories.Category.name",
    "type": "property",
    "description": "\n        Returns the name of this category.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Category\n        >>> K = Category(\"K\")\n        >>> K.name\n        'K'\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "objects",
    "full_id": "sympy.categories.Category.objects",
    "type": "property",
    "description": "\n        Returns the class of objects of this category.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, Category\n        >>> from sympy import FiniteSet\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> K = Category(\"K\", FiniteSet(A, B))\n        >>> K.objects\n        Class({Object(\"A\"), Object(\"B\")})\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "conclusions",
    "full_id": "sympy.categories.Diagram.conclusions",
    "type": "property",
    "description": "\n        Returns the conclusions of this diagram.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> from sympy.categories import IdentityMorphism, Diagram\n        >>> from sympy import FiniteSet\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> d = Diagram([f, g])\n        >>> IdentityMorphism(A) in d.premises.keys()\n        True\n        >>> g * f in d.premises.keys()\n        True\n        >>> d = Diagram([f, g], {g * f: \"unique\"})\n        >>> d.conclusions[g * f] == FiniteSet(\"unique\")\n        True\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "hom",
    "full_id": "sympy.categories.Diagram.hom",
    "type": "method",
    "description": "\n        Returns a 2-tuple of sets of morphisms between objects ``A`` and\n        ``B``: one set of morphisms listed as premises, and the other set\n        of morphisms listed as conclusions.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism, Diagram\n        >>> from sympy import pretty\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> d = Diagram([f, g], {g * f: \"unique\"})\n        >>> print(pretty(d.hom(A, C), use_unicode=False))\n        ({g*f:A-->C}, {g*f:A-->C})\n\n        See Also\n        ========\n        Object, Morphism\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "is_subdiagram",
    "full_id": "sympy.categories.Diagram.is_subdiagram",
    "type": "method",
    "description": "\n        Checks whether ``diagram`` is a subdiagram of ``self``.\n        Diagram `D'` is a subdiagram of `D` if all premises\n        (conclusions) of `D'` are contained in the premises\n        (conclusions) of `D`.  The morphisms contained\n        both in `D'` and `D` should have the same properties for `D'`\n        to be a subdiagram of `D`.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism, Diagram\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> d = Diagram([f, g], {g * f: \"unique\"})\n        >>> d1 = Diagram([f])\n        >>> d.is_subdiagram(d1)\n        True\n        >>> d1.is_subdiagram(d)\n        False\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "objects",
    "full_id": "sympy.categories.Diagram.objects",
    "type": "property",
    "description": "\n        Returns the :class:`~.FiniteSet` of objects that appear in this\n        diagram.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism, Diagram\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> d = Diagram([f, g])\n        >>> d.objects\n        {Object(\"A\"), Object(\"B\"), Object(\"C\")}\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "premises",
    "full_id": "sympy.categories.Diagram.premises",
    "type": "property",
    "description": "\n        Returns the premises of this diagram.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> from sympy.categories import IdentityMorphism, Diagram\n        >>> from sympy import pretty\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> id_A = IdentityMorphism(A)\n        >>> id_B = IdentityMorphism(B)\n        >>> d = Diagram([f])\n        >>> print(pretty(d.premises, use_unicode=False))\n        {id:A-->A: EmptySet, id:B-->B: EmptySet, f:A-->B: EmptySet}\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "subdiagram_from_objects",
    "full_id": "sympy.categories.Diagram.subdiagram_from_objects",
    "type": "method",
    "description": "\n        If ``objects`` is a subset of the objects of ``self``, returns\n        a diagram which has as premises all those premises of ``self``\n        which have a domains and codomains in ``objects``, likewise\n        for conclusions.  Properties are preserved.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism, Diagram\n        >>> from sympy import FiniteSet\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> d = Diagram([f, g], {f: \"unique\", g*f: \"veryunique\"})\n        >>> d1 = d.subdiagram_from_objects(FiniteSet(A, B))\n        >>> d1 == Diagram([f], {f: \"unique\"})\n        True\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "height",
    "full_id": "sympy.categories.diagram_drawing.DiagramGrid.height",
    "type": "property",
    "description": "\n        Returns the number of rows in this diagram layout.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> from sympy.categories import Diagram, DiagramGrid\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> diagram = Diagram([f, g])\n        >>> grid = DiagramGrid(diagram)\n        >>> grid.height\n        2\n\n        ",
    "section": "Diagram Drawing",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "morphisms",
    "full_id": "sympy.categories.diagram_drawing.DiagramGrid.morphisms",
    "type": "property",
    "description": "\n        Returns those morphisms (and their properties) which are\n        sufficiently meaningful to be drawn.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> from sympy.categories import Diagram, DiagramGrid\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> diagram = Diagram([f, g])\n        >>> grid = DiagramGrid(diagram)\n        >>> grid.morphisms\n        {NamedMorphism(Object(\"A\"), Object(\"B\"), \"f\"): EmptySet,\n        NamedMorphism(Object(\"B\"), Object(\"C\"), \"g\"): EmptySet}\n\n        ",
    "section": "Diagram Drawing",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "width",
    "full_id": "sympy.categories.diagram_drawing.DiagramGrid.width",
    "type": "property",
    "description": "\n        Returns the number of columns in this diagram layout.\n\n        Examples\n        ========\n\n        >>> from sympy.categories import Object, NamedMorphism\n        >>> from sympy.categories import Diagram, DiagramGrid\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> diagram = Diagram([f, g])\n        >>> grid = DiagramGrid(diagram)\n        >>> grid.width\n        2\n\n        ",
    "section": "Diagram Drawing",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "draw",
    "full_id": "sympy.categories.diagram_drawing.XypicDiagramDrawer.draw",
    "type": "method",
    "description": "\n        Returns the Xy-pic representation of ``diagram`` laid out in\n        ``grid``.\n\n        Consider the following simple triangle diagram.\n\n        >>> from sympy.categories import Object, NamedMorphism, Diagram\n        >>> from sympy.categories import DiagramGrid, XypicDiagramDrawer\n        >>> A = Object(\"A\")\n        >>> B = Object(\"B\")\n        >>> C = Object(\"C\")\n        >>> f = NamedMorphism(A, B, \"f\")\n        >>> g = NamedMorphism(B, C, \"g\")\n        >>> diagram = Diagram([f, g], {g * f: \"unique\"})\n\n        To draw this diagram, its objects need to be laid out with a\n        :class:`DiagramGrid`::\n\n        >>> grid = DiagramGrid(diagram)\n\n        Finally, the drawing:\n\n        >>> drawer = XypicDiagramDrawer()\n        >>> print(drawer.draw(diagram, grid))\n        \\xymatrix{\n        A \\ar[d]_{g\\circ f} \\ar[r]^{f} & B \\ar[ld]^{g} \\\\\n        C &\n        }\n\n        The argument ``masked`` can be used to skip morphisms in the\n        presentation of the diagram:\n\n        >>> print(drawer.draw(diagram, grid, masked=[g * f]))\n        \\xymatrix{\n        A \\ar[r]^{f} & B \\ar[ld]^{g} \\\\\n        C &\n        }\n\n        Finally, the ``diagram_format`` argument can be used to\n        specify the format string of the diagram.  For example, to\n        increase the spacing by 1 cm, proceeding as follows:\n\n        >>> print(drawer.draw(diagram, grid, diagram_format=\"@+1cm\"))\n        \\xymatrix@+1cm{\n        A \\ar[d]_{g\\circ f} \\ar[r]^{f} & B \\ar[ld]^{g} \\\\\n        C &\n        }\n\n        ",
    "section": "Diagram Drawing",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "xypic_draw_diagram",
    "full_id": "sympy.categories.diagram_drawing.xypic_draw_diagram",
    "type": "function",
    "description": "\n    Provides a shortcut combining :class:`DiagramGrid` and\n    :class:`XypicDiagramDrawer`.  Returns an Xy-pic presentation of\n    ``diagram``.  The argument ``masked`` is a list of morphisms which\n    will be not be drawn.  The argument ``diagram_format`` is the\n    format string inserted after \"\\xymatrix\".  ``groups`` should be a\n    set of logical groups.  The ``hints`` will be passed directly to\n    the constructor of :class:`DiagramGrid`.\n\n    For more information about the arguments, see the docstrings of\n    :class:`DiagramGrid` and ``XypicDiagramDrawer.draw``.\n\n    Examples\n    ========\n\n    >>> from sympy.categories import Object, NamedMorphism, Diagram\n    >>> from sympy.categories import xypic_draw_diagram\n    >>> A = Object(\"A\")\n    >>> B = Object(\"B\")\n    >>> C = Object(\"C\")\n    >>> f = NamedMorphism(A, B, \"f\")\n    >>> g = NamedMorphism(B, C, \"g\")\n    >>> diagram = Diagram([f, g], {g * f: \"unique\"})\n    >>> print(xypic_draw_diagram(diagram))\n    \\xymatrix{\n    A \\ar[d]_{g\\circ f} \\ar[r]^{f} & B \\ar[ld]^{g} \\\\\n    C &\n    }\n\n    See Also\n    ========\n\n    XypicDiagramDrawer, DiagramGrid\n    ",
    "section": "Diagram Drawing",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "preview_diagram",
    "full_id": "sympy.categories.diagram_drawing.preview_diagram",
    "type": "function",
    "description": "\n    Combines the functionality of ``xypic_draw_diagram`` and\n    ``sympy.printing.preview``.  The arguments ``masked``,\n    ``diagram_format``, ``groups``, and ``hints`` are passed to\n    ``xypic_draw_diagram``, while ``output``, ``viewer, and ``euler``\n    are passed to ``preview``.\n\n    Examples\n    ========\n\n    >>> from sympy.categories import Object, NamedMorphism, Diagram\n    >>> from sympy.categories import preview_diagram\n    >>> A = Object(\"A\")\n    >>> B = Object(\"B\")\n    >>> C = Object(\"C\")\n    >>> f = NamedMorphism(A, B, \"f\")\n    >>> g = NamedMorphism(B, C, \"g\")\n    >>> d = Diagram([f, g], {g * f: \"unique\"})\n    >>> preview_diagram(d)\n\n    See Also\n    ========\n\n    XypicDiagramDrawer\n    ",
    "section": "Diagram Drawing",
    "url": "https://docs.sympy.org/latest/modules/categories.html"
  },
  {
    "name": "AZ",
    "full_id": "sympy.crypto.crypto.AZ",
    "type": "function",
    "description": "Return the letters of ``s`` in uppercase. In case more than\n    one string is passed, each of them will be processed and a list\n    of upper case strings will be returned.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import AZ\n    >>> AZ('Hello, world!')\n    'HELLOWORLD'\n    >>> AZ('Hello, world!'.split())\n    ['HELLO', 'WORLD']\n\n    See Also\n    ========\n\n    check_and_join\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "padded_key",
    "full_id": "sympy.crypto.crypto.padded_key",
    "type": "function",
    "description": "Return a string of the distinct characters of ``symbols`` with\n    those of ``key`` appearing first. A ValueError is raised if\n    a) there are duplicate characters in ``symbols`` or\n    b) there are characters in ``key`` that are  not in ``symbols``.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import padded_key\n    >>> padded_key('PUPPY', 'OPQRSTUVWXY')\n    'PUYOQRSTVWX'\n    >>> padded_key('RSA', 'ARTIST')\n    Traceback (most recent call last):\n    ...\n    ValueError: duplicate characters in symbols: T\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "check_and_join",
    "full_id": "sympy.crypto.crypto.check_and_join",
    "type": "function",
    "description": "\n    Joins characters of ``phrase`` and if ``symbols`` is given, raises\n    an error if any character in ``phrase`` is not in ``symbols``.\n\n    Parameters\n    ==========\n\n    phrase\n        String or list of strings to be returned as a string.\n\n    symbols\n        Iterable of characters allowed in ``phrase``.\n\n        If ``symbols`` is ``None``, no checking is performed.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import check_and_join\n    >>> check_and_join('a phrase')\n    'a phrase'\n    >>> check_and_join('a phrase'.upper().split())\n    'APHRASE'\n    >>> check_and_join('a phrase!'.upper().split(), 'ARE', filter=True)\n    'ARAE'\n    >>> check_and_join('a phrase!'.upper().split(), 'ARE')\n    Traceback (most recent call last):\n    ...\n    ValueError: characters in phrase but not symbols: \"!HPS\"\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "cycle_list",
    "full_id": "sympy.crypto.crypto.cycle_list",
    "type": "function",
    "description": "\n    Returns the elements of the list ``range(n)`` shifted to the\n    left by ``k`` (so the list starts with ``k`` (mod ``n``)).\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import cycle_list\n    >>> cycle_list(3, 10)\n    [3, 4, 5, 6, 7, 8, 9, 0, 1, 2]\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_shift",
    "full_id": "sympy.crypto.crypto.encipher_shift",
    "type": "function",
    "description": "\n    Performs shift cipher encryption on plaintext msg, and returns the\n    ciphertext.\n\n    Parameters\n    ==========\n\n    key : int\n        The secret key.\n\n    msg : str\n        Plaintext of upper-case letters.\n\n    Returns\n    =======\n\n    str\n        Ciphertext of upper-case letters.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_shift, decipher_shift\n    >>> msg = \"GONAVYBEATARMY\"\n    >>> ct = encipher_shift(msg, 1); ct\n    'HPOBWZCFBUBSNZ'\n\n    To decipher the shifted text, change the sign of the key:\n\n    >>> encipher_shift(ct, -1)\n    'GONAVYBEATARMY'\n\n    There is also a convenience function that does this with the\n    original key:\n\n    >>> decipher_shift(ct, 1)\n    'GONAVYBEATARMY'\n\n    Notes\n    =====\n\n    ALGORITHM:\n\n        STEPS:\n            0. Number the letters of the alphabet from 0, ..., N\n            1. Compute from the string ``msg`` a list ``L1`` of\n               corresponding integers.\n            2. Compute from the list ``L1`` a new list ``L2``, given by\n               adding ``(k mod 26)`` to each element in ``L1``.\n            3. Compute from the list ``L2`` a string ``ct`` of\n               corresponding letters.\n\n    The shift cipher is also called the Caesar cipher, after\n    Julius Caesar, who, according to Suetonius, used it with a\n    shift of three to protect messages of military significance.\n    Caesar's nephew Augustus reportedly used a similar cipher, but\n    with a right shift of 1.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Caesar_cipher\n    .. [2] https://mathworld.wolfram.com/CaesarsMethod.html\n\n    See Also\n    ========\n\n    decipher_shift\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_shift",
    "full_id": "sympy.crypto.crypto.decipher_shift",
    "type": "function",
    "description": "\n    Return the text by shifting the characters of ``msg`` to the\n    left by the amount given by ``key``.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_shift, decipher_shift\n    >>> msg = \"GONAVYBEATARMY\"\n    >>> ct = encipher_shift(msg, 1); ct\n    'HPOBWZCFBUBSNZ'\n\n    To decipher the shifted text, change the sign of the key:\n\n    >>> encipher_shift(ct, -1)\n    'GONAVYBEATARMY'\n\n    Or use this function with the original key:\n\n    >>> decipher_shift(ct, 1)\n    'GONAVYBEATARMY'\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_rot13",
    "full_id": "sympy.crypto.crypto.encipher_rot13",
    "type": "function",
    "description": "\n    Performs the ROT13 encryption on a given plaintext ``msg``.\n\n    Explanation\n    ===========\n\n    ROT13 is a substitution cipher which substitutes each letter\n    in the plaintext message for the letter furthest away from it\n    in the English alphabet.\n\n    Equivalently, it is just a Caeser (shift) cipher with a shift\n    key of 13 (midway point of the alphabet).\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/ROT13\n\n    See Also\n    ========\n\n    decipher_rot13\n    encipher_shift\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_rot13",
    "full_id": "sympy.crypto.crypto.decipher_rot13",
    "type": "function",
    "description": "\n    Performs the ROT13 decryption on a given plaintext ``msg``.\n\n    Explanation\n    ============\n\n    ``decipher_rot13`` is equivalent to ``encipher_rot13`` as both\n    ``decipher_shift`` with a key of 13 and ``encipher_shift`` key with a\n    key of 13 will return the same results. Nonetheless,\n    ``decipher_rot13`` has nonetheless been explicitly defined here for\n    consistency.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_rot13, decipher_rot13\n    >>> msg = 'GONAVYBEATARMY'\n    >>> ciphertext = encipher_rot13(msg);ciphertext\n    'TBANILORNGNEZL'\n    >>> decipher_rot13(ciphertext)\n    'GONAVYBEATARMY'\n    >>> encipher_rot13(msg) == decipher_rot13(msg)\n    True\n    >>> msg == decipher_rot13(ciphertext)\n    True\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_affine",
    "full_id": "sympy.crypto.crypto.encipher_affine",
    "type": "function",
    "description": "\n    Performs the affine cipher encryption on plaintext ``msg``, and\n    returns the ciphertext.\n\n    Explanation\n    ===========\n\n    Encryption is based on the map `x \\rightarrow ax+b` (mod `N`)\n    where ``N`` is the number of characters in the alphabet.\n    Decryption is based on the map `x \\rightarrow cx+d` (mod `N`),\n    where `c = a^{-1}` (mod `N`) and `d = -a^{-1}b` (mod `N`).\n    In particular, for the map to be invertible, we need\n    `\\mathrm{gcd}(a, N) = 1` and an error will be raised if this is\n    not true.\n\n    Parameters\n    ==========\n\n    msg : str\n        Characters that appear in ``symbols``.\n\n    a, b : int, int\n        A pair integers, with ``gcd(a, N) = 1`` (the secret key).\n\n    symbols\n        String of characters (default = uppercase letters).\n\n        When no symbols are given, ``msg`` is converted to upper case\n        letters and all other characters are ignored.\n\n    Returns\n    =======\n\n    ct\n        String of characters (the ciphertext message)\n\n    Notes\n    =====\n\n    ALGORITHM:\n\n        STEPS:\n            0. Number the letters of the alphabet from 0, ..., N\n            1. Compute from the string ``msg`` a list ``L1`` of\n               corresponding integers.\n            2. Compute from the list ``L1`` a new list ``L2``, given by\n               replacing ``x`` by ``a*x + b (mod N)``, for each element\n               ``x`` in ``L1``.\n            3. Compute from the list ``L2`` a string ``ct`` of\n               corresponding letters.\n\n    This is a straightforward generalization of the shift cipher with\n    the added complexity of requiring 2 characters to be deciphered in\n    order to recover the key.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Affine_cipher\n\n    See Also\n    ========\n\n    decipher_affine\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_affine",
    "full_id": "sympy.crypto.crypto.decipher_affine",
    "type": "function",
    "description": "\n    Return the deciphered text that was made from the mapping,\n    `x \\rightarrow ax+b` (mod `N`), where ``N`` is the\n    number of characters in the alphabet. Deciphering is done by\n    reciphering with a new key: `x \\rightarrow cx+d` (mod `N`),\n    where `c = a^{-1}` (mod `N`) and `d = -a^{-1}b` (mod `N`).\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_affine, decipher_affine\n    >>> msg = \"GO NAVY BEAT ARMY\"\n    >>> key = (3, 1)\n    >>> encipher_affine(msg, key)\n    'TROBMVENBGBALV'\n    >>> decipher_affine(_, key)\n    'GONAVYBEATARMY'\n\n    See Also\n    ========\n\n    encipher_affine\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_atbash",
    "full_id": "sympy.crypto.crypto.encipher_atbash",
    "type": "function",
    "description": "\n    Enciphers a given ``msg`` into its Atbash ciphertext and returns it.\n\n    Explanation\n    ===========\n\n    Atbash is a substitution cipher originally used to encrypt the Hebrew\n    alphabet. Atbash works on the principle of mapping each alphabet to its\n    reverse / counterpart (i.e. a would map to z, b to y etc.)\n\n    Atbash is functionally equivalent to the affine cipher with ``a = 25``\n    and ``b = 25``\n\n    See Also\n    ========\n\n    decipher_atbash\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_atbash",
    "full_id": "sympy.crypto.crypto.decipher_atbash",
    "type": "function",
    "description": "\n    Deciphers a given ``msg`` using Atbash cipher and returns it.\n\n    Explanation\n    ===========\n\n    ``decipher_atbash`` is functionally equivalent to ``encipher_atbash``.\n    However, it has still been added as a separate function to maintain\n    consistency.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_atbash, decipher_atbash\n    >>> msg = 'GONAVYBEATARMY'\n    >>> encipher_atbash(msg)\n    'TLMZEBYVZGZINB'\n    >>> decipher_atbash(msg)\n    'TLMZEBYVZGZINB'\n    >>> encipher_atbash(msg) == decipher_atbash(msg)\n    True\n    >>> msg == encipher_atbash(encipher_atbash(msg))\n    True\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Atbash\n\n    See Also\n    ========\n\n    encipher_atbash\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_substitution",
    "full_id": "sympy.crypto.crypto.encipher_substitution",
    "type": "function",
    "description": "\n    Returns the ciphertext obtained by replacing each character that\n    appears in ``old`` with the corresponding character in ``new``.\n    If ``old`` is a mapping, then new is ignored and the replacements\n    defined by ``old`` are used.\n\n    Explanation\n    ===========\n\n    This is a more general than the affine cipher in that the key can\n    only be recovered by determining the mapping for each symbol.\n    Though in practice, once a few symbols are recognized the mappings\n    for other characters can be quickly guessed.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_substitution, AZ\n    >>> old = 'OEYAG'\n    >>> new = '034^6'\n    >>> msg = AZ(\"go navy! beat army!\")\n    >>> ct = encipher_substitution(msg, old, new); ct\n    '60N^V4B3^T^RM4'\n\n    To decrypt a substitution, reverse the last two arguments:\n\n    >>> encipher_substitution(ct, new, old)\n    'GONAVYBEATARMY'\n\n    In the special case where ``old`` and ``new`` are a permutation of\n    order 2 (representing a transposition of characters) their order\n    is immaterial:\n\n    >>> old = 'NAVY'\n    >>> new = 'ANYV'\n    >>> encipher = lambda x: encipher_substitution(x, old, new)\n    >>> encipher('NAVY')\n    'ANYV'\n    >>> encipher(_)\n    'NAVY'\n\n    The substitution cipher, in general, is a method\n    whereby \"units\" (not necessarily single characters) of plaintext\n    are replaced with ciphertext according to a regular system.\n\n    >>> ords = dict(zip('abc', ['\\\\%i' % ord(i) for i in 'abc']))\n    >>> print(encipher_substitution('abc', ords))\n    \\97\\98\\99\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Substitution_cipher\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_vigenere",
    "full_id": "sympy.crypto.crypto.encipher_vigenere",
    "type": "function",
    "description": "\n    Performs the Vigenere cipher encryption on plaintext ``msg``, and\n    returns the ciphertext.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_vigenere, AZ\n    >>> key = \"encrypt\"\n    >>> msg = \"meet me on monday\"\n    >>> encipher_vigenere(msg, key)\n    'QRGKKTHRZQEBPR'\n\n    Section 1 of the Kryptos sculpture at the CIA headquarters\n    uses this cipher and also changes the order of the\n    alphabet [2]_. Here is the first line of that section of\n    the sculpture:\n\n    >>> from sympy.crypto.crypto import decipher_vigenere, padded_key\n    >>> alp = padded_key('KRYPTOS', AZ())\n    >>> key = 'PALIMPSEST'\n    >>> msg = 'EMUFPHZLRFAXYUSDJKZLDKRNSHGNFIVJ'\n    >>> decipher_vigenere(msg, key, alp)\n    'BETWEENSUBTLESHADINGANDTHEABSENC'\n\n    Explanation\n    ===========\n\n    The Vigenere cipher is named after Blaise de Vigenere, a sixteenth\n    century diplomat and cryptographer, by a historical accident.\n    Vigenere actually invented a different and more complicated cipher.\n    The so-called *Vigenere cipher* was actually invented\n    by Giovan Batista Belaso in 1553.\n\n    This cipher was used in the 1800's, for example, during the American\n    Civil War. The Confederacy used a brass cipher disk to implement the\n    Vigenere cipher (now on display in the NSA Museum in Fort\n    Meade) [1]_.\n\n    The Vigenere cipher is a generalization of the shift cipher.\n    Whereas the shift cipher shifts each letter by the same amount\n    (that amount being the key of the shift cipher) the Vigenere\n    cipher shifts a letter by an amount determined by the key (which is\n    a word or phrase known only to the sender and receiver).\n\n    For example, if the key was a single letter, such as \"C\", then the\n    so-called Vigenere cipher is actually a shift cipher with a\n    shift of `2` (since \"C\" is the 2nd letter of the alphabet, if\n    you start counting at `0`). If the key was a word with two\n    letters, such as \"CA\", then the so-called Vigenere cipher will\n    shift letters in even positions by `2` and letters in odd positions\n    are left alone (shifted by `0`, since \"A\" is the 0th letter, if\n    you start counting at `0`).\n\n\n    ALGORITHM:\n\n        INPUT:\n\n            ``msg``: string of characters that appear in ``symbols``\n            (the plaintext)\n\n            ``key``: a string of characters that appear in ``symbols``\n            (the secret key)\n\n            ``symbols``: a string of letters defining the alphabet\n\n\n        OUTPUT:\n\n            ``ct``: string of characters (the ciphertext message)\n\n        STEPS:\n            0. Number the letters of the alphabet from 0, ..., N\n            1. Compute from the string ``key`` a list ``L1`` of\n               corresponding integers. Let ``n1 = len(L1)``.\n            2. Compute from the string ``msg`` a list ``L2`` of\n               corresponding integers. Let ``n2 = len(L2)``.\n            3. Break ``L2`` up sequentially into sublists of size\n               ``n1``; the last sublist may be smaller than ``n1``\n            4. For each of these sublists ``L`` of ``L2``, compute a\n               new list ``C`` given by ``C[i] = L[i] + L1[i] (mod N)``\n               to the ``i``-th element in the sublist, for each ``i``.\n            5. Assemble these lists ``C`` by concatenation into a new\n               list of length ``n2``.\n            6. Compute from the new list a string ``ct`` of\n               corresponding letters.\n\n    Once it is known that the key is, say, `n` characters long,\n    frequency analysis can be applied to every `n`-th letter of\n    the ciphertext to determine the plaintext. This method is\n    called *Kasiski examination* (although it was first discovered\n    by Babbage). If they key is as long as the message and is\n    comprised of randomly selected characters -- a one-time pad -- the\n    message is theoretically unbreakable.\n\n    The cipher Vigenere actually discovered is an \"auto-key\" cipher\n    described as follows.\n\n    ALGORITHM:\n\n        INPUT:\n\n          ``key``: a string of letters (the secret key)\n\n          ``msg``: string of letters (the plaintext message)\n\n        OUTPUT:\n\n          ``ct``: string of upper-case letters (the ciphertext message)\n\n        STEPS:\n            0. Number the letters of the alphabet from 0, ..., N\n            1. Compute from the string ``msg`` a list ``L2`` of\n               corresponding integers. Let ``n2 = len(L2)``.\n            2. Let ``n1`` be the length of the key. Append to the\n               string ``key`` the first ``n2 - n1`` characters of\n               the plaintext message. Compute from this string (also of\n               length ``n2``) a list ``L1`` of integers corresponding\n               to the letter numbers in the first step.\n            3. Compute a new list ``C`` given by\n               ``C[i] = L1[i] + L2[i] (mod N)``.\n            4. Compute from the new list a string ``ct`` of letters\n               corresponding to the new integers.\n\n    To decipher the auto-key ciphertext, the key is used to decipher\n    the first ``n1`` characters and then those characters become the\n    key to  decipher the next ``n1`` characters, etc...:\n\n    >>> m = AZ('go navy, beat army! yes you can'); m\n    'GONAVYBEATARMYYESYOUCAN'\n    >>> key = AZ('gold bug'); n1 = len(key); n2 = len(m)\n    >>> auto_key = key + m[:n2 - n1]; auto_key\n    'GOLDBUGGONAVYBEATARMYYE'\n    >>> ct = encipher_vigenere(m, auto_key); ct\n    'MCYDWSHKOGAMKZCELYFGAYR'\n    >>> n1 = len(key)\n    >>> pt = []\n    >>> while ct:\n    ...     part, ct = ct[:n1], ct[n1:]\n    ...     pt.append(decipher_vigenere(part, key))\n    ...     key = pt[-1]\n    ...\n    >>> ''.join(pt) == m\n    True\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Vigenere_cipher\n    .. [2] https://web.archive.org/web/20071116100808/https://filebox.vt.edu/users/batman/kryptos.html\n       (short URL: https://goo.gl/ijr22d)\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_vigenere",
    "full_id": "sympy.crypto.crypto.decipher_vigenere",
    "type": "function",
    "description": "\n    Decode using the Vigenere cipher.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import decipher_vigenere\n    >>> key = \"encrypt\"\n    >>> ct = \"QRGK kt HRZQE BPR\"\n    >>> decipher_vigenere(ct, key)\n    'MEETMEONMONDAY'\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_hill",
    "full_id": "sympy.crypto.crypto.encipher_hill",
    "type": "function",
    "description": "\n    Return the Hill cipher encryption of ``msg``.\n\n    Explanation\n    ===========\n\n    The Hill cipher [1]_, invented by Lester S. Hill in the 1920's [2]_,\n    was the first polygraphic cipher in which it was practical\n    (though barely) to operate on more than three symbols at once.\n    The following discussion assumes an elementary knowledge of\n    matrices.\n\n    First, each letter is first encoded as a number starting with 0.\n    Suppose your message `msg` consists of `n` capital letters, with no\n    spaces. This may be regarded an `n`-tuple M of elements of\n    `Z_{26}` (if the letters are those of the English alphabet). A key\n    in the Hill cipher is a `k x k` matrix `K`, all of whose entries\n    are in `Z_{26}`, such that the matrix `K` is invertible (i.e., the\n    linear transformation `K: Z_{N}^k \\rightarrow Z_{N}^k`\n    is one-to-one).\n\n\n    Parameters\n    ==========\n\n    msg\n        Plaintext message of `n` upper-case letters.\n\n    key\n        A `k \\times k` invertible matrix `K`, all of whose entries are\n        in `Z_{26}` (or whatever number of symbols are being used).\n\n    pad\n        Character (default \"Q\") to use to make length of text be a\n        multiple of ``k``.\n\n    Returns\n    =======\n\n    ct\n        Ciphertext of upper-case letters.\n\n    Notes\n    =====\n\n    ALGORITHM:\n\n        STEPS:\n            0. Number the letters of the alphabet from 0, ..., N\n            1. Compute from the string ``msg`` a list ``L`` of\n               corresponding integers. Let ``n = len(L)``.\n            2. Break the list ``L`` up into ``t = ceiling(n/k)``\n               sublists ``L_1``, ..., ``L_t`` of size ``k`` (with\n               the last list \"padded\" to ensure its size is\n               ``k``).\n            3. Compute new list ``C_1``, ..., ``C_t`` given by\n               ``C[i] = K*L_i`` (arithmetic is done mod N), for each\n               ``i``.\n            4. Concatenate these into a list ``C = C_1 + ... + C_t``.\n            5. Compute from ``C`` a string ``ct`` of corresponding\n               letters. This has length ``k*t``.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Hill_cipher\n    .. [2] Lester S. Hill, Cryptography in an Algebraic Alphabet,\n       The American Mathematical Monthly Vol.36, June-July 1929,\n       pp.306-312.\n\n    See Also\n    ========\n\n    decipher_hill\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_hill",
    "full_id": "sympy.crypto.crypto.decipher_hill",
    "type": "function",
    "description": "\n    Deciphering is the same as enciphering but using the inverse of the\n    key matrix.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_hill, decipher_hill\n    >>> from sympy import Matrix\n\n    >>> key = Matrix([[1, 2], [3, 5]])\n    >>> encipher_hill(\"meet me on monday\", key)\n    'UEQDUEODOCTCWQ'\n    >>> decipher_hill(_, key)\n    'MEETMEONMONDAY'\n\n    When the length of the plaintext (stripped of invalid characters)\n    is not a multiple of the key dimension, extra characters will\n    appear at the end of the enciphered and deciphered text. In order to\n    decipher the text, those characters must be included in the text to\n    be deciphered. In the following, the key has a dimension of 4 but\n    the text is 2 short of being a multiple of 4 so two characters will\n    be added.\n\n    >>> key = Matrix([[1, 1, 1, 2], [0, 1, 1, 0],\n    ...               [2, 2, 3, 4], [1, 1, 0, 1]])\n    >>> msg = \"ST\"\n    >>> encipher_hill(msg, key)\n    'HJEB'\n    >>> decipher_hill(_, key)\n    'STQQ'\n    >>> encipher_hill(msg, key, pad=\"Z\")\n    'ISPK'\n    >>> decipher_hill(_, key)\n    'STZZ'\n\n    If the last two characters of the ciphertext were ignored in\n    either case, the wrong plaintext would be recovered:\n\n    >>> decipher_hill(\"HD\", key)\n    'ORMV'\n    >>> decipher_hill(\"IS\", key)\n    'UIKY'\n\n    See Also\n    ========\n\n    encipher_hill\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_bifid",
    "full_id": "sympy.crypto.crypto.encipher_bifid",
    "type": "function",
    "description": "\n    Performs the Bifid cipher encryption on plaintext ``msg``, and\n    returns the ciphertext.\n\n    This is the version of the Bifid cipher that uses an `n \\times n`\n    Polybius square.\n\n    Parameters\n    ==========\n\n    msg\n        Plaintext string.\n\n    key\n        Short string for key.\n\n        Duplicate characters are ignored and then it is padded with the\n        characters in ``symbols`` that were not in the short key.\n\n    symbols\n        `n \\times n` characters defining the alphabet.\n\n        (default is string.printable)\n\n    Returns\n    =======\n\n    ciphertext\n        Ciphertext using Bifid5 cipher without spaces.\n\n    See Also\n    ========\n\n    decipher_bifid, encipher_bifid5, encipher_bifid6\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Bifid_cipher\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_bifid",
    "full_id": "sympy.crypto.crypto.decipher_bifid",
    "type": "function",
    "description": "\n    Performs the Bifid cipher decryption on ciphertext ``msg``, and\n    returns the plaintext.\n\n    This is the version of the Bifid cipher that uses the `n \\times n`\n    Polybius square.\n\n    Parameters\n    ==========\n\n    msg\n        Ciphertext string.\n\n    key\n        Short string for key.\n\n        Duplicate characters are ignored and then it is padded with the\n        characters in symbols that were not in the short key.\n\n    symbols\n        `n \\times n` characters defining the alphabet.\n\n        (default=string.printable, a `10 \\times 10` matrix)\n\n    Returns\n    =======\n\n    deciphered\n        Deciphered text.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import (\n    ...     encipher_bifid, decipher_bifid, AZ)\n\n    Do an encryption using the bifid5 alphabet:\n\n    >>> alp = AZ().replace('J', '')\n    >>> ct = AZ(\"meet me on monday!\")\n    >>> key = AZ(\"gold bug\")\n    >>> encipher_bifid(ct, key, alp)\n    'IEILHHFSTSFQYE'\n\n    When entering the text or ciphertext, spaces are ignored so it\n    can be formatted as desired. Re-entering the ciphertext from the\n    preceding, putting 4 characters per line and padding with an extra\n    J, does not cause problems for the deciphering:\n\n    >>> decipher_bifid('''\n    ... IEILH\n    ... HFSTS\n    ... FQYEJ''', key, alp)\n    'MEETMEONMONDAY'\n\n    When no alphabet is given, all 100 printable characters will be\n    used:\n\n    >>> key = ''\n    >>> encipher_bifid('hello world!', key)\n    'bmtwmg-bIo*w'\n    >>> decipher_bifid(_, key)\n    'hello world!'\n\n    If the key is changed, a different encryption is obtained:\n\n    >>> key = 'gold bug'\n    >>> encipher_bifid('hello world!', 'gold_bug')\n    'hg2sfuei7t}w'\n\n    And if the key used to decrypt the message is not exact, the\n    original text will not be perfectly obtained:\n\n    >>> decipher_bifid(_, 'gold pug')\n    'heldo~wor6d!'\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "bifid5_square",
    "full_id": "sympy.crypto.crypto.bifid5_square",
    "type": "function",
    "description": "\n    5x5 Polybius square.\n\n    Produce the Polybius square for the `5 \\times 5` Bifid cipher.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import bifid5_square\n    >>> bifid5_square(\"gold bug\")\n    Matrix([\n    [G, O, L, D, B],\n    [U, A, C, E, F],\n    [H, I, K, M, N],\n    [P, Q, R, S, T],\n    [V, W, X, Y, Z]])\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_bifid5",
    "full_id": "sympy.crypto.crypto.encipher_bifid5",
    "type": "function",
    "description": "\n    Performs the Bifid cipher encryption on plaintext ``msg``, and\n    returns the ciphertext.\n\n    Explanation\n    ===========\n\n    This is the version of the Bifid cipher that uses the `5 \\times 5`\n    Polybius square. The letter \"J\" is ignored so it must be replaced\n    with something else (traditionally an \"I\") before encryption.\n\n    ALGORITHM: (5x5 case)\n\n        STEPS:\n            0. Create the `5 \\times 5` Polybius square ``S`` associated\n               to ``key`` as follows:\n\n                a) moving from left-to-right, top-to-bottom,\n                   place the letters of the key into a `5 \\times 5`\n                   matrix,\n                b) if the key has less than 25 letters, add the\n                   letters of the alphabet not in the key until the\n                   `5 \\times 5` square is filled.\n\n            1. Create a list ``P`` of pairs of numbers which are the\n               coordinates in the Polybius square of the letters in\n               ``msg``.\n            2. Let ``L1`` be the list of all first coordinates of ``P``\n               (length of ``L1 = n``), let ``L2`` be the list of all\n               second coordinates of ``P`` (so the length of ``L2``\n               is also ``n``).\n            3. Let ``L`` be the concatenation of ``L1`` and ``L2``\n               (length ``L = 2*n``), except that consecutive numbers\n               are paired ``(L[2*i], L[2*i + 1])``. You can regard\n               ``L`` as a list of pairs of length ``n``.\n            4. Let ``C`` be the list of all letters which are of the\n               form ``S[i, j]``, for all ``(i, j)`` in ``L``. As a\n               string, this is the ciphertext of ``msg``.\n\n    Parameters\n    ==========\n\n    msg : str\n        Plaintext string.\n\n        Converted to upper case and filtered of anything but all letters\n        except J.\n\n    key\n        Short string for key; non-alphabetic letters, J and duplicated\n        characters are ignored and then, if the length is less than 25\n        characters, it is padded with other letters of the alphabet\n        (in alphabetical order).\n\n    Returns\n    =======\n\n    ct\n        Ciphertext (all caps, no spaces).\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import (\n    ...     encipher_bifid5, decipher_bifid5)\n\n    \"J\" will be omitted unless it is replaced with something else:\n\n    >>> round_trip = lambda m, k: \\\n    ...     decipher_bifid5(encipher_bifid5(m, k), k)\n    >>> key = 'a'\n    >>> msg = \"JOSIE\"\n    >>> round_trip(msg, key)\n    'OSIE'\n    >>> round_trip(msg.replace(\"J\", \"I\"), key)\n    'IOSIE'\n    >>> j = \"QIQ\"\n    >>> round_trip(msg.replace(\"J\", j), key).replace(j, \"J\")\n    'JOSIE'\n\n\n    Notes\n    =====\n\n    The Bifid cipher was invented around 1901 by Felix Delastelle.\n    It is a *fractional substitution* cipher, where letters are\n    replaced by pairs of symbols from a smaller alphabet. The\n    cipher uses a `5 \\times 5` square filled with some ordering of the\n    alphabet, except that \"J\" is replaced with \"I\" (this is a so-called\n    Polybius square; there is a `6 \\times 6` analog if you add back in\n    \"J\" and also append onto the usual 26 letter alphabet, the digits\n    0, 1, ..., 9).\n    According to Helen Gaines' book *Cryptanalysis*, this type of cipher\n    was used in the field by the German Army during World War I.\n\n    See Also\n    ========\n\n    decipher_bifid5, encipher_bifid\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_bifid5",
    "full_id": "sympy.crypto.crypto.decipher_bifid5",
    "type": "function",
    "description": "\n    Return the Bifid cipher decryption of ``msg``.\n\n    Explanation\n    ===========\n\n    This is the version of the Bifid cipher that uses the `5 \\times 5`\n    Polybius square; the letter \"J\" is ignored unless a ``key`` of\n    length 25 is used.\n\n    Parameters\n    ==========\n\n    msg\n        Ciphertext string.\n\n    key\n        Short string for key; duplicated characters are ignored and if\n        the length is less then 25 characters, it will be padded with\n        other letters from the alphabet omitting \"J\".\n        Non-alphabetic characters are ignored.\n\n    Returns\n    =======\n\n    plaintext\n        Plaintext from Bifid5 cipher (all caps, no spaces).\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_bifid5, decipher_bifid5\n    >>> key = \"gold bug\"\n    >>> encipher_bifid5('meet me on friday', key)\n    'IEILEHFSTSFXEE'\n    >>> encipher_bifid5('meet me on monday', key)\n    'IEILHHFSTSFQYE'\n    >>> decipher_bifid5(_, key)\n    'MEETMEONMONDAY'\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_bifid6",
    "full_id": "sympy.crypto.crypto.encipher_bifid6",
    "type": "function",
    "description": "\n    Performs the Bifid cipher encryption on plaintext ``msg``, and\n    returns the ciphertext.\n\n    This is the version of the Bifid cipher that uses the `6 \\times 6`\n    Polybius square.\n\n    Parameters\n    ==========\n\n    msg\n        Plaintext string (digits okay).\n\n    key\n        Short string for key (digits okay).\n\n        If ``key`` is less than 36 characters long, the square will be\n        filled with letters A through Z and digits 0 through 9.\n\n    Returns\n    =======\n\n    ciphertext\n        Ciphertext from Bifid cipher (all caps, no spaces).\n\n    See Also\n    ========\n\n    decipher_bifid6, encipher_bifid\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_bifid6",
    "full_id": "sympy.crypto.crypto.decipher_bifid6",
    "type": "function",
    "description": "\n    Performs the Bifid cipher decryption on ciphertext ``msg``, and\n    returns the plaintext.\n\n    This is the version of the Bifid cipher that uses the `6 \\times 6`\n    Polybius square.\n\n    Parameters\n    ==========\n\n    msg\n        Ciphertext string (digits okay); converted to upper case\n\n    key\n        Short string for key (digits okay).\n\n        If ``key`` is less than 36 characters long, the square will be\n        filled with letters A through Z and digits 0 through 9.\n        All letters are converted to uppercase.\n\n    Returns\n    =======\n\n    plaintext\n        Plaintext from Bifid cipher (all caps, no spaces).\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_bifid6, decipher_bifid6\n    >>> key = \"gold bug\"\n    >>> encipher_bifid6('meet me on monday at 8am', key)\n    'KFKLJJHF5MMMKTFRGPL'\n    >>> decipher_bifid6(_, key)\n    'MEETMEONMONDAYAT8AM'\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "bifid6_square",
    "full_id": "sympy.crypto.crypto.bifid6_square",
    "type": "function",
    "description": "\n    6x6 Polybius square.\n\n    Produces the Polybius square for the `6 \\times 6` Bifid cipher.\n    Assumes alphabet of symbols is \"A\", ..., \"Z\", \"0\", ..., \"9\".\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import bifid6_square\n    >>> key = \"gold bug\"\n    >>> bifid6_square(key)\n    Matrix([\n    [G, O, L, D, B, U],\n    [A, C, E, F, H, I],\n    [J, K, M, N, P, Q],\n    [R, S, T, V, W, X],\n    [Y, Z, 0, 1, 2, 3],\n    [4, 5, 6, 7, 8, 9]])\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "rsa_public_key",
    "full_id": "sympy.crypto.crypto.rsa_public_key",
    "type": "function",
    "description": "Return the RSA *public key* pair, `(n, e)`\n\n    Parameters\n    ==========\n\n    args : naturals\n        If specified as `p, q, e` where `p` and `q` are distinct primes\n        and `e` is a desired public exponent of the RSA, `n = p q` and\n        `e` will be verified against the totient\n        `\\phi(n)` (Euler totient) or `\\lambda(n)` (Carmichael totient)\n        to be `\\gcd(e, \\phi(n)) = 1` or `\\gcd(e, \\lambda(n)) = 1`.\n\n        If specified as `p_1, p_2, \\dots, p_n, e` where\n        `p_1, p_2, \\dots, p_n` are specified as primes,\n        and `e` is specified as a desired public exponent of the RSA,\n        it will be able to form a multi-prime RSA, which is a more\n        generalized form of the popular 2-prime RSA.\n\n        It can also be possible to form a single-prime RSA by specifying\n        the argument as `p, e`, which can be considered a trivial case\n        of a multiprime RSA.\n\n        Furthermore, it can be possible to form a multi-power RSA by\n        specifying two or more pairs of the primes to be same.\n        However, unlike the two-distinct prime RSA or multi-prime\n        RSA, not every numbers in the complete residue system\n        (`\\mathbb{Z}_n`) will be decryptable since the mapping\n        `\\mathbb{Z}_{n} \\rightarrow \\mathbb{Z}_{n}`\n        will not be bijective.\n        (Only except for the trivial case when\n        `e = 1`\n        or more generally,\n\n        .. math::\n            e \\in \\left \\{ 1 + k \\lambda(n)\n            \\mid k \\in \\mathbb{Z} \\land k \\geq 0 \\right \\}\n\n        when RSA reduces to the identity.)\n        However, the RSA can still be decryptable for the numbers in the\n        reduced residue system (`\\mathbb{Z}_n^{\\times}`), since the\n        mapping\n        `\\mathbb{Z}_{n}^{\\times} \\rightarrow \\mathbb{Z}_{n}^{\\times}`\n        can still be bijective.\n\n        If you pass a non-prime integer to the arguments\n        `p_1, p_2, \\dots, p_n`, the particular number will be\n        prime-factored and it will become either a multi-prime RSA or a\n        multi-power RSA in its canonical form, depending on whether the\n        product equals its radical or not.\n        `p_1 p_2 \\dots p_n = \\text{rad}(p_1 p_2 \\dots p_n)`\n\n    totient : bool, optional\n        If ``'Euler'``, it uses Euler's totient `\\phi(n)` which is\n        :meth:`sympy.functions.combinatorial.numbers.totient` in SymPy.\n\n        If ``'Carmichael'``, it uses Carmichael's totient `\\lambda(n)`\n        which is :meth:`sympy.functions.combinatorial.numbers.reduced_totient` in SymPy.\n\n        Unlike private key generation, this is a trivial keyword for\n        public key generation because\n        `\\gcd(e, \\phi(n)) = 1 \\iff \\gcd(e, \\lambda(n)) = 1`.\n\n    index : nonnegative integer, optional\n        Returns an arbitrary solution of a RSA public key at the index\n        specified at `0, 1, 2, \\dots`. This parameter needs to be\n        specified along with ``totient='Carmichael'``.\n\n        Similarly to the non-uniquenss of a RSA private key as described\n        in the ``index`` parameter documentation in\n        :meth:`rsa_private_key`, RSA public key is also not unique and\n        there is an infinite number of RSA public exponents which\n        can behave in the same manner.\n\n        From any given RSA public exponent `e`, there are can be an\n        another RSA public exponent `e + k \\lambda(n)` where `k` is an\n        integer, `\\lambda` is a Carmichael's totient function.\n\n        However, considering only the positive cases, there can be\n        a principal solution of a RSA public exponent `e_0` in\n        `0 < e_0 < \\lambda(n)`, and all the other solutions\n        can be canonicalzed in a form of `e_0 + k \\lambda(n)`.\n\n        ``index`` specifies the `k` notation to yield any possible value\n        an RSA public key can have.\n\n        An example of computing any arbitrary RSA public key:\n\n        >>> from sympy.crypto.crypto import rsa_public_key\n        >>> rsa_public_key(61, 53, 17, totient='Carmichael', index=0)\n        (3233, 17)\n        >>> rsa_public_key(61, 53, 17, totient='Carmichael', index=1)\n        (3233, 797)\n        >>> rsa_public_key(61, 53, 17, totient='Carmichael', index=2)\n        (3233, 1577)\n\n    multipower : bool, optional\n        Any pair of non-distinct primes found in the RSA specification\n        will restrict the domain of the cryptosystem, as noted in the\n        explanation of the parameter ``args``.\n\n        SymPy RSA key generator may give a warning before dispatching it\n        as a multi-power RSA, however, you can disable the warning if\n        you pass ``True`` to this keyword.\n\n    Returns\n    =======\n\n    (n, e) : int, int\n        `n` is a product of any arbitrary number of primes given as\n        the argument.\n\n        `e` is relatively prime (coprime) to the Euler totient\n        `\\phi(n)`.\n\n    False\n        Returned if less than two arguments are given, or `e` is\n        not relatively prime to the modulus.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import rsa_public_key\n\n    A public key of a two-prime RSA:\n\n    >>> p, q, e = 3, 5, 7\n    >>> rsa_public_key(p, q, e)\n    (15, 7)\n    >>> rsa_public_key(p, q, 30)\n    False\n\n    A public key of a multiprime RSA:\n\n    >>> primes = [2, 3, 5, 7, 11, 13]\n    >>> e = 7\n    >>> args = primes + [e]\n    >>> rsa_public_key(*args)\n    (30030, 7)\n\n    Notes\n    =====\n\n    Although the RSA can be generalized over any modulus `n`, using\n    two large primes had became the most popular specification because a\n    product of two large primes is usually the hardest to factor\n    relatively to the digits of `n` can have.\n\n    However, it may need further understanding of the time complexities\n    of each prime-factoring algorithms to verify the claim.\n\n    See Also\n    ========\n\n    rsa_private_key\n    encipher_rsa\n    decipher_rsa\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29\n\n    .. [2] https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n\n    .. [3] https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf\n\n    .. [4] https://www.itiis.org/digital-library/manuscript/1381\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "rsa_private_key",
    "full_id": "sympy.crypto.crypto.rsa_private_key",
    "type": "function",
    "description": "Return the RSA *private key* pair, `(n, d)`\n\n    Parameters\n    ==========\n\n    args : naturals\n        The keyword is identical to the ``args`` in\n        :meth:`rsa_public_key`.\n\n    totient : bool, optional\n        If ``'Euler'``, it uses Euler's totient convention `\\phi(n)`\n        which is :meth:`sympy.functions.combinatorial.numbers.totient` in SymPy.\n\n        If ``'Carmichael'``, it uses Carmichael's totient convention\n        `\\lambda(n)` which is\n        :meth:`sympy.functions.combinatorial.numbers.reduced_totient` in SymPy.\n\n        There can be some output differences for private key generation\n        as examples below.\n\n        Example using Euler's totient:\n\n        >>> from sympy.crypto.crypto import rsa_private_key\n        >>> rsa_private_key(61, 53, 17, totient='Euler')\n        (3233, 2753)\n\n        Example using Carmichael's totient:\n\n        >>> from sympy.crypto.crypto import rsa_private_key\n        >>> rsa_private_key(61, 53, 17, totient='Carmichael')\n        (3233, 413)\n\n    index : nonnegative integer, optional\n        Returns an arbitrary solution of a RSA private key at the index\n        specified at `0, 1, 2, \\dots`. This parameter needs to be\n        specified along with ``totient='Carmichael'``.\n\n        RSA private exponent is a non-unique solution of\n        `e d \\mod \\lambda(n) = 1` and it is possible in any form of\n        `d + k \\lambda(n)`, where `d` is an another\n        already-computed private exponent, and `\\lambda` is a\n        Carmichael's totient function, and `k` is any integer.\n\n        However, considering only the positive cases, there can be\n        a principal solution of a RSA private exponent `d_0` in\n        `0 < d_0 < \\lambda(n)`, and all the other solutions\n        can be canonicalzed in a form of `d_0 + k \\lambda(n)`.\n\n        ``index`` specifies the `k` notation to yield any possible value\n        an RSA private key can have.\n\n        An example of computing any arbitrary RSA private key:\n\n        >>> from sympy.crypto.crypto import rsa_private_key\n        >>> rsa_private_key(61, 53, 17, totient='Carmichael', index=0)\n        (3233, 413)\n        >>> rsa_private_key(61, 53, 17, totient='Carmichael', index=1)\n        (3233, 1193)\n        >>> rsa_private_key(61, 53, 17, totient='Carmichael', index=2)\n        (3233, 1973)\n\n    multipower : bool, optional\n        The keyword is identical to the ``multipower`` in\n        :meth:`rsa_public_key`.\n\n    Returns\n    =======\n\n    (n, d) : int, int\n        `n` is a product of any arbitrary number of primes given as\n        the argument.\n\n        `d` is the inverse of `e` (mod `\\phi(n)`) where `e` is the\n        exponent given, and `\\phi` is a Euler totient.\n\n    False\n        Returned if less than two arguments are given, or `e` is\n        not relatively prime to the totient of the modulus.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import rsa_private_key\n\n    A private key of a two-prime RSA:\n\n    >>> p, q, e = 3, 5, 7\n    >>> rsa_private_key(p, q, e)\n    (15, 7)\n    >>> rsa_private_key(p, q, 30)\n    False\n\n    A private key of a multiprime RSA:\n\n    >>> primes = [2, 3, 5, 7, 11, 13]\n    >>> e = 7\n    >>> args = primes + [e]\n    >>> rsa_private_key(*args)\n    (30030, 823)\n\n    See Also\n    ========\n\n    rsa_public_key\n    encipher_rsa\n    decipher_rsa\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29\n\n    .. [2] https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n\n    .. [3] https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf\n\n    .. [4] https://www.itiis.org/digital-library/manuscript/1381\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_rsa",
    "full_id": "sympy.crypto.crypto.encipher_rsa",
    "type": "function",
    "description": "Encrypt the plaintext with RSA.\n\n    Parameters\n    ==========\n\n    i : integer\n        The plaintext to be encrypted for.\n\n    key : (n, e) where n, e are integers\n        `n` is the modulus of the key and `e` is the exponent of the\n        key. The encryption is computed by `i^e \\bmod n`.\n\n        The key can either be a public key or a private key, however,\n        the message encrypted by a public key can only be decrypted by\n        a private key, and vice versa, as RSA is an asymmetric\n        cryptography system.\n\n    factors : list of coprime integers\n        This is identical to the keyword ``factors`` in\n        :meth:`decipher_rsa`.\n\n    Notes\n    =====\n\n    Some specifications may make the RSA not cryptographically\n    meaningful.\n\n    For example, `0`, `1` will remain always same after taking any\n    number of exponentiation, thus, should be avoided.\n\n    Furthermore, if `i^e < n`, `i` may easily be figured out by taking\n    `e` th root.\n\n    And also, specifying the exponent as `1` or in more generalized form\n    as `1 + k \\lambda(n)` where `k` is an nonnegative integer,\n    `\\lambda` is a carmichael totient, the RSA becomes an identity\n    mapping.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_rsa\n    >>> from sympy.crypto.crypto import rsa_public_key, rsa_private_key\n\n    Public Key Encryption:\n\n    >>> p, q, e = 3, 5, 7\n    >>> puk = rsa_public_key(p, q, e)\n    >>> msg = 12\n    >>> encipher_rsa(msg, puk)\n    3\n\n    Private Key Encryption:\n\n    >>> p, q, e = 3, 5, 7\n    >>> prk = rsa_private_key(p, q, e)\n    >>> msg = 12\n    >>> encipher_rsa(msg, prk)\n    3\n\n    Encryption using chinese remainder theorem:\n\n    >>> encipher_rsa(msg, prk, factors=[p, q])\n    3\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_rsa",
    "full_id": "sympy.crypto.crypto.decipher_rsa",
    "type": "function",
    "description": "Decrypt the ciphertext with RSA.\n\n    Parameters\n    ==========\n\n    i : integer\n        The ciphertext to be decrypted for.\n\n    key : (n, d) where n, d are integers\n        `n` is the modulus of the key and `d` is the exponent of the\n        key. The decryption is computed by `i^d \\bmod n`.\n\n        The key can either be a public key or a private key, however,\n        the message encrypted by a public key can only be decrypted by\n        a private key, and vice versa, as RSA is an asymmetric\n        cryptography system.\n\n    factors : list of coprime integers\n        As the modulus `n` created from RSA key generation is composed\n        of arbitrary prime factors\n        `n = {p_1}^{k_1}{p_2}^{k_2}\\dots{p_n}^{k_n}` where\n        `p_1, p_2, \\dots, p_n` are distinct primes and\n        `k_1, k_2, \\dots, k_n` are positive integers, chinese remainder\n        theorem can be used to compute `i^d \\bmod n` from the\n        fragmented modulo operations like\n\n        .. math::\n            i^d \\bmod {p_1}^{k_1}, i^d \\bmod {p_2}^{k_2}, \\dots,\n            i^d \\bmod {p_n}^{k_n}\n\n        or like\n\n        .. math::\n            i^d \\bmod {p_1}^{k_1}{p_2}^{k_2},\n            i^d \\bmod {p_3}^{k_3}, \\dots ,\n            i^d \\bmod {p_n}^{k_n}\n\n        as long as every moduli does not share any common divisor each\n        other.\n\n        The raw primes used in generating the RSA key pair can be a good\n        option.\n\n        Note that the speed advantage of using this is only viable for\n        very large cases (Like 2048-bit RSA keys) since the\n        overhead of using pure Python implementation of\n        :meth:`sympy.ntheory.modular.crt` may overcompensate the\n        theoretical speed advantage.\n\n    Notes\n    =====\n\n    See the ``Notes`` section in the documentation of\n    :meth:`encipher_rsa`\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import decipher_rsa, encipher_rsa\n    >>> from sympy.crypto.crypto import rsa_public_key, rsa_private_key\n\n    Public Key Encryption and Decryption:\n\n    >>> p, q, e = 3, 5, 7\n    >>> prk = rsa_private_key(p, q, e)\n    >>> puk = rsa_public_key(p, q, e)\n    >>> msg = 12\n    >>> new_msg = encipher_rsa(msg, prk)\n    >>> new_msg\n    3\n    >>> decipher_rsa(new_msg, puk)\n    12\n\n    Private Key Encryption and Decryption:\n\n    >>> p, q, e = 3, 5, 7\n    >>> prk = rsa_private_key(p, q, e)\n    >>> puk = rsa_public_key(p, q, e)\n    >>> msg = 12\n    >>> new_msg = encipher_rsa(msg, puk)\n    >>> new_msg\n    3\n    >>> decipher_rsa(new_msg, prk)\n    12\n\n    Decryption using chinese remainder theorem:\n\n    >>> decipher_rsa(new_msg, prk, factors=[p, q])\n    12\n\n    See Also\n    ========\n\n    encipher_rsa\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "kid_rsa_public_key",
    "full_id": "sympy.crypto.crypto.kid_rsa_public_key",
    "type": "function",
    "description": "\n    Kid RSA is a version of RSA useful to teach grade school children\n    since it does not involve exponentiation.\n\n    Explanation\n    ===========\n\n    Alice wants to talk to Bob. Bob generates keys as follows.\n    Key generation:\n\n    * Select positive integers `a, b, A, B` at random.\n    * Compute `M = a b - 1`, `e = A M + a`, `d = B M + b`,\n      `n = (e d - 1)//M`.\n    * The *public key* is `(n, e)`. Bob sends these to Alice.\n    * The *private key* is `(n, d)`, which Bob keeps secret.\n\n    Encryption: If `p` is the plaintext message then the\n    ciphertext is `c = p e \\pmod n`.\n\n    Decryption: If `c` is the ciphertext message then the\n    plaintext is `p = c d \\pmod n`.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import kid_rsa_public_key\n    >>> a, b, A, B = 3, 4, 5, 6\n    >>> kid_rsa_public_key(a, b, A, B)\n    (369, 58)\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "kid_rsa_private_key",
    "full_id": "sympy.crypto.crypto.kid_rsa_private_key",
    "type": "function",
    "description": "\n    Compute `M = a b - 1`, `e = A M + a`, `d = B M + b`,\n    `n = (e d - 1) / M`. The *private key* is `d`, which Bob\n    keeps secret.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import kid_rsa_private_key\n    >>> a, b, A, B = 3, 4, 5, 6\n    >>> kid_rsa_private_key(a, b, A, B)\n    (369, 70)\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_kid_rsa",
    "full_id": "sympy.crypto.crypto.encipher_kid_rsa",
    "type": "function",
    "description": "\n    Here ``msg`` is the plaintext and ``key`` is the public key.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import (\n    ...     encipher_kid_rsa, kid_rsa_public_key)\n    >>> msg = 200\n    >>> a, b, A, B = 3, 4, 5, 6\n    >>> key = kid_rsa_public_key(a, b, A, B)\n    >>> encipher_kid_rsa(msg, key)\n    161\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_kid_rsa",
    "full_id": "sympy.crypto.crypto.decipher_kid_rsa",
    "type": "function",
    "description": "\n    Here ``msg`` is the plaintext and ``key`` is the private key.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import (\n    ...     kid_rsa_public_key, kid_rsa_private_key,\n    ...     decipher_kid_rsa, encipher_kid_rsa)\n    >>> a, b, A, B = 3, 4, 5, 6\n    >>> d = kid_rsa_private_key(a, b, A, B)\n    >>> msg = 200\n    >>> pub = kid_rsa_public_key(a, b, A, B)\n    >>> pri = kid_rsa_private_key(a, b, A, B)\n    >>> ct = encipher_kid_rsa(msg, pub)\n    >>> decipher_kid_rsa(ct, pri)\n    200\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encode_morse",
    "full_id": "sympy.crypto.crypto.encode_morse",
    "type": "function",
    "description": "\n    Encodes a plaintext into popular Morse Code with letters\n    separated by ``sep`` and words by a double ``sep``.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encode_morse\n    >>> msg = 'ATTACK RIGHT FLANK'\n    >>> encode_morse(msg)\n    '.-|-|-|.-|-.-.|-.-||.-.|..|--.|....|-||..-.|.-..|.-|-.|-.-'\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Morse_code\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decode_morse",
    "full_id": "sympy.crypto.crypto.decode_morse",
    "type": "function",
    "description": "\n    Decodes a Morse Code with letters separated by ``sep``\n    (default is '|') and words by `word_sep` (default is '||)\n    into plaintext.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import decode_morse\n    >>> mc = '--|---|...-|.||.|.-|...|-'\n    >>> decode_morse(mc)\n    'MOVE EAST'\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Morse_code\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "lfsr_sequence",
    "full_id": "sympy.crypto.crypto.lfsr_sequence",
    "type": "function",
    "description": "\n    This function creates an LFSR sequence.\n\n    Parameters\n    ==========\n\n    key : list\n        A list of finite field elements, `[c_0, c_1, \\ldots, c_k].`\n\n    fill : list\n        The list of the initial terms of the LFSR sequence,\n        `[x_0, x_1, \\ldots, x_k].`\n\n    n\n        Number of terms of the sequence that the function returns.\n\n    Returns\n    =======\n\n    L\n        The LFSR sequence defined by\n        `x_{n+1} = c_k x_n + \\ldots + c_0 x_{n-k}`, for\n        `n \\leq k`.\n\n    Notes\n    =====\n\n    S. Golomb [G]_ gives a list of three statistical properties a\n    sequence of numbers `a = \\{a_n\\}_{n=1}^\\infty`,\n    `a_n \\in \\{0,1\\}`, should display to be considered\n    \"random\". Define the autocorrelation of `a` to be\n\n    .. math::\n\n        C(k) = C(k,a) = \\lim_{N\\rightarrow \\infty} {1\\over N}\\sum_{n=1}^N (-1)^{a_n + a_{n+k}}.\n\n    In the case where `a` is periodic with period\n    `P` then this reduces to\n\n    .. math::\n\n        C(k) = {1\\over P}\\sum_{n=1}^P (-1)^{a_n + a_{n+k}}.\n\n    Assume `a` is periodic with period `P`.\n\n    - balance:\n\n      .. math::\n\n        \\left|\\sum_{n=1}^P(-1)^{a_n}\\right| \\leq 1.\n\n    - low autocorrelation:\n\n       .. math::\n\n         C(k) = \\left\\{ \\begin{array}{cc} 1,& k = 0,\\\\ \\epsilon, & k \\ne 0. \\end{array} \\right.\n\n      (For sequences satisfying these first two properties, it is known\n      that `\\epsilon = -1/P` must hold.)\n\n    - proportional runs property: In each period, half the runs have\n      length `1`, one-fourth have length `2`, etc.\n      Moreover, there are as many runs of `1`'s as there are of\n      `0`'s.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import lfsr_sequence\n    >>> from sympy.polys.domains import FF\n    >>> F = FF(2)\n    >>> fill = [F(1), F(1), F(0), F(1)]\n    >>> key = [F(1), F(0), F(0), F(1)]\n    >>> lfsr_sequence(key, fill, 10)\n    [1 mod 2, 1 mod 2, 0 mod 2, 1 mod 2, 0 mod 2,\n    1 mod 2, 1 mod 2, 0 mod 2, 0 mod 2, 1 mod 2]\n\n    References\n    ==========\n\n    .. [G] Solomon Golomb, Shift register sequences, Aegean Park Press,\n       Laguna Hills, Ca, 1967\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "lfsr_autocorrelation",
    "full_id": "sympy.crypto.crypto.lfsr_autocorrelation",
    "type": "function",
    "description": "\n    This function computes the LFSR autocorrelation function.\n\n    Parameters\n    ==========\n\n    L\n        A periodic sequence of elements of `GF(2)`.\n        L must have length larger than P.\n\n    P\n        The period of L.\n\n    k : int\n        An integer `k` (`0 < k < P`).\n\n    Returns\n    =======\n\n    autocorrelation\n        The k-th value of the autocorrelation of the LFSR L.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import (\n    ...     lfsr_sequence, lfsr_autocorrelation)\n    >>> from sympy.polys.domains import FF\n    >>> F = FF(2)\n    >>> fill = [F(1), F(1), F(0), F(1)]\n    >>> key = [F(1), F(0), F(0), F(1)]\n    >>> s = lfsr_sequence(key, fill, 20)\n    >>> lfsr_autocorrelation(s, 15, 7)\n    -1/15\n    >>> lfsr_autocorrelation(s, 15, 0)\n    1\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "lfsr_connection_polynomial",
    "full_id": "sympy.crypto.crypto.lfsr_connection_polynomial",
    "type": "function",
    "description": "\n    This function computes the LFSR connection polynomial.\n\n    Parameters\n    ==========\n\n    s\n        A sequence of elements of even length, with entries in a finite\n        field.\n\n    Returns\n    =======\n\n    C(x)\n        The connection polynomial of a minimal LFSR yielding s.\n\n        This implements the algorithm in section 3 of J. L. Massey's\n        article [M]_.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import (\n    ...     lfsr_sequence, lfsr_connection_polynomial)\n    >>> from sympy.polys.domains import FF\n    >>> F = FF(2)\n    >>> fill = [F(1), F(1), F(0), F(1)]\n    >>> key = [F(1), F(0), F(0), F(1)]\n    >>> s = lfsr_sequence(key, fill, 20)\n    >>> lfsr_connection_polynomial(s)\n    x**4 + x + 1\n    >>> fill = [F(1), F(0), F(0), F(1)]\n    >>> key = [F(1), F(1), F(0), F(1)]\n    >>> s = lfsr_sequence(key, fill, 20)\n    >>> lfsr_connection_polynomial(s)\n    x**3 + 1\n    >>> fill = [F(1), F(0), F(1)]\n    >>> key = [F(1), F(1), F(0)]\n    >>> s = lfsr_sequence(key, fill, 20)\n    >>> lfsr_connection_polynomial(s)\n    x**3 + x**2 + 1\n    >>> fill = [F(1), F(0), F(1)]\n    >>> key = [F(1), F(0), F(1)]\n    >>> s = lfsr_sequence(key, fill, 20)\n    >>> lfsr_connection_polynomial(s)\n    x**3 + x + 1\n\n    References\n    ==========\n\n    .. [M] James L. Massey, \"Shift-Register Synthesis and BCH Decoding.\"\n        IEEE Trans. on Information Theory, vol. 15(1), pp. 122-127,\n        Jan 1969.\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "elgamal_public_key",
    "full_id": "sympy.crypto.crypto.elgamal_public_key",
    "type": "function",
    "description": "\n    Return three number tuple as public key.\n\n    Parameters\n    ==========\n\n    key : (p, r, e)\n        Tuple generated by ``elgamal_private_key``.\n\n    Returns\n    =======\n\n    tuple : (p, r, e)\n        `e = r**d \\bmod p`\n\n        `d` is a random number in private key.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import elgamal_public_key\n    >>> elgamal_public_key((1031, 14, 636))\n    (1031, 14, 212)\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "elgamal_private_key",
    "full_id": "sympy.crypto.crypto.elgamal_private_key",
    "type": "function",
    "description": "\n    Return three number tuple as private key.\n\n    Explanation\n    ===========\n\n    Elgamal encryption is based on the mathematical problem\n    called the Discrete Logarithm Problem (DLP). For example,\n\n    `a^{b} \\equiv c \\pmod p`\n\n    In general, if ``a`` and ``b`` are known, ``ct`` is easily\n    calculated. If ``b`` is unknown, it is hard to use\n    ``a`` and ``ct`` to get ``b``.\n\n    Parameters\n    ==========\n\n    digit : int\n        Minimum number of binary digits for key.\n\n    Returns\n    =======\n\n    tuple : (p, r, d)\n        p = prime number.\n\n        r = primitive root.\n\n        d = random number.\n\n    Notes\n    =====\n\n    For testing purposes, the ``seed`` parameter may be set to control\n    the output of this routine. See sympy.core.random._randrange.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import elgamal_private_key\n    >>> from sympy.ntheory import is_primitive_root, isprime\n    >>> a, b, _ = elgamal_private_key()\n    >>> isprime(a)\n    True\n    >>> is_primitive_root(b, a)\n    True\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_elgamal",
    "full_id": "sympy.crypto.crypto.encipher_elgamal",
    "type": "function",
    "description": "\n    Encrypt message with public key.\n\n    Explanation\n    ===========\n\n    ``i`` is a plaintext message expressed as an integer.\n    ``key`` is public key (p, r, e). In order to encrypt\n    a message, a random number ``a`` in ``range(2, p)``\n    is generated and the encryped message is returned as\n    `c_{1}` and `c_{2}` where:\n\n    `c_{1} \\equiv r^{a} \\pmod p`\n\n    `c_{2} \\equiv m e^{a} \\pmod p`\n\n    Parameters\n    ==========\n\n    msg\n        int of encoded message.\n\n    key\n        Public key.\n\n    Returns\n    =======\n\n    tuple : (c1, c2)\n        Encipher into two number.\n\n    Notes\n    =====\n\n    For testing purposes, the ``seed`` parameter may be set to control\n    the output of this routine. See sympy.core.random._randrange.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_elgamal, elgamal_private_key, elgamal_public_key\n    >>> pri = elgamal_private_key(5, seed=[3]); pri\n    (37, 2, 3)\n    >>> pub = elgamal_public_key(pri); pub\n    (37, 2, 8)\n    >>> msg = 36\n    >>> encipher_elgamal(msg, pub, seed=[3])\n    (8, 6)\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_elgamal",
    "full_id": "sympy.crypto.crypto.decipher_elgamal",
    "type": "function",
    "description": "\n    Decrypt message with private key.\n\n    `msg = (c_{1}, c_{2})`\n\n    `key = (p, r, d)`\n\n    According to extended Eucliden theorem,\n    `u c_{1}^{d} + p n = 1`\n\n    `u \\equiv 1/{{c_{1}}^d} \\pmod p`\n\n    `u c_{2} \\equiv \\frac{1}{c_{1}^d} c_{2} \\equiv \\frac{1}{r^{ad}} c_{2} \\pmod p`\n\n    `\\frac{1}{r^{ad}} m e^a \\equiv \\frac{1}{r^{ad}} m {r^{d a}} \\equiv m \\pmod p`\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import decipher_elgamal\n    >>> from sympy.crypto.crypto import encipher_elgamal\n    >>> from sympy.crypto.crypto import elgamal_private_key\n    >>> from sympy.crypto.crypto import elgamal_public_key\n\n    >>> pri = elgamal_private_key(5, seed=[3])\n    >>> pub = elgamal_public_key(pri); pub\n    (37, 2, 8)\n    >>> msg = 17\n    >>> decipher_elgamal(encipher_elgamal(msg, pub), pri) == msg\n    True\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "dh_public_key",
    "full_id": "sympy.crypto.crypto.dh_public_key",
    "type": "function",
    "description": "\n    Return three number tuple as public key.\n\n    This is the tuple that Alice sends to Bob.\n\n    Parameters\n    ==========\n\n    key : (p, g, a)\n        A tuple generated by ``dh_private_key``.\n\n    Returns\n    =======\n\n    tuple : int, int, int\n        A tuple of `(p, g, g^a \\mod p)` with `p`, `g` and `a` given as\n        parameters.s\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import dh_private_key, dh_public_key\n    >>> p, g, a = dh_private_key();\n    >>> _p, _g, x = dh_public_key((p, g, a))\n    >>> p == _p and g == _g\n    True\n    >>> x == pow(g, a, p)\n    True\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "dh_private_key",
    "full_id": "sympy.crypto.crypto.dh_private_key",
    "type": "function",
    "description": "\n    Return three integer tuple as private key.\n\n    Explanation\n    ===========\n\n    Diffie-Hellman key exchange is based on the mathematical problem\n    called the Discrete Logarithm Problem (see ElGamal).\n\n    Diffie-Hellman key exchange is divided into the following steps:\n\n    *   Alice and Bob agree on a base that consist of a prime ``p``\n        and a primitive root of ``p`` called ``g``\n    *   Alice choses a number ``a`` and Bob choses a number ``b`` where\n        ``a`` and ``b`` are random numbers in range `[2, p)`. These are\n        their private keys.\n    *   Alice then publicly sends Bob `g^{a} \\pmod p` while Bob sends\n        Alice `g^{b} \\pmod p`\n    *   They both raise the received value to their secretly chosen\n        number (``a`` or ``b``) and now have both as their shared key\n        `g^{ab} \\pmod p`\n\n    Parameters\n    ==========\n\n    digit\n        Minimum number of binary digits required in key.\n\n    Returns\n    =======\n\n    tuple : (p, g, a)\n        p = prime number.\n\n        g = primitive root of p.\n\n        a = random number from 2 through p - 1.\n\n    Notes\n    =====\n\n    For testing purposes, the ``seed`` parameter may be set to control\n    the output of this routine. See sympy.core.random._randrange.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import dh_private_key\n    >>> from sympy.ntheory import isprime, is_primitive_root\n    >>> p, g, _ = dh_private_key()\n    >>> isprime(p)\n    True\n    >>> is_primitive_root(g, p)\n    True\n    >>> p, g, _ = dh_private_key(5)\n    >>> isprime(p)\n    True\n    >>> is_primitive_root(g, p)\n    True\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "dh_shared_key",
    "full_id": "sympy.crypto.crypto.dh_shared_key",
    "type": "function",
    "description": "\n    Return an integer that is the shared key.\n\n    This is what Bob and Alice can both calculate using the public\n    keys they received from each other and their private keys.\n\n    Parameters\n    ==========\n\n    key : (p, g, x)\n        Tuple `(p, g, x)` generated by ``dh_public_key``.\n\n    b\n        Random number in the range of `2` to `p - 1`\n        (Chosen by second key exchange member (Bob)).\n\n    Returns\n    =======\n\n    int\n        A shared key.\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import (\n    ...     dh_private_key, dh_public_key, dh_shared_key)\n    >>> prk = dh_private_key();\n    >>> p, g, x = dh_public_key(prk);\n    >>> sk = dh_shared_key((p, g, x), 1000)\n    >>> sk == pow(x, 1000, p)\n    True\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "gm_public_key",
    "full_id": "sympy.crypto.crypto.gm_public_key",
    "type": "function",
    "description": "\n    Compute public keys for ``p`` and ``q``.\n    Note that in Goldwasser-Micali Encryption,\n    public keys are randomly selected.\n\n    Parameters\n    ==========\n\n    p, q, a : int, int, int\n        Initialization variables.\n\n    Returns\n    =======\n\n    tuple : (a, N)\n        ``a`` is the input ``a`` if it is not ``None`` otherwise\n        some random integer coprime to ``p`` and ``q``.\n\n        ``N`` is the product of ``p`` and ``q``.\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "gm_private_key",
    "full_id": "sympy.crypto.crypto.gm_private_key",
    "type": "function",
    "description": "\n    Check if ``p`` and ``q`` can be used as private keys for\n    the Goldwasser-Micali encryption. The method works\n    roughly as follows.\n\n    Explanation\n    ===========\n\n    #. Pick two large primes $p$ and $q$.\n    #. Call their product $N$.\n    #. Given a message as an integer $i$, write $i$ in its bit representation $b_0, \\dots, b_n$.\n    #. For each $k$,\n\n     if $b_k = 0$:\n        let $a_k$ be a random square\n        (quadratic residue) modulo $p q$\n        such that ``jacobi_symbol(a, p*q) = 1``\n     if $b_k = 1$:\n        let $a_k$ be a random non-square\n        (non-quadratic residue) modulo $p q$\n        such that ``jacobi_symbol(a, p*q) = 1``\n\n    returns $\\left[a_1, a_2, \\dots\\right]$\n\n    $b_k$ can be recovered by checking whether or not\n    $a_k$ is a residue. And from the $b_k$'s, the message\n    can be reconstructed.\n\n    The idea is that, while ``jacobi_symbol(a, p*q)``\n    can be easily computed (and when it is equal to $-1$ will\n    tell you that $a$ is not a square mod $p q$), quadratic\n    residuosity modulo a composite number is hard to compute\n    without knowing its factorization.\n\n    Moreover, approximately half the numbers coprime to $p q$ have\n    :func:`~.jacobi_symbol` equal to $1$ . And among those, approximately half\n    are residues and approximately half are not. This maximizes the\n    entropy of the code.\n\n    Parameters\n    ==========\n\n    p, q, a\n        Initialization variables.\n\n    Returns\n    =======\n\n    tuple : (p, q)\n        The input value ``p`` and ``q``.\n\n    Raises\n    ======\n\n    ValueError\n        If ``p`` and ``q`` are not distinct odd primes.\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_gm",
    "full_id": "sympy.crypto.crypto.encipher_gm",
    "type": "function",
    "description": "\n    Encrypt integer 'i' using public_key 'key'\n    Note that gm uses random encryption.\n\n    Parameters\n    ==========\n\n    i : int\n        The message to encrypt.\n\n    key : (a, N)\n        The public key.\n\n    Returns\n    =======\n\n    list : list of int\n        The randomized encrypted message.\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_gm",
    "full_id": "sympy.crypto.crypto.decipher_gm",
    "type": "function",
    "description": "\n    Decrypt message 'message' using public_key 'key'.\n\n    Parameters\n    ==========\n\n    message : list of int\n        The randomized encrypted message.\n\n    key : (p, q)\n        The private key.\n\n    Returns\n    =======\n\n    int\n        The encrypted message.\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "encipher_railfence",
    "full_id": "sympy.crypto.crypto.encipher_railfence",
    "type": "function",
    "description": "\n    Performs Railfence Encryption on plaintext and returns ciphertext\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import encipher_railfence\n    >>> message = \"hello world\"\n    >>> encipher_railfence(message,3)\n    'horel ollwd'\n\n    Parameters\n    ==========\n\n    message : string, the message to encrypt.\n    rails : int, the number of rails.\n\n    Returns\n    =======\n\n    The Encrypted string message.\n\n    References\n    ==========\n    .. [1] https://en.wikipedia.org/wiki/Rail_fence_cipher\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "decipher_railfence",
    "full_id": "sympy.crypto.crypto.decipher_railfence",
    "type": "function",
    "description": "\n    Decrypt the message using the given rails\n\n    Examples\n    ========\n\n    >>> from sympy.crypto.crypto import decipher_railfence\n    >>> decipher_railfence(\"horel ollwd\",3)\n    'hello world'\n\n    Parameters\n    ==========\n\n    message : string, the message to encrypt.\n    rails : int, the number of rails.\n\n    Returns\n    =======\n\n    The Decrypted string message.\n\n    ",
    "section": "Cryptography",
    "url": "https://docs.sympy.org/latest/modules/crypto.html"
  },
  {
    "name": "base_oneform",
    "full_id": "sympy.diffgeom.CoordSystem.base_oneform",
    "type": "method",
    "description": "Return a basis 1-form field.\n        The basis one-form field for this coordinate system. It is also an\n        operator on vector fields.",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "base_oneforms",
    "full_id": "sympy.diffgeom.CoordSystem.base_oneforms",
    "type": "method",
    "description": "Returns a list of all base oneforms.\n        For more details see the ``base_oneform`` method of this class.",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "base_scalar",
    "full_id": "sympy.diffgeom.CoordSystem.base_scalar",
    "type": "method",
    "description": "Return ``BaseScalarField`` that takes a point and returns one of the coordinates.",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "base_scalars",
    "full_id": "sympy.diffgeom.CoordSystem.base_scalars",
    "type": "method",
    "description": "Returns a list of all coordinate functions.\n        For more details see the ``base_scalar`` method of this class.",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "base_vector",
    "full_id": "sympy.diffgeom.CoordSystem.base_vector",
    "type": "method",
    "description": "Return a basis vector field.\n        The basis vector field for this coordinate system. It is also an\n        operator on scalar fields.",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "base_vectors",
    "full_id": "sympy.diffgeom.CoordSystem.base_vectors",
    "type": "method",
    "description": "Returns a list of all base vectors.\n        For more details see the ``base_vector`` method of this class.",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "coord_tuple_transform_to",
    "full_id": "sympy.diffgeom.CoordSystem.coord_tuple_transform_to",
    "type": "method",
    "description": "Transform ``coords`` to coord system ``to_sys``.",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "jacobian",
    "full_id": "sympy.diffgeom.CoordSystem.jacobian",
    "type": "method",
    "description": "\n        Return the jacobian matrix of a transformation on given coordinates.\n        If coordinates are not given, coordinate symbols of *self* are used.\n\n        Parameters\n        ==========\n\n        sys : CoordSystem\n\n        coordinates : Any iterable, optional.\n\n        Returns\n        =======\n\n        sympy.ImmutableDenseMatrix\n\n        Examples\n        ========\n\n        >>> from sympy.diffgeom.rn import R2_r, R2_p\n        >>> R2_p.jacobian(R2_r)\n        Matrix([\n        [cos(theta), -rho*sin(theta)],\n        [sin(theta),  rho*cos(theta)]])\n        >>> R2_p.jacobian(R2_r, [1, 0])\n        Matrix([\n        [1, 0],\n        [0, 1]])\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "jacobian_determinant",
    "full_id": "sympy.diffgeom.CoordSystem.jacobian_determinant",
    "type": "method",
    "description": "\n        Return the jacobian determinant of a transformation on given\n        coordinates. If coordinates are not given, coordinate symbols of *self*\n        are used.\n\n        Parameters\n        ==========\n\n        sys : CoordSystem\n\n        coordinates : Any iterable, optional.\n\n        Returns\n        =======\n\n        sympy.Expr\n\n        Examples\n        ========\n\n        >>> from sympy.diffgeom.rn import R2_r, R2_p\n        >>> R2_r.jacobian_determinant(R2_p)\n        1/sqrt(x**2 + y**2)\n        >>> R2_r.jacobian_determinant(R2_p, [1, 0])\n        1\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "point",
    "full_id": "sympy.diffgeom.CoordSystem.point",
    "type": "method",
    "description": "Create a ``Point`` with coordinates given in this coord system.",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "point_to_coords",
    "full_id": "sympy.diffgeom.CoordSystem.point_to_coords",
    "type": "method",
    "description": "Calculate the coordinates of a point in this coord system.",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "transform",
    "full_id": "sympy.diffgeom.CoordSystem.transform",
    "type": "method",
    "description": "\n        Return the result of coordinate transformation from *self* to *sys*.\n        If coordinates are not given, coordinate symbols of *self* are used.\n\n        Parameters\n        ==========\n\n        sys : CoordSystem\n\n        coordinates : Any iterable, optional.\n\n        Returns\n        =======\n\n        sympy.ImmutableDenseMatrix containing CoordinateSymbol\n\n        Examples\n        ========\n\n        >>> from sympy.diffgeom.rn import R2_r, R2_p\n        >>> R2_r.transform(R2_p)\n        Matrix([\n        [sqrt(x**2 + y**2)],\n        [      atan2(y, x)]])\n        >>> R2_r.transform(R2_p, [0, 1])\n        Matrix([\n        [   1],\n        [pi/2]])\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "transformation",
    "full_id": "sympy.diffgeom.CoordSystem.transformation",
    "type": "method",
    "description": "\n        Return coordinate transformation function from *self* to *sys*.\n\n        Parameters\n        ==========\n\n        sys : CoordSystem\n\n        Returns\n        =======\n\n        sympy.Lambda\n\n        Examples\n        ========\n\n        >>> from sympy.diffgeom.rn import R2_r, R2_p\n        >>> R2_r.transformation(R2_p)\n        Lambda((x, y), Matrix([\n        [sqrt(x**2 + y**2)],\n        [      atan2(y, x)]]))\n\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "coords",
    "full_id": "sympy.diffgeom.Point.coords",
    "type": "method",
    "description": "\n        Coordinates of the point in given coordinate system. If coordinate system\n        is not passed, it returns the coordinates in the coordinate system in which\n        the poin was defined.\n        ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "intcurve_series",
    "full_id": "sympy.diffgeom.intcurve_series",
    "type": "function",
    "description": "Return the series expansion for an integral curve of the field.\n\n    Explanation\n    ===========\n\n    Integral curve is a function `\\gamma` taking a parameter in `R` to a point\n    in the manifold. It verifies the equation:\n\n    `V(f)\\big(\\gamma(t)\\big) = \\frac{d}{dt}f\\big(\\gamma(t)\\big)`\n\n    where the given ``vector_field`` is denoted as `V`. This holds for any\n    value `t` for the parameter and any scalar field `f`.\n\n    This equation can also be decomposed of a basis of coordinate functions\n    `V(f_i)\\big(\\gamma(t)\\big) = \\frac{d}{dt}f_i\\big(\\gamma(t)\\big) \\quad \\forall i`\n\n    This function returns a series expansion of `\\gamma(t)` in terms of the\n    coordinate system ``coord_sys``. The equations and expansions are necessarily\n    done in coordinate-system-dependent way as there is no other way to\n    represent movement between points on the manifold (i.e. there is no such\n    thing as a difference of points for a general manifold).\n\n    Parameters\n    ==========\n    vector_field\n        the vector field for which an integral curve will be given\n\n    param\n        the argument of the function `\\gamma` from R to the curve\n\n    start_point\n        the point which corresponds to `\\gamma(0)`\n\n    n\n        the order to which to expand\n\n    coord_sys\n        the coordinate system in which to expand\n        coeffs (default False) - if True return a list of elements of the expansion\n\n    Examples\n    ========\n\n    Use the predefined R2 manifold:\n\n    >>> from sympy.abc import t, x, y\n    >>> from sympy.diffgeom.rn import R2_p, R2_r\n    >>> from sympy.diffgeom import intcurve_series\n\n    Specify a starting point and a vector field:\n\n    >>> start_point = R2_r.point([x, y])\n    >>> vector_field = R2_r.e_x\n\n    Calculate the series:\n\n    >>> intcurve_series(vector_field, t, start_point, n=3)\n    Matrix([\n    [t + x],\n    [    y]])\n\n    Or get the elements of the expansion in a list:\n\n    >>> series = intcurve_series(vector_field, t, start_point, n=3, coeffs=True)\n    >>> series[0]\n    Matrix([\n    [x],\n    [y]])\n    >>> series[1]\n    Matrix([\n    [t],\n    [0]])\n    >>> series[2]\n    Matrix([\n    [0],\n    [0]])\n\n    The series in the polar coordinate system:\n\n    >>> series = intcurve_series(vector_field, t, start_point,\n    ...             n=3, coord_sys=R2_p, coeffs=True)\n    >>> series[0]\n    Matrix([\n    [sqrt(x**2 + y**2)],\n    [      atan2(y, x)]])\n    >>> series[1]\n    Matrix([\n    [t*x/sqrt(x**2 + y**2)],\n    [   -t*y/(x**2 + y**2)]])\n    >>> series[2]\n    Matrix([\n    [t**2*(-x**2/(x**2 + y**2)**(3/2) + 1/sqrt(x**2 + y**2))/2],\n    [                                t**2*x*y/(x**2 + y**2)**2]])\n\n    See Also\n    ========\n\n    intcurve_diffequ\n\n    ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "intcurve_diffequ",
    "full_id": "sympy.diffgeom.intcurve_diffequ",
    "type": "function",
    "description": "Return the differential equation for an integral curve of the field.\n\n    Explanation\n    ===========\n\n    Integral curve is a function `\\gamma` taking a parameter in `R` to a point\n    in the manifold. It verifies the equation:\n\n    `V(f)\\big(\\gamma(t)\\big) = \\frac{d}{dt}f\\big(\\gamma(t)\\big)`\n\n    where the given ``vector_field`` is denoted as `V`. This holds for any\n    value `t` for the parameter and any scalar field `f`.\n\n    This function returns the differential equation of `\\gamma(t)` in terms of the\n    coordinate system ``coord_sys``. The equations and expansions are necessarily\n    done in coordinate-system-dependent way as there is no other way to\n    represent movement between points on the manifold (i.e. there is no such\n    thing as a difference of points for a general manifold).\n\n    Parameters\n    ==========\n\n    vector_field\n        the vector field for which an integral curve will be given\n\n    param\n        the argument of the function `\\gamma` from R to the curve\n\n    start_point\n        the point which corresponds to `\\gamma(0)`\n\n    coord_sys\n        the coordinate system in which to give the equations\n\n    Returns\n    =======\n\n    a tuple of (equations, initial conditions)\n\n    Examples\n    ========\n\n    Use the predefined R2 manifold:\n\n    >>> from sympy.abc import t\n    >>> from sympy.diffgeom.rn import R2, R2_p, R2_r\n    >>> from sympy.diffgeom import intcurve_diffequ\n\n    Specify a starting point and a vector field:\n\n    >>> start_point = R2_r.point([0, 1])\n    >>> vector_field = -R2.y*R2.e_x + R2.x*R2.e_y\n\n    Get the equation:\n\n    >>> equations, init_cond = intcurve_diffequ(vector_field, t, start_point)\n    >>> equations\n    [f_1(t) + Derivative(f_0(t), t), -f_0(t) + Derivative(f_1(t), t)]\n    >>> init_cond\n    [f_0(0), f_1(0) - 1]\n\n    The series in the polar coordinate system:\n\n    >>> equations, init_cond = intcurve_diffequ(vector_field, t, start_point, R2_p)\n    >>> equations\n    [Derivative(f_0(t), t), Derivative(f_1(t), t) - 1]\n    >>> init_cond\n    [f_0(0) - 1, f_1(0) - pi/2]\n\n    See Also\n    ========\n\n    intcurve_series\n\n    ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "vectors_in_basis",
    "full_id": "sympy.diffgeom.vectors_in_basis",
    "type": "function",
    "description": "Transform all base vectors in base vectors of a specified coord basis.\n    While the new base vectors are in the new coordinate system basis, any\n    coefficients are kept in the old system.\n\n    Examples\n    ========\n\n    >>> from sympy.diffgeom import vectors_in_basis\n    >>> from sympy.diffgeom.rn import R2_r, R2_p\n\n    >>> vectors_in_basis(R2_r.e_x, R2_p)\n    -y*e_theta/(x**2 + y**2) + x*e_rho/sqrt(x**2 + y**2)\n    >>> vectors_in_basis(R2_p.e_r, R2_r)\n    sin(theta)*e_y + cos(theta)*e_x\n\n    ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "twoform_to_matrix",
    "full_id": "sympy.diffgeom.twoform_to_matrix",
    "type": "function",
    "description": "Return the matrix representing the twoform.\n\n    For the twoform `w` return the matrix `M` such that `M[i,j]=w(e_i, e_j)`,\n    where `e_i` is the i-th base vector field for the coordinate system in\n    which the expression of `w` is given.\n\n    Examples\n    ========\n\n    >>> from sympy.diffgeom.rn import R2\n    >>> from sympy.diffgeom import twoform_to_matrix, TensorProduct\n    >>> TP = TensorProduct\n\n    >>> twoform_to_matrix(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n    Matrix([\n    [1, 0],\n    [0, 1]])\n    >>> twoform_to_matrix(R2.x*TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n    Matrix([\n    [x, 0],\n    [0, 1]])\n    >>> twoform_to_matrix(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy) - TP(R2.dx, R2.dy)/2)\n    Matrix([\n    [   1, 0],\n    [-1/2, 1]])\n\n    ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "metric_to_Christoffel_1st",
    "full_id": "sympy.diffgeom.metric_to_Christoffel_1st",
    "type": "function",
    "description": "Return the nested list of Christoffel symbols for the given metric.\n    This returns the Christoffel symbol of first kind that represents the\n    Levi-Civita connection for the given metric.\n\n    Examples\n    ========\n\n    >>> from sympy.diffgeom.rn import R2\n    >>> from sympy.diffgeom import metric_to_Christoffel_1st, TensorProduct\n    >>> TP = TensorProduct\n\n    >>> metric_to_Christoffel_1st(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n    [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n    >>> metric_to_Christoffel_1st(R2.x*TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n    [[[1/2, 0], [0, 0]], [[0, 0], [0, 0]]]\n\n    ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "metric_to_Christoffel_2nd",
    "full_id": "sympy.diffgeom.metric_to_Christoffel_2nd",
    "type": "function",
    "description": "Return the nested list of Christoffel symbols for the given metric.\n    This returns the Christoffel symbol of second kind that represents the\n    Levi-Civita connection for the given metric.\n\n    Examples\n    ========\n\n    >>> from sympy.diffgeom.rn import R2\n    >>> from sympy.diffgeom import metric_to_Christoffel_2nd, TensorProduct\n    >>> TP = TensorProduct\n\n    >>> metric_to_Christoffel_2nd(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n    [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n    >>> metric_to_Christoffel_2nd(R2.x*TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n    [[[1/(2*x), 0], [0, 0]], [[0, 0], [0, 0]]]\n\n    ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "metric_to_Riemann_components",
    "full_id": "sympy.diffgeom.metric_to_Riemann_components",
    "type": "function",
    "description": "Return the components of the Riemann tensor expressed in a given basis.\n\n    Given a metric it calculates the components of the Riemann tensor in the\n    canonical basis of the coordinate system in which the metric expression is\n    given.\n\n    Examples\n    ========\n\n    >>> from sympy import exp\n    >>> from sympy.diffgeom.rn import R2\n    >>> from sympy.diffgeom import metric_to_Riemann_components, TensorProduct\n    >>> TP = TensorProduct\n\n    >>> metric_to_Riemann_components(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n    [[[[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]]\n    >>> non_trivial_metric = exp(2*R2.r)*TP(R2.dr, R2.dr) +         R2.r**2*TP(R2.dtheta, R2.dtheta)\n    >>> non_trivial_metric\n    exp(2*rho)*TensorProduct(drho, drho) + rho**2*TensorProduct(dtheta, dtheta)\n    >>> riemann = metric_to_Riemann_components(non_trivial_metric)\n    >>> riemann[0, :, :, :]\n    [[[0, 0], [0, 0]], [[0, exp(-2*rho)*rho], [-exp(-2*rho)*rho, 0]]]\n    >>> riemann[1, :, :, :]\n    [[[0, -1/rho], [1/rho, 0]], [[0, 0], [0, 0]]]\n\n    ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "metric_to_Ricci_components",
    "full_id": "sympy.diffgeom.metric_to_Ricci_components",
    "type": "function",
    "description": "Return the components of the Ricci tensor expressed in a given basis.\n\n    Given a metric it calculates the components of the Ricci tensor in the\n    canonical basis of the coordinate system in which the metric expression is\n    given.\n\n    Examples\n    ========\n\n    >>> from sympy import exp\n    >>> from sympy.diffgeom.rn import R2\n    >>> from sympy.diffgeom import metric_to_Ricci_components, TensorProduct\n    >>> TP = TensorProduct\n\n    >>> metric_to_Ricci_components(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n    [[0, 0], [0, 0]]\n    >>> non_trivial_metric = exp(2*R2.r)*TP(R2.dr, R2.dr) +                              R2.r**2*TP(R2.dtheta, R2.dtheta)\n    >>> non_trivial_metric\n    exp(2*rho)*TensorProduct(drho, drho) + rho**2*TensorProduct(dtheta, dtheta)\n    >>> metric_to_Ricci_components(non_trivial_metric)\n    [[1/rho, 0], [0, exp(-2*rho)*rho]]\n\n    ",
    "section": "Base Class Reference",
    "url": "https://docs.sympy.org/latest/modules/diffgeom.html"
  },
  {
    "name": "annotations",
    "full_id": "sympy.plotting.plot.Plot.annotations",
    "type": "property",
    "description": ".. deprecated:: 1.13",
    "section": "Plot Class",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "append",
    "full_id": "sympy.plotting.plot.Plot.append",
    "type": "method",
    "description": "Adds an element from a plot's series to an existing plot.\n\n        Examples\n        ========\n\n        Consider two ``Plot`` objects, ``p1`` and ``p2``. To add the\n        second plot's first series object to the first, use the\n        ``append`` method, like so:\n\n        .. plot::\n           :format: doctest\n           :include-source: True\n\n           >>> from sympy import symbols\n           >>> from sympy.plotting import plot\n           >>> x = symbols('x')\n           >>> p1 = plot(x*x, show=False)\n           >>> p2 = plot(x, show=False)\n           >>> p1.append(p2[0])\n           >>> p1\n           Plot object containing:\n           [0]: cartesian line: x**2 for x over (-10.0, 10.0)\n           [1]: cartesian line: x for x over (-10.0, 10.0)\n           >>> p1.show()\n\n        See Also\n        ========\n\n        extend\n\n        ",
    "section": "Plot Class",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "extend",
    "full_id": "sympy.plotting.plot.Plot.extend",
    "type": "method",
    "description": "Adds all series from another plot.\n\n        Examples\n        ========\n\n        Consider two ``Plot`` objects, ``p1`` and ``p2``. To add the\n        second plot to the first, use the ``extend`` method, like so:\n\n        .. plot::\n           :format: doctest\n           :include-source: True\n\n           >>> from sympy import symbols\n           >>> from sympy.plotting import plot\n           >>> x = symbols('x')\n           >>> p1 = plot(x**2, show=False)\n           >>> p2 = plot(x, -x, show=False)\n           >>> p1.extend(p2)\n           >>> p1\n           Plot object containing:\n           [0]: cartesian line: x**2 for x over (-10.0, 10.0)\n           [1]: cartesian line: x for x over (-10.0, 10.0)\n           [2]: cartesian line: -x for x over (-10.0, 10.0)\n           >>> p1.show()\n\n        ",
    "section": "Plot Class",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "plot",
    "full_id": "sympy.plotting.plot.plot",
    "type": "function",
    "description": "Plots a function of a single variable as a curve.\n\n    Parameters\n    ==========\n\n    args :\n        The first argument is the expression representing the function\n        of single variable to be plotted.\n\n        The last argument is a 3-tuple denoting the range of the free\n        variable. e.g. ``(x, 0, 5)``\n\n        Typical usage examples are in the following:\n\n        - Plotting a single expression with a single range.\n            ``plot(expr, range, **kwargs)``\n        - Plotting a single expression with the default range (-10, 10).\n            ``plot(expr, **kwargs)``\n        - Plotting multiple expressions with a single range.\n            ``plot(expr1, expr2, ..., range, **kwargs)``\n        - Plotting multiple expressions with multiple ranges.\n            ``plot((expr1, range1), (expr2, range2), ..., **kwargs)``\n\n        It is best practice to specify range explicitly because default\n        range may change in the future if a more advanced default range\n        detection algorithm is implemented.\n\n    show : bool, optional\n        The default value is set to ``True``. Set show to ``False`` and\n        the function will not display the plot. The returned instance of\n        the ``Plot`` class can then be used to save or display the plot\n        by calling the ``save()`` and ``show()`` methods respectively.\n\n    line_color : string, or float, or function, optional\n        Specifies the color for the plot.\n        See ``Plot`` to see how to set color for the plots.\n        Note that by setting ``line_color``, it would be applied simultaneously\n        to all the series.\n\n    title : str, optional\n        Title of the plot. It is set to the latex representation of\n        the expression, if the plot has only one expression.\n\n    label : str, optional\n        The label of the expression in the plot. It will be used when\n        called with ``legend``. Default is the name of the expression.\n        e.g. ``sin(x)``\n\n    xlabel : str or expression, optional\n        Label for the x-axis.\n\n    ylabel : str or expression, optional\n        Label for the y-axis.\n\n    xscale : 'linear' or 'log', optional\n        Sets the scaling of the x-axis.\n\n    yscale : 'linear' or 'log', optional\n        Sets the scaling of the y-axis.\n\n    axis_center : (float, float), optional\n        Tuple of two floats denoting the coordinates of the center or\n        {'center', 'auto'}\n\n    xlim : (float, float), optional\n        Denotes the x-axis limits, ``(min, max)```.\n\n    ylim : (float, float), optional\n        Denotes the y-axis limits, ``(min, max)```.\n\n    annotations : list, optional\n        A list of dictionaries specifying the type of annotation\n        required. The keys in the dictionary should be equivalent\n        to the arguments of the :external:mod:`matplotlib`'s\n        :external:meth:`~matplotlib.axes.Axes.annotate` method.\n\n    markers : list, optional\n        A list of dictionaries specifying the type the markers required.\n        The keys in the dictionary should be equivalent to the arguments\n        of the :external:mod:`matplotlib`'s :external:func:`~matplotlib.pyplot.plot()` function\n        along with the marker related keyworded arguments.\n\n    rectangles : list, optional\n        A list of dictionaries specifying the dimensions of the\n        rectangles to be plotted. The keys in the dictionary should be\n        equivalent to the arguments of the :external:mod:`matplotlib`'s\n        :external:class:`~matplotlib.patches.Rectangle` class.\n\n    fill : dict, optional\n        A dictionary specifying the type of color filling required in\n        the plot. The keys in the dictionary should be equivalent to the\n        arguments of the :external:mod:`matplotlib`'s\n        :external:meth:`~matplotlib.axes.Axes.fill_between` method.\n\n    adaptive : bool, optional\n        The default value is set to ``True``. Set adaptive to ``False``\n        and specify ``n`` if uniform sampling is required.\n\n        The plotting uses an adaptive algorithm which samples\n        recursively to accurately plot. The adaptive algorithm uses a\n        random point near the midpoint of two points that has to be\n        further sampled. Hence the same plots can appear slightly\n        different.\n\n    depth : int, optional\n        Recursion depth of the adaptive algorithm. A depth of value\n        `n` samples a maximum of `2^{n}` points.\n\n        If the ``adaptive`` flag is set to ``False``, this will be\n        ignored.\n\n    n : int, optional\n        Used when the ``adaptive`` is set to ``False``. The function\n        is uniformly sampled at ``n`` number of points. If the ``adaptive``\n        flag is set to ``True``, this will be ignored.\n        This keyword argument replaces ``nb_of_points``, which should be\n        considered deprecated.\n\n    size : (float, float), optional\n        A tuple in the form (width, height) in inches to specify the size of\n        the overall figure. The default value is set to ``None``, meaning\n        the size will be set by the default backend.\n\n    Examples\n    ========\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> from sympy import symbols\n       >>> from sympy.plotting import plot\n       >>> x = symbols('x')\n\n    Single Plot\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot(x**2, (x, -5, 5))\n       Plot object containing:\n       [0]: cartesian line: x**2 for x over (-5.0, 5.0)\n\n    Multiple plots with single range.\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot(x, x**2, x**3, (x, -5, 5))\n       Plot object containing:\n       [0]: cartesian line: x for x over (-5.0, 5.0)\n       [1]: cartesian line: x**2 for x over (-5.0, 5.0)\n       [2]: cartesian line: x**3 for x over (-5.0, 5.0)\n\n    Multiple plots with different ranges.\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot((x**2, (x, -6, 6)), (x, (x, -5, 5)))\n       Plot object containing:\n       [0]: cartesian line: x**2 for x over (-6.0, 6.0)\n       [1]: cartesian line: x for x over (-5.0, 5.0)\n\n    No adaptive sampling.\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot(x**2, adaptive=False, n=400)\n       Plot object containing:\n       [0]: cartesian line: x**2 for x over (-10.0, 10.0)\n\n    See Also\n    ========\n\n    Plot, LineOver1DRangeSeries\n\n    ",
    "section": "Plotting Function Reference",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "plot_parametric",
    "full_id": "sympy.plotting.plot.plot_parametric",
    "type": "function",
    "description": "\n    Plots a 2D parametric curve.\n\n    Parameters\n    ==========\n\n    args\n        Common specifications are:\n\n        - Plotting a single parametric curve with a range\n            ``plot_parametric((expr_x, expr_y), range)``\n        - Plotting multiple parametric curves with the same range\n            ``plot_parametric((expr_x, expr_y), ..., range)``\n        - Plotting multiple parametric curves with different ranges\n            ``plot_parametric((expr_x, expr_y, range), ...)``\n\n        ``expr_x`` is the expression representing $x$ component of the\n        parametric function.\n\n        ``expr_y`` is the expression representing $y$ component of the\n        parametric function.\n\n        ``range`` is a 3-tuple denoting the parameter symbol, start and\n        stop. For example, ``(u, 0, 5)``.\n\n        If the range is not specified, then a default range of (-10, 10)\n        is used.\n\n        However, if the arguments are specified as\n        ``(expr_x, expr_y, range), ...``, you must specify the ranges\n        for each expressions manually.\n\n        Default range may change in the future if a more advanced\n        algorithm is implemented.\n\n    adaptive : bool, optional\n        Specifies whether to use the adaptive sampling or not.\n\n        The default value is set to ``True``. Set adaptive to ``False``\n        and specify ``n`` if uniform sampling is required.\n\n    depth :  int, optional\n        The recursion depth of the adaptive algorithm. A depth of\n        value $n$ samples a maximum of $2^n$ points.\n\n    n : int, optional\n        Used when the ``adaptive`` flag is set to ``False``. Specifies the\n        number of the points used for the uniform sampling.\n        This keyword argument replaces ``nb_of_points``, which should be\n        considered deprecated.\n\n    line_color : string, or float, or function, optional\n        Specifies the color for the plot.\n        See ``Plot`` to see how to set color for the plots.\n        Note that by setting ``line_color``, it would be applied simultaneously\n        to all the series.\n\n    label : str, optional\n        The label of the expression in the plot. It will be used when\n        called with ``legend``. Default is the name of the expression.\n        e.g. ``sin(x)``\n\n    xlabel : str, optional\n        Label for the x-axis.\n\n    ylabel : str, optional\n        Label for the y-axis.\n\n    xscale : 'linear' or 'log', optional\n        Sets the scaling of the x-axis.\n\n    yscale : 'linear' or 'log', optional\n        Sets the scaling of the y-axis.\n\n    axis_center : (float, float), optional\n        Tuple of two floats denoting the coordinates of the center or\n        {'center', 'auto'}\n\n    xlim : (float, float), optional\n        Denotes the x-axis limits, ``(min, max)```.\n\n    ylim : (float, float), optional\n        Denotes the y-axis limits, ``(min, max)```.\n\n    size : (float, float), optional\n        A tuple in the form (width, height) in inches to specify the size of\n        the overall figure. The default value is set to ``None``, meaning\n        the size will be set by the default backend.\n\n    Examples\n    ========\n\n    .. plot::\n       :context: reset\n       :format: doctest\n       :include-source: True\n\n       >>> from sympy import plot_parametric, symbols, cos, sin\n       >>> u = symbols('u')\n\n    A parametric plot with a single expression:\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot_parametric((cos(u), sin(u)), (u, -5, 5))\n       Plot object containing:\n       [0]: parametric cartesian line: (cos(u), sin(u)) for u over (-5.0, 5.0)\n\n    A parametric plot with multiple expressions with the same range:\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot_parametric((cos(u), sin(u)), (u, cos(u)), (u, -10, 10))\n       Plot object containing:\n       [0]: parametric cartesian line: (cos(u), sin(u)) for u over (-10.0, 10.0)\n       [1]: parametric cartesian line: (u, cos(u)) for u over (-10.0, 10.0)\n\n    A parametric plot with multiple expressions with different ranges\n    for each curve:\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot_parametric((cos(u), sin(u), (u, -5, 5)),\n       ...     (cos(u), u, (u, -5, 5)))\n       Plot object containing:\n       [0]: parametric cartesian line: (cos(u), sin(u)) for u over (-5.0, 5.0)\n       [1]: parametric cartesian line: (cos(u), u) for u over (-5.0, 5.0)\n\n    Notes\n    =====\n\n    The plotting uses an adaptive algorithm which samples recursively to\n    accurately plot the curve. The adaptive algorithm uses a random point\n    near the midpoint of two points that has to be further sampled.\n    Hence, repeating the same plot command can give slightly different\n    results because of the random sampling.\n\n    If there are multiple plots, then the same optional arguments are\n    applied to all the plots drawn in the same canvas. If you want to\n    set these options separately, you can index the returned ``Plot``\n    object and set it.\n\n    For example, when you specify ``line_color`` once, it would be\n    applied simultaneously to both series.\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n        >>> from sympy import pi\n        >>> expr1 = (u, cos(2*pi*u)/2 + 1/2)\n        >>> expr2 = (u, sin(2*pi*u)/2 + 1/2)\n        >>> p = plot_parametric(expr1, expr2, (u, 0, 1), line_color='blue')\n\n    If you want to specify the line color for the specific series, you\n    should index each item and apply the property manually.\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n        >>> p[0].line_color = 'red'\n        >>> p.show()\n\n    See Also\n    ========\n\n    Plot, Parametric2DLineSeries\n    ",
    "section": "Plotting Function Reference",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "plot3d",
    "full_id": "sympy.plotting.plot.plot3d",
    "type": "function",
    "description": "\n    Plots a 3D surface plot.\n\n    Usage\n    =====\n\n    Single plot\n\n    ``plot3d(expr, range_x, range_y, **kwargs)``\n\n    If the ranges are not specified, then a default range of (-10, 10) is used.\n\n    Multiple plot with the same range.\n\n    ``plot3d(expr1, expr2, range_x, range_y, **kwargs)``\n\n    If the ranges are not specified, then a default range of (-10, 10) is used.\n\n    Multiple plots with different ranges.\n\n    ``plot3d((expr1, range_x, range_y), (expr2, range_x, range_y), ..., **kwargs)``\n\n    Ranges have to be specified for every expression.\n\n    Default range may change in the future if a more advanced default range\n    detection algorithm is implemented.\n\n    Arguments\n    =========\n\n    expr : Expression representing the function along x.\n\n    range_x : (:class:`~.Symbol`, float, float)\n        A 3-tuple denoting the range of the x variable, e.g. (x, 0, 5).\n\n    range_y : (:class:`~.Symbol`, float, float)\n        A 3-tuple denoting the range of the y variable, e.g. (y, 0, 5).\n\n    Keyword Arguments\n    =================\n\n    Arguments for ``SurfaceOver2DRangeSeries`` class:\n\n    n1 : int\n        The x range is sampled uniformly at ``n1`` of points.\n        This keyword argument replaces ``nb_of_points_x``, which should be\n        considered deprecated.\n\n    n2 : int\n        The y range is sampled uniformly at ``n2`` of points.\n        This keyword argument replaces ``nb_of_points_y``, which should be\n        considered deprecated.\n\n    Aesthetics:\n\n    surface_color : Function which returns a float\n        Specifies the color for the surface of the plot.\n        See :class:`~.Plot` for more details.\n\n    If there are multiple plots, then the same series arguments are applied to\n    all the plots. If you want to set these options separately, you can index\n    the returned ``Plot`` object and set it.\n\n    Arguments for ``Plot`` class:\n\n    title : str\n        Title of the plot.\n\n    size : (float, float), optional\n        A tuple in the form (width, height) in inches to specify the size of the\n        overall figure. The default value is set to ``None``, meaning the size will\n        be set by the default backend.\n\n    Examples\n    ========\n\n    .. plot::\n       :context: reset\n       :format: doctest\n       :include-source: True\n\n       >>> from sympy import symbols\n       >>> from sympy.plotting import plot3d\n       >>> x, y = symbols('x y')\n\n    Single plot\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot3d(x*y, (x, -5, 5), (y, -5, 5))\n       Plot object containing:\n       [0]: cartesian surface: x*y for x over (-5.0, 5.0) and y over (-5.0, 5.0)\n\n\n    Multiple plots with same range\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot3d(x*y, -x*y, (x, -5, 5), (y, -5, 5))\n       Plot object containing:\n       [0]: cartesian surface: x*y for x over (-5.0, 5.0) and y over (-5.0, 5.0)\n       [1]: cartesian surface: -x*y for x over (-5.0, 5.0) and y over (-5.0, 5.0)\n\n\n    Multiple plots with different ranges.\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot3d((x**2 + y**2, (x, -5, 5), (y, -5, 5)),\n       ...     (x*y, (x, -3, 3), (y, -3, 3)))\n       Plot object containing:\n       [0]: cartesian surface: x**2 + y**2 for x over (-5.0, 5.0) and y over (-5.0, 5.0)\n       [1]: cartesian surface: x*y for x over (-3.0, 3.0) and y over (-3.0, 3.0)\n\n\n    See Also\n    ========\n\n    Plot, SurfaceOver2DRangeSeries\n\n    ",
    "section": "Plotting Function Reference",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "plot3d_parametric_line",
    "full_id": "sympy.plotting.plot.plot3d_parametric_line",
    "type": "function",
    "description": "\n    Plots a 3D parametric line plot.\n\n    Usage\n    =====\n\n    Single plot:\n\n    ``plot3d_parametric_line(expr_x, expr_y, expr_z, range, **kwargs)``\n\n    If the range is not specified, then a default range of (-10, 10) is used.\n\n    Multiple plots.\n\n    ``plot3d_parametric_line((expr_x, expr_y, expr_z, range), ..., **kwargs)``\n\n    Ranges have to be specified for every expression.\n\n    Default range may change in the future if a more advanced default range\n    detection algorithm is implemented.\n\n    Arguments\n    =========\n\n    expr_x : Expression representing the function along x.\n\n    expr_y : Expression representing the function along y.\n\n    expr_z : Expression representing the function along z.\n\n    range : (:class:`~.Symbol`, float, float)\n        A 3-tuple denoting the range of the parameter variable, e.g., (u, 0, 5).\n\n    Keyword Arguments\n    =================\n\n    Arguments for ``Parametric3DLineSeries`` class.\n\n    n : int\n        The range is uniformly sampled at ``n`` number of points.\n        This keyword argument replaces ``nb_of_points``, which should be\n        considered deprecated.\n\n    Aesthetics:\n\n    line_color : string, or float, or function, optional\n        Specifies the color for the plot.\n        See ``Plot`` to see how to set color for the plots.\n        Note that by setting ``line_color``, it would be applied simultaneously\n        to all the series.\n\n    label : str\n        The label to the plot. It will be used when called with ``legend=True``\n        to denote the function with the given label in the plot.\n\n    If there are multiple plots, then the same series arguments are applied to\n    all the plots. If you want to set these options separately, you can index\n    the returned ``Plot`` object and set it.\n\n    Arguments for ``Plot`` class.\n\n    title : str\n        Title of the plot.\n\n    size : (float, float), optional\n        A tuple in the form (width, height) in inches to specify the size of\n        the overall figure. The default value is set to ``None``, meaning\n        the size will be set by the default backend.\n\n    Examples\n    ========\n\n    .. plot::\n       :context: reset\n       :format: doctest\n       :include-source: True\n\n       >>> from sympy import symbols, cos, sin\n       >>> from sympy.plotting import plot3d_parametric_line\n       >>> u = symbols('u')\n\n    Single plot.\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot3d_parametric_line(cos(u), sin(u), u, (u, -5, 5))\n       Plot object containing:\n       [0]: 3D parametric cartesian line: (cos(u), sin(u), u) for u over (-5.0, 5.0)\n\n\n    Multiple plots.\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot3d_parametric_line((cos(u), sin(u), u, (u, -5, 5)),\n       ...     (sin(u), u**2, u, (u, -5, 5)))\n       Plot object containing:\n       [0]: 3D parametric cartesian line: (cos(u), sin(u), u) for u over (-5.0, 5.0)\n       [1]: 3D parametric cartesian line: (sin(u), u**2, u) for u over (-5.0, 5.0)\n\n\n    See Also\n    ========\n\n    Plot, Parametric3DLineSeries\n\n    ",
    "section": "Plotting Function Reference",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "plot3d_parametric_surface",
    "full_id": "sympy.plotting.plot.plot3d_parametric_surface",
    "type": "function",
    "description": "\n    Plots a 3D parametric surface plot.\n\n    Explanation\n    ===========\n\n    Single plot.\n\n    ``plot3d_parametric_surface(expr_x, expr_y, expr_z, range_u, range_v, **kwargs)``\n\n    If the ranges is not specified, then a default range of (-10, 10) is used.\n\n    Multiple plots.\n\n    ``plot3d_parametric_surface((expr_x, expr_y, expr_z, range_u, range_v), ..., **kwargs)``\n\n    Ranges have to be specified for every expression.\n\n    Default range may change in the future if a more advanced default range\n    detection algorithm is implemented.\n\n    Arguments\n    =========\n\n    expr_x : Expression representing the function along ``x``.\n\n    expr_y : Expression representing the function along ``y``.\n\n    expr_z : Expression representing the function along ``z``.\n\n    range_u : (:class:`~.Symbol`, float, float)\n        A 3-tuple denoting the range of the u variable, e.g. (u, 0, 5).\n\n    range_v : (:class:`~.Symbol`, float, float)\n        A 3-tuple denoting the range of the v variable, e.g. (v, 0, 5).\n\n    Keyword Arguments\n    =================\n\n    Arguments for ``ParametricSurfaceSeries`` class:\n\n    n1 : int\n        The ``u`` range is sampled uniformly at ``n1`` of points.\n        This keyword argument replaces ``nb_of_points_u``, which should be\n        considered deprecated.\n\n    n2 : int\n        The ``v`` range is sampled uniformly at ``n2`` of points.\n        This keyword argument replaces ``nb_of_points_v``, which should be\n        considered deprecated.\n\n    Aesthetics:\n\n    surface_color : Function which returns a float\n        Specifies the color for the surface of the plot. See\n        :class:`~Plot` for more details.\n\n    If there are multiple plots, then the same series arguments are applied for\n    all the plots. If you want to set these options separately, you can index\n    the returned ``Plot`` object and set it.\n\n\n    Arguments for ``Plot`` class:\n\n    title : str\n        Title of the plot.\n\n    size : (float, float), optional\n        A tuple in the form (width, height) in inches to specify the size of the\n        overall figure. The default value is set to ``None``, meaning the size will\n        be set by the default backend.\n\n    Examples\n    ========\n\n    .. plot::\n       :context: reset\n       :format: doctest\n       :include-source: True\n\n       >>> from sympy import symbols, cos, sin\n       >>> from sympy.plotting import plot3d_parametric_surface\n       >>> u, v = symbols('u v')\n\n    Single plot.\n\n    .. plot::\n       :context: close-figs\n       :format: doctest\n       :include-source: True\n\n       >>> plot3d_parametric_surface(cos(u + v), sin(u - v), u - v,\n       ...     (u, -5, 5), (v, -5, 5))\n       Plot object containing:\n       [0]: parametric cartesian surface: (cos(u + v), sin(u - v), u - v) for u over (-5.0, 5.0) and v over (-5.0, 5.0)\n\n\n    See Also\n    ========\n\n    Plot, ParametricSurfaceSeries\n\n    ",
    "section": "Plotting Function Reference",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "plot_implicit",
    "full_id": "sympy.plotting.plot_implicit.plot_implicit",
    "type": "function",
    "description": "A plot function to plot implicit equations / inequalities.\n\n    Arguments\n    =========\n\n    - expr : The equation / inequality that is to be plotted.\n    - x_var (optional) : symbol to plot on x-axis or tuple giving symbol\n      and range as ``(symbol, xmin, xmax)``\n    - y_var (optional) : symbol to plot on y-axis or tuple giving symbol\n      and range as ``(symbol, ymin, ymax)``\n\n    If neither ``x_var`` nor ``y_var`` are given then the free symbols in the\n    expression will be assigned in the order they are sorted.\n\n    The following keyword arguments can also be used:\n\n    - ``adaptive`` Boolean. The default value is set to True. It has to be\n        set to False if you want to use a mesh grid.\n\n    - ``depth`` integer. The depth of recursion for adaptive mesh grid.\n        Default value is 0. Takes value in the range (0, 4).\n\n    - ``n`` integer. The number of points if adaptive mesh grid is not\n        used. Default value is 300. This keyword argument replaces ``points``,\n        which should be considered deprecated.\n\n    - ``show`` Boolean. Default value is True. If set to False, the plot will\n        not be shown. See ``Plot`` for further information.\n\n    - ``title`` string. The title for the plot.\n\n    - ``xlabel`` string. The label for the x-axis\n\n    - ``ylabel`` string. The label for the y-axis\n\n    Aesthetics options:\n\n    - ``line_color``: float or string. Specifies the color for the plot.\n        See ``Plot`` to see how to set color for the plots.\n        Default value is \"Blue\"\n\n    plot_implicit, by default, uses interval arithmetic to plot functions. If\n    the expression cannot be plotted using interval arithmetic, it defaults to\n    a generating a contour using a mesh grid of fixed number of points. By\n    setting adaptive to False, you can force plot_implicit to use the mesh\n    grid. The mesh grid method can be effective when adaptive plotting using\n    interval arithmetic, fails to plot with small line width.\n\n    Examples\n    ========\n\n    Plot expressions:\n\n    .. plot::\n        :context: reset\n        :format: doctest\n        :include-source: True\n\n        >>> from sympy import plot_implicit, symbols, Eq, And\n        >>> x, y = symbols('x y')\n\n    Without any ranges for the symbols in the expression:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> p1 = plot_implicit(Eq(x**2 + y**2, 5))\n\n    With the range for the symbols:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> p2 = plot_implicit(\n        ...     Eq(x**2 + y**2, 3), (x, -3, 3), (y, -3, 3))\n\n    With depth of recursion as argument:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> p3 = plot_implicit(\n        ...     Eq(x**2 + y**2, 5), (x, -4, 4), (y, -4, 4), depth = 2)\n\n    Using mesh grid and not using adaptive meshing:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> p4 = plot_implicit(\n        ...     Eq(x**2 + y**2, 5), (x, -5, 5), (y, -2, 2),\n        ...     adaptive=False)\n\n    Using mesh grid without using adaptive meshing with number of points\n    specified:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> p5 = plot_implicit(\n        ...     Eq(x**2 + y**2, 5), (x, -5, 5), (y, -2, 2),\n        ...     adaptive=False, n=400)\n\n    Plotting regions:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> p6 = plot_implicit(y > x**2)\n\n    Plotting Using boolean conjunctions:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> p7 = plot_implicit(And(y > x, y > -x))\n\n    When plotting an expression with a single variable (y - 1, for example),\n    specify the x or the y variable explicitly:\n\n    .. plot::\n        :context: close-figs\n        :format: doctest\n        :include-source: True\n\n        >>> p8 = plot_implicit(y - 1, y_var=y)\n        >>> p9 = plot_implicit(x - 1, x_var=x)\n    ",
    "section": "Plotting Function Reference",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "eval_color_func",
    "full_id": "sympy.plotting.series.BaseSeries.eval_color_func",
    "type": "method",
    "description": "Evaluate the color function.\n\n        Parameters\n        ==========\n\n        args : tuple\n            Arguments to be passed to the coloring function. Can be coordinates\n            or parameters or both.\n\n        Notes\n        =====\n\n        The backend will request the data series to generate the numerical\n        data. Depending on the data series, either the data series itself or\n        the backend will eventually execute this function to generate the\n        appropriate coloring value.\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "expr",
    "full_id": "sympy.plotting.series.BaseSeries.expr",
    "type": "property",
    "description": "Return the expression (or expressions) of the series.",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "get_data",
    "full_id": "sympy.plotting.series.BaseSeries.get_data",
    "type": "method",
    "description": "Compute and returns the numerical data.\n\n        The number of parameters returned by this method depends on the\n        specific instance. If ``s`` is the series, make sure to read\n        ``help(s.get_data)`` to understand what it returns.\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "get_label",
    "full_id": "sympy.plotting.series.BaseSeries.get_label",
    "type": "method",
    "description": "Return the label to be used to display the expression.\n\n        Parameters\n        ==========\n        use_latex : bool\n            If False, the string representation of the expression is returned.\n            If True, the latex representation is returned.\n        wrapper : str\n            The backend might need the latex representation to be wrapped by\n            some characters. Default to ``\"$%s$\"``.\n\n        Returns\n        =======\n        label : str\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "n",
    "full_id": "sympy.plotting.series.BaseSeries.n",
    "type": "property",
    "description": "Returns a list [n1, n2, n3] of numbers of discratization points.",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "params",
    "full_id": "sympy.plotting.series.BaseSeries.params",
    "type": "property",
    "description": "Get or set the current parameters dictionary.\n\n        Parameters\n        ==========\n\n        p : dict\n\n            * key: symbol associated to the parameter\n            * val: the numeric value\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "get_data",
    "full_id": "sympy.plotting.series.Line2DBaseSeries.get_data",
    "type": "method",
    "description": "Return coordinates for plotting the line.\n\n        Returns\n        =======\n\n        x: np.ndarray\n            x-coordinates\n\n        y: np.ndarray\n            y-coordinates\n\n        z: np.ndarray (optional)\n            z-coordinates in case of Parametric3DLineSeries,\n            Parametric3DLineInteractiveSeries\n\n        param : np.ndarray (optional)\n            The parameter in case of Parametric2DLineSeries,\n            Parametric3DLineSeries or AbsArgLineSeries (and their\n            corresponding interactive series).\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "get_points",
    "full_id": "sympy.plotting.series.LineOver1DRangeSeries.get_points",
    "type": "method",
    "description": "Return lists of coordinates for plotting. Depending on the\n        ``adaptive`` option, this function will either use an adaptive algorithm\n        or it will uniformly sample the expression over the provided range.\n\n        This function is available for back-compatibility purposes. Consider\n        using ``get_data()`` instead.\n\n        Returns\n        =======\n            x : list\n                List of x-coordinates\n\n            y : list\n                List of y-coordinates\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "get_data",
    "full_id": "sympy.plotting.series.SurfaceOver2DRangeSeries.get_data",
    "type": "method",
    "description": "Return arrays of coordinates for plotting.\n\n        Returns\n        =======\n        mesh_x : np.ndarray\n            Discretized x-domain.\n        mesh_y : np.ndarray\n            Discretized y-domain.\n        mesh_z : np.ndarray\n            Results of the evaluation.\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "get_meshes",
    "full_id": "sympy.plotting.series.SurfaceOver2DRangeSeries.get_meshes",
    "type": "method",
    "description": "Return the x,y,z coordinates for plotting the surface.\n        This function is available for back-compatibility purposes. Consider\n        using ``get_data()`` instead.\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "get_data",
    "full_id": "sympy.plotting.series.ParametricSurfaceSeries.get_data",
    "type": "method",
    "description": "Return arrays of coordinates for plotting.\n\n        Returns\n        =======\n        x : np.ndarray [n2 x n1]\n            x-coordinates.\n        y : np.ndarray [n2 x n1]\n            y-coordinates.\n        z : np.ndarray [n2 x n1]\n            z-coordinates.\n        mesh_u : np.ndarray [n2 x n1]\n            Discretized u range.\n        mesh_v : np.ndarray [n2 x n1]\n            Discretized v range.\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "get_data",
    "full_id": "sympy.plotting.series.ImplicitSeries.get_data",
    "type": "method",
    "description": "Returns numerical data.\n\n        Returns\n        =======\n\n        If the series is evaluated with the `adaptive=True` it returns:\n\n        interval_list : list\n            List of bounding rectangular intervals to be postprocessed and\n            eventually used with Matplotlib's ``fill`` command.\n        dummy : str\n            A string containing ``\"fill\"``.\n\n        Otherwise, it returns 2D numpy arrays to be used with Matplotlib's\n        ``contour`` or ``contourf`` commands:\n\n        x_array : np.ndarray\n        y_array : np.ndarray\n        z_array : np.ndarray\n        plot_type : str\n            A string specifying which plot command to use, ``\"contour\"``\n            or ``\"contourf\"``.\n        ",
    "section": "Series Classes",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "get_segments",
    "full_id": "sympy.plotting.plot.MatplotlibBackend.get_segments",
    "type": "method",
    "description": "Convert two list of coordinates to a list of segments to be used\n        with Matplotlib's :external:class:`~matplotlib.collections.LineCollection`.\n\n        Parameters\n        ==========\n            x : list\n                List of x-coordinates\n\n            y : list\n                List of y-coordinates\n\n            z : list\n                List of z-coordinates for a 3D line.\n        ",
    "section": "Backends",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "process_series",
    "full_id": "sympy.plotting.plot.MatplotlibBackend.process_series",
    "type": "method",
    "description": "\n        Iterates over every ``Plot`` object and further calls\n        _process_series()\n        ",
    "section": "Backends",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "textplot",
    "full_id": "sympy.plotting.textplot.textplot",
    "type": "function",
    "description": "\n    Print a crude ASCII art plot of the SymPy expression 'expr' (which\n    should contain a single symbol, e.g. x or something else) over the\n    interval [a, b].\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, sin\n    >>> from sympy.plotting import textplot\n    >>> t = Symbol('t')\n    >>> textplot(sin(t)*t, 0, 15)\n     14 |                                                  ...\n        |                                                     .\n        |                                                 .\n        |                                                      .\n        |                                                .\n        |                            ...\n        |                           /   .               .\n        |                          /\n        |                         /      .\n        |                        .        .            .\n    1.5 |----.......--------------------------------------------\n        |....       \\           .          .\n        |            \\         /                      .\n        |             ..      /             .\n        |               \\    /                       .\n        |                ....\n        |                                    .\n        |                                     .     .\n        |\n        |                                      .   .\n    -11 |_______________________________________________________\n         0                          7.5                        15\n    ",
    "section": "Plotting with ASCII art",
    "url": "https://docs.sympy.org/latest/modules/plotting.html"
  },
  {
    "name": "DiscreteUniform",
    "full_id": "sympy.stats.DiscreteUniform",
    "type": "function",
    "description": "\n    Create a Finite Random Variable representing a uniform distribution over\n    the input set.\n\n    Parameters\n    ==========\n\n    items : list/tuple\n        Items over which Uniform distribution is to be made\n\n    Examples\n    ========\n\n    >>> from sympy.stats import DiscreteUniform, density\n    >>> from sympy import symbols\n\n    >>> X = DiscreteUniform('X', symbols('a b c')) # equally likely over a, b, c\n    >>> density(X).dict\n    {a: 1/3, b: 1/3, c: 1/3}\n\n    >>> Y = DiscreteUniform('Y', list(range(5))) # distribution over a range\n    >>> density(Y).dict\n    {0: 1/5, 1: 1/5, 2: 1/5, 3: 1/5, 4: 1/5}\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Discrete_uniform_distribution\n    .. [2] https://mathworld.wolfram.com/DiscreteUniformDistribution.html\n\n    ",
    "section": "Finite Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Die",
    "full_id": "sympy.stats.Die",
    "type": "function",
    "description": "\n    Create a Finite Random Variable representing a fair die.\n\n    Parameters\n    ==========\n\n    sides : Integer\n        Represents the number of sides of the Die, by default is 6\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Die, density\n    >>> from sympy import Symbol\n\n    >>> D6 = Die('D6', 6) # Six sided Die\n    >>> density(D6).dict\n    {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}\n\n    >>> D4 = Die('D4', 4) # Four sided Die\n    >>> density(D4).dict\n    {1: 1/4, 2: 1/4, 3: 1/4, 4: 1/4}\n\n    >>> n = Symbol('n', positive=True, integer=True)\n    >>> Dn = Die('Dn', n) # n sided Die\n    >>> density(Dn).dict\n    Density(DieDistribution(n))\n    >>> density(Dn).dict.subs(n, 4).doit()\n    {1: 1/4, 2: 1/4, 3: 1/4, 4: 1/4}\n\n    Returns\n    =======\n\n    RandomSymbol\n    ",
    "section": "Finite Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Bernoulli",
    "full_id": "sympy.stats.Bernoulli",
    "type": "function",
    "description": "\n    Create a Finite Random Variable representing a Bernoulli process.\n\n    Parameters\n    ==========\n\n    p : Rational number between 0 and 1\n       Represents probability of success\n    succ : Integer/symbol/string\n       Represents event of success\n    fail : Integer/symbol/string\n       Represents event of failure\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Bernoulli, density\n    >>> from sympy import S\n\n    >>> X = Bernoulli('X', S(3)/4) # 1-0 Bernoulli variable, probability = 3/4\n    >>> density(X).dict\n    {0: 1/4, 1: 3/4}\n\n    >>> X = Bernoulli('X', S.Half, 'Heads', 'Tails') # A fair coin toss\n    >>> density(X).dict\n    {Heads: 1/2, Tails: 1/2}\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Bernoulli_distribution\n    .. [2] https://mathworld.wolfram.com/BernoulliDistribution.html\n\n    ",
    "section": "Finite Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Coin",
    "full_id": "sympy.stats.Coin",
    "type": "function",
    "description": "\n    Create a Finite Random Variable representing a Coin toss.\n\n    Parameters\n    ==========\n\n    p : Rational Number between 0 and 1\n      Represents probability of getting \"Heads\", by default is Half\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Coin, density\n    >>> from sympy import Rational\n\n    >>> C = Coin('C') # A fair coin toss\n    >>> density(C).dict\n    {H: 1/2, T: 1/2}\n\n    >>> C2 = Coin('C2', Rational(3, 5)) # An unfair coin\n    >>> density(C2).dict\n    {H: 3/5, T: 2/5}\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    See Also\n    ========\n\n    sympy.stats.Binomial\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Coin_flipping\n\n    ",
    "section": "Finite Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Binomial",
    "full_id": "sympy.stats.Binomial",
    "type": "function",
    "description": "\n    Create a Finite Random Variable representing a binomial distribution.\n\n    Parameters\n    ==========\n\n    n : Positive Integer\n      Represents number of trials\n    p : Rational Number between 0 and 1\n      Represents probability of success\n    succ : Integer/symbol/string\n      Represents event of success, by default is 1\n    fail : Integer/symbol/string\n      Represents event of failure, by default is 0\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Binomial, density\n    >>> from sympy import S, Symbol\n\n    >>> X = Binomial('X', 4, S.Half) # Four \"coin flips\"\n    >>> density(X).dict\n    {0: 1/16, 1: 1/4, 2: 3/8, 3: 1/4, 4: 1/16}\n\n    >>> n = Symbol('n', positive=True, integer=True)\n    >>> p = Symbol('p', positive=True)\n    >>> X = Binomial('X', n, S.Half) # n \"coin flips\"\n    >>> density(X).dict\n    Density(BinomialDistribution(n, 1/2, 1, 0))\n    >>> density(X).dict.subs(n, 4).doit()\n    {0: 1/16, 1: 1/4, 2: 3/8, 3: 1/4, 4: 1/16}\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Binomial_distribution\n    .. [2] https://mathworld.wolfram.com/BinomialDistribution.html\n\n    ",
    "section": "Finite Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "BetaBinomial",
    "full_id": "sympy.stats.BetaBinomial",
    "type": "function",
    "description": "\n    Create a Finite Random Variable representing a Beta-binomial distribution.\n\n    Parameters\n    ==========\n\n    n : Positive Integer\n      Represents number of trials\n    alpha : Real positive number\n    beta : Real positive number\n\n    Examples\n    ========\n\n    >>> from sympy.stats import BetaBinomial, density\n\n    >>> X = BetaBinomial('X', 2, 1, 1)\n    >>> density(X).dict\n    {0: 1/3, 1: 2*beta(2, 2), 2: 1/3}\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Beta-binomial_distribution\n    .. [2] https://mathworld.wolfram.com/BetaBinomialDistribution.html\n\n    ",
    "section": "Finite Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Hypergeometric",
    "full_id": "sympy.stats.Hypergeometric",
    "type": "function",
    "description": "\n    Create a Finite Random Variable representing a hypergeometric distribution.\n\n    Parameters\n    ==========\n\n    N : Positive Integer\n      Represents finite population of size N.\n    m : Positive Integer\n      Represents number of trials with required feature.\n    n : Positive Integer\n      Represents numbers of draws.\n\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Hypergeometric, density\n\n    >>> X = Hypergeometric('X', 10, 5, 3) # 10 marbles, 5 white (success), 3 draws\n    >>> density(X).dict\n    {0: 1/12, 1: 5/12, 2: 5/12, 3: 1/12}\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Hypergeometric_distribution\n    .. [2] https://mathworld.wolfram.com/HypergeometricDistribution.html\n\n    ",
    "section": "Finite Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "FiniteRV",
    "full_id": "sympy.stats.FiniteRV",
    "type": "function",
    "description": "\n    Create a Finite Random Variable given a dict representing the density.\n\n    Parameters\n    ==========\n\n    name : Symbol\n        Represents name of the random variable.\n    density : dict\n        Dictionary containing the pdf of finite distribution\n    check : bool\n        If True, it will check whether the given density\n        integrates to 1 over the given set. If False, it\n        will not perform this check. Default is False.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import FiniteRV, P, E\n\n    >>> density = {0: .1, 1: .2, 2: .3, 3: .4}\n    >>> X = FiniteRV('X', density)\n\n    >>> E(X)\n    2.00000000000000\n    >>> P(X >= 2)\n    0.700000000000000\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    ",
    "section": "Finite Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Rademacher",
    "full_id": "sympy.stats.Rademacher",
    "type": "function",
    "description": "\n    Create a Finite Random Variable representing a Rademacher distribution.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Rademacher, density\n\n    >>> X = Rademacher('X')\n    >>> density(X).dict\n    {-1: 1/2, 1: 1/2}\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    See Also\n    ========\n\n    sympy.stats.Bernoulli\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Rademacher_distribution\n\n    ",
    "section": "Finite Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Geometric",
    "full_id": "sympy.stats.Geometric",
    "type": "function",
    "description": "\n    Create a discrete random variable with a Geometric distribution.\n\n    Explanation\n    ===========\n\n    The density of the Geometric distribution is given by\n\n    .. math::\n        f(k) := p (1 - p)^{k - 1}\n\n    Parameters\n    ==========\n\n    p : A probability between 0 and 1\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Geometric, density, E, variance\n    >>> from sympy import Symbol, S\n\n    >>> p = S.One / 5\n    >>> z = Symbol(\"z\")\n\n    >>> X = Geometric(\"x\", p)\n\n    >>> density(X)(z)\n    (5/4)**(1 - z)/5\n\n    >>> E(X)\n    5\n\n    >>> variance(X)\n    20\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Geometric_distribution\n    .. [2] https://mathworld.wolfram.com/GeometricDistribution.html\n\n    ",
    "section": "Discrete Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Hermite",
    "full_id": "sympy.stats.Hermite",
    "type": "function",
    "description": "\n    Create a discrete random variable with a Hermite distribution.\n\n    Explanation\n    ===========\n\n    The density of the Hermite distribution is given by\n\n    .. math::\n        f(x):= e^{-a_1 -a_2}\\sum_{j=0}^{\\left \\lfloor x/2 \\right \\rfloor}\n                    \\frac{a_{1}^{x-2j}a_{2}^{j}}{(x-2j)!j!}\n\n    Parameters\n    ==========\n\n    a1 : A Positive number greater than equal to 0.\n    a2 : A Positive number greater than equal to 0.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Hermite, density, E, variance\n    >>> from sympy import Symbol\n\n    >>> a1 = Symbol(\"a1\", positive=True)\n    >>> a2 = Symbol(\"a2\", positive=True)\n    >>> x = Symbol(\"x\")\n\n    >>> H = Hermite(\"H\", a1=5, a2=4)\n\n    >>> density(H)(2)\n    33*exp(-9)/2\n\n    >>> E(H)\n    13\n\n    >>> variance(H)\n    21\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Hermite_distribution\n\n    ",
    "section": "Discrete Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Poisson",
    "full_id": "sympy.stats.Poisson",
    "type": "function",
    "description": "\n    Create a discrete random variable with a Poisson distribution.\n\n    Explanation\n    ===========\n\n    The density of the Poisson distribution is given by\n\n    .. math::\n        f(k) := \\frac{\\lambda^{k} e^{- \\lambda}}{k!}\n\n    Parameters\n    ==========\n\n    lamda : Positive number, a rate\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Poisson, density, E, variance\n    >>> from sympy import Symbol, simplify\n\n    >>> rate = Symbol(\"lambda\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Poisson(\"x\", rate)\n\n    >>> density(X)(z)\n    lambda**z*exp(-lambda)/factorial(z)\n\n    >>> E(X)\n    lambda\n\n    >>> simplify(variance(X))\n    lambda\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Poisson_distribution\n    .. [2] https://mathworld.wolfram.com/PoissonDistribution.html\n\n    ",
    "section": "Discrete Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Logarithmic",
    "full_id": "sympy.stats.Logarithmic",
    "type": "function",
    "description": "\n    Create a discrete random variable with a Logarithmic distribution.\n\n    Explanation\n    ===========\n\n    The density of the Logarithmic distribution is given by\n\n    .. math::\n        f(k) := \\frac{-p^k}{k \\ln{(1 - p)}}\n\n    Parameters\n    ==========\n\n    p : A value between 0 and 1\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Logarithmic, density, E, variance\n    >>> from sympy import Symbol, S\n\n    >>> p = S.One / 5\n    >>> z = Symbol(\"z\")\n\n    >>> X = Logarithmic(\"x\", p)\n\n    >>> density(X)(z)\n    -1/(5**z*z*log(4/5))\n\n    >>> E(X)\n    -1/(-4*log(5) + 8*log(2))\n\n    >>> variance(X)\n    -1/((-4*log(5) + 8*log(2))*(-2*log(5) + 4*log(2))) + 1/(-64*log(2)*log(5) + 64*log(2)**2 + 16*log(5)**2) - 10/(-32*log(5) + 64*log(2))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Logarithmic_distribution\n    .. [2] https://mathworld.wolfram.com/LogarithmicDistribution.html\n\n    ",
    "section": "Discrete Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "NegativeBinomial",
    "full_id": "sympy.stats.NegativeBinomial",
    "type": "function",
    "description": "\n    Create a discrete random variable with a Negative Binomial distribution.\n\n    Explanation\n    ===========\n\n    The density of the Negative Binomial distribution is given by\n\n    .. math::\n        f(k) := \\binom{k + r - 1}{k} (1 - p)^r p^k\n\n    Parameters\n    ==========\n\n    r : A positive value\n    p : A value between 0 and 1\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import NegativeBinomial, density, E, variance\n    >>> from sympy import Symbol, S\n\n    >>> r = 5\n    >>> p = S.One / 5\n    >>> z = Symbol(\"z\")\n\n    >>> X = NegativeBinomial(\"x\", r, p)\n\n    >>> density(X)(z)\n    1024*binomial(z + 4, z)/(3125*5**z)\n\n    >>> E(X)\n    5/4\n\n    >>> variance(X)\n    25/16\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Negative_binomial_distribution\n    .. [2] https://mathworld.wolfram.com/NegativeBinomialDistribution.html\n\n    ",
    "section": "Discrete Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Skellam",
    "full_id": "sympy.stats.Skellam",
    "type": "function",
    "description": "\n    Create a discrete random variable with a Skellam distribution.\n\n    Explanation\n    ===========\n\n    The Skellam is the distribution of the difference N1 - N2\n    of two statistically independent random variables N1 and N2\n    each Poisson-distributed with respective expected values mu1 and mu2.\n\n    The density of the Skellam distribution is given by\n\n    .. math::\n        f(k) := e^{-(\\mu_1+\\mu_2)}(\\frac{\\mu_1}{\\mu_2})^{k/2}I_k(2\\sqrt{\\mu_1\\mu_2})\n\n    Parameters\n    ==========\n\n    mu1 : A non-negative value\n    mu2 : A non-negative value\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Skellam, density, E, variance\n    >>> from sympy import Symbol, pprint\n\n    >>> z = Symbol(\"z\", integer=True)\n    >>> mu1 = Symbol(\"mu1\", positive=True)\n    >>> mu2 = Symbol(\"mu2\", positive=True)\n    >>> X = Skellam(\"x\", mu1, mu2)\n\n    >>> pprint(density(X)(z), use_unicode=False)\n         z\n         -\n         2\n    /mu1\\   -mu1 - mu2        /       _____   _____\\\n    |---| *e          *besseli\\z, 2*\\/ mu1 *\\/ mu2 /\n    \\mu2/\n    >>> E(X)\n    mu1 - mu2\n    >>> variance(X).expand()\n    mu1 + mu2\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Skellam_distribution\n\n    ",
    "section": "Discrete Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "YuleSimon",
    "full_id": "sympy.stats.YuleSimon",
    "type": "function",
    "description": "\n    Create a discrete random variable with a Yule-Simon distribution.\n\n    Explanation\n    ===========\n\n    The density of the Yule-Simon distribution is given by\n\n    .. math::\n        f(k) := \\rho B(k, \\rho + 1)\n\n    Parameters\n    ==========\n\n    rho : A positive value\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import YuleSimon, density, E, variance\n    >>> from sympy import Symbol, simplify\n\n    >>> p = 5\n    >>> z = Symbol(\"z\")\n\n    >>> X = YuleSimon(\"x\", p)\n\n    >>> density(X)(z)\n    5*beta(z, 6)\n\n    >>> simplify(E(X))\n    5/4\n\n    >>> simplify(variance(X))\n    25/48\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Yule%E2%80%93Simon_distribution\n\n    ",
    "section": "Discrete Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Zeta",
    "full_id": "sympy.stats.Zeta",
    "type": "function",
    "description": "\n    Create a discrete random variable with a Zeta distribution.\n\n    Explanation\n    ===========\n\n    The density of the Zeta distribution is given by\n\n    .. math::\n        f(k) := \\frac{1}{k^s \\zeta{(s)}}\n\n    Parameters\n    ==========\n\n    s : A value greater than 1\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Zeta, density, E, variance\n    >>> from sympy import Symbol\n\n    >>> s = 5\n    >>> z = Symbol(\"z\")\n\n    >>> X = Zeta(\"x\", s)\n\n    >>> density(X)(z)\n    1/(z**5*zeta(5))\n\n    >>> E(X)\n    pi**4/(90*zeta(5))\n\n    >>> variance(X)\n    -pi**8/(8100*zeta(5)**2) + zeta(3)/zeta(5)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Zeta_distribution\n\n    ",
    "section": "Discrete Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Arcsin",
    "full_id": "sympy.stats.Arcsin",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with an arcsin distribution.\n\n    The density of the arcsin distribution is given by\n\n    .. math::\n        f(x) := \\frac{1}{\\pi\\sqrt{(x-a)(b-x)}}\n\n    with :math:`x \\in (a,b)`. It must hold that :math:`-\\infty < a < b < \\infty`.\n\n    Parameters\n    ==========\n\n    a : Real number, the left interval boundary\n    b : Real number, the right interval boundary\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Arcsin, density, cdf\n    >>> from sympy import Symbol\n\n    >>> a = Symbol(\"a\", real=True)\n    >>> b = Symbol(\"b\", real=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Arcsin(\"x\", a, b)\n\n    >>> density(X)(z)\n    1/(pi*sqrt((-a + z)*(b - z)))\n\n    >>> cdf(X)(z)\n    Piecewise((0, a > z),\n            (2*asin(sqrt((-a + z)/(-a + b)))/pi, b >= z),\n            (1, True))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Arcsine_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Benini",
    "full_id": "sympy.stats.Benini",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with a Benini distribution.\n\n    The density of the Benini distribution is given by\n\n    .. math::\n        f(x) := e^{-\\alpha\\log{\\frac{x}{\\sigma}}\n                -\\beta\\log^2\\left[{\\frac{x}{\\sigma}}\\right]}\n                \\left(\\frac{\\alpha}{x}+\\frac{2\\beta\\log{\\frac{x}{\\sigma}}}{x}\\right)\n\n    This is a heavy-tailed distribution and is also known as the log-Rayleigh\n    distribution.\n\n    Parameters\n    ==========\n\n    alpha : Real number, `\\alpha > 0`, a shape\n    beta : Real number, `\\beta > 0`, a shape\n    sigma : Real number, `\\sigma > 0`, a scale\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Benini, density, cdf\n    >>> from sympy import Symbol, pprint\n\n    >>> alpha = Symbol(\"alpha\", positive=True)\n    >>> beta = Symbol(\"beta\", positive=True)\n    >>> sigma = Symbol(\"sigma\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Benini(\"x\", alpha, beta, sigma)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n    /                  /  z  \\\\             /  z  \\            2/  z  \\\n    |        2*beta*log|-----||  - alpha*log|-----| - beta*log  |-----|\n    |alpha             \\sigma/|             \\sigma/             \\sigma/\n    |----- + -----------------|*e\n    \\  z             z        /\n\n    >>> cdf(X)(z)\n    Piecewise((1 - exp(-alpha*log(z/sigma) - beta*log(z/sigma)**2), sigma <= z),\n            (0, True))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Benini_distribution\n    .. [2] https://reference.wolfram.com/legacy/v8/ref/BeniniDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Beta",
    "full_id": "sympy.stats.Beta",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with a Beta distribution.\n\n    The density of the Beta distribution is given by\n\n    .. math::\n        f(x) := \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)}\n\n    with :math:`x \\in [0,1]`.\n\n    Parameters\n    ==========\n\n    alpha : Real number, `\\alpha > 0`, a shape\n    beta : Real number, `\\beta > 0`, a shape\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Beta, density, E, variance\n    >>> from sympy import Symbol, simplify, pprint, factor\n\n    >>> alpha = Symbol(\"alpha\", positive=True)\n    >>> beta = Symbol(\"beta\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Beta(\"x\", alpha, beta)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n     alpha - 1        beta - 1\n    z         *(1 - z)\n    --------------------------\n          B(alpha, beta)\n\n    >>> simplify(E(X))\n    alpha/(alpha + beta)\n\n    >>> factor(simplify(variance(X)))\n    alpha*beta/((alpha + beta)**2*(alpha + beta + 1))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Beta_distribution\n    .. [2] https://mathworld.wolfram.com/BetaDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "BetaNoncentral",
    "full_id": "sympy.stats.BetaNoncentral",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with a Type I Noncentral Beta distribution.\n\n    The density of the Noncentral Beta distribution is given by\n\n    .. math::\n        f(x) := \\sum_{k=0}^\\infty e^{-\\lambda/2}\\frac{(\\lambda/2)^k}{k!}\n                \\frac{x^{\\alpha+k-1}(1-x)^{\\beta-1}}{\\mathrm{B}(\\alpha+k,\\beta)}\n\n    with :math:`x \\in [0,1]`.\n\n    Parameters\n    ==========\n\n    alpha : Real number, `\\alpha > 0`, a shape\n    beta : Real number, `\\beta > 0`, a shape\n    lamda : Real number, `\\lambda \\geq 0`, noncentrality parameter\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import BetaNoncentral, density, cdf\n    >>> from sympy import Symbol, pprint\n\n    >>> alpha = Symbol(\"alpha\", positive=True)\n    >>> beta = Symbol(\"beta\", positive=True)\n    >>> lamda = Symbol(\"lamda\", nonnegative=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = BetaNoncentral(\"x\", alpha, beta, lamda)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n      oo\n    _____\n    \\    `\n     \\                                              -lamda\n      \\                          k                  -------\n       \\    k + alpha - 1 /lamda\\         beta - 1     2\n        )  z             *|-----| *(1 - z)        *e\n       /                  \\  2  /\n      /    ------------------------------------------------\n     /                  B(k + alpha, beta)*k!\n    /____,\n    k = 0\n\n    Compute cdf with specific 'x', 'alpha', 'beta' and 'lamda' values as follows:\n\n    >>> cdf(BetaNoncentral(\"x\", 1, 1, 1), evaluate=False)(2).doit()\n    2*exp(1/2)\n\n    The argument evaluate=False prevents an attempt at evaluation\n    of the sum for general x, before the argument 2 is passed.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Noncentral_beta_distribution\n    .. [2] https://reference.wolfram.com/language/ref/NoncentralBetaDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "BetaPrime",
    "full_id": "sympy.stats.BetaPrime",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Beta prime distribution.\n\n    The density of the Beta prime distribution is given by\n\n    .. math::\n        f(x) := \\frac{x^{\\alpha-1} (1+x)^{-\\alpha -\\beta}}{B(\\alpha,\\beta)}\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    alpha : Real number, `\\alpha > 0`, a shape\n    beta : Real number, `\\beta > 0`, a shape\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import BetaPrime, density\n    >>> from sympy import Symbol, pprint\n\n    >>> alpha = Symbol(\"alpha\", positive=True)\n    >>> beta = Symbol(\"beta\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = BetaPrime(\"x\", alpha, beta)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n     alpha - 1        -alpha - beta\n    z         *(z + 1)\n    -------------------------------\n             B(alpha, beta)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Beta_prime_distribution\n    .. [2] https://mathworld.wolfram.com/BetaPrimeDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "BoundedPareto",
    "full_id": "sympy.stats.BoundedPareto",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Bounded Pareto distribution.\n\n    The density of the Bounded Pareto distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\alpha L^{\\alpha}x^{-\\alpha-1}}{1-(\\frac{L}{H})^{\\alpha}}\n\n    Parameters\n    ==========\n\n    alpha : Real Number, `\\alpha > 0`\n        Shape parameter\n    left : Real Number, `left > 0`\n        Location parameter\n    right : Real Number, `right > left`\n        Location parameter\n\n    Examples\n    ========\n\n    >>> from sympy.stats import BoundedPareto, density, cdf, E\n    >>> from sympy import symbols\n    >>> L, H = symbols('L, H', positive=True)\n    >>> X = BoundedPareto('X', 2, L, H)\n    >>> x = symbols('x')\n    >>> density(X)(x)\n    2*L**2/(x**3*(1 - L**2/H**2))\n    >>> cdf(X)(x)\n    Piecewise((-H**2*L**2/(x**2*(H**2 - L**2)) + H**2/(H**2 - L**2), L <= x), (0, True))\n    >>> E(X).simplify()\n    2*H*L/(H + L)\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Pareto_distribution#Bounded_Pareto_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Cauchy",
    "full_id": "sympy.stats.Cauchy",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Cauchy distribution.\n\n    The density of the Cauchy distribution is given by\n\n    .. math::\n        f(x) := \\frac{1}{\\pi \\gamma [1 + {(\\frac{x-x_0}{\\gamma})}^2]}\n\n    Parameters\n    ==========\n\n    x0 : Real number, the location\n    gamma : Real number, `\\gamma > 0`, a scale\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Cauchy, density\n    >>> from sympy import Symbol\n\n    >>> x0 = Symbol(\"x0\")\n    >>> gamma = Symbol(\"gamma\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Cauchy(\"x\", x0, gamma)\n\n    >>> density(X)(z)\n    1/(pi*gamma*(1 + (-x0 + z)**2/gamma**2))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Cauchy_distribution\n    .. [2] https://mathworld.wolfram.com/CauchyDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Chi",
    "full_id": "sympy.stats.Chi",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Chi distribution.\n\n    The density of the Chi distribution is given by\n\n    .. math::\n        f(x) := \\frac{2^{1-k/2}x^{k-1}e^{-x^2/2}}{\\Gamma(k/2)}\n\n    with :math:`x \\geq 0`.\n\n    Parameters\n    ==========\n\n    k : Positive integer, The number of degrees of freedom\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Chi, density, E\n    >>> from sympy import Symbol, simplify\n\n    >>> k = Symbol(\"k\", integer=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Chi(\"x\", k)\n\n    >>> density(X)(z)\n    2**(1 - k/2)*z**(k - 1)*exp(-z**2/2)/gamma(k/2)\n\n    >>> simplify(E(X))\n    sqrt(2)*gamma(k/2 + 1/2)/gamma(k/2)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Chi_distribution\n    .. [2] https://mathworld.wolfram.com/ChiDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "ChiNoncentral",
    "full_id": "sympy.stats.ChiNoncentral",
    "type": "function",
    "description": "\n    Create a continuous random variable with a non-central Chi distribution.\n\n    Explanation\n    ===========\n\n    The density of the non-central Chi distribution is given by\n\n    .. math::\n        f(x) := \\frac{e^{-(x^2+\\lambda^2)/2} x^k\\lambda}\n                {(\\lambda x)^{k/2}} I_{k/2-1}(\\lambda x)\n\n    with `x \\geq 0`. Here, `I_\\nu (x)` is the\n    :ref:`modified Bessel function of the first kind <besseli>`.\n\n    Parameters\n    ==========\n\n    k : A positive Integer, $k > 0$\n        The number of degrees of freedom.\n    lambda : Real number, `\\lambda > 0`\n        Shift parameter.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import ChiNoncentral, density\n    >>> from sympy import Symbol\n\n    >>> k = Symbol(\"k\", integer=True)\n    >>> l = Symbol(\"l\")\n    >>> z = Symbol(\"z\")\n\n    >>> X = ChiNoncentral(\"x\", k, l)\n\n    >>> density(X)(z)\n    l*z**k*exp(-l**2/2 - z**2/2)*besseli(k/2 - 1, l*z)/(l*z)**(k/2)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Noncentral_chi_distribution\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "ChiSquared",
    "full_id": "sympy.stats.ChiSquared",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Chi-squared distribution.\n\n    Explanation\n    ===========\n\n    The density of the Chi-squared distribution is given by\n\n    .. math::\n        f(x) := \\frac{1}{2^{\\frac{k}{2}}\\Gamma\\left(\\frac{k}{2}\\right)}\n                x^{\\frac{k}{2}-1} e^{-\\frac{x}{2}}\n\n    with :math:`x \\geq 0`.\n\n    Parameters\n    ==========\n\n    k : Positive integer\n        The number of degrees of freedom.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import ChiSquared, density, E, variance, moment\n    >>> from sympy import Symbol\n\n    >>> k = Symbol(\"k\", integer=True, positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = ChiSquared(\"x\", k)\n\n    >>> density(X)(z)\n    z**(k/2 - 1)*exp(-z/2)/(2**(k/2)*gamma(k/2))\n\n    >>> E(X)\n    k\n\n    >>> variance(X)\n    2*k\n\n    >>> moment(X, 3)\n    k**3 + 6*k**2 + 8*k\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Chi_squared_distribution\n    .. [2] https://mathworld.wolfram.com/Chi-SquaredDistribution.html\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Dagum",
    "full_id": "sympy.stats.Dagum",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Dagum distribution.\n\n    Explanation\n    ===========\n\n    The density of the Dagum distribution is given by\n\n    .. math::\n        f(x) := \\frac{a p}{x} \\left( \\frac{\\left(\\tfrac{x}{b}\\right)^{a p}}\n                {\\left(\\left(\\tfrac{x}{b}\\right)^a + 1 \\right)^{p+1}} \\right)\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    p : Real number\n        `p > 0`, a shape.\n    a : Real number\n        `a > 0`, a shape.\n    b : Real number\n        `b > 0`, a scale.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Dagum, density, cdf\n    >>> from sympy import Symbol\n\n    >>> p = Symbol(\"p\", positive=True)\n    >>> a = Symbol(\"a\", positive=True)\n    >>> b = Symbol(\"b\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Dagum(\"x\", p, a, b)\n\n    >>> density(X)(z)\n    a*p*(z/b)**(a*p)*((z/b)**a + 1)**(-p - 1)/z\n\n    >>> cdf(X)(z)\n    Piecewise(((1 + (z/b)**(-a))**(-p), z >= 0), (0, True))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Dagum_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Davis",
    "full_id": "sympy.stats.Davis",
    "type": "function",
    "description": " Create a continuous random variable with Davis distribution.\n\n    Explanation\n    ===========\n\n    The density of Davis distribution is given by\n\n    .. math::\n        f(x; \\mu; b, n) := \\frac{b^{n}(x - \\mu)^{1-n}}{ \\left( e^{\\frac{b}{x-\\mu}} - 1 \\right) \\Gamma(n)\\zeta(n)}\n\n    with :math:`x \\in [0,\\infty]`.\n\n    Davis distribution is a generalization of the Planck's law of radiation from statistical physics. It is used for modeling income distribution.\n\n    Parameters\n    ==========\n    b : Real number\n        `p > 0`, a scale.\n    n : Real number\n        `n > 1`, a shape.\n    mu : Real number\n        `mu > 0`, a location.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n    >>> from sympy.stats import Davis, density\n    >>> from sympy import Symbol\n    >>> b = Symbol(\"b\", positive=True)\n    >>> n = Symbol(\"n\", positive=True)\n    >>> mu = Symbol(\"mu\", positive=True)\n    >>> z = Symbol(\"z\")\n    >>> X = Davis(\"x\", b, n, mu)\n    >>> density(X)(z)\n    b**n*(-mu + z)**(-n - 1)/((exp(b/(-mu + z)) - 1)*gamma(n)*zeta(n))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Davis_distribution\n    .. [2] https://reference.wolfram.com/language/ref/DavisDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Erlang",
    "full_id": "sympy.stats.Erlang",
    "type": "function",
    "description": "\n    Create a continuous random variable with an Erlang distribution.\n\n    Explanation\n    ===========\n\n    The density of the Erlang distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\lambda^k x^{k-1} e^{-\\lambda x}}{(k-1)!}\n\n    with :math:`x \\in [0,\\infty]`.\n\n    Parameters\n    ==========\n\n    k : Positive integer\n    l : Real number, `\\lambda > 0`, the rate\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Erlang, density, cdf, E, variance\n    >>> from sympy import Symbol, simplify, pprint\n\n    >>> k = Symbol(\"k\", integer=True, positive=True)\n    >>> l = Symbol(\"l\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Erlang(\"x\", k, l)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n     k  k - 1  -l*z\n    l *z     *e\n    ---------------\n        Gamma(k)\n\n    >>> C = cdf(X)(z)\n    >>> pprint(C, use_unicode=False)\n    /lowergamma(k, l*z)\n    |------------------  for z > 0\n    <     Gamma(k)\n    |\n    \\        0           otherwise\n\n\n    >>> E(X)\n    k/l\n\n    >>> simplify(variance(X))\n    k/l**2\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Erlang_distribution\n    .. [2] https://mathworld.wolfram.com/ErlangDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "ExGaussian",
    "full_id": "sympy.stats.ExGaussian",
    "type": "function",
    "description": "\n    Create a continuous random variable with an Exponentially modified\n    Gaussian (EMG) distribution.\n\n    Explanation\n    ===========\n\n    The density of the exponentially modified Gaussian distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\lambda}{2}e^{\\frac{\\lambda}{2}(2\\mu+\\lambda\\sigma^2-2x)}\n            \\text{erfc}(\\frac{\\mu + \\lambda\\sigma^2 - x}{\\sqrt{2}\\sigma})\n\n    with $x > 0$. Note that the expected value is `1/\\lambda`.\n\n    Parameters\n    ==========\n\n    name : A string giving a name for this distribution\n    mean : A Real number, the mean of Gaussian component\n    std : A positive Real number,\n        :math: `\\sigma^2 > 0` the variance of Gaussian component\n    rate : A positive Real number,\n        :math: `\\lambda > 0` the rate of Exponential component\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import ExGaussian, density, cdf, E\n    >>> from sympy.stats import variance, skewness\n    >>> from sympy import Symbol, pprint, simplify\n\n    >>> mean = Symbol(\"mu\")\n    >>> std = Symbol(\"sigma\", positive=True)\n    >>> rate = Symbol(\"lamda\", positive=True)\n    >>> z = Symbol(\"z\")\n    >>> X = ExGaussian(\"x\", mean, std, rate)\n\n    >>> pprint(density(X)(z), use_unicode=False)\n                 /           2             \\\n           lamda*\\lamda*sigma  + 2*mu - 2*z/\n           ---------------------------------     /  ___ /           2         \\\\\n                           2                     |\\/ 2 *\\lamda*sigma  + mu - z/|\n    lamda*e                                 *erfc|-----------------------------|\n                                                 \\           2*sigma           /\n    ----------------------------------------------------------------------------\n                                         2\n\n    >>> cdf(X)(z)\n    -(erf(sqrt(2)*(-lamda**2*sigma**2 + lamda*(-mu + z))/(2*lamda*sigma))/2 + 1/2)*exp(lamda**2*sigma**2/2 - lamda*(-mu + z)) + erf(sqrt(2)*(-mu + z)/(2*sigma))/2 + 1/2\n\n    >>> E(X)\n    (lamda*mu + 1)/lamda\n\n    >>> simplify(variance(X))\n    sigma**2 + lamda**(-2)\n\n    >>> simplify(skewness(X))\n    2/(lamda**2*sigma**2 + 1)**(3/2)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Exponentially_modified_Gaussian_distribution\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Exponential",
    "full_id": "sympy.stats.Exponential",
    "type": "function",
    "description": "\n    Create a continuous random variable with an Exponential distribution.\n\n    Explanation\n    ===========\n\n    The density of the exponential distribution is given by\n\n    .. math::\n        f(x) := \\lambda \\exp(-\\lambda x)\n\n    with $x > 0$. Note that the expected value is `1/\\lambda`.\n\n    Parameters\n    ==========\n\n    rate : A positive Real number, `\\lambda > 0`, the rate (or inverse scale/inverse mean)\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Exponential, density, cdf, E\n    >>> from sympy.stats import variance, std, skewness, quantile\n    >>> from sympy import Symbol\n\n    >>> l = Symbol(\"lambda\", positive=True)\n    >>> z = Symbol(\"z\")\n    >>> p = Symbol(\"p\")\n    >>> X = Exponential(\"x\", l)\n\n    >>> density(X)(z)\n    lambda*exp(-lambda*z)\n\n    >>> cdf(X)(z)\n    Piecewise((1 - exp(-lambda*z), z >= 0), (0, True))\n\n    >>> quantile(X)(p)\n    -log(1 - p)/lambda\n\n    >>> E(X)\n    1/lambda\n\n    >>> variance(X)\n    lambda**(-2)\n\n    >>> skewness(X)\n    2\n\n    >>> X = Exponential('x', 10)\n\n    >>> density(X)(z)\n    10*exp(-10*z)\n\n    >>> E(X)\n    1/10\n\n    >>> std(X)\n    1/10\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Exponential_distribution\n    .. [2] https://mathworld.wolfram.com/ExponentialDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "FDistribution",
    "full_id": "sympy.stats.FDistribution",
    "type": "function",
    "description": "\n    Create a continuous random variable with a F distribution.\n\n    Explanation\n    ===========\n\n    The density of the F distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\sqrt{\\frac{(d_1 x)^{d_1} d_2^{d_2}}\n                {(d_1 x + d_2)^{d_1 + d_2}}}}\n                {x \\mathrm{B} \\left(\\frac{d_1}{2}, \\frac{d_2}{2}\\right)}\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    d1 : `d_1 > 0`, where `d_1` is the degrees of freedom (`n_1 - 1`)\n    d2 : `d_2 > 0`, where `d_2` is the degrees of freedom (`n_2 - 1`)\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import FDistribution, density\n    >>> from sympy import Symbol, pprint\n\n    >>> d1 = Symbol(\"d1\", positive=True)\n    >>> d2 = Symbol(\"d2\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = FDistribution(\"x\", d1, d2)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n      d2\n      --    ______________________________\n      2    /       d1            -d1 - d2\n    d2  *\\/  (d1*z)  *(d1*z + d2)\n    --------------------------------------\n                    /d1  d2\\\n                 z*B|--, --|\n                    \\2   2 /\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/F-distribution\n    .. [2] https://mathworld.wolfram.com/F-Distribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "FisherZ",
    "full_id": "sympy.stats.FisherZ",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with an Fisher's Z distribution.\n\n    Explanation\n    ===========\n\n    The density of the Fisher's Z distribution is given by\n\n    .. math::\n        f(x) := \\frac{2d_1^{d_1/2} d_2^{d_2/2}} {\\mathrm{B}(d_1/2, d_2/2)}\n                \\frac{e^{d_1z}}{\\left(d_1e^{2z}+d_2\\right)^{\\left(d_1+d_2\\right)/2}}\n\n\n    .. TODO - What is the difference between these degrees of freedom?\n\n    Parameters\n    ==========\n\n    d1 : `d_1 > 0`\n        Degree of freedom.\n    d2 : `d_2 > 0`\n        Degree of freedom.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import FisherZ, density\n    >>> from sympy import Symbol, pprint\n\n    >>> d1 = Symbol(\"d1\", positive=True)\n    >>> d2 = Symbol(\"d2\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = FisherZ(\"x\", d1, d2)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                                d1   d2\n        d1   d2               - -- - --\n        --   --                 2    2\n        2    2  /    2*z     \\           d1*z\n    2*d1  *d2  *\\d1*e    + d2/         *e\n    -----------------------------------------\n                     /d1  d2\\\n                    B|--, --|\n                     \\2   2 /\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Fisher%27s_z-distribution\n    .. [2] https://mathworld.wolfram.com/Fishersz-Distribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Frechet",
    "full_id": "sympy.stats.Frechet",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Frechet distribution.\n\n    Explanation\n    ===========\n\n    The density of the Frechet distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\alpha}{s} \\left(\\frac{x-m}{s}\\right)^{-1-\\alpha}\n                 e^{-(\\frac{x-m}{s})^{-\\alpha}}\n\n    with :math:`x \\geq m`.\n\n    Parameters\n    ==========\n\n    a : Real number, :math:`a \\in \\left(0, \\infty\\right)` the shape\n    s : Real number, :math:`s \\in \\left(0, \\infty\\right)` the scale\n    m : Real number, :math:`m \\in \\left(-\\infty, \\infty\\right)` the minimum\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Frechet, density, cdf\n    >>> from sympy import Symbol\n\n    >>> a = Symbol(\"a\", positive=True)\n    >>> s = Symbol(\"s\", positive=True)\n    >>> m = Symbol(\"m\", real=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Frechet(\"x\", a, s, m)\n\n    >>> density(X)(z)\n    a*((-m + z)/s)**(-a - 1)*exp(-1/((-m + z)/s)**a)/s\n\n    >>> cdf(X)(z)\n    Piecewise((exp(-1/((-m + z)/s)**a), m <= z), (0, True))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Fr%C3%A9chet_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Gamma",
    "full_id": "sympy.stats.Gamma",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Gamma distribution.\n\n    Explanation\n    ===========\n\n    The density of the Gamma distribution is given by\n\n    .. math::\n        f(x) := \\frac{1}{\\Gamma(k) \\theta^k} x^{k - 1} e^{-\\frac{x}{\\theta}}\n\n    with :math:`x \\in [0,1]`.\n\n    Parameters\n    ==========\n\n    k : Real number, `k > 0`, a shape\n    theta : Real number, `\\theta > 0`, a scale\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Gamma, density, cdf, E, variance\n    >>> from sympy import Symbol, pprint, simplify\n\n    >>> k = Symbol(\"k\", positive=True)\n    >>> theta = Symbol(\"theta\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Gamma(\"x\", k, theta)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                      -z\n                    -----\n         -k  k - 1  theta\n    theta  *z     *e\n    ---------------------\n           Gamma(k)\n\n    >>> C = cdf(X, meijerg=True)(z)\n    >>> pprint(C, use_unicode=False)\n    /            /     z  \\\n    |k*lowergamma|k, -----|\n    |            \\   theta/\n    <----------------------  for z >= 0\n    |     Gamma(k + 1)\n    |\n    \\          0             otherwise\n\n    >>> E(X)\n    k*theta\n\n    >>> V = simplify(variance(X))\n    >>> pprint(V, use_unicode=False)\n           2\n    k*theta\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gamma_distribution\n    .. [2] https://mathworld.wolfram.com/GammaDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "GammaInverse",
    "full_id": "sympy.stats.GammaInverse",
    "type": "function",
    "description": "\n    Create a continuous random variable with an inverse Gamma distribution.\n\n    Explanation\n    ===========\n\n    The density of the inverse Gamma distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} x^{-\\alpha - 1}\n                \\exp\\left(\\frac{-\\beta}{x}\\right)\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    a : Real number, `a > 0`, a shape\n    b : Real number, `b > 0`, a scale\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import GammaInverse, density, cdf\n    >>> from sympy import Symbol, pprint\n\n    >>> a = Symbol(\"a\", positive=True)\n    >>> b = Symbol(\"b\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = GammaInverse(\"x\", a, b)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                -b\n                ---\n     a  -a - 1   z\n    b *z      *e\n    ---------------\n       Gamma(a)\n\n    >>> cdf(X)(z)\n    Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Inverse-gamma_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Gompertz",
    "full_id": "sympy.stats.Gompertz",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with Gompertz distribution.\n\n    Explanation\n    ===========\n\n    The density of the Gompertz distribution is given by\n\n    .. math::\n        f(x) := b \\eta e^{b x} e^{\\eta} \\exp \\left(-\\eta e^{bx} \\right)\n\n    with :math:`x \\in [0, \\infty)`.\n\n    Parameters\n    ==========\n\n    b : Real number, `b > 0`, a scale\n    eta : Real number, `\\eta > 0`, a shape\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Gompertz, density\n    >>> from sympy import Symbol\n\n    >>> b = Symbol(\"b\", positive=True)\n    >>> eta = Symbol(\"eta\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Gompertz(\"x\", b, eta)\n\n    >>> density(X)(z)\n    b*eta*exp(eta)*exp(b*z)*exp(-eta*exp(b*z))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Gompertz_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Gumbel",
    "full_id": "sympy.stats.Gumbel",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with Gumbel distribution.\n\n    Explanation\n    ===========\n\n    The density of the Gumbel distribution is given by\n\n    For Maximum\n\n    .. math::\n        f(x) := \\dfrac{1}{\\beta} \\exp \\left( -\\dfrac{x-\\mu}{\\beta}\n                - \\exp \\left( -\\dfrac{x - \\mu}{\\beta} \\right) \\right)\n\n    with :math:`x \\in [ - \\infty, \\infty ]`.\n\n    For Minimum\n\n    .. math::\n        f(x) := \\frac{e^{- e^{\\frac{- \\mu + x}{\\beta}} + \\frac{- \\mu + x}{\\beta}}}{\\beta}\n\n    with :math:`x \\in [ - \\infty, \\infty ]`.\n\n    Parameters\n    ==========\n\n    mu : Real number, `\\mu`, a location\n    beta : Real number, `\\beta > 0`, a scale\n    minimum : Boolean, by default ``False``, set to ``True`` for enabling minimum distribution\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Gumbel, density, cdf\n    >>> from sympy import Symbol\n    >>> x = Symbol(\"x\")\n    >>> mu = Symbol(\"mu\")\n    >>> beta = Symbol(\"beta\", positive=True)\n    >>> X = Gumbel(\"x\", beta, mu)\n    >>> density(X)(x)\n    exp(-exp(-(-mu + x)/beta) - (-mu + x)/beta)/beta\n    >>> cdf(X)(x)\n    exp(-exp(-(-mu + x)/beta))\n\n    References\n    ==========\n\n    .. [1] https://mathworld.wolfram.com/GumbelDistribution.html\n    .. [2] https://en.wikipedia.org/wiki/Gumbel_distribution\n    .. [3] https://web.archive.org/web/20200628222206/http://www.mathwave.com/help/easyfit/html/analyses/distributions/gumbel_max.html\n    .. [4] https://web.archive.org/web/20200628222212/http://www.mathwave.com/help/easyfit/html/analyses/distributions/gumbel_min.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Kumaraswamy",
    "full_id": "sympy.stats.Kumaraswamy",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with a Kumaraswamy distribution.\n\n    Explanation\n    ===========\n\n    The density of the Kumaraswamy distribution is given by\n\n    .. math::\n        f(x) := a b x^{a-1} (1-x^a)^{b-1}\n\n    with :math:`x \\in [0,1]`.\n\n    Parameters\n    ==========\n\n    a : Real number, `a > 0`, a shape\n    b : Real number, `b > 0`, a shape\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Kumaraswamy, density, cdf\n    >>> from sympy import Symbol, pprint\n\n    >>> a = Symbol(\"a\", positive=True)\n    >>> b = Symbol(\"b\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Kumaraswamy(\"x\", a, b)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                       b - 1\n         a - 1 /     a\\\n    a*b*z     *\\1 - z /\n\n    >>> cdf(X)(z)\n    Piecewise((0, z < 0), (1 - (1 - z**a)**b, z <= 1), (1, True))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Kumaraswamy_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Laplace",
    "full_id": "sympy.stats.Laplace",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Laplace distribution.\n\n    Explanation\n    ===========\n\n    The density of the Laplace distribution is given by\n\n    .. math::\n        f(x) := \\frac{1}{2 b} \\exp \\left(-\\frac{|x-\\mu|}b \\right)\n\n    Parameters\n    ==========\n\n    mu : Real number or a list/matrix, the location (mean) or the\n        location vector\n    b : Real number or a positive definite matrix, representing a scale\n        or the covariance matrix.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Laplace, density, cdf\n    >>> from sympy import Symbol, pprint\n\n    >>> mu = Symbol(\"mu\")\n    >>> b = Symbol(\"b\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Laplace(\"x\", mu, b)\n\n    >>> density(X)(z)\n    exp(-Abs(mu - z)/b)/(2*b)\n\n    >>> cdf(X)(z)\n    Piecewise((exp((-mu + z)/b)/2, mu > z), (1 - exp((mu - z)/b)/2, True))\n\n    >>> L = Laplace('L', [1, 2], [[1, 0], [0, 1]])\n    >>> pprint(density(L)(1, 2), use_unicode=False)\n     5        /     ____\\\n    e *besselk\\0, \\/ 35 /\n    ---------------------\n              pi\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Laplace_distribution\n    .. [2] https://mathworld.wolfram.com/LaplaceDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Levy",
    "full_id": "sympy.stats.Levy",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Levy distribution.\n\n    The density of the Levy distribution is given by\n\n    .. math::\n        f(x) := \\sqrt(\\frac{c}{2 \\pi}) \\frac{\\exp -\\frac{c}{2 (x - \\mu)}}{(x - \\mu)^{3/2}}\n\n    Parameters\n    ==========\n\n    mu : Real number\n        The location parameter.\n    c : Real number, `c > 0`\n        A scale parameter.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Levy, density, cdf\n    >>> from sympy import Symbol\n\n    >>> mu = Symbol(\"mu\", real=True)\n    >>> c = Symbol(\"c\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Levy(\"x\", mu, c)\n\n    >>> density(X)(z)\n    sqrt(2)*sqrt(c)*exp(-c/(-2*mu + 2*z))/(2*sqrt(pi)*(-mu + z)**(3/2))\n\n    >>> cdf(X)(z)\n    erfc(sqrt(c)*sqrt(1/(-2*mu + 2*z)))\n\n    References\n    ==========\n    .. [1] https://en.wikipedia.org/wiki/L%C3%A9vy_distribution\n    .. [2] https://mathworld.wolfram.com/LevyDistribution.html\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Logistic",
    "full_id": "sympy.stats.Logistic",
    "type": "function",
    "description": "\n    Create a continuous random variable with a logistic distribution.\n\n    Explanation\n    ===========\n\n    The density of the logistic distribution is given by\n\n    .. math::\n        f(x) := \\frac{e^{-(x-\\mu)/s}} {s\\left(1+e^{-(x-\\mu)/s}\\right)^2}\n\n    Parameters\n    ==========\n\n    mu : Real number, the location (mean)\n    s : Real number, `s > 0`, a scale\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Logistic, density, cdf\n    >>> from sympy import Symbol\n\n    >>> mu = Symbol(\"mu\", real=True)\n    >>> s = Symbol(\"s\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Logistic(\"x\", mu, s)\n\n    >>> density(X)(z)\n    exp((mu - z)/s)/(s*(exp((mu - z)/s) + 1)**2)\n\n    >>> cdf(X)(z)\n    1/(exp((mu - z)/s) + 1)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Logistic_distribution\n    .. [2] https://mathworld.wolfram.com/LogisticDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "LogLogistic",
    "full_id": "sympy.stats.LogLogistic",
    "type": "function",
    "description": "\n    Create a continuous random variable with a log-logistic distribution.\n    The distribution is unimodal when ``beta > 1``.\n\n    Explanation\n    ===========\n\n    The density of the log-logistic distribution is given by\n\n    .. math::\n        f(x) := \\frac{(\\frac{\\beta}{\\alpha})(\\frac{x}{\\alpha})^{\\beta - 1}}\n                {(1 + (\\frac{x}{\\alpha})^{\\beta})^2}\n\n    Parameters\n    ==========\n\n    alpha : Real number, `\\alpha > 0`, scale parameter and median of distribution\n    beta : Real number, `\\beta > 0`, a shape parameter\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import LogLogistic, density, cdf, quantile\n    >>> from sympy import Symbol, pprint\n\n    >>> alpha = Symbol(\"alpha\", positive=True)\n    >>> beta = Symbol(\"beta\", positive=True)\n    >>> p = Symbol(\"p\")\n    >>> z = Symbol(\"z\", positive=True)\n\n    >>> X = LogLogistic(\"x\", alpha, beta)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                  beta - 1\n           /  z  \\\n      beta*|-----|\n           \\alpha/\n    ------------------------\n                           2\n          /       beta    \\\n          |/  z  \\        |\n    alpha*||-----|     + 1|\n          \\\\alpha/        /\n\n    >>> cdf(X)(z)\n    1/(1 + (z/alpha)**(-beta))\n\n    >>> quantile(X)(p)\n    alpha*(p/(1 - p))**(1/beta)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Log-logistic_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "LogNormal",
    "full_id": "sympy.stats.LogNormal",
    "type": "function",
    "description": "\n    Create a continuous random variable with a log-normal distribution.\n\n    Explanation\n    ===========\n\n    The density of the log-normal distribution is given by\n\n    .. math::\n        f(x) := \\frac{1}{x\\sqrt{2\\pi\\sigma^2}}\n                e^{-\\frac{\\left(\\ln x-\\mu\\right)^2}{2\\sigma^2}}\n\n    with :math:`x \\geq 0`.\n\n    Parameters\n    ==========\n\n    mu : Real number\n        The log-scale.\n    sigma : Real number\n        A shape. ($\\sigma^2 > 0$)\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import LogNormal, density\n    >>> from sympy import Symbol, pprint\n\n    >>> mu = Symbol(\"mu\", real=True)\n    >>> sigma = Symbol(\"sigma\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = LogNormal(\"x\", mu, sigma)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                          2\n           -(-mu + log(z))\n           -----------------\n                      2\n      ___      2*sigma\n    \\/ 2 *e\n    ------------------------\n            ____\n        2*\\/ pi *sigma*z\n\n\n    >>> X = LogNormal('x', 0, 1) # Mean 0, standard deviation 1\n\n    >>> density(X)(z)\n    sqrt(2)*exp(-log(z)**2/2)/(2*sqrt(pi)*z)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Lognormal\n    .. [2] https://mathworld.wolfram.com/LogNormalDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Lomax",
    "full_id": "sympy.stats.Lomax",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Lomax distribution.\n\n    Explanation\n    ===========\n\n    The density of the Lomax distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\alpha}{\\lambda}\\left[1+\\frac{x}{\\lambda}\\right]^{-(\\alpha+1)}\n\n    Parameters\n    ==========\n\n    alpha : Real Number, `\\alpha > 0`\n        Shape parameter\n    lamda : Real Number, `\\lambda > 0`\n        Scale parameter\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Lomax, density, cdf, E\n    >>> from sympy import symbols\n    >>> a, l = symbols('a, l', positive=True)\n    >>> X = Lomax('X', a, l)\n    >>> x = symbols('x')\n    >>> density(X)(x)\n    a*(1 + x/l)**(-a - 1)/l\n    >>> cdf(X)(x)\n    Piecewise((1 - 1/(1 + x/l)**a, x >= 0), (0, True))\n    >>> a = 2\n    >>> X = Lomax('X', a, l)\n    >>> E(X)\n    l\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Lomax_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Maxwell",
    "full_id": "sympy.stats.Maxwell",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Maxwell distribution.\n\n    Explanation\n    ===========\n\n    The density of the Maxwell distribution is given by\n\n    .. math::\n        f(x) := \\sqrt{\\frac{2}{\\pi}} \\frac{x^2 e^{-x^2/(2a^2)}}{a^3}\n\n    with :math:`x \\geq 0`.\n\n    .. TODO - what does the parameter mean?\n\n    Parameters\n    ==========\n\n    a : Real number, `a > 0`\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Maxwell, density, E, variance\n    >>> from sympy import Symbol, simplify\n\n    >>> a = Symbol(\"a\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Maxwell(\"x\", a)\n\n    >>> density(X)(z)\n    sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3)\n\n    >>> E(X)\n    2*sqrt(2)*a/sqrt(pi)\n\n    >>> simplify(variance(X))\n    a**2*(-8 + 3*pi)/pi\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Maxwell_distribution\n    .. [2] https://mathworld.wolfram.com/MaxwellDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Moyal",
    "full_id": "sympy.stats.Moyal",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Moyal distribution.\n\n    Explanation\n    ===========\n\n    The density of the Moyal distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\exp-\\frac{1}{2}\\exp-\\frac{x-\\mu}{\\sigma}-\\frac{x-\\mu}{2\\sigma}}{\\sqrt{2\\pi}\\sigma}\n\n    with :math:`x \\in \\mathbb{R}`.\n\n    Parameters\n    ==========\n\n    mu : Real number\n        Location parameter\n    sigma : Real positive number\n        Scale parameter\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Moyal, density, cdf\n    >>> from sympy import Symbol, simplify\n    >>> mu = Symbol(\"mu\", real=True)\n    >>> sigma = Symbol(\"sigma\", positive=True, real=True)\n    >>> z = Symbol(\"z\")\n    >>> X = Moyal(\"x\", mu, sigma)\n    >>> density(X)(z)\n    sqrt(2)*exp(-exp((mu - z)/sigma)/2 - (-mu + z)/(2*sigma))/(2*sqrt(pi)*sigma)\n    >>> simplify(cdf(X)(z))\n    1 - erf(sqrt(2)*exp((mu - z)/(2*sigma))/2)\n\n    References\n    ==========\n\n    .. [1] https://reference.wolfram.com/language/ref/MoyalDistribution.html\n    .. [2] https://www.stat.rice.edu/~dobelman/textfiles/DistributionsHandbook.pdf\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Nakagami",
    "full_id": "sympy.stats.Nakagami",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Nakagami distribution.\n\n    Explanation\n    ===========\n\n    The density of the Nakagami distribution is given by\n\n    .. math::\n        f(x) := \\frac{2\\mu^\\mu}{\\Gamma(\\mu)\\omega^\\mu} x^{2\\mu-1}\n                \\exp\\left(-\\frac{\\mu}{\\omega}x^2 \\right)\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    mu : Real number, `\\mu \\geq \\frac{1}{2}`, a shape\n    omega : Real number, `\\omega > 0`, the spread\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Nakagami, density, E, variance, cdf\n    >>> from sympy import Symbol, simplify, pprint\n\n    >>> mu = Symbol(\"mu\", positive=True)\n    >>> omega = Symbol(\"omega\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Nakagami(\"x\", mu, omega)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                                    2\n                               -mu*z\n                               -------\n        mu      -mu  2*mu - 1  omega\n    2*mu  *omega   *z        *e\n    ----------------------------------\n                Gamma(mu)\n\n    >>> simplify(E(X))\n    sqrt(mu)*sqrt(omega)*gamma(mu + 1/2)/gamma(mu + 1)\n\n    >>> V = simplify(variance(X))\n    >>> pprint(V, use_unicode=False)\n                        2\n             omega*Gamma (mu + 1/2)\n    omega - -----------------------\n            Gamma(mu)*Gamma(mu + 1)\n\n    >>> cdf(X)(z)\n    Piecewise((lowergamma(mu, mu*z**2/omega)/gamma(mu), z > 0),\n            (0, True))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Nakagami_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Normal",
    "full_id": "sympy.stats.Normal",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Normal distribution.\n\n    Explanation\n    ===========\n\n    The density of the Normal distribution is given by\n\n    .. math::\n        f(x) := \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{ -\\frac{(x-\\mu)^2}{2\\sigma^2} }\n\n    Parameters\n    ==========\n\n    mu : Real number or a list representing the mean or the mean vector\n    sigma : Real number or a positive definite square matrix,\n         :math:`\\sigma^2 > 0`, the variance\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Normal, density, E, std, cdf, skewness, quantile, marginal_distribution\n    >>> from sympy import Symbol, simplify, pprint\n\n    >>> mu = Symbol(\"mu\")\n    >>> sigma = Symbol(\"sigma\", positive=True)\n    >>> z = Symbol(\"z\")\n    >>> y = Symbol(\"y\")\n    >>> p = Symbol(\"p\")\n    >>> X = Normal(\"x\", mu, sigma)\n\n    >>> density(X)(z)\n    sqrt(2)*exp(-(-mu + z)**2/(2*sigma**2))/(2*sqrt(pi)*sigma)\n\n    >>> C = simplify(cdf(X))(z) # it needs a little more help...\n    >>> pprint(C, use_unicode=False)\n       /  ___          \\\n       |\\/ 2 *(-mu + z)|\n    erf|---------------|\n       \\    2*sigma    /   1\n    -------------------- + -\n             2             2\n\n    >>> quantile(X)(p)\n    mu + sqrt(2)*sigma*erfinv(2*p - 1)\n\n    >>> simplify(skewness(X))\n    0\n\n    >>> X = Normal(\"x\", 0, 1) # Mean 0, standard deviation 1\n    >>> density(X)(z)\n    sqrt(2)*exp(-z**2/2)/(2*sqrt(pi))\n\n    >>> E(2*X + 1)\n    1\n\n    >>> simplify(std(2*X + 1))\n    2\n\n    >>> m = Normal('X', [1, 2], [[2, 1], [1, 2]])\n    >>> pprint(density(m)(y, z), use_unicode=False)\n              2          2\n             y    y*z   z\n           - -- + --- - -- + z - 1\n      ___    3     3    3\n    \\/ 3 *e\n    ------------------------------\n                 6*pi\n\n    >>> marginal_distribution(m, m[0])(1)\n     1/(2*sqrt(pi))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Normal_distribution\n    .. [2] https://mathworld.wolfram.com/NormalDistributionFunction.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Pareto",
    "full_id": "sympy.stats.Pareto",
    "type": "function",
    "description": "\n    Create a continuous random variable with the Pareto distribution.\n\n    Explanation\n    ===========\n\n    The density of the Pareto distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\alpha\\,x_m^\\alpha}{x^{\\alpha+1}}\n\n    with :math:`x \\in [x_m,\\infty]`.\n\n    Parameters\n    ==========\n\n    xm : Real number, `x_m > 0`, a scale\n    alpha : Real number, `\\alpha > 0`, a shape\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Pareto, density\n    >>> from sympy import Symbol\n\n    >>> xm = Symbol(\"xm\", positive=True)\n    >>> beta = Symbol(\"beta\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Pareto(\"x\", xm, beta)\n\n    >>> density(X)(z)\n    beta*xm**beta*z**(-beta - 1)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Pareto_distribution\n    .. [2] https://mathworld.wolfram.com/ParetoDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "PowerFunction",
    "full_id": "sympy.stats.PowerFunction",
    "type": "function",
    "description": "\n    Creates a continuous random variable with a Power Function Distribution.\n\n    Explanation\n    ===========\n\n    The density of PowerFunction distribution is given by\n\n    .. math::\n        f(x) := \\frac{{\\alpha}(x - a)^{\\alpha - 1}}{(b - a)^{\\alpha}}\n\n    with :math:`x \\in [a,b]`.\n\n    Parameters\n    ==========\n\n    alpha : Positive number, `0 < \\alpha`, the shape parameter\n    a : Real number, :math:`-\\infty < a`, the left boundary\n    b : Real number, :math:`a < b < \\infty`, the right boundary\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import PowerFunction, density, cdf, E, variance\n    >>> from sympy import Symbol\n    >>> alpha = Symbol(\"alpha\", positive=True)\n    >>> a = Symbol(\"a\", real=True)\n    >>> b = Symbol(\"b\", real=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = PowerFunction(\"X\", 2, a, b)\n\n    >>> density(X)(z)\n    (-2*a + 2*z)/(-a + b)**2\n\n    >>> cdf(X)(z)\n    Piecewise((a**2/(a**2 - 2*a*b + b**2) - 2*a*z/(a**2 - 2*a*b + b**2) +\n    z**2/(a**2 - 2*a*b + b**2), a <= z), (0, True))\n\n    >>> alpha = 2\n    >>> a = 0\n    >>> b = 1\n    >>> Y = PowerFunction(\"Y\", alpha, a, b)\n\n    >>> E(Y)\n    2/3\n\n    >>> variance(Y)\n    1/18\n\n    References\n    ==========\n\n    .. [1] https://web.archive.org/web/20200204081320/http://www.mathwave.com/help/easyfit/html/analyses/distributions/power_func.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "QuadraticU",
    "full_id": "sympy.stats.QuadraticU",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with a U-quadratic distribution.\n\n    Explanation\n    ===========\n\n    The density of the U-quadratic distribution is given by\n\n    .. math::\n        f(x) := \\alpha (x-\\beta)^2\n\n    with :math:`x \\in [a,b]`.\n\n    Parameters\n    ==========\n\n    a : Real number\n    b : Real number, :math:`a < b`\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import QuadraticU, density\n    >>> from sympy import Symbol, pprint\n\n    >>> a = Symbol(\"a\", real=True)\n    >>> b = Symbol(\"b\", real=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = QuadraticU(\"x\", a, b)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n    /                2\n    |   /  a   b    \\\n    |12*|- - - - + z|\n    |   \\  2   2    /\n    <-----------------  for And(b >= z, a <= z)\n    |            3\n    |    (-a + b)\n    |\n    \\        0                 otherwise\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/U-quadratic_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "RaisedCosine",
    "full_id": "sympy.stats.RaisedCosine",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with a raised cosine distribution.\n\n    Explanation\n    ===========\n\n    The density of the raised cosine distribution is given by\n\n    .. math::\n        f(x) := \\frac{1}{2s}\\left(1+\\cos\\left(\\frac{x-\\mu}{s}\\pi\\right)\\right)\n\n    with :math:`x \\in [\\mu-s,\\mu+s]`.\n\n    Parameters\n    ==========\n\n    mu : Real number\n    s : Real number, `s > 0`\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import RaisedCosine, density\n    >>> from sympy import Symbol, pprint\n\n    >>> mu = Symbol(\"mu\", real=True)\n    >>> s = Symbol(\"s\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = RaisedCosine(\"x\", mu, s)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n    /   /pi*(-mu + z)\\\n    |cos|------------| + 1\n    |   \\     s      /\n    <---------------------  for And(z >= mu - s, z <= mu + s)\n    |         2*s\n    |\n    \\          0                        otherwise\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Raised_cosine_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Rayleigh",
    "full_id": "sympy.stats.Rayleigh",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Rayleigh distribution.\n\n    Explanation\n    ===========\n\n    The density of the Rayleigh distribution is given by\n\n    .. math ::\n        f(x) := \\frac{x}{\\sigma^2} e^{-x^2/2\\sigma^2}\n\n    with :math:`x > 0`.\n\n    Parameters\n    ==========\n\n    sigma : Real number, `\\sigma > 0`\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Rayleigh, density, E, variance\n    >>> from sympy import Symbol\n\n    >>> sigma = Symbol(\"sigma\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Rayleigh(\"x\", sigma)\n\n    >>> density(X)(z)\n    z*exp(-z**2/(2*sigma**2))/sigma**2\n\n    >>> E(X)\n    sqrt(2)*sqrt(pi)*sigma/2\n\n    >>> variance(X)\n    -pi*sigma**2/2 + 2*sigma**2\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Rayleigh_distribution\n    .. [2] https://mathworld.wolfram.com/RayleighDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Reciprocal",
    "full_id": "sympy.stats.Reciprocal",
    "type": "function",
    "description": "Creates a continuous random variable with a reciprocal distribution.\n\n\n    Parameters\n    ==========\n\n    a : Real number, :math:`0 < a`\n    b : Real number, :math:`a < b`\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Reciprocal, density, cdf\n    >>> from sympy import symbols\n    >>> a, b, x = symbols('a, b, x', positive=True)\n    >>> R = Reciprocal('R', a, b)\n\n    >>> density(R)(x)\n    1/(x*(-log(a) + log(b)))\n    >>> cdf(R)(x)\n    Piecewise((log(a)/(log(a) - log(b)) - log(x)/(log(a) - log(b)), a <= x), (0, True))\n\n    Reference\n    =========\n\n    .. [1] https://en.wikipedia.org/wiki/Reciprocal_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "StudentT",
    "full_id": "sympy.stats.StudentT",
    "type": "function",
    "description": "\n    Create a continuous random variable with a student's t distribution.\n\n    Explanation\n    ===========\n\n    The density of the student's t distribution is given by\n\n    .. math::\n        f(x) := \\frac{\\Gamma \\left(\\frac{\\nu+1}{2} \\right)}\n                {\\sqrt{\\nu\\pi}\\Gamma \\left(\\frac{\\nu}{2} \\right)}\n                \\left(1+\\frac{x^2}{\\nu} \\right)^{-\\frac{\\nu+1}{2}}\n\n    Parameters\n    ==========\n\n    nu : Real number, `\\nu > 0`, the degrees of freedom\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import StudentT, density, cdf\n    >>> from sympy import Symbol, pprint\n\n    >>> nu = Symbol(\"nu\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = StudentT(\"x\", nu)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n               nu   1\n             - -- - -\n               2    2\n     /     2\\\n     |    z |\n     |1 + --|\n     \\    nu/\n    -----------------\n      ____  /     nu\\\n    \\/ nu *B|1/2, --|\n            \\     2 /\n\n    >>> cdf(X)(z)\n    1/2 + z*gamma(nu/2 + 1/2)*hyper((1/2, nu/2 + 1/2), (3/2,),\n                                -z**2/nu)/(sqrt(pi)*sqrt(nu)*gamma(nu/2))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Student_t-distribution\n    .. [2] https://mathworld.wolfram.com/Studentst-Distribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "ShiftedGompertz",
    "full_id": "sympy.stats.ShiftedGompertz",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Shifted Gompertz distribution.\n\n    Explanation\n    ===========\n\n    The density of the Shifted Gompertz distribution is given by\n\n    .. math::\n        f(x) := b e^{-b x} e^{-\\eta \\exp(-b x)} \\left[1 + \\eta(1 - e^(-bx)) \\right]\n\n    with :math:`x \\in [0, \\infty)`.\n\n    Parameters\n    ==========\n\n    b : Real number, `b > 0`, a scale\n    eta : Real number, `\\eta > 0`, a shape\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n    >>> from sympy.stats import ShiftedGompertz, density\n    >>> from sympy import Symbol\n\n    >>> b = Symbol(\"b\", positive=True)\n    >>> eta = Symbol(\"eta\", positive=True)\n    >>> x = Symbol(\"x\")\n\n    >>> X = ShiftedGompertz(\"x\", b, eta)\n\n    >>> density(X)(x)\n    b*(eta*(1 - exp(-b*x)) + 1)*exp(-b*x)*exp(-eta*exp(-b*x))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Shifted_Gompertz_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Trapezoidal",
    "full_id": "sympy.stats.Trapezoidal",
    "type": "function",
    "description": "\n    Create a continuous random variable with a trapezoidal distribution.\n\n    Explanation\n    ===========\n\n    The density of the trapezoidal distribution is given by\n\n    .. math::\n        f(x) := \\begin{cases}\n                  0 & \\mathrm{for\\ } x < a, \\\\\n                  \\frac{2(x-a)}{(b-a)(d+c-a-b)} & \\mathrm{for\\ } a \\le x < b, \\\\\n                  \\frac{2}{d+c-a-b} & \\mathrm{for\\ } b \\le x < c, \\\\\n                  \\frac{2(d-x)}{(d-c)(d+c-a-b)} & \\mathrm{for\\ } c \\le x < d, \\\\\n                  0 & \\mathrm{for\\ } d < x.\n                \\end{cases}\n\n    Parameters\n    ==========\n\n    a : Real number, :math:`a < d`\n    b : Real number, :math:`a \\le b < c`\n    c : Real number, :math:`b < c \\le d`\n    d : Real number\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Trapezoidal, density\n    >>> from sympy import Symbol, pprint\n\n    >>> a = Symbol(\"a\")\n    >>> b = Symbol(\"b\")\n    >>> c = Symbol(\"c\")\n    >>> d = Symbol(\"d\")\n    >>> z = Symbol(\"z\")\n\n    >>> X = Trapezoidal(\"x\", a,b,c,d)\n\n    >>> pprint(density(X)(z), use_unicode=False)\n    /        -2*a + 2*z\n    |-------------------------  for And(a <= z, b > z)\n    |(-a + b)*(-a - b + c + d)\n    |\n    |           2\n    |     --------------        for And(b <= z, c > z)\n    <     -a - b + c + d\n    |\n    |        2*d - 2*z\n    |-------------------------  for And(d >= z, c <= z)\n    |(-c + d)*(-a - b + c + d)\n    |\n    \\            0                     otherwise\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Trapezoidal_distribution\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Triangular",
    "full_id": "sympy.stats.Triangular",
    "type": "function",
    "description": "\n    Create a continuous random variable with a triangular distribution.\n\n    Explanation\n    ===========\n\n    The density of the triangular distribution is given by\n\n    .. math::\n        f(x) := \\begin{cases}\n                  0 & \\mathrm{for\\ } x < a, \\\\\n                  \\frac{2(x-a)}{(b-a)(c-a)} & \\mathrm{for\\ } a \\le x < c, \\\\\n                  \\frac{2}{b-a} & \\mathrm{for\\ } x = c, \\\\\n                  \\frac{2(b-x)}{(b-a)(b-c)} & \\mathrm{for\\ } c < x \\le b, \\\\\n                  0 & \\mathrm{for\\ } b < x.\n                \\end{cases}\n\n    Parameters\n    ==========\n\n    a : Real number, :math:`a \\in \\left(-\\infty, \\infty\\right)`\n    b : Real number, :math:`a < b`\n    c : Real number, :math:`a \\leq c \\leq b`\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Triangular, density\n    >>> from sympy import Symbol, pprint\n\n    >>> a = Symbol(\"a\")\n    >>> b = Symbol(\"b\")\n    >>> c = Symbol(\"c\")\n    >>> z = Symbol(\"z\")\n\n    >>> X = Triangular(\"x\", a,b,c)\n\n    >>> pprint(density(X)(z), use_unicode=False)\n    /    -2*a + 2*z\n    |-----------------  for And(a <= z, c > z)\n    |(-a + b)*(-a + c)\n    |\n    |       2\n    |     ------              for c = z\n    <     -a + b\n    |\n    |   2*b - 2*z\n    |----------------   for And(b >= z, c < z)\n    |(-a + b)*(b - c)\n    |\n    \\        0                otherwise\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Triangular_distribution\n    .. [2] https://mathworld.wolfram.com/TriangularDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Uniform",
    "full_id": "sympy.stats.Uniform",
    "type": "function",
    "description": "\n    Create a continuous random variable with a uniform distribution.\n\n    Explanation\n    ===========\n\n    The density of the uniform distribution is given by\n\n    .. math::\n        f(x) := \\begin{cases}\n                  \\frac{1}{b - a} & \\text{for } x \\in [a,b]  \\\\\n                  0               & \\text{otherwise}\n                \\end{cases}\n\n    with :math:`x \\in [a,b]`.\n\n    Parameters\n    ==========\n\n    a : Real number, :math:`-\\infty < a`, the left boundary\n    b : Real number, :math:`a < b < \\infty`, the right boundary\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Uniform, density, cdf, E, variance\n    >>> from sympy import Symbol, simplify\n\n    >>> a = Symbol(\"a\", negative=True)\n    >>> b = Symbol(\"b\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Uniform(\"x\", a, b)\n\n    >>> density(X)(z)\n    Piecewise((1/(-a + b), (b >= z) & (a <= z)), (0, True))\n\n    >>> cdf(X)(z)\n    Piecewise((0, a > z), ((-a + z)/(-a + b), b >= z), (1, True))\n\n    >>> E(X)\n    a/2 + b/2\n\n    >>> simplify(variance(X))\n    a**2/12 - a*b/6 + b**2/12\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Uniform_distribution_%28continuous%29\n    .. [2] https://mathworld.wolfram.com/UniformDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "UniformSum",
    "full_id": "sympy.stats.UniformSum",
    "type": "function",
    "description": "\n    Create a continuous random variable with an Irwin-Hall distribution.\n\n    Explanation\n    ===========\n\n    The probability distribution function depends on a single parameter\n    $n$ which is an integer.\n\n    The density of the Irwin-Hall distribution is given by\n\n    .. math ::\n        f(x) := \\frac{1}{(n-1)!}\\sum_{k=0}^{\\left\\lfloor x\\right\\rfloor}(-1)^k\n                \\binom{n}{k}(x-k)^{n-1}\n\n    Parameters\n    ==========\n\n    n : A positive integer, `n > 0`\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import UniformSum, density, cdf\n    >>> from sympy import Symbol, pprint\n\n    >>> n = Symbol(\"n\", integer=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = UniformSum(\"x\", n)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n    floor(z)\n      ___\n      \\  `\n       \\         k         n - 1 /n\\\n        )    (-1) *(-k + z)     *| |\n       /                         \\k/\n      /__,\n     k = 0\n    --------------------------------\n                (n - 1)!\n\n    >>> cdf(X)(z)\n    Piecewise((0, z < 0), (Sum((-1)**_k*(-_k + z)**n*binomial(n, _k),\n                    (_k, 0, floor(z)))/factorial(n), n >= z), (1, True))\n\n\n    Compute cdf with specific 'x' and 'n' values as follows :\n    >>> cdf(UniformSum(\"x\", 5), evaluate=False)(2).doit()\n    9/40\n\n    The argument evaluate=False prevents an attempt at evaluation\n    of the sum for general n, before the argument 2 is passed.\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Uniform_sum_distribution\n    .. [2] https://mathworld.wolfram.com/UniformSumDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "VonMises",
    "full_id": "sympy.stats.VonMises",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable with a von Mises distribution.\n\n    Explanation\n    ===========\n\n    The density of the von Mises distribution is given by\n\n    .. math::\n        f(x) := \\frac{e^{\\kappa\\cos(x-\\mu)}}{2\\pi I_0(\\kappa)}\n\n    with :math:`x \\in [0,2\\pi]`.\n\n    Parameters\n    ==========\n\n    mu : Real number\n        Measure of location.\n    k : Real number\n        Measure of concentration.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import VonMises, density\n    >>> from sympy import Symbol, pprint\n\n    >>> mu = Symbol(\"mu\")\n    >>> k = Symbol(\"k\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = VonMises(\"x\", mu, k)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n         k*cos(mu - z)\n        e\n    ------------------\n    2*pi*besseli(0, k)\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Von_Mises_distribution\n    .. [2] https://mathworld.wolfram.com/vonMisesDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Wald",
    "full_id": "sympy.stats.Wald",
    "type": "function",
    "description": "\n    Create a continuous random variable with an Inverse Gaussian distribution.\n    Inverse Gaussian distribution is also known as Wald distribution.\n\n    Explanation\n    ===========\n\n    The density of the Inverse Gaussian distribution is given by\n\n    .. math::\n        f(x) := \\sqrt{\\frac{\\lambda}{2\\pi x^3}} e^{-\\frac{\\lambda(x-\\mu)^2}{2x\\mu^2}}\n\n    Parameters\n    ==========\n\n    mu :\n        Positive number representing the mean.\n    lambda :\n        Positive number representing the shape parameter.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import GaussianInverse, density, E, std, skewness\n    >>> from sympy import Symbol, pprint\n\n    >>> mu = Symbol(\"mu\", positive=True)\n    >>> lamda = Symbol(\"lambda\", positive=True)\n    >>> z = Symbol(\"z\", positive=True)\n    >>> X = GaussianInverse(\"x\", mu, lamda)\n\n    >>> D = density(X)(z)\n    >>> pprint(D, use_unicode=False)\n                                       2\n                      -lambda*(-mu + z)\n                      -------------------\n                                2\n      ___   ________        2*mu *z\n    \\/ 2 *\\/ lambda *e\n    -------------------------------------\n                    ____  3/2\n                2*\\/ pi *z\n\n    >>> E(X)\n    mu\n\n    >>> std(X).expand()\n    mu**(3/2)/sqrt(lambda)\n\n    >>> skewness(X).expand()\n    3*sqrt(mu)/sqrt(lambda)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution\n    .. [2] https://mathworld.wolfram.com/InverseGaussianDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Weibull",
    "full_id": "sympy.stats.Weibull",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Weibull distribution.\n\n    Explanation\n    ===========\n\n    The density of the Weibull distribution is given by\n\n    .. math::\n        f(x) := \\begin{cases}\n                  \\frac{k}{\\lambda}\\left(\\frac{x}{\\lambda}\\right)^{k-1}\n                  e^{-(x/\\lambda)^{k}} & x\\geq0\\\\\n                  0 & x<0\n                \\end{cases}\n\n    Parameters\n    ==========\n\n    lambda : Real number, $\\lambda > 0$, a scale\n    k : Real number, $k > 0$, a shape\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Weibull, density, E, variance\n    >>> from sympy import Symbol, simplify\n\n    >>> l = Symbol(\"lambda\", positive=True)\n    >>> k = Symbol(\"k\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = Weibull(\"x\", l, k)\n\n    >>> density(X)(z)\n    k*(z/lambda)**(k - 1)*exp(-(z/lambda)**k)/lambda\n\n    >>> simplify(E(X))\n    lambda*gamma(1 + 1/k)\n\n    >>> simplify(variance(X))\n    lambda**2*(-gamma(1 + 1/k)**2 + gamma(1 + 2/k))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Weibull_distribution\n    .. [2] https://mathworld.wolfram.com/WeibullDistribution.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "WignerSemicircle",
    "full_id": "sympy.stats.WignerSemicircle",
    "type": "function",
    "description": "\n    Create a continuous random variable with a Wigner semicircle distribution.\n\n    Explanation\n    ===========\n\n    The density of the Wigner semicircle distribution is given by\n\n    .. math::\n        f(x) := \\frac2{\\pi R^2}\\,\\sqrt{R^2-x^2}\n\n    with :math:`x \\in [-R,R]`.\n\n    Parameters\n    ==========\n\n    R : Real number, `R > 0`, the radius\n\n    Returns\n    =======\n\n    A RandomSymbol.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import WignerSemicircle, density, E\n    >>> from sympy import Symbol\n\n    >>> R = Symbol(\"R\", positive=True)\n    >>> z = Symbol(\"z\")\n\n    >>> X = WignerSemicircle(\"x\", R)\n\n    >>> density(X)(z)\n    2*sqrt(R**2 - z**2)/(pi*R**2)\n\n    >>> E(X)\n    0\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Wigner_semicircle_distribution\n    .. [2] https://mathworld.wolfram.com/WignersSemicircleLaw.html\n\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "ContinuousRV",
    "full_id": "sympy.stats.ContinuousRV",
    "type": "function",
    "description": "\n    Create a Continuous Random Variable given the following:\n\n    Parameters\n    ==========\n\n    symbol : Symbol\n        Represents name of the random variable.\n    density : Expression containing symbol\n        Represents probability density function.\n    set : set/Interval\n        Represents the region where the pdf is valid, by default is real line.\n    check : bool\n        If True, it will check whether the given density\n        integrates to 1 over the given set. If False, it\n        will not perform this check. Default is False.\n\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Many common continuous random variable types are already implemented.\n    This function should be necessary only very rarely.\n\n\n    Examples\n    ========\n\n    >>> from sympy import Symbol, sqrt, exp, pi\n    >>> from sympy.stats import ContinuousRV, P, E\n\n    >>> x = Symbol(\"x\")\n\n    >>> pdf = sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)) # Normal distribution\n    >>> X = ContinuousRV(x, pdf)\n\n    >>> E(X)\n    0\n    >>> P(X>0)\n    1/2\n    ",
    "section": "Continuous Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "JointRV",
    "full_id": "sympy.stats.JointRV",
    "type": "function",
    "description": "\n    Create a Joint Random Variable where each of its component is continuous,\n    given the following:\n\n    Parameters\n    ==========\n\n    symbol : Symbol\n        Represents name of the random variable.\n    pdf : A PDF in terms of indexed symbols of the symbol given\n        as the first argument\n\n    NOTE\n    ====\n\n    As of now, the set for each component for a ``JointRV`` is\n    equal to the set of all integers, which cannot be changed.\n\n    Examples\n    ========\n\n    >>> from sympy import exp, pi, Indexed, S\n    >>> from sympy.stats import density, JointRV\n    >>> x1, x2 = (Indexed('x', i) for i in (1, 2))\n    >>> pdf = exp(-x1**2/2 + x1 - x2**2/2 - S(1)/2)/(2*pi)\n    >>> N1 = JointRV('x', pdf) #Multivariate Normal distribution\n    >>> density(N1)(1, 2)\n    exp(-2)/(2*pi)\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "marginal_distribution",
    "full_id": "sympy.stats.marginal_distribution",
    "type": "function",
    "description": "\n    Marginal distribution function of a joint random variable.\n\n    Parameters\n    ==========\n\n    rv : A random variable with a joint probability distribution.\n    indices : Component indices or the indexed random symbol\n        for which the joint distribution is to be calculated\n\n    Returns\n    =======\n\n    A Lambda expression in `sym`.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import MultivariateNormal, marginal_distribution\n    >>> m = MultivariateNormal('X', [1, 2], [[2, 1], [1, 2]])\n    >>> marginal_distribution(m, m[0])(1)\n    1/(2*sqrt(pi))\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "MultivariateNormal",
    "full_id": "sympy.stats.MultivariateNormal",
    "type": "function",
    "description": "\n    Creates a continuous random variable with Multivariate Normal\n    Distribution.\n\n    The density of the multivariate normal distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    mu : List representing the mean or the mean vector\n    sigma : Positive semidefinite square matrix\n        Represents covariance Matrix.\n        If `\\sigma` is noninvertible then only sampling is supported currently\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import MultivariateNormal, density, marginal_distribution\n    >>> from sympy import symbols, MatrixSymbol\n    >>> X = MultivariateNormal('X', [3, 4], [[2, 1], [1, 2]])\n    >>> y, z = symbols('y z')\n    >>> density(X)(y, z)\n    sqrt(3)*exp(-y**2/3 + y*z/3 + 2*y/3 - z**2/3 + 5*z/3 - 13/3)/(6*pi)\n    >>> density(X)(1, 2)\n    sqrt(3)*exp(-4/3)/(6*pi)\n    >>> marginal_distribution(X, X[1])(y)\n    exp(-(y - 4)**2/4)/(2*sqrt(pi))\n    >>> marginal_distribution(X, X[0])(y)\n    exp(-(y - 3)**2/4)/(2*sqrt(pi))\n\n    The example below shows that it is also possible to use\n    symbolic parameters to define the MultivariateNormal class.\n\n    >>> n = symbols('n', integer=True, positive=True)\n    >>> Sg = MatrixSymbol('Sg', n, n)\n    >>> mu = MatrixSymbol('mu', n, 1)\n    >>> obs = MatrixSymbol('obs', n, 1)\n    >>> X = MultivariateNormal('X', mu, Sg)\n\n    The density of a multivariate normal can be\n    calculated using a matrix argument, as shown below.\n\n    >>> density(X)(obs)\n    (exp(((1/2)*mu.T - (1/2)*obs.T)*Sg**(-1)*(-mu + obs))/sqrt((2*pi)**n*Determinant(Sg)))[0, 0]\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Multivariate_normal_distribution\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "MultivariateLaplace",
    "full_id": "sympy.stats.MultivariateLaplace",
    "type": "function",
    "description": "\n    Creates a continuous random variable with Multivariate Laplace\n    Distribution.\n\n    The density of the multivariate Laplace distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    mu : List representing the mean or the mean vector\n    sigma : Positive definite square matrix\n        Represents covariance Matrix\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import MultivariateLaplace, density\n    >>> from sympy import symbols\n    >>> y, z = symbols('y z')\n    >>> X = MultivariateLaplace('X', [2, 4], [[3, 1], [1, 3]])\n    >>> density(X)(y, z)\n    sqrt(2)*exp(y/4 + 5*z/4)*besselk(0, sqrt(15*y*(3*y/8 - z/8)/2 + 15*z*(-y/8 + 3*z/8)/2))/(4*pi)\n    >>> density(X)(1, 2)\n    sqrt(2)*exp(11/4)*besselk(0, sqrt(165)/4)/(4*pi)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Multivariate_Laplace_distribution\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "GeneralizedMultivariateLogGamma",
    "full_id": "sympy.stats.GeneralizedMultivariateLogGamma",
    "type": "function",
    "description": "\n    Creates a joint random variable with generalized multivariate log gamma\n    distribution.\n\n    The joint pdf can be found at [1].\n\n    Parameters\n    ==========\n\n    syms : list/tuple/set of symbols for identifying each component\n    delta : A constant in range $[0, 1]$\n    v : Positive real number\n    lamda : List of positive real numbers\n    mu : List of positive real numbers\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density\n    >>> from sympy.stats.joint_rv_types import GeneralizedMultivariateLogGamma\n    >>> from sympy import symbols, S\n    >>> v = 1\n    >>> l, mu = [1, 1, 1], [1, 1, 1]\n    >>> d = S.Half\n    >>> y = symbols('y_1:4', positive=True)\n    >>> Gd = GeneralizedMultivariateLogGamma('G', d, v, l, mu)\n    >>> density(Gd)(y[0], y[1], y[2])\n    Sum(exp((n + 1)*(y_1 + y_2 + y_3) - exp(y_1) - exp(y_2) -\n    exp(y_3))/(2**n*gamma(n + 1)**3), (n, 0, oo))/2\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Generalized_multivariate_log-gamma_distribution\n    .. [2] https://www.researchgate.net/publication/234137346_On_a_multivariate_log-gamma_distribution_and_the_use_of_the_distribution_in_the_Bayesian_analysis\n\n    Note\n    ====\n\n    If the GeneralizedMultivariateLogGamma is too long to type use,\n\n    >>> from sympy.stats.joint_rv_types import GeneralizedMultivariateLogGamma as GMVLG\n    >>> Gd = GMVLG('G', d, v, l, mu)\n\n    If you want to pass the matrix omega instead of the constant delta, then use\n    ``GeneralizedMultivariateLogGammaOmega``.\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "GeneralizedMultivariateLogGammaOmega",
    "full_id": "sympy.stats.GeneralizedMultivariateLogGammaOmega",
    "type": "function",
    "description": "\n    Extends GeneralizedMultivariateLogGamma.\n\n    Parameters\n    ==========\n\n    syms : list/tuple/set of symbols\n        For identifying each component\n    omega : A square matrix\n           Every element of square matrix must be absolute value of\n           square root of correlation coefficient\n    v : Positive real number\n    lamda : List of positive real numbers\n    mu : List of positive real numbers\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density\n    >>> from sympy.stats.joint_rv_types import GeneralizedMultivariateLogGammaOmega\n    >>> from sympy import Matrix, symbols, S\n    >>> omega = Matrix([[1, S.Half, S.Half], [S.Half, 1, S.Half], [S.Half, S.Half, 1]])\n    >>> v = 1\n    >>> l, mu = [1, 1, 1], [1, 1, 1]\n    >>> G = GeneralizedMultivariateLogGammaOmega('G', omega, v, l, mu)\n    >>> y = symbols('y_1:4', positive=True)\n    >>> density(G)(y[0], y[1], y[2])\n    sqrt(2)*Sum((1 - sqrt(2)/2)**n*exp((n + 1)*(y_1 + y_2 + y_3) - exp(y_1) -\n    exp(y_2) - exp(y_3))/gamma(n + 1)**3, (n, 0, oo))/2\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Generalized_multivariate_log-gamma_distribution\n    .. [2] https://www.researchgate.net/publication/234137346_On_a_multivariate_log-gamma_distribution_and_the_use_of_the_distribution_in_the_Bayesian_analysis\n\n    Notes\n    =====\n\n    If the GeneralizedMultivariateLogGammaOmega is too long to type use,\n\n    >>> from sympy.stats.joint_rv_types import GeneralizedMultivariateLogGammaOmega as GMVLGO\n    >>> G = GMVLGO('G', omega, v, l, mu)\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Multinomial",
    "full_id": "sympy.stats.Multinomial",
    "type": "function",
    "description": "\n    Creates a discrete random variable with Multinomial Distribution.\n\n    The density of the said distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    n : Positive integer\n        Represents number of trials\n    p : List of event probabilities\n        Must be in the range of $[0, 1]$.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, Multinomial, marginal_distribution\n    >>> from sympy import symbols\n    >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)\n    >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)\n    >>> M = Multinomial('M', 3, p1, p2, p3)\n    >>> density(M)(x1, x2, x3)\n    Piecewise((6*p1**x1*p2**x2*p3**x3/(factorial(x1)*factorial(x2)*factorial(x3)),\n    Eq(x1 + x2 + x3, 3)), (0, True))\n    >>> marginal_distribution(M, M[0])(x1).subs(x1, 1)\n    3*p1*p2**2 + 6*p1*p2*p3 + 3*p1*p3**2\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Multinomial_distribution\n    .. [2] https://mathworld.wolfram.com/MultinomialDistribution.html\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "MultivariateBeta",
    "full_id": "sympy.stats.MultivariateBeta",
    "type": "function",
    "description": "\n    Creates a continuous random variable with Dirichlet/Multivariate Beta\n    Distribution.\n\n    The density of the Dirichlet distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    alpha : Positive real numbers\n        Signifies concentration numbers.\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, MultivariateBeta, marginal_distribution\n    >>> from sympy import Symbol\n    >>> a1 = Symbol('a1', positive=True)\n    >>> a2 = Symbol('a2', positive=True)\n    >>> B = MultivariateBeta('B', [a1, a2])\n    >>> C = MultivariateBeta('C', a1, a2)\n    >>> x = Symbol('x')\n    >>> y = Symbol('y')\n    >>> density(B)(x, y)\n    x**(a1 - 1)*y**(a2 - 1)*gamma(a1 + a2)/(gamma(a1)*gamma(a2))\n    >>> marginal_distribution(C, C[0])(x)\n    x**(a1 - 1)*gamma(a1 + a2)/(a2*gamma(a1)*gamma(a2))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Dirichlet_distribution\n    .. [2] https://mathworld.wolfram.com/DirichletDistribution.html\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "MultivariateEwens",
    "full_id": "sympy.stats.MultivariateEwens",
    "type": "function",
    "description": "\n    Creates a discrete random variable with Multivariate Ewens\n    Distribution.\n\n    The density of the said distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    n : Positive integer\n        Size of the sample or the integer whose partitions are considered\n    theta : Positive real number\n        Denotes Mutation rate\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, marginal_distribution, MultivariateEwens\n    >>> from sympy import Symbol\n    >>> a1 = Symbol('a1', positive=True)\n    >>> a2 = Symbol('a2', positive=True)\n    >>> ed = MultivariateEwens('E', 2, 1)\n    >>> density(ed)(a1, a2)\n    Piecewise((1/(2**a2*factorial(a1)*factorial(a2)), Eq(a1 + 2*a2, 2)), (0, True))\n    >>> marginal_distribution(ed, ed[0])(a1)\n    Piecewise((1/factorial(a1), Eq(a1, 2)), (0, True))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Ewens%27s_sampling_formula\n    .. [2] https://www.jstor.org/stable/24780825\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "MultivariateT",
    "full_id": "sympy.stats.MultivariateT",
    "type": "function",
    "description": "\n    Creates a joint random variable with multivariate T-distribution.\n\n    Parameters\n    ==========\n\n    syms : A symbol/str\n        For identifying the random variable.\n    mu : A list/matrix\n        Representing the location vector\n    sigma : The shape matrix for the distribution\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, MultivariateT\n    >>> from sympy import Symbol\n\n    >>> x = Symbol(\"x\")\n    >>> X = MultivariateT(\"x\", [1, 1], [[1, 0], [0, 1]], 2)\n\n    >>> density(X)(1, 2)\n    2/(9*pi)\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "NegativeMultinomial",
    "full_id": "sympy.stats.NegativeMultinomial",
    "type": "function",
    "description": "\n    Creates a discrete random variable with Negative Multinomial Distribution.\n\n    The density of the said distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    k0 : positive integer\n        Represents number of failures before the experiment is stopped\n    p : List of event probabilities\n        Must be in the range of $[0, 1]$\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, NegativeMultinomial, marginal_distribution\n    >>> from sympy import symbols\n    >>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)\n    >>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)\n    >>> N = NegativeMultinomial('M', 3, p1, p2, p3)\n    >>> N_c = NegativeMultinomial('M', 3, 0.1, 0.1, 0.1)\n    >>> density(N)(x1, x2, x3)\n    p1**x1*p2**x2*p3**x3*(-p1 - p2 - p3 + 1)**3*gamma(x1 + x2 +\n    x3 + 3)/(2*factorial(x1)*factorial(x2)*factorial(x3))\n    >>> marginal_distribution(N_c, N_c[0])(1).evalf().round(2)\n    0.25\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Negative_multinomial_distribution\n    .. [2] https://mathworld.wolfram.com/NegativeBinomialDistribution.html\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "NormalGamma",
    "full_id": "sympy.stats.NormalGamma",
    "type": "function",
    "description": "\n    Creates a bivariate joint random variable with multivariate Normal gamma\n    distribution.\n\n    Parameters\n    ==========\n\n    sym : A symbol/str\n        For identifying the random variable.\n    mu : A real number\n        The mean of the normal distribution\n    lamda : A positive integer\n        Parameter of joint distribution\n    alpha : A positive integer\n        Parameter of joint distribution\n    beta : A positive integer\n        Parameter of joint distribution\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, NormalGamma\n    >>> from sympy import symbols\n\n    >>> X = NormalGamma('x', 0, 1, 2, 3)\n    >>> y, z = symbols('y z')\n\n    >>> density(X)(y, z)\n    9*sqrt(2)*z**(3/2)*exp(-3*z)*exp(-y**2*z/2)/(2*sqrt(pi))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Normal-gamma_distribution\n\n    ",
    "section": "Joint Types",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "absorbing_probabilities",
    "full_id": "sympy.stats.DiscreteMarkovChain.absorbing_probabilities",
    "type": "method",
    "description": "\n        Computes the absorbing probabilities, i.e.\n        the ij-th entry of the matrix denotes the\n        probability of Markov chain being absorbed\n        in state j starting from state i.\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "canonical_form",
    "full_id": "sympy.stats.DiscreteMarkovChain.canonical_form",
    "type": "method",
    "description": "\n        Reorders the one-step transition matrix\n        so that recurrent states appear first and transient\n        states appear last. Other representations include inserting\n        transient states first and recurrent states last.\n\n        Returns\n        =======\n\n        states, P_new\n            ``states`` is the list that describes the order of the\n            new states in the matrix\n            so that the ith element in ``states`` is the state of the\n            ith row of A.\n            ``P_new`` is the new transition matrix in canonical form.\n\n        Examples\n        ========\n\n        >>> from sympy.stats import DiscreteMarkovChain\n        >>> from sympy import Matrix, S\n\n        You can convert your chain into canonical form:\n\n        >>> T = Matrix([[S(1)/2, S(1)/2, 0,      0,      0],\n        ...             [S(2)/5, S(1)/5, S(2)/5, 0,      0],\n        ...             [0,      0,      1,      0,      0],\n        ...             [0,      0,      S(1)/2, S(1)/2, 0],\n        ...             [S(1)/2, 0,      0,      0, S(1)/2]])\n        >>> X = DiscreteMarkovChain('X', list(range(1, 6)), trans_probs=T)\n        >>> states, new_matrix = X.canonical_form()\n        >>> states\n        [3, 1, 2, 4, 5]\n\n        >>> new_matrix\n        Matrix([\n        [  1,   0,   0,   0,   0],\n        [  0, 1/2, 1/2,   0,   0],\n        [2/5, 2/5, 1/5,   0,   0],\n        [1/2,   0,   0, 1/2,   0],\n        [  0, 1/2,   0,   0, 1/2]])\n\n        The new states are [3, 1, 2, 4, 5] and you can\n        create a new chain with this and its canonical\n        form will remain the same (since it is already\n        in canonical form).\n\n        >>> X = DiscreteMarkovChain('X', states, new_matrix)\n        >>> states, new_matrix = X.canonical_form()\n        >>> states\n        [3, 1, 2, 4, 5]\n\n        >>> new_matrix\n        Matrix([\n        [  1,   0,   0,   0,   0],\n        [  0, 1/2, 1/2,   0,   0],\n        [2/5, 2/5, 1/5,   0,   0],\n        [1/2,   0,   0, 1/2,   0],\n        [  0, 1/2,   0,   0, 1/2]])\n\n        This is not limited to absorbing chains:\n\n        >>> T = Matrix([[0, 5,  5, 0,  0],\n        ...             [0, 0,  0, 10, 0],\n        ...             [5, 0,  5, 0,  0],\n        ...             [0, 10, 0, 0,  0],\n        ...             [0, 3,  0, 3,  4]])/10\n        >>> X = DiscreteMarkovChain('X', trans_probs=T)\n        >>> states, new_matrix = X.canonical_form()\n        >>> states\n        [1, 3, 0, 2, 4]\n\n        >>> new_matrix\n        Matrix([\n        [   0,    1,   0,   0,   0],\n        [   1,    0,   0,   0,   0],\n        [ 1/2,    0,   0, 1/2,   0],\n        [   0,    0, 1/2, 1/2,   0],\n        [3/10, 3/10,   0,   0, 2/5]])\n\n        See Also\n        ========\n\n        sympy.stats.DiscreteMarkovChain.communication_classes\n        sympy.stats.DiscreteMarkovChain.decompose\n\n        References\n        ==========\n\n        .. [1] https://onlinelibrary.wiley.com/doi/pdf/10.1002/9780470316887.app1\n        .. [2] http://www.columbia.edu/~ww2040/6711F12/lect1023big.pdf\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "communication_classes",
    "full_id": "sympy.stats.DiscreteMarkovChain.communication_classes",
    "type": "method",
    "description": "\n        Returns the list of communication classes that partition\n        the states of the markov chain.\n\n        A communication class is defined to be a set of states\n        such that every state in that set is reachable from\n        every other state in that set. Due to its properties\n        this forms a class in the mathematical sense.\n        Communication classes are also known as recurrence\n        classes.\n\n        Returns\n        =======\n\n        classes\n            The ``classes`` are a list of tuples. Each\n            tuple represents a single communication class\n            with its properties. The first element in the\n            tuple is the list of states in the class, the\n            second element is whether the class is recurrent\n            and the third element is the period of the\n            communication class.\n\n        Examples\n        ========\n\n        >>> from sympy.stats import DiscreteMarkovChain\n        >>> from sympy import Matrix\n        >>> T = Matrix([[0, 1, 0],\n        ...             [1, 0, 0],\n        ...             [1, 0, 0]])\n        >>> X = DiscreteMarkovChain('X', [1, 2, 3], T)\n        >>> classes = X.communication_classes()\n        >>> for states, is_recurrent, period in classes:\n        ...     states, is_recurrent, period\n        ([1, 2], True, 2)\n        ([3], False, 1)\n\n        From this we can see that states ``1`` and ``2``\n        communicate, are recurrent and have a period\n        of 2. We can also see state ``3`` is transient\n        with a period of 1.\n\n        Notes\n        =====\n\n        The algorithm used is of order ``O(n**2)`` where\n        ``n`` is the number of states in the markov chain.\n        It uses Tarjan's algorithm to find the classes\n        themselves and then it uses a breadth-first search\n        algorithm to find each class's periodicity.\n        Most of the algorithm's components approach ``O(n)``\n        as the matrix becomes more and more sparse.\n\n        References\n        ==========\n\n        .. [1] https://web.archive.org/web/20220207032113/https://www.columbia.edu/~ww2040/4701Sum07/4701-06-Notes-MCII.pdf\n        .. [2] https://cecas.clemson.edu/~shierd/Shier/markov.pdf\n        .. [3] https://www.proquest.com/openview/4adc6a51d8371be5b0e4c7dff287fc70/1?pq-origsite=gscholar&cbl=2026366&diss=y\n        .. [4] https://www.mathworks.com/help/econ/dtmc.classify.html\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "decompose",
    "full_id": "sympy.stats.DiscreteMarkovChain.decompose",
    "type": "method",
    "description": "\n        Decomposes the transition matrix into submatrices with\n        special properties.\n\n        The transition matrix can be decomposed into 4 submatrices:\n        - A - the submatrix from recurrent states to recurrent states.\n        - B - the submatrix from transient to recurrent states.\n        - C - the submatrix from transient to transient states.\n        - O - the submatrix of zeros for recurrent to transient states.\n\n        Returns\n        =======\n\n        states, A, B, C\n            ``states`` - a list of state names with the first being\n            the recurrent states and the last being\n            the transient states in the order\n            of the row names of A and then the row names of C.\n            ``A`` - the submatrix from recurrent states to recurrent states.\n            ``B`` - the submatrix from transient to recurrent states.\n            ``C`` - the submatrix from transient to transient states.\n\n        Examples\n        ========\n\n        >>> from sympy.stats import DiscreteMarkovChain\n        >>> from sympy import Matrix, S\n\n        One can decompose this chain for example:\n\n        >>> T = Matrix([[S(1)/2, S(1)/2, 0,      0,      0],\n        ...             [S(2)/5, S(1)/5, S(2)/5, 0,      0],\n        ...             [0,      0,      1,      0,      0],\n        ...             [0,      0,      S(1)/2, S(1)/2, 0],\n        ...             [S(1)/2, 0,      0,      0, S(1)/2]])\n        >>> X = DiscreteMarkovChain('X', trans_probs=T)\n        >>> states, A, B, C = X.decompose()\n        >>> states\n        [2, 0, 1, 3, 4]\n\n        >>> A   # recurrent to recurrent\n        Matrix([[1]])\n\n        >>> B  # transient to recurrent\n        Matrix([\n        [  0],\n        [2/5],\n        [1/2],\n        [  0]])\n\n        >>> C  # transient to transient\n        Matrix([\n        [1/2, 1/2,   0,   0],\n        [2/5, 1/5,   0,   0],\n        [  0,   0, 1/2,   0],\n        [1/2,   0,   0, 1/2]])\n\n        This means that state 2 is the only absorbing state\n        (since A is a 1x1 matrix). B is a 4x1 matrix since\n        the 4 remaining transient states all merge into reccurent\n        state 2. And C is the 4x4 matrix that shows how the\n        transient states 0, 1, 3, 4 all interact.\n\n        See Also\n        ========\n\n        sympy.stats.DiscreteMarkovChain.communication_classes\n        sympy.stats.DiscreteMarkovChain.canonical_form\n\n        References\n        ==========\n\n        .. [1] https://en.wikipedia.org/wiki/Absorbing_Markov_chain\n        .. [2] https://people.brandeis.edu/~igusa/Math56aS08/Math56a_S08_notes015.pdf\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "fixed_row_vector",
    "full_id": "sympy.stats.DiscreteMarkovChain.fixed_row_vector",
    "type": "method",
    "description": "\n        A wrapper for ``stationary_distribution()``.\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "fundamental_matrix",
    "full_id": "sympy.stats.DiscreteMarkovChain.fundamental_matrix",
    "type": "method",
    "description": "\n        Each entry fundamental matrix can be interpreted as\n        the expected number of times the chains is in state j\n        if it started in state i.\n\n        References\n        ==========\n\n        .. [1] https://lips.cs.princeton.edu/the-fundamental-matrix-of-a-finite-markov-chain/\n\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "limiting_distribution",
    "full_id": "sympy.stats.DiscreteMarkovChain.limiting_distribution",
    "type": "property",
    "description": "\n        The fixed row vector is the limiting\n        distribution of a discrete Markov chain.\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "sample",
    "full_id": "sympy.stats.DiscreteMarkovChain.sample",
    "type": "method",
    "description": "\n        Returns\n        =======\n\n        sample: iterator object\n            iterator object containing the sample\n\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "stationary_distribution",
    "full_id": "sympy.stats.DiscreteMarkovChain.stationary_distribution",
    "type": "method",
    "description": "\n        The stationary distribution is any row vector, p, that solves p = pP,\n        is row stochastic and each element in p must be nonnegative.\n        That means in matrix form: :math:`(P-I)^T p^T = 0` and\n        :math:`(1, \\dots, 1) p = 1`\n        where ``P`` is the one-step transition matrix.\n\n        All time-homogeneous Markov Chains with a finite state space\n        have at least one stationary distribution. In addition, if\n        a finite time-homogeneous Markov Chain is irreducible, the\n        stationary distribution is unique.\n\n        Parameters\n        ==========\n\n        condition_set : bool\n            If the chain has a symbolic size or transition matrix,\n            it will return a ``Lambda`` if ``False`` and return a\n            ``ConditionSet`` if ``True``.\n\n        Examples\n        ========\n\n        >>> from sympy.stats import DiscreteMarkovChain\n        >>> from sympy import Matrix, S\n\n        An irreducible Markov Chain\n\n        >>> T = Matrix([[S(1)/2, S(1)/2, 0],\n        ...             [S(4)/5, S(1)/5, 0],\n        ...             [1, 0, 0]])\n        >>> X = DiscreteMarkovChain('X', trans_probs=T)\n        >>> X.stationary_distribution()\n        Matrix([[8/13, 5/13, 0]])\n\n        A reducible Markov Chain\n\n        >>> T = Matrix([[S(1)/2, S(1)/2, 0],\n        ...             [S(4)/5, S(1)/5, 0],\n        ...             [0, 0, 1]])\n        >>> X = DiscreteMarkovChain('X', trans_probs=T)\n        >>> X.stationary_distribution()\n        Matrix([[8/13 - 8*tau0/13, 5/13 - 5*tau0/13, tau0]])\n\n        >>> Y = DiscreteMarkovChain('Y')\n        >>> Y.stationary_distribution()\n        Lambda((wm, _T), Eq(wm*_T, wm))\n\n        >>> Y.stationary_distribution(condition_set=True)\n        ConditionSet(wm, Eq(wm*_T, wm))\n\n        References\n        ==========\n\n        .. [1] https://www.probabilitycourse.com/chapter11/11_2_6_stationary_and_limiting_distributions.php\n        .. [2] https://web.archive.org/web/20210508104430/https://galton.uchicago.edu/~yibi/teaching/stat317/2014/Lectures/Lecture4_6up.pdf\n\n        See Also\n        ========\n\n        sympy.stats.DiscreteMarkovChain.limiting_distribution\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "transition_probabilities",
    "full_id": "sympy.stats.DiscreteMarkovChain.transition_probabilities",
    "type": "property",
    "description": "\n        Transition probabilities of discrete Markov chain,\n        either an instance of Matrix or MatrixSymbol.\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "expectation",
    "full_id": "sympy.stats.BernoulliProcess.expectation",
    "type": "method",
    "description": "\n        Computes expectation.\n\n        Parameters\n        ==========\n\n        expr : RandomIndexedSymbol, Relational, Logic\n            Condition for which expectation has to be computed. Must\n            contain a RandomIndexedSymbol of the process.\n        condition : Relational, Logic\n            The given conditions under which computations should be done.\n\n        Returns\n        =======\n\n        Expectation of the RandomIndexedSymbol.\n\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "probability",
    "full_id": "sympy.stats.BernoulliProcess.probability",
    "type": "method",
    "description": "\n        Computes probability.\n\n        Parameters\n        ==========\n\n        condition : Relational\n                Condition for which probability has to be computed. Must\n                contain a RandomIndexedSymbol of the process.\n        given_condition : Relational, Logic\n                The given conditions under which computations should be done.\n\n        Returns\n        =======\n\n        Probability of the condition.\n\n        ",
    "section": "Stochastic Processes",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "MatrixGamma",
    "full_id": "sympy.stats.MatrixGamma",
    "type": "function",
    "description": "\n    Creates a random variable with Matrix Gamma Distribution.\n\n    The density of the said distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    alpha: Positive Real number\n        Shape Parameter\n    beta: Positive Real number\n        Scale Parameter\n    scale_matrix: Positive definite real square matrix\n        Scale Matrix\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, MatrixGamma\n    >>> from sympy import MatrixSymbol, symbols\n    >>> a, b = symbols('a b', positive=True)\n    >>> M = MatrixGamma('M', a, b, [[2, 1], [1, 2]])\n    >>> X = MatrixSymbol('X', 2, 2)\n    >>> density(M)(X).doit()\n    exp(Trace(Matrix([\n    [-2/3,  1/3],\n    [ 1/3, -2/3]])*X)/b)*Determinant(X)**(a - 3/2)/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2))\n    >>> density(M)([[1, 0], [0, 1]]).doit()\n    exp(-4/(3*b))/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2))\n\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Matrix_gamma_distribution\n\n    ",
    "section": "Matrix Distributions",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "Wishart",
    "full_id": "sympy.stats.Wishart",
    "type": "function",
    "description": "\n    Creates a random variable with Wishart Distribution.\n\n    The density of the said distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    n: Positive Real number\n        Represents degrees of freedom\n    scale_matrix: Positive definite real square matrix\n        Scale Matrix\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, Wishart\n    >>> from sympy import MatrixSymbol, symbols\n    >>> n = symbols('n', positive=True)\n    >>> W = Wishart('W', n, [[2, 1], [1, 2]])\n    >>> X = MatrixSymbol('X', 2, 2)\n    >>> density(W)(X).doit()\n    exp(Trace(Matrix([\n    [-1/3,  1/6],\n    [ 1/6, -1/3]])*X))*Determinant(X)**(n/2 - 3/2)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2))\n    >>> density(W)([[1, 0], [0, 1]]).doit()\n    exp(-2/3)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2))\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Wishart_distribution\n\n    ",
    "section": "Matrix Distributions",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "MatrixNormal",
    "full_id": "sympy.stats.MatrixNormal",
    "type": "function",
    "description": "\n    Creates a random variable with Matrix Normal Distribution.\n\n    The density of the said distribution can be found at [1].\n\n    Parameters\n    ==========\n\n    location_matrix: Real ``n x p`` matrix\n        Represents degrees of freedom\n    scale_matrix_1: Positive definite matrix\n        Scale Matrix of shape ``n x n``\n    scale_matrix_2: Positive definite matrix\n        Scale Matrix of shape ``p x p``\n\n    Returns\n    =======\n\n    RandomSymbol\n\n    Examples\n    ========\n\n    >>> from sympy import MatrixSymbol\n    >>> from sympy.stats import density, MatrixNormal\n    >>> M = MatrixNormal('M', [[1, 2]], [1], [[1, 0], [0, 1]])\n    >>> X = MatrixSymbol('X', 1, 2)\n    >>> density(M)(X).doit()\n    exp(-Trace((Matrix([\n    [-1],\n    [-2]]) + X.T)*(Matrix([[-1, -2]]) + X))/2)/(2*pi)\n    >>> density(M)([[3, 4]]).doit()\n    exp(-4)/(2*pi)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Matrix_normal_distribution\n\n    ",
    "section": "Matrix Distributions",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "P",
    "full_id": "sympy.stats.P",
    "type": "function",
    "description": "\n    Probability that a condition is true, optionally given a second condition.\n\n    Parameters\n    ==========\n\n    condition : Combination of Relationals containing RandomSymbols\n        The condition of which you want to compute the probability\n    given_condition : Combination of Relationals containing RandomSymbols\n        A conditional expression. P(X > 1, X > 0) is expectation of X > 1\n        given X > 0\n    numsamples : int\n        Enables sampling and approximates the probability with this many samples\n    evaluate : Bool (defaults to True)\n        In case of continuous systems return unevaluated integral\n\n    Examples\n    ========\n\n    >>> from sympy.stats import P, Die\n    >>> from sympy import Eq\n    >>> X, Y = Die('X', 6), Die('Y', 6)\n    >>> P(X > 3)\n    1/2\n    >>> P(Eq(X, 5), X > 2) # Probability that X == 5 given that X > 2\n    1/4\n    >>> P(X > Y)\n    5/12\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "E",
    "full_id": "sympy.stats.E",
    "type": "function",
    "description": "\n    Returns the expected value of a random expression.\n\n    Parameters\n    ==========\n\n    expr : Expr containing RandomSymbols\n        The expression of which you want to compute the expectation value\n    given : Expr containing RandomSymbols\n        A conditional expression. E(X, X>0) is expectation of X given X > 0\n    numsamples : int\n        Enables sampling and approximates the expectation with this many samples\n    evalf : Bool (defaults to True)\n        If sampling return a number rather than a complex expression\n    evaluate : Bool (defaults to True)\n        In case of continuous systems return unevaluated integral\n\n    Examples\n    ========\n\n    >>> from sympy.stats import E, Die\n    >>> X = Die('X', 6)\n    >>> E(X)\n    7/2\n    >>> E(2*X + 1)\n    8\n\n    >>> E(X, X > 3) # Expectation of X given that it is above 3\n    5\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "density",
    "full_id": "sympy.stats.density",
    "type": "function",
    "description": "\n    Probability density of a random expression, optionally given a second\n    condition.\n\n    Explanation\n    ===========\n\n    This density will take on different forms for different types of\n    probability spaces. Discrete variables produce Dicts. Continuous\n    variables produce Lambdas.\n\n    Parameters\n    ==========\n\n    expr : Expr containing RandomSymbols\n        The expression of which you want to compute the density value\n    condition : Relational containing RandomSymbols\n        A conditional expression. density(X > 1, X > 0) is density of X > 1\n        given X > 0\n    numsamples : int\n        Enables sampling and approximates the density with this many samples\n\n    Examples\n    ========\n\n    >>> from sympy.stats import density, Die, Normal\n    >>> from sympy import Symbol\n\n    >>> x = Symbol('x')\n    >>> D = Die('D', 6)\n    >>> X = Normal(x, 0, 1)\n\n    >>> density(D).dict\n    {1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}\n    >>> density(2*D).dict\n    {2: 1/6, 4: 1/6, 6: 1/6, 8: 1/6, 10: 1/6, 12: 1/6}\n    >>> density(X)(x)\n    sqrt(2)*exp(-x**2/2)/(2*sqrt(pi))\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "entropy",
    "full_id": "sympy.stats.entropy",
    "type": "function",
    "description": "\n    Calculuates entropy of a probability distribution.\n\n    Parameters\n    ==========\n\n    expression : the random expression whose entropy is to be calculated\n    condition : optional, to specify conditions on random expression\n    b: base of the logarithm, optional\n       By default, it is taken as Euler's number\n\n    Returns\n    =======\n\n    result : Entropy of the expression, a constant\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Normal, Die, entropy\n    >>> X = Normal('X', 0, 1)\n    >>> entropy(X)\n    log(2)/2 + 1/2 + log(pi)/2\n\n    >>> D = Die('D', 4)\n    >>> entropy(D)\n    log(4)\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Entropy_%28information_theory%29\n    .. [2] https://www.crmarsh.com/static/pdf/Charles_Marsh_Continuous_Entropy.pdf\n    .. [3] https://kconrad.math.uconn.edu/blurbs/analysis/entropypost.pdf\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "given",
    "full_id": "sympy.stats.given",
    "type": "function",
    "description": " Conditional Random Expression.\n\n    Explanation\n    ===========\n\n    From a random expression and a condition on that expression creates a new\n    probability space from the condition and returns the same expression on that\n    conditional probability space.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import given, density, Die\n    >>> X = Die('X', 6)\n    >>> Y = given(X, X > 3)\n    >>> density(Y).dict\n    {4: 1/3, 5: 1/3, 6: 1/3}\n\n    Following convention, if the condition is a random symbol then that symbol\n    is considered fixed.\n\n    >>> from sympy.stats import Normal\n    >>> from sympy import pprint\n    >>> from sympy.abc import z\n\n    >>> X = Normal('X', 0, 1)\n    >>> Y = Normal('Y', 0, 1)\n    >>> pprint(density(X + Y, Y)(z), use_unicode=False)\n                    2\n           -(-Y + z)\n           -----------\n      ___       2\n    \\/ 2 *e\n    ------------------\n             ____\n         2*\\/ pi\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "where",
    "full_id": "sympy.stats.where",
    "type": "function",
    "description": "\n    Returns the domain where a condition is True.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import where, Die, Normal\n    >>> from sympy import And\n\n    >>> D1, D2 = Die('a', 6), Die('b', 6)\n    >>> a, b = D1.symbol, D2.symbol\n    >>> X = Normal('x', 0, 1)\n\n    >>> where(X**2<1)\n    Domain: (-1 < x) & (x < 1)\n\n    >>> where(X**2<1).set\n    Interval.open(-1, 1)\n\n    >>> where(And(D1<=D2, D2<3))\n    Domain: (Eq(a, 1) & Eq(b, 1)) | (Eq(a, 1) & Eq(b, 2)) | (Eq(a, 2) & Eq(b, 2))\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "variance",
    "full_id": "sympy.stats.variance",
    "type": "function",
    "description": "\n    Variance of a random expression.\n\n    .. math::\n        variance(X) = E((X-E(X))^{2})\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Die, Bernoulli, variance\n    >>> from sympy import simplify, Symbol\n\n    >>> X = Die('X', 6)\n    >>> p = Symbol('p')\n    >>> B = Bernoulli('B', p, 1, 0)\n\n    >>> variance(2*X)\n    35/3\n\n    >>> simplify(variance(B))\n    p*(1 - p)\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "covariance",
    "full_id": "sympy.stats.covariance",
    "type": "function",
    "description": "\n    Covariance of two random expressions.\n\n    Explanation\n    ===========\n\n    The expectation that the two variables will rise and fall together\n\n    .. math::\n        covariance(X,Y) = E((X-E(X)) (Y-E(Y)))\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Exponential, covariance\n    >>> from sympy import Symbol\n\n    >>> rate = Symbol('lambda', positive=True, real=True)\n    >>> X = Exponential('X', rate)\n    >>> Y = Exponential('Y', rate)\n\n    >>> covariance(X, X)\n    lambda**(-2)\n    >>> covariance(X, Y)\n    0\n    >>> covariance(X, Y + rate*X)\n    1/lambda\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "coskewness",
    "full_id": "sympy.stats.coskewness",
    "type": "function",
    "description": "\n    Calculates the co-skewness of three random variables.\n\n    Explanation\n    ===========\n\n    Mathematically Coskewness is defined as\n\n    .. math::\n        coskewness(X,Y,Z)=\\frac{E[(X-E[X]) * (Y-E[Y]) * (Z-E[Z])]} {\\sigma_{X}\\sigma_{Y}\\sigma_{Z}}\n\n    Parameters\n    ==========\n\n    X : RandomSymbol\n            Random Variable used to calculate coskewness\n    Y : RandomSymbol\n            Random Variable used to calculate coskewness\n    Z : RandomSymbol\n            Random Variable used to calculate coskewness\n    condition : Expr containing RandomSymbols\n            A conditional expression\n\n    Examples\n    ========\n\n    >>> from sympy.stats import coskewness, Exponential, skewness\n    >>> from sympy import symbols\n    >>> p = symbols('p', positive=True)\n    >>> X = Exponential('X', p)\n    >>> Y = Exponential('Y', 2*p)\n    >>> coskewness(X, Y, Y)\n    0\n    >>> coskewness(X, Y + X, Y + 2*X)\n    16*sqrt(85)/85\n    >>> coskewness(X + 2*Y, Y + X, Y + 2*X, X > 3)\n    9*sqrt(170)/85\n    >>> coskewness(Y, Y, Y) == skewness(Y)\n    True\n    >>> coskewness(X, Y + p*X, Y + 2*p*X)\n    4/(sqrt(1 + 1/(4*p**2))*sqrt(4 + 1/(4*p**2)))\n\n    Returns\n    =======\n\n    coskewness : The coskewness of the three random variables\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Coskewness\n\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "median",
    "full_id": "sympy.stats.median",
    "type": "function",
    "description": "\n    Calculuates the median of the probability distribution.\n\n    Explanation\n    ===========\n\n    Mathematically, median of Probability distribution is defined as all those\n    values of `m` for which the following condition is satisfied\n\n    .. math::\n        P(X\\leq m) \\geq  \\frac{1}{2} \\text{ and} \\text{ } P(X\\geq m)\\geq \\frac{1}{2}\n\n    Parameters\n    ==========\n\n    X: The random expression whose median is to be calculated.\n\n    Returns\n    =======\n\n    The FiniteSet or an Interval which contains the median of the\n    random expression.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Normal, Die, median\n    >>> N = Normal('N', 3, 1)\n    >>> median(N)\n    {3}\n    >>> D = Die('D')\n    >>> median(D)\n    {3, 4}\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Median#Probability_distributions\n\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "std",
    "full_id": "sympy.stats.std",
    "type": "function",
    "description": "\n    Standard Deviation of a random expression\n\n    .. math::\n        std(X) = \\sqrt(E((X-E(X))^{2}))\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Bernoulli, std\n    >>> from sympy import Symbol, simplify\n\n    >>> p = Symbol('p')\n    >>> B = Bernoulli('B', p, 1, 0)\n\n    >>> simplify(std(B))\n    sqrt(p*(1 - p))\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "quantile",
    "full_id": "sympy.stats.quantile",
    "type": "function",
    "description": "\n    Return the :math:`p^{th}` order quantile of a probability distribution.\n\n    Explanation\n    ===========\n\n    Quantile is defined as the value at which the probability of the random\n    variable is less than or equal to the given probability.\n\n    .. math::\n        Q(p) = \\inf\\{x \\in (-\\infty, \\infty) : p \\le F(x)\\}\n\n    Examples\n    ========\n\n    >>> from sympy.stats import quantile, Die, Exponential\n    >>> from sympy import Symbol, pprint\n    >>> p = Symbol(\"p\")\n\n    >>> l = Symbol(\"lambda\", positive=True)\n    >>> X = Exponential(\"x\", l)\n    >>> quantile(X)(p)\n    -log(1 - p)/lambda\n\n    >>> D = Die(\"d\", 6)\n    >>> pprint(quantile(D)(p), use_unicode=False)\n    /nan  for Or(p > 1, p < 0)\n    |\n    | 1       for p <= 1/6\n    |\n    | 2       for p <= 1/3\n    |\n    < 3       for p <= 1/2\n    |\n    | 4       for p <= 2/3\n    |\n    | 5       for p <= 5/6\n    |\n    \\ 6        for p <= 1\n\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "sample",
    "full_id": "sympy.stats.sample",
    "type": "function",
    "description": "\n    A realization of the random expression.\n\n    Parameters\n    ==========\n\n    expr : Expression of random variables\n        Expression from which sample is extracted\n    condition : Expr containing RandomSymbols\n        A conditional expression\n    size : int, tuple\n        Represents size of each sample in numsamples\n    library : str\n        - 'scipy' : Sample using scipy\n        - 'numpy' : Sample using numpy\n        - 'pymc'  : Sample using PyMC\n\n        Choose any of the available options to sample from as string,\n        by default is 'scipy'\n    numsamples : int\n        Number of samples, each with size as ``size``.\n\n        .. deprecated:: 1.9\n\n        The ``numsamples`` parameter is deprecated and is only provided for\n        compatibility with v1.8. Use a list comprehension or an additional\n        dimension in ``size`` instead. See\n        :ref:`deprecated-sympy-stats-numsamples` for details.\n\n    seed :\n        An object to be used as seed by the given external library for sampling `expr`.\n        Following is the list of possible types of object for the supported libraries,\n\n        - 'scipy': int, numpy.random.RandomState, numpy.random.Generator\n        - 'numpy': int, numpy.random.RandomState, numpy.random.Generator\n        - 'pymc': int\n\n        Optional, by default None, in which case seed settings\n        related to the given library will be used.\n        No modifications to environment's global seed settings\n        are done by this argument.\n\n    Returns\n    =======\n\n    sample: float/list/numpy.ndarray\n        one sample or a collection of samples of the random expression.\n\n        - sample(X) returns float/numpy.float64/numpy.int64 object.\n        - sample(X, size=int/tuple) returns numpy.ndarray object.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Die, sample, Normal, Geometric\n    >>> X, Y, Z = Die('X', 6), Die('Y', 6), Die('Z', 6) # Finite Random Variable\n    >>> die_roll = sample(X + Y + Z)\n    >>> die_roll # doctest: +SKIP\n    3\n    >>> N = Normal('N', 3, 4) # Continuous Random Variable\n    >>> samp = sample(N)\n    >>> samp in N.pspace.domain.set\n    True\n    >>> samp = sample(N, N>0)\n    >>> samp > 0\n    True\n    >>> samp_list = sample(N, size=4)\n    >>> [sam in N.pspace.domain.set for sam in samp_list]\n    [True, True, True, True]\n    >>> sample(N, size = (2,3)) # doctest: +SKIP\n    array([[5.42519758, 6.40207856, 4.94991743],\n       [1.85819627, 6.83403519, 1.9412172 ]])\n    >>> G = Geometric('G', 0.5) # Discrete Random Variable\n    >>> samp_list = sample(G, size=3)\n    >>> samp_list # doctest: +SKIP\n    [1, 3, 2]\n    >>> [sam in G.pspace.domain.set for sam in samp_list]\n    [True, True, True]\n    >>> MN = Normal(\"MN\", [3, 4], [[2, 1], [1, 2]]) # Joint Random Variable\n    >>> samp_list = sample(MN, size=4)\n    >>> samp_list # doctest: +SKIP\n    [array([2.85768055, 3.38954165]),\n     array([4.11163337, 4.3176591 ]),\n     array([0.79115232, 1.63232916]),\n     array([4.01747268, 3.96716083])]\n    >>> [tuple(sam) in MN.pspace.domain.set for sam in samp_list]\n    [True, True, True, True]\n\n    .. versionchanged:: 1.7.0\n        sample used to return an iterator containing the samples instead of value.\n\n    .. versionchanged:: 1.9.0\n        sample returns values or array of values instead of an iterator and numsamples is deprecated.\n\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "sample_iter",
    "full_id": "sympy.stats.sample_iter",
    "type": "function",
    "description": "\n    Returns an iterator of realizations from the expression given a condition.\n\n    Parameters\n    ==========\n\n    expr: Expr\n        Random expression to be realized\n    condition: Expr, optional\n        A conditional expression\n    size : int, tuple\n        Represents size of each sample in numsamples\n    numsamples: integer, optional\n        Length of the iterator (defaults to infinity)\n    seed :\n        An object to be used as seed by the given external library for sampling `expr`.\n        Following is the list of possible types of object for the supported libraries,\n\n        - 'scipy': int, numpy.random.RandomState, numpy.random.Generator\n        - 'numpy': int, numpy.random.RandomState, numpy.random.Generator\n        - 'pymc': int\n\n        Optional, by default None, in which case seed settings\n        related to the given library will be used.\n        No modifications to environment's global seed settings\n        are done by this argument.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Normal, sample_iter\n    >>> X = Normal('X', 0, 1)\n    >>> expr = X*X + 3\n    >>> iterator = sample_iter(expr, numsamples=3) # doctest: +SKIP\n    >>> list(iterator) # doctest: +SKIP\n    [12, 4, 7]\n\n    Returns\n    =======\n\n    sample_iter: iterator object\n        iterator object containing the sample/samples of given expr\n\n    See Also\n    ========\n\n    sample\n    sampling_P\n    sampling_E\n\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "factorial_moment",
    "full_id": "sympy.stats.factorial_moment",
    "type": "function",
    "description": "\n    The factorial moment is a mathematical quantity defined as the expectation\n    or average of the falling factorial of a random variable.\n\n    .. math::\n        factorial-moment(X, n) = E(X(X - 1)(X - 2)...(X - n + 1))\n\n    Parameters\n    ==========\n\n    n: A natural number, n-th factorial moment.\n\n    condition : Expr containing RandomSymbols\n            A conditional expression.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import factorial_moment, Poisson, Binomial\n    >>> from sympy import Symbol, S\n    >>> lamda = Symbol('lamda')\n    >>> X = Poisson('X', lamda)\n    >>> factorial_moment(X, 2)\n    lamda**2\n    >>> Y = Binomial('Y', 2, S.Half)\n    >>> factorial_moment(Y, 2)\n    1/2\n    >>> factorial_moment(Y, 2, Y > 1) # find factorial moment for Y > 1\n    2\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Factorial_moment\n    .. [2] https://mathworld.wolfram.com/FactorialMoment.html\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "kurtosis",
    "full_id": "sympy.stats.kurtosis",
    "type": "function",
    "description": "\n    Characterizes the tails/outliers of a probability distribution.\n\n    Explanation\n    ===========\n\n    Kurtosis of any univariate normal distribution is 3. Kurtosis less than\n    3 means that the distribution produces fewer and less extreme outliers\n    than the normal distribution.\n\n    .. math::\n        kurtosis(X) = E(((X - E(X))/\\sigma_X)^{4})\n\n    Parameters\n    ==========\n\n    condition : Expr containing RandomSymbols\n            A conditional expression. kurtosis(X, X>0) is kurtosis of X given X > 0\n\n    Examples\n    ========\n\n    >>> from sympy.stats import kurtosis, Exponential, Normal\n    >>> from sympy import Symbol\n    >>> X = Normal('X', 0, 1)\n    >>> kurtosis(X)\n    3\n    >>> kurtosis(X, X > 0) # find kurtosis given X > 0\n    (-4/pi - 12/pi**2 + 3)/(1 - 2/pi)**2\n\n    >>> rate = Symbol('lamda', positive=True, real=True)\n    >>> Y = Exponential('Y', rate)\n    >>> kurtosis(Y)\n    9\n\n    References\n    ==========\n\n    .. [1] https://en.wikipedia.org/wiki/Kurtosis\n    .. [2] https://mathworld.wolfram.com/Kurtosis.html\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "skewness",
    "full_id": "sympy.stats.skewness",
    "type": "function",
    "description": "\n    Measure of the asymmetry of the probability distribution.\n\n    Explanation\n    ===========\n\n    Positive skew indicates that most of the values lie to the right of\n    the mean.\n\n    .. math::\n        skewness(X) = E(((X - E(X))/\\sigma_X)^{3})\n\n    Parameters\n    ==========\n\n    condition : Expr containing RandomSymbols\n            A conditional expression. skewness(X, X>0) is skewness of X given X > 0\n\n    Examples\n    ========\n\n    >>> from sympy.stats import skewness, Exponential, Normal\n    >>> from sympy import Symbol\n    >>> X = Normal('X', 0, 1)\n    >>> skewness(X)\n    0\n    >>> skewness(X, X > 0) # find skewness given X > 0\n    (-sqrt(2)/sqrt(pi) + 4*sqrt(2)/pi**(3/2))/(1 - 2/pi)**(3/2)\n\n    >>> rate = Symbol('lambda', positive=True, real=True)\n    >>> Y = Exponential('Y', rate)\n    >>> skewness(Y)\n    2\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "correlation",
    "full_id": "sympy.stats.correlation",
    "type": "function",
    "description": "\n    Correlation of two random expressions, also known as correlation\n    coefficient or Pearson's correlation.\n\n    Explanation\n    ===========\n\n    The normalized expectation that the two variables will rise\n    and fall together\n\n    .. math::\n        correlation(X,Y) = E((X-E(X))(Y-E(Y)) / (\\sigma_x  \\sigma_y))\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Exponential, correlation\n    >>> from sympy import Symbol\n\n    >>> rate = Symbol('lambda', positive=True, real=True)\n    >>> X = Exponential('X', rate)\n    >>> Y = Exponential('Y', rate)\n\n    >>> correlation(X, X)\n    1\n    >>> correlation(X, Y)\n    0\n    >>> correlation(X, Y + rate*X)\n    1/sqrt(1 + lambda**(-2))\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "sampling_density",
    "full_id": "sympy.stats.rv.sampling_density",
    "type": "function",
    "description": "\n    Sampling version of density.\n\n    See Also\n    ========\n    density\n    sampling_P\n    sampling_E\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "sampling_P",
    "full_id": "sympy.stats.rv.sampling_P",
    "type": "function",
    "description": "\n    Sampling version of P.\n\n    See Also\n    ========\n\n    P\n    sampling_E\n    sampling_density\n\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "sampling_E",
    "full_id": "sympy.stats.rv.sampling_E",
    "type": "function",
    "description": "\n    Sampling version of E.\n\n    See Also\n    ========\n\n    P\n    sampling_P\n    sampling_density\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "moment",
    "full_id": "sympy.stats.moment",
    "type": "function",
    "description": "\n    Return the nth moment of a random expression about c.\n\n    .. math::\n        moment(X, c, n) = E((X-c)^{n})\n\n    Default value of c is 0.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Die, moment, E\n    >>> X = Die('X', 6)\n    >>> moment(X, 1, 6)\n    -5/2\n    >>> moment(X, 2)\n    91/6\n    >>> moment(X, 1) == E(X)\n    True\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "cmoment",
    "full_id": "sympy.stats.cmoment",
    "type": "function",
    "description": "\n    Return the nth central moment of a random expression about its mean.\n\n    .. math::\n        cmoment(X, n) = E((X - E(X))^{n})\n\n    Examples\n    ========\n\n    >>> from sympy.stats import Die, cmoment, variance\n    >>> X = Die('X', 6)\n    >>> cmoment(X, 3)\n    0\n    >>> cmoment(X, 2)\n    35/12\n    >>> cmoment(X, 2) == variance(X)\n    True\n    ",
    "section": "Interface",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "random_symbols",
    "full_id": "sympy.stats.rv.random_symbols",
    "type": "function",
    "description": "\n    Returns all RandomSymbols within a SymPy Expression.\n    ",
    "section": "Mechanics",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "pspace",
    "full_id": "sympy.stats.rv.pspace",
    "type": "function",
    "description": "\n    Returns the underlying Probability Space of a random expression.\n\n    For internal use.\n\n    Examples\n    ========\n\n    >>> from sympy.stats import pspace, Normal\n    >>> X = Normal('X', 0, 1)\n    >>> pspace(2*X + 1) == X.pspace\n    True\n    ",
    "section": "Mechanics",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  },
  {
    "name": "rs_swap",
    "full_id": "sympy.stats.rv.rs_swap",
    "type": "function",
    "description": "\n    Build a dictionary to swap RandomSymbols based on their underlying symbol.\n\n    i.e.\n    if    ``X = ('x', pspace1)``\n    and   ``Y = ('x', pspace2)``\n    then ``X`` and ``Y`` match and the key, value pair\n    ``{X:Y}`` will appear in the result\n\n    Inputs: collections a and b of random variables which share common symbols\n    Output: dict mapping RVs in a to RVs in b\n    ",
    "section": "Mechanics",
    "url": "https://docs.sympy.org/latest/modules/stats.html"
  }
]