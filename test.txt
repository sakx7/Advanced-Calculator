----------------------------------------------------------------------------------

Permutations.apply~method -

 Help on function apply in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.apply = apply(self, i)
    Apply the permutation to an expression.
    
    Parameters
    ==========
    
    i : Expr
        It should be an integer between $0$ and $n-1$ where $n$
        is the size of the permutation.
    
        If it is a symbol or a symbolic expression that can
        have integer values, an ``AppliedPermutation`` object
        will be returned which can represent an unevaluated
        function.
    
    Notes
    =====
    
    Any permutation can be defined as a bijective function
    $\sigma : \{ 0, 1, \dots, n-1 \} \rightarrow \{ 0, 1, \dots, n-1 \}$
    where $n$ denotes the size of the permutation.
    
    The definition may even be extended for any set with distinctive
    elements, such that the permutation can even be applied for
    real numbers or such, however, it is not implemented for now for
    computational reasons and the integrity with the group theory
    module.
    
    This function is similar to the ``__call__`` magic, however,
    ``__call__`` magic already has some other applications like
    permuting an array or attaching new cycles, which would
    not always be mathematically consistent.
    
    This also guarantees that the return type is a SymPy integer,
    which guarantees the safety to use assumptions.



----------------------------------------------------------------------------------

Permutations.array_form~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.array_form
    Return a copy of the attribute _array_form
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([[2, 0], [3, 1]])
    >>> p.array_form
    [2, 3, 0, 1]
    >>> Permutation([[2, 0, 3, 1]]).array_form
    [3, 2, 0, 1]
    >>> Permutation([2, 0, 3, 1]).array_form
    [2, 0, 3, 1]
    >>> Permutation([[1, 2], [4, 5]]).array_form
    [0, 2, 1, 3, 5, 4]



----------------------------------------------------------------------------------

Permutations.ascents~method -

 Help on function ascents in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.ascents = ascents(self)
    Returns the positions of ascents in a permutation, ie, the location
    where p[i] < p[i+1]
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([4, 0, 1, 3, 2])
    >>> p.ascents()
    [1, 2]
    
    See Also
    ========
    
    descents, inversions, min, max



----------------------------------------------------------------------------------

Permutations.atoms~method -

 Help on function atoms in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.atoms = atoms(self)
    Returns all the elements of a permutation
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation([0, 1, 2, 3, 4, 5]).atoms()
    {0, 1, 2, 3, 4, 5}
    >>> Permutation([[0, 1], [2, 3], [4, 5]]).atoms()
    {0, 1, 2, 3, 4, 5}



----------------------------------------------------------------------------------

Permutations.cardinality~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.cardinality
    Returns the number of all possible permutations.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 2, 3])
    >>> p.cardinality
    24
    
    See Also
    ========
    
    length, order, rank, size



----------------------------------------------------------------------------------

Permutations.commutator~method -

 Help on function commutator in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.commutator = commutator(self, x)
    Return the commutator of ``self`` and ``x``: ``~x*~self*x*self``
    
    If f and g are part of a group, G, then the commutator of f and g
    is the group identity iff f and g commute, i.e. fg == gf.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> from sympy import init_printing
    >>> init_printing(perm_cyclic=False, pretty_print=False)
    >>> p = Permutation([0, 2, 3, 1])
    >>> x = Permutation([2, 0, 3, 1])
    >>> c = p.commutator(x); c
    Permutation([2, 1, 3, 0])
    >>> c == ~x*~p*x*p
    True
    
    >>> I = Permutation(3)
    >>> p = [I + i for i in range(6)]
    >>> for i in range(len(p)):
    ...     for j in range(len(p)):
    ...         c = p[i].commutator(p[j])
    ...         if p[i]*p[j] == p[j]*p[i]:
    ...             assert c == I
    ...         else:
    ...             assert c != I
    ...
    
    References
    ==========
    
    .. [1] https://en.wikipedia.org/wiki/Commutator



----------------------------------------------------------------------------------

Permutations.commutes_with~method -

 Help on function commutes_with in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.commutes_with = commutes_with(self, other)
    Checks if the elements are commuting.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> a = Permutation([1, 4, 3, 0, 2, 5])
    >>> b = Permutation([0, 1, 2, 3, 4, 5])
    >>> a.commutes_with(b)
    True
    >>> b = Permutation([2, 3, 5, 4, 1, 0])
    >>> a.commutes_with(b)
    False



----------------------------------------------------------------------------------

Permutations.cycle_structure~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.cycle_structure
    Return the cycle structure of the permutation as a dictionary
    indicating the multiplicity of each cycle length.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation(3).cycle_structure
    {1: 4}
    >>> Permutation(0, 4, 3)(1, 2)(5, 6).cycle_structure
    {2: 2, 3: 1}



----------------------------------------------------------------------------------

Permutations.cycles~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.cycles
    Returns the number of cycles contained in the permutation
    (including singletons).
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation([0, 1, 2]).cycles
    3
    >>> Permutation([0, 1, 2]).full_cyclic_form
    [[0], [1], [2]]
    >>> Permutation(0, 1)(2, 3).cycles
    2
    
    See Also
    ========
    sympy.functions.combinatorial.numbers.stirling



----------------------------------------------------------------------------------

Permutations.cyclic_form~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.cyclic_form
    This is used to convert to the cyclic notation
    from the canonical notation. Singletons are omitted.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 3, 1, 2])
    >>> p.cyclic_form
    [[1, 3, 2]]
    >>> Permutation([1, 0, 2, 4, 3, 5]).cyclic_form
    [[0, 1], [3, 4]]
    
    See Also
    ========
    
    array_form, full_cyclic_form



----------------------------------------------------------------------------------

Permutations.descents~method -

 Help on function descents in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.descents = descents(self)
    Returns the positions of descents in a permutation, ie, the location
    where p[i] > p[i+1]
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([4, 0, 1, 3, 2])
    >>> p.descents()
    [0, 3]
    
    See Also
    ========
    
    ascents, inversions, min, max



----------------------------------------------------------------------------------

Permutations.from_inversion_vector~method -

 Help on method from_inversion_vector in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.from_inversion_vector = from_inversion_vector(inversion) class method of sympy.combinatorics.permutations.Permutation
    Calculates the permutation from the inversion vector.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> from sympy import init_printing
    >>> init_printing(perm_cyclic=False, pretty_print=False)
    >>> Permutation.from_inversion_vector([3, 2, 1, 0, 0])
    Permutation([3, 2, 1, 0, 4, 5])



----------------------------------------------------------------------------------

Permutations.from_sequence~method -

 Help on method from_sequence in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.from_sequence = from_sequence(i, key=None) class method of sympy.combinatorics.permutations.Permutation
    Return the permutation needed to obtain ``i`` from the sorted
    elements of ``i``. If custom sorting is desired, a key can be given.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    
    >>> Permutation.from_sequence('SymPy')
    (4)(0 1 3)
    >>> _(sorted("SymPy"))
    ['S', 'y', 'm', 'P', 'y']
    >>> Permutation.from_sequence('SymPy', key=lambda x: x.lower())
    (4)(0 2)(1 3)



----------------------------------------------------------------------------------

Permutations.full_cyclic_form~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.full_cyclic_form
    Return permutation in cyclic form including singletons.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation([0, 2, 1]).full_cyclic_form
    [[0], [1, 2]]



----------------------------------------------------------------------------------

Permutations.get_adjacency_distance~method -

 Help on function get_adjacency_distance in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.get_adjacency_distance = get_adjacency_distance(self, other)
    Computes the adjacency distance between two permutations.
    
    Explanation
    ===========
    
    This metric counts the number of times a pair i,j of jobs is
    adjacent in both p and p'. If n_adj is this quantity then
    the adjacency distance is n - n_adj - 1 [1]
    
    [1] Reeves, Colin R. Landscapes, Operators and Heuristic search, Annals
    of Operational Research, 86, pp 473-490. (1999)
    
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 3, 1, 2, 4])
    >>> q = Permutation.josephus(4, 5, 2)
    >>> p.get_adjacency_distance(q)
    3
    >>> r = Permutation([0, 2, 1, 4, 3])
    >>> p.get_adjacency_distance(r)
    4
    
    See Also
    ========
    
    get_precedence_matrix, get_precedence_distance, get_adjacency_matrix



----------------------------------------------------------------------------------

Permutations.get_adjacency_matrix~method -

 Help on function get_adjacency_matrix in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.get_adjacency_matrix = get_adjacency_matrix(self)
    Computes the adjacency matrix of a permutation.
    
    Explanation
    ===========
    
    If job i is adjacent to job j in a permutation p
    then we set m[i, j] = 1 where m is the adjacency
    matrix of p.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation.josephus(3, 6, 1)
    >>> p.get_adjacency_matrix()
    Matrix([
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 1],
    [0, 1, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0]])
    >>> q = Permutation([0, 1, 2, 3])
    >>> q.get_adjacency_matrix()
    Matrix([
    [0, 1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1],
    [0, 0, 0, 0]])
    
    See Also
    ========
    
    get_precedence_matrix, get_precedence_distance, get_adjacency_distance



----------------------------------------------------------------------------------

Permutations.get_positional_distance~method -

 Help on function get_positional_distance in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.get_positional_distance = get_positional_distance(self, other)
    Computes the positional distance between two permutations.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 3, 1, 2, 4])
    >>> q = Permutation.josephus(4, 5, 2)
    >>> r = Permutation([3, 1, 4, 0, 2])
    >>> p.get_positional_distance(q)
    12
    >>> p.get_positional_distance(r)
    12
    
    See Also
    ========
    
    get_precedence_distance, get_adjacency_distance



----------------------------------------------------------------------------------

Permutations.get_precedence_distance~method -

 Help on function get_precedence_distance in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.get_precedence_distance = get_precedence_distance(self, other)
    Computes the precedence distance between two permutations.
    
    Explanation
    ===========
    
    Suppose p and p' represent n jobs. The precedence metric
    counts the number of times a job j is preceded by job i
    in both p and p'. This metric is commutative.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([2, 0, 4, 3, 1])
    >>> q = Permutation([3, 1, 2, 4, 0])
    >>> p.get_precedence_distance(q)
    7
    >>> q.get_precedence_distance(p)
    7
    
    See Also
    ========
    
    get_precedence_matrix, get_adjacency_matrix, get_adjacency_distance



----------------------------------------------------------------------------------

Permutations.get_precedence_matrix~method -

 Help on function get_precedence_matrix in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.get_precedence_matrix = get_precedence_matrix(self)
    Gets the precedence matrix. This is used for computing the
    distance between two permutations.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> from sympy import init_printing
    >>> init_printing(perm_cyclic=False, pretty_print=False)
    >>> p = Permutation.josephus(3, 6, 1)
    >>> p
    Permutation([2, 5, 3, 1, 4, 0])
    >>> p.get_precedence_matrix()
    Matrix([
    [0, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 1, 0],
    [1, 1, 0, 1, 1, 1],
    [1, 1, 0, 0, 1, 0],
    [1, 0, 0, 0, 0, 0],
    [1, 1, 0, 1, 1, 0]])
    
    See Also
    ========
    
    get_precedence_distance, get_adjacency_matrix, get_adjacency_distance



----------------------------------------------------------------------------------

Permutations.index~method -

 Help on function index in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.index = index(self)
    Returns the index of a permutation.
    
    The index of a permutation is the sum of all subscripts j such
    that p[j] is greater than p[j+1].
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([3, 0, 2, 1, 4])
    >>> p.index()
    2



----------------------------------------------------------------------------------

Permutations.inversion_vector~method -

 Help on function inversion_vector in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.inversion_vector = inversion_vector(self)
    Return the inversion vector of the permutation.
    
    The inversion vector consists of elements whose value
    indicates the number of elements in the permutation
    that are lesser than it and lie on its right hand side.
    
    The inversion vector is the same as the Lehmer encoding of a
    permutation.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([4, 8, 0, 7, 1, 5, 3, 6, 2])
    >>> p.inversion_vector()
    [4, 7, 0, 5, 0, 2, 1, 1]
    >>> p = Permutation([3, 2, 1, 0])
    >>> p.inversion_vector()
    [3, 2, 1]
    
    The inversion vector increases lexicographically with the rank
    of the permutation, the -ith element cycling through 0..i.
    
    >>> p = Permutation(2)
    >>> while p:
    ...     print('%s %s %s' % (p, p.inversion_vector(), p.rank()))
    ...     p = p.next_lex()
    (2) [0, 0] 0
    (1 2) [0, 1] 1
    (2)(0 1) [1, 0] 2
    (0 1 2) [1, 1] 3
    (0 2 1) [2, 0] 4
    (0 2) [2, 1] 5
    
    See Also
    ========
    
    from_inversion_vector



----------------------------------------------------------------------------------

Permutations.inversions~method -

 Help on function inversions in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.inversions = inversions(self)
    Computes the number of inversions of a permutation.
    
    Explanation
    ===========
    
    An inversion is where i > j but p[i] < p[j].
    
    For small length of p, it iterates over all i and j
    values and calculates the number of inversions.
    For large length of p, it uses a variation of merge
    sort to calculate the number of inversions.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 2, 3, 4, 5])
    >>> p.inversions()
    0
    >>> Permutation([3, 2, 1, 0]).inversions()
    6
    
    See Also
    ========
    
    descents, ascents, min, max
    
    References
    ==========
    
    .. [1] https://www.cp.eng.chula.ac.th/~prabhas//teaching/algo/algo2008/count-inv.htm



----------------------------------------------------------------------------------

Permutations.is_Empty~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.is_Empty
    Checks to see if the permutation is a set with zero elements
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation([]).is_Empty
    True
    >>> Permutation([0]).is_Empty
    False
    
    See Also
    ========
    
    is_Singleton



----------------------------------------------------------------------------------

Permutations.is_Identity~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.is_Identity
    Returns True if the Permutation is an identity permutation.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([])
    >>> p.is_Identity
    True
    >>> p = Permutation([[0], [1], [2]])
    >>> p.is_Identity
    True
    >>> p = Permutation([0, 1, 2])
    >>> p.is_Identity
    True
    >>> p = Permutation([0, 2, 1])
    >>> p.is_Identity
    False
    
    See Also
    ========
    
    order



----------------------------------------------------------------------------------

Permutations.is_Singleton~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.is_Singleton
    Checks to see if the permutation contains only one number and is
    thus the only possible permutation of this set of numbers
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation([0]).is_Singleton
    True
    >>> Permutation([0, 1]).is_Singleton
    False
    
    See Also
    ========
    
    is_Empty



----------------------------------------------------------------------------------

Permutations.is_even~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.is_even
    Checks if a permutation is even.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 2, 3])
    >>> p.is_even
    True
    >>> p = Permutation([3, 2, 1, 0])
    >>> p.is_even
    True
    
    See Also
    ========
    
    is_odd



----------------------------------------------------------------------------------

Permutations.is_odd~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.is_odd
    Checks if a permutation is odd.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 2, 3])
    >>> p.is_odd
    False
    >>> p = Permutation([3, 2, 0, 1])
    >>> p.is_odd
    True
    
    See Also
    ========
    
    is_even



----------------------------------------------------------------------------------

Permutations.josephus~method -

 Help on method josephus in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.josephus = josephus(m, n, s=1) class method of sympy.combinatorics.permutations.Permutation
    Return as a permutation the shuffling of range(n) using the Josephus
    scheme in which every m-th item is selected until all have been chosen.
    The returned permutation has elements listed by the order in which they
    were selected.
    
    The parameter ``s`` stops the selection process when there are ``s``
    items remaining and these are selected by continuing the selection,
    counting by 1 rather than by ``m``.
    
    Consider selecting every 3rd item from 6 until only 2 remain::
    
        choices    chosen
        ========   ======
          012345
          01 345   2
          01 34    25
          01  4    253
          0   4    2531
          0        25314
                   253140
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation.josephus(3, 6, 2).array_form
    [2, 5, 3, 1, 4, 0]
    
    References
    ==========
    
    .. [1] https://en.wikipedia.org/wiki/Flavius_Josephus
    .. [2] https://en.wikipedia.org/wiki/Josephus_problem
    .. [3] https://web.archive.org/web/20171008094331/http://www.wou.edu/~burtonl/josephus.html



----------------------------------------------------------------------------------

Permutations.length~method -

 Help on function length in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.length = length(self)
    Returns the number of integers moved by a permutation.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation([0, 3, 2, 1]).length()
    2
    >>> Permutation([[0, 1], [2, 3]]).length()
    4
    
    See Also
    ========
    
    min, max, support, cardinality, order, rank, size



----------------------------------------------------------------------------------

Permutations.list~method -

 Help on function list in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.list = list(self, size=None)
    Return the permutation as an explicit list, possibly
    trimming unmoved elements if size is less than the maximum
    element in the permutation; if this is desired, setting
    ``size=-1`` will guarantee such trimming.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation(2, 3)(4, 5)
    >>> p.list()
    [0, 1, 3, 2, 5, 4]
    >>> p.list(10)
    [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]
    
    Passing a length too small will trim trailing, unchanged elements
    in the permutation:
    
    >>> Permutation(2, 4)(1, 2, 4).list(-1)
    [0, 2, 1]
    >>> Permutation(3).list(-1)
    []



----------------------------------------------------------------------------------

Permutations.max~method -

 Help on function max in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.max = max(self) -> int
    The maximum element moved by the permutation.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([1, 0, 2, 3, 4])
    >>> p.max()
    1
    
    See Also
    ========
    
    min, descents, ascents, inversions



----------------------------------------------------------------------------------

Permutations.min~method -

 Help on function min in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.min = min(self) -> int
    The minimum element moved by the permutation.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 4, 3, 2])
    >>> p.min()
    2
    
    See Also
    ========
    
    max, descents, ascents, inversions



----------------------------------------------------------------------------------

Permutations.mul_inv~method -

 Help on function mul_inv in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.mul_inv = mul_inv(self, other)
    other*~self, self and other have _array_form



----------------------------------------------------------------------------------

Permutations.next_lex~method -

 Help on function next_lex in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.next_lex = next_lex(self)
    Returns the next permutation in lexicographical order.
    If self is the last permutation in lexicographical order
    it returns None.
    See [4] section 2.4.
    
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([2, 3, 1, 0])
    >>> p = Permutation([2, 3, 1, 0]); p.rank()
    17
    >>> p = p.next_lex(); p.rank()
    18
    
    See Also
    ========
    
    rank, unrank_lex



----------------------------------------------------------------------------------

Permutations.next_nonlex~method -

 Help on function next_nonlex in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.next_nonlex = next_nonlex(self)
    Returns the next permutation in nonlex order [3].
    If self is the last permutation in this order it returns None.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> from sympy import init_printing
    >>> init_printing(perm_cyclic=False, pretty_print=False)
    >>> p = Permutation([2, 0, 3, 1]); p.rank_nonlex()
    5
    >>> p = p.next_nonlex(); p
    Permutation([3, 0, 1, 2])
    >>> p.rank_nonlex()
    6
    
    See Also
    ========
    
    rank_nonlex, unrank_nonlex



----------------------------------------------------------------------------------

Permutations.next_trotterjohnson~method -

 Help on function next_trotterjohnson in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.next_trotterjohnson = next_trotterjohnson(self)
    Returns the next permutation in Trotter-Johnson order.
    If self is the last permutation it returns None.
    See [4] section 2.4. If it is desired to generate all such
    permutations, they can be generated in order more quickly
    with the ``generate_bell`` function.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> from sympy import init_printing
    >>> init_printing(perm_cyclic=False, pretty_print=False)
    >>> p = Permutation([3, 0, 2, 1])
    >>> p.rank_trotterjohnson()
    4
    >>> p = p.next_trotterjohnson(); p
    Permutation([0, 3, 2, 1])
    >>> p.rank_trotterjohnson()
    5
    
    See Also
    ========
    
    rank_trotterjohnson, unrank_trotterjohnson, sympy.utilities.iterables.generate_bell



----------------------------------------------------------------------------------

Permutations.order~method -

 Help on function order in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.order = order(self)
    Computes the order of a permutation.
    
    When the permutation is raised to the power of its
    order it equals the identity permutation.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> from sympy import init_printing
    >>> init_printing(perm_cyclic=False, pretty_print=False)
    >>> p = Permutation([3, 1, 5, 2, 4, 0])
    >>> p.order()
    4
    >>> (p**(p.order()))
    Permutation([], size=6)
    
    See Also
    ========
    
    identity, cardinality, length, rank, size



----------------------------------------------------------------------------------

Permutations.parity~method -

 Help on function parity in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.parity = parity(self)
    Computes the parity of a permutation.
    
    Explanation
    ===========
    
    The parity of a permutation reflects the parity of the
    number of inversions in the permutation, i.e., the
    number of pairs of x and y such that ``x > y`` but ``p[x] < p[y]``.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 2, 3])
    >>> p.parity()
    0
    >>> p = Permutation([3, 2, 0, 1])
    >>> p.parity()
    1
    
    See Also
    ========
    
    _af_parity



----------------------------------------------------------------------------------

Permutations.random~method -

 Help on method random in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.random = random(n) class method of sympy.combinatorics.permutations.Permutation
    Generates a random permutation of length ``n``.
    
    Uses the underlying Python pseudo-random number generator.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation.random(2) in (Permutation([1, 0]), Permutation([0, 1]))
    True



----------------------------------------------------------------------------------

Permutations.rank~method -

 Help on function rank in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.rank = rank(self)
    Returns the lexicographic rank of the permutation.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 2, 3])
    >>> p.rank()
    0
    >>> p = Permutation([3, 2, 1, 0])
    >>> p.rank()
    23
    
    See Also
    ========
    
    next_lex, unrank_lex, cardinality, length, order, size



----------------------------------------------------------------------------------

Permutations.rank_nonlex~method -

 Help on function rank_nonlex in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.rank_nonlex = rank_nonlex(self, inv_perm=None)
    This is a linear time ranking algorithm that does not
    enforce lexicographic order [3].
    
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 2, 3])
    >>> p.rank_nonlex()
    23
    
    See Also
    ========
    
    next_nonlex, unrank_nonlex



----------------------------------------------------------------------------------

Permutations.rank_trotterjohnson~method -

 Help on function rank_trotterjohnson in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.rank_trotterjohnson = rank_trotterjohnson(self)
    Returns the Trotter Johnson rank, which we get from the minimal
    change algorithm. See [4] section 2.4.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 2, 3])
    >>> p.rank_trotterjohnson()
    0
    >>> p = Permutation([0, 2, 1, 3])
    >>> p.rank_trotterjohnson()
    7
    
    See Also
    ========
    
    unrank_trotterjohnson, next_trotterjohnson



----------------------------------------------------------------------------------

Permutations.resize~method -

 Help on function resize in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.resize = resize(self, n)
    Resize the permutation to the new size ``n``.
    
    Parameters
    ==========
    
    n : int
        The new size of the permutation.
    
    Raises
    ======
    
    ValueError
        If the permutation cannot be resized to the given size.
        This may only happen when resized to a smaller size than
        the original.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    
    Increasing the size of a permutation:
    
    >>> p = Permutation(0, 1, 2)
    >>> p = p.resize(5)
    >>> p
    (4)(0 1 2)
    
    Decreasing the size of the permutation:
    
    >>> p = p.resize(4)
    >>> p
    (3)(0 1 2)
    
    If resizing to the specific size breaks the cycles:
    
    >>> p.resize(2)
    Traceback (most recent call last):
    ...
    ValueError: The permutation cannot be resized to 2 because the
    cycle (0, 1, 2) may break.



----------------------------------------------------------------------------------

Permutations.rmul~method -

 Help on function rmul in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.rmul = rmul(*args)
    Return product of Permutations [a, b, c, ...] as the Permutation whose
    ith value is a(b(c(i))).
    
    a, b, c, ... can be Permutation objects or tuples.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    
    >>> a, b = [1, 0, 2], [0, 2, 1]
    >>> a = Permutation(a); b = Permutation(b)
    >>> list(Permutation.rmul(a, b))
    [1, 2, 0]
    >>> [a(b(i)) for i in range(3)]
    [1, 2, 0]
    
    This handles the operands in reverse order compared to the ``*`` operator:
    
    >>> a = Permutation(a); b = Permutation(b)
    >>> list(a*b)
    [2, 0, 1]
    >>> [b(a(i)) for i in range(3)]
    [2, 0, 1]
    
    Notes
    =====
    
    All items in the sequence will be parsed by Permutation as
    necessary as long as the first item is a Permutation:
    
    >>> Permutation.rmul(a, [0, 2, 1]) == Permutation.rmul(a, b)
    True
    
    The reverse order of arguments will raise a TypeError.



----------------------------------------------------------------------------------

Permutations.rmul_with_af~method -

 Help on method rmul_with_af in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.rmul_with_af = rmul_with_af(*args) class method of sympy.combinatorics.permutations.Permutation
    same as rmul, but the elements of args are Permutation objects
    which have _array_form



----------------------------------------------------------------------------------

Permutations.runs~method -

 Help on function runs in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.runs = runs(self)
    Returns the runs of a permutation.
    
    An ascending sequence in a permutation is called a run [5].
    
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([2, 5, 7, 3, 6, 0, 1, 4, 8])
    >>> p.runs()
    [[2, 5, 7], [3, 6], [0, 1, 4, 8]]
    >>> q = Permutation([1,3,2,0])
    >>> q.runs()
    [[1, 3], [2], [0]]



----------------------------------------------------------------------------------

Permutations.signature~method -

 Help on function signature in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.signature = signature(self)
    Gives the signature of the permutation needed to place the
    elements of the permutation in canonical order.
    
    The signature is calculated as (-1)^<number of inversions>
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([0, 1, 2])
    >>> p.inversions()
    0
    >>> p.signature()
    1
    >>> q = Permutation([0,2,1])
    >>> q.inversions()
    1
    >>> q.signature()
    -1
    
    See Also
    ========
    
    inversions



----------------------------------------------------------------------------------

Permutations.size~property -

 Help on property in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.size
    Returns the number of elements in the permutation.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> Permutation([[3, 2], [0, 1]]).size
    4
    
    See Also
    ========
    
    cardinality, length, order, rank



----------------------------------------------------------------------------------

Permutations.support~method -

 Help on function support in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.support = support(self)
    Return the elements in permutation, P, for which P[i] != i.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([[3, 2], [0, 1], [4]])
    >>> p.array_form
    [1, 0, 3, 2, 4]
    >>> p.support()
    [0, 1, 2, 3]



----------------------------------------------------------------------------------

Permutations.transpositions~method -

 Help on function transpositions in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.transpositions = transpositions(self)
    Return the permutation decomposed into a list of transpositions.
    
    Explanation
    ===========
    
    It is always possible to express a permutation as the product of
    transpositions, see [1]
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> p = Permutation([[1, 2, 3], [0, 4, 5, 6, 7]])
    >>> t = p.transpositions()
    >>> t
    [(0, 7), (0, 6), (0, 5), (0, 4), (1, 3), (1, 2)]
    >>> print(''.join(str(c) for c in t))
    (0, 7)(0, 6)(0, 5)(0, 4)(1, 3)(1, 2)
    >>> Permutation.rmul(*[Permutation([ti], size=p.size) for ti in t]) == p
    True
    
    References
    ==========
    
    .. [1] https://en.wikipedia.org/wiki/Transposition_%28mathematics%29#Properties



----------------------------------------------------------------------------------

Permutations.unrank_lex~method -

 Help on method unrank_lex in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.unrank_lex = unrank_lex(size, rank) class method of sympy.combinatorics.permutations.Permutation
    Lexicographic permutation unranking.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> from sympy import init_printing
    >>> init_printing(perm_cyclic=False, pretty_print=False)
    >>> a = Permutation.unrank_lex(5, 10)
    >>> a.rank()
    10
    >>> a
    Permutation([0, 2, 4, 1, 3])
    
    See Also
    ========
    
    rank, next_lex



----------------------------------------------------------------------------------

Permutations.unrank_nonlex~method -

 Help on method unrank_nonlex in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.unrank_nonlex = unrank_nonlex(n, r) class method of sympy.combinatorics.permutations.Permutation
    This is a linear time unranking algorithm that does not
    respect lexicographic order [3].
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> from sympy import init_printing
    >>> init_printing(perm_cyclic=False, pretty_print=False)
    >>> Permutation.unrank_nonlex(4, 5)
    Permutation([2, 0, 3, 1])
    >>> Permutation.unrank_nonlex(4, -1)
    Permutation([0, 1, 2, 3])
    
    See Also
    ========
    
    next_nonlex, rank_nonlex



----------------------------------------------------------------------------------

Permutations.unrank_trotterjohnson~method -

 Help on method unrank_trotterjohnson in sympy.combinatorics.permutations.Permutation:

sympy.combinatorics.permutations.Permutation.unrank_trotterjohnson = unrank_trotterjohnson(size, rank) class method of sympy.combinatorics.permutations.Permutation
    Trotter Johnson permutation unranking. See [4] section 2.4.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Permutation
    >>> from sympy import init_printing
    >>> init_printing(perm_cyclic=False, pretty_print=False)
    >>> Permutation.unrank_trotterjohnson(5, 10)
    Permutation([0, 3, 1, 2, 4])
    
    See Also
    ========
    
    rank_trotterjohnson, next_trotterjohnson



----------------------------------------------------------------------------------

----------------------------------------------------------------------------------

Permutations.list~method -

 Help on function list in sympy.combinatorics.permutations.Cycle:

sympy.combinatorics.permutations.Cycle.list = list(self, size=None)
    Return the cycles as an explicit list starting from 0 up
    to the greater of the largest value in the cycles and size.
    
    Truncation of trailing unmoved items will occur when size
    is less than the maximum element in the cycle; if this is
    desired, setting ``size=-1`` will guarantee such trimming.
    
    Examples
    ========
    
    >>> from sympy.combinatorics import Cycle
    >>> p = Cycle(2, 3)(4, 5)
    >>> p.list()
    [0, 1, 3, 2, 5, 4]
    >>> p.list(10)
    [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]
    
    Passing a length too small will trim trailing, unchanged elements
    in the permutation:
    
    >>> Cycle(2, 4)(1, 2, 4).list(-1)
    [0, 2, 1]



----------------------------------------------------------------------------------

_af_parity~function -

 Help on function _af_parity in sympy.combinatorics.permutations:

sympy.combinatorics.permutations._af_parity = _af_parity(pi)
    Computes the parity of a permutation in array form.
    
    Explanation
    ===========
    
    The parity of a permutation reflects the parity of the
    number of inversions in the permutation, i.e., the
    number of pairs of x and y such that x > y but p[x] < p[y].
    
    Examples
    ========
    
    >>> from sympy.combinatorics.permutations import _af_parity
    >>> _af_parity([0, 1, 2, 3])
    0
    >>> _af_parity([3, 2, 0, 1])
    1
    
    See Also
    ========
    
    Permutation



----------------------------------------------------------------------------------

Generators.symmetric~method -

 Help on function symmetric in sympy.combinatorics.generators:

sympy.combinatorics.generators.symmetric = symmetric(n)
    Generates the symmetric group of order n, Sn.
    
    Examples
    ========
    
    >>> from sympy.combinatorics.generators import symmetric
    >>> list(symmetric(3))
    [(2), (1 2), (2)(0 1), (0 1 2), (0 2 1), (0 2)]



----------------------------------------------------------------------------------

Generators.cyclic~method -

 Help on function cyclic in sympy.combinatorics.generators:

sympy.combinatorics.generators.cyclic = cyclic(n)
    Generates the cyclic group of order n, Cn.
    
    Examples
    ========
    
    >>> from sympy.combinatorics.generators import cyclic
    >>> list(cyclic(5))
    [(4), (0 1 2 3 4), (0 2 4 1 3),
     (0 3 1 4 2), (0 4 3 2 1)]
    
    See Also
    ========
    
    dihedral



----------------------------------------------------------------------------------

Generators.alternating~method -

 Help on function alternating in sympy.combinatorics.generators:

sympy.combinatorics.generators.alternating = alternating(n)
    Generates the alternating group of order n, An.
    
    Examples
    ========
    
    >>> from sympy.combinatorics.generators import alternating
    >>> list(alternating(3))
    [(2), (0 1 2), (0 2 1)]



----------------------------------------------------------------------------------

Generators.dihedral~method -

 Help on function dihedral in sympy.combinatorics.generators:

sympy.combinatorics.generators.dihedral = dihedral(n)
    Generates the dihedral group of order 2n, Dn.
    
    The result is given as a subgroup of Sn, except for the special cases n=1
    (the group S2) and n=2 (the Klein 4-group) where that's not possible
    and embeddings in S2 and S4 respectively are given.
    
    Examples
    ========
    
    >>> from sympy.combinatorics.generators import dihedral
    >>> list(dihedral(3))
    [(2), (0 2), (0 1 2), (1 2), (0 2 1), (2)(0 1)]
    
    See Also
    ========
    
    cyclic



----------------------------------------------------------------------------------

